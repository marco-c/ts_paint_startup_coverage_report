<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jit/IonAnalysis.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/jit</a> - IonAnalysis.cpp<span style="font-size: 80%;"> (source / <a href="IonAnalysis.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1509</td>
            <td class="headerCovTableEntry">2364</td>
            <td class="headerCovTableEntryLo">63.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">105</td>
            <td class="headerCovTableEntry">123</td>
            <td class="headerCovTableEntryMed">85.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;jit/IonAnalysis.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/SizePrintfMacros.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;jit/AliasAnalysis.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;jit/BaselineInspector.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;jit/BaselineJIT.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;jit/FlowAliasAnalysis.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;jit/Ion.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;jit/IonBuilder.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;jit/IonOptimizationLevels.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;jit/LIR.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;jit/Lowering.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;jit/MIRGraph.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;vm/RegExpObject.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;vm/SelfHosting.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;jsobjinlines.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;jsopcodeinlines.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;jsscriptinlines.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;jit/shared/Lowering-shared-inl.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : using namespace js;
<span class="lineNum">      31 </span>            : using namespace js::jit;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : using mozilla::DebugOnly;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : typedef Vector&lt;MPhi*, 16, SystemAllocPolicy&gt; MPhiVector;
<a name="36"><span class="lineNum">      36 </span>            : </a>
<span class="lineNum">      37 </span>            : static bool
<span class="lineNum">      38 </span><span class="lineCov">        119 : FlagPhiInputsAsHavingRemovedUses(MIRGenerator* mir, MBasicBlock* block, MBasicBlock* succ,</span>
<span class="lineNum">      39 </span>            :                                  MPhiVector&amp; worklist)
<span class="lineNum">      40 </span>            : {
<span class="lineNum">      41 </span>            :     // When removing an edge between 2 blocks, we might remove the ability of
<span class="lineNum">      42 </span>            :     // later phases to figure out that the uses of a Phi should be considered as
<span class="lineNum">      43 </span>            :     // a use of all its inputs. Thus we need to mark the Phi inputs as having
<span class="lineNum">      44 </span>            :     // removed uses iff the phi has any uses.
<span class="lineNum">      45 </span>            :     //
<span class="lineNum">      46 </span>            :     //
<span class="lineNum">      47 </span>            :     //        +--------------------+         +---------------------+
<span class="lineNum">      48 </span>            :     //        |12 MFoo 6           |         |32 MBar 5            |
<span class="lineNum">      49 </span>            :     //        |                    |         |                     |
<span class="lineNum">      50 </span>            :     //        |   ...              |         |   ...               |
<span class="lineNum">      51 </span>            :     //        |                    |         |                     |
<span class="lineNum">      52 </span>            :     //        |25 MGoto Block 4    |         |43 MGoto Block 4     |
<span class="lineNum">      53 </span>            :     //        +--------------------+         +---------------------+
<span class="lineNum">      54 </span>            :     //                   |                              |
<span class="lineNum">      55 </span>            :     //             |     |                              |
<span class="lineNum">      56 </span>            :     //             |     |                              |
<span class="lineNum">      57 </span>            :     //             |     +-----X------------------------+
<span class="lineNum">      58 </span>            :     //             |         Edge       |
<span class="lineNum">      59 </span>            :     //             |        Removed     |
<span class="lineNum">      60 </span>            :     //             |                    |
<span class="lineNum">      61 </span>            :     //             |       +------------v-----------+
<span class="lineNum">      62 </span>            :     //             |       |50 MPhi 12 32           |
<span class="lineNum">      63 </span>            :     //             |       |                        |
<span class="lineNum">      64 </span>            :     //             |       |   ...                  |
<span class="lineNum">      65 </span>            :     //             |       |                        |
<span class="lineNum">      66 </span>            :     //             |       |70 MReturn 50           |
<span class="lineNum">      67 </span>            :     //             |       +------------------------+
<span class="lineNum">      68 </span>            :     //             |
<span class="lineNum">      69 </span>            :     //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
<span class="lineNum">      70 </span>            :     //             |
<span class="lineNum">      71 </span>            :     //             v
<span class="lineNum">      72 </span>            :     //
<span class="lineNum">      73 </span>            :     //    ^   +--------------------+         +---------------------+
<span class="lineNum">      74 </span>            :     //   /!\  |12 MConst opt-out   |         |32 MBar 5            |
<span class="lineNum">      75 </span>            :     //  '---' |                    |         |                     |
<span class="lineNum">      76 </span>            :     //        |   ...              |         |   ...               |
<span class="lineNum">      77 </span>            :     //        |78 MBail            |         |                     |
<span class="lineNum">      78 </span>            :     //        |80 MUnreachable     |         |43 MGoto Block 4     |
<span class="lineNum">      79 </span>            :     //        +--------------------+         +---------------------+
<span class="lineNum">      80 </span>            :     //                                                  |
<span class="lineNum">      81 </span>            :     //                                                  |
<span class="lineNum">      82 </span>            :     //                                                  |
<span class="lineNum">      83 </span>            :     //                                  +---------------+
<span class="lineNum">      84 </span>            :     //                                  |
<span class="lineNum">      85 </span>            :     //                                  |
<span class="lineNum">      86 </span>            :     //                                  |
<span class="lineNum">      87 </span>            :     //                     +------------v-----------+
<span class="lineNum">      88 </span>            :     //                     |50 MPhi 32              |
<span class="lineNum">      89 </span>            :     //                     |                        |
<span class="lineNum">      90 </span>            :     //                     |   ...                  |
<span class="lineNum">      91 </span>            :     //                     |                        |
<span class="lineNum">      92 </span>            :     //                     |70 MReturn 50           |
<span class="lineNum">      93 </span>            :     //                     +------------------------+
<span class="lineNum">      94 </span>            :     //
<span class="lineNum">      95 </span>            :     //
<span class="lineNum">      96 </span>            :     // If the inputs of the Phi are not flagged as having removed uses, then
<span class="lineNum">      97 </span>            :     // later compilation phase might optimize them out. The problem is that a
<span class="lineNum">      98 </span>            :     // bailout will use this value and give it back to baseline, which will then
<span class="lineNum">      99 </span>            :     // use the OptimizedOut magic value in a computation.
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :     // Conservative upper limit for the number of Phi instructions which are
<span class="lineNum">     102 </span>            :     // visited while looking for uses.
<span class="lineNum">     103 </span><span class="lineCov">        119 :     const size_t conservativeUsesLimit = 128;</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineCov">        119 :     MOZ_ASSERT(worklist.empty());</span>
<span class="lineNum">     106 </span><span class="lineCov">        119 :     size_t predIndex = succ-&gt;getPredecessorIndex(block);</span>
<span class="lineNum">     107 </span><span class="lineCov">        119 :     MPhiIterator end = succ-&gt;phisEnd();</span>
<span class="lineNum">     108 </span><span class="lineCov">        119 :     MPhiIterator it = succ-&gt;phisBegin();</span>
<span class="lineNum">     109 </span><span class="lineCov">        391 :     for (; it != end; it++) {</span>
<span class="lineNum">     110 </span><span class="lineCov">        136 :         MPhi* phi = *it;</span>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineCov">        136 :         if (mir-&gt;shouldCancel(&quot;FlagPhiInputsAsHavingRemovedUses outer loop&quot;))</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :         // We are looking to mark the Phi inputs which are used across the edge
<span class="lineNum">     116 </span>            :         // between the |block| and its successor |succ|.
<span class="lineNum">     117 </span><span class="lineCov">        136 :         MDefinition* def = phi-&gt;getOperand(predIndex);</span>
<span class="lineNum">     118 </span><span class="lineCov">        136 :         if (def-&gt;isUseRemoved())</span>
<span class="lineNum">     119 </span><span class="lineCov">         70 :             continue;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">         66 :         phi-&gt;setInWorklist();</span>
<span class="lineNum">     122 </span><span class="lineCov">         66 :         if (!worklist.append(phi))</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :         // Fill the work list with all the Phi nodes uses until we reach either:
<span class="lineNum">     126 </span>            :         //  - A resume point which uses the Phi as an observable operand.
<span class="lineNum">     127 </span>            :         //  - An explicit use of the Phi instruction.
<span class="lineNum">     128 </span>            :         //  - An implicit use of the Phi instruction.
<span class="lineNum">     129 </span><span class="lineCov">         66 :         bool isUsed = false;</span>
<span class="lineNum">     130 </span><span class="lineCov">        159 :         for (size_t idx = 0; !isUsed &amp;&amp; idx &lt; worklist.length(); idx++) {</span>
<span class="lineNum">     131 </span><span class="lineCov">        128 :             phi = worklist[idx];</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineCov">        128 :             if (mir-&gt;shouldCancel(&quot;FlagPhiInputsAsHavingRemovedUses inner loop 1&quot;))</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineCov">        128 :             if (phi-&gt;isUseRemoved() || phi-&gt;isImplicitlyUsed()) {</span>
<span class="lineNum">     137 </span>            :                 // The phi is implicitly used.
<span class="lineNum">     138 </span><span class="lineCov">         35 :                 isUsed = true;</span>
<span class="lineNum">     139 </span><span class="lineCov">         70 :                 break;</span>
<span class="lineNum">     140 </span>            :             }
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineCov">         93 :             MUseIterator usesEnd(phi-&gt;usesEnd());</span>
<span class="lineNum">     143 </span><span class="lineCov">       1285 :             for (MUseIterator use(phi-&gt;usesBegin()); use != usesEnd; use++) {</span>
<span class="lineNum">     144 </span><span class="lineCov">       1223 :                 MNode* consumer = (*use)-&gt;consumer();</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineCov">       1223 :                 if (mir-&gt;shouldCancel(&quot;FlagPhiInputsAsHavingRemovedUses inner loop 2&quot;))</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineCov">       1223 :                 if (consumer-&gt;isResumePoint()) {</span>
<span class="lineNum">     150 </span><span class="lineCov">       1038 :                     MResumePoint* rp = consumer-&gt;toResumePoint();</span>
<span class="lineNum">     151 </span><span class="lineCov">       1038 :                     if (rp-&gt;isObservableOperand(*use)) {</span>
<span class="lineNum">     152 </span>            :                         // The phi is observable via a resume point operand.
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                         isUsed = true;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     155 </span>            :                     }
<span class="lineNum">     156 </span><span class="lineCov">       1038 :                     continue;</span>
<span class="lineNum">     157 </span>            :                 }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineCov">        185 :                 MDefinition* cdef = consumer-&gt;toDefinition();</span>
<span class="lineNum">     160 </span><span class="lineCov">        185 :                 if (!cdef-&gt;isPhi()) {</span>
<span class="lineNum">     161 </span>            :                     // The phi is explicitly used.
<span class="lineNum">     162 </span><span class="lineCov">         31 :                     isUsed = true;</span>
<span class="lineNum">     163 </span><span class="lineCov">         31 :                     break;</span>
<span class="lineNum">     164 </span>            :                 }
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineCov">        154 :                 phi = cdef-&gt;toPhi();</span>
<span class="lineNum">     167 </span><span class="lineCov">        154 :                 if (phi-&gt;isInWorklist())</span>
<span class="lineNum">     168 </span><span class="lineCov">         48 :                     continue;</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">        106 :                 phi-&gt;setInWorklist();</span>
<span class="lineNum">     171 </span><span class="lineCov">        106 :                 if (!worklist.append(phi))</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">     173 </span>            :             }
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :             // Use a conservative upper bound to avoid iterating too many times
<span class="lineNum">     176 </span>            :             // on very large graphs.
<span class="lineNum">     177 </span><span class="lineCov">         93 :             if (idx &gt;= conservativeUsesLimit) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 isUsed = true;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     180 </span>            :             }
<span class="lineNum">     181 </span>            :         }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">         66 :         if (isUsed)</span>
<span class="lineNum">     184 </span><span class="lineCov">         66 :             def-&gt;setUseRemoved();</span>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :         // Remove all the InWorklist flags.
<span class="lineNum">     187 </span><span class="lineCov">        410 :         while (!worklist.empty()) {</span>
<span class="lineNum">     188 </span><span class="lineCov">        172 :             phi = worklist.popCopy();</span>
<span class="lineNum">     189 </span><span class="lineCov">        172 :             phi-&gt;setNotInWorklist();</span>
<span class="lineNum">     190 </span>            :         }
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineCov">        119 :     return true;</span>
<span class="lineNum">     194 </span>            : }
<a name="195"><span class="lineNum">     195 </span>            : </a>
<span class="lineNum">     196 </span>            : static bool
<span class="lineNum">     197 </span><span class="lineCov">        105 : FlagAllOperandsAsHavingRemovedUses(MIRGenerator* mir, MBasicBlock* block)</span>
<span class="lineNum">     198 </span>            : {
<span class="lineNum">     199 </span><span class="lineCov">        105 :     const CompileInfo&amp; info = block-&gt;info();</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :     // Flag all instructions operands as having removed uses.
<span class="lineNum">     202 </span><span class="lineCov">        105 :     MInstructionIterator end = block-&gt;end();</span>
<span class="lineNum">     203 </span><span class="lineCov">        494 :     for (MInstructionIterator it = block-&gt;begin(); it != end; it++) {</span>
<span class="lineNum">     204 </span><span class="lineCov">        389 :         if (mir-&gt;shouldCancel(&quot;FlagAllOperandsAsHavingRemovedUses loop 1&quot;))</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineCov">        389 :         MInstruction* ins = *it;</span>
<span class="lineNum">     208 </span><span class="lineCov">        678 :         for (size_t i = 0, e = ins-&gt;numOperands(); i &lt; e; i++)</span>
<span class="lineNum">     209 </span><span class="lineCov">        289 :             ins-&gt;getOperand(i)-&gt;setUseRemovedUnchecked();</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :         // Flag observable resume point operands as having removed uses.
<span class="lineNum">     212 </span><span class="lineCov">        389 :         if (MResumePoint* rp = ins-&gt;resumePoint()) {</span>
<span class="lineNum">     213 </span>            :             // Note: no need to iterate over the caller's of the resume point as
<span class="lineNum">     214 </span>            :             // this is the same as the entry resume point.
<span class="lineNum">     215 </span><span class="lineCov">       1979 :             for (size_t i = 0, e = rp-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">     216 </span><span class="lineCov">       1863 :                 if (info.isObservableSlot(i))</span>
<span class="lineNum">     217 </span><span class="lineCov">        163 :                     rp-&gt;getOperand(i)-&gt;setUseRemovedUnchecked();</span>
<span class="lineNum">     218 </span>            :             }
<span class="lineNum">     219 </span>            :         }
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     // Flag observable operands of the entry resume point as having removed uses.
<span class="lineNum">     223 </span><span class="lineCov">        105 :     MResumePoint* rp = block-&gt;entryResumePoint();</span>
<span class="lineNum">     224 </span><span class="lineCov">        381 :     while (rp) {</span>
<span class="lineNum">     225 </span><span class="lineCov">        138 :         if (mir-&gt;shouldCancel(&quot;FlagAllOperandsAsHavingRemovedUses loop 2&quot;))</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">       2353 :         for (size_t i = 0, e = rp-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">     229 </span><span class="lineCov">       2215 :             if (info.isObservableSlot(i))</span>
<span class="lineNum">     230 </span><span class="lineCov">        196 :                 rp-&gt;getOperand(i)-&gt;setUseRemovedUnchecked();</span>
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineCov">        138 :         rp = rp-&gt;caller();</span>
<span class="lineNum">     234 </span>            :     }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :     // Flag Phi inputs of the successors has having removed uses.
<span class="lineNum">     237 </span><span class="lineCov">        210 :     MPhiVector worklist;</span>
<span class="lineNum">     238 </span><span class="lineCov">        224 :     for (size_t i = 0, e = block-&gt;numSuccessors(); i &lt; e; i++) {</span>
<span class="lineNum">     239 </span><span class="lineCov">        119 :         if (mir-&gt;shouldCancel(&quot;FlagAllOperandsAsHavingRemovedUses loop 3&quot;))</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineCov">        119 :         if (!FlagPhiInputsAsHavingRemovedUses(mir, block, block-&gt;getSuccessor(i), worklist))</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     244 </span>            :     }
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">        105 :     return true;</span>
<span class="lineNum">     247 </span>            : }
<a name="248"><span class="lineNum">     248 </span>            : </a>
<span class="lineNum">     249 </span>            : static void
<span class="lineNum">     250 </span><span class="lineCov">        105 : RemoveFromSuccessors(MBasicBlock* block)</span>
<span class="lineNum">     251 </span>            : {
<span class="lineNum">     252 </span>            :     // Remove this block from its successors.
<span class="lineNum">     253 </span><span class="lineCov">        105 :     size_t numSucc = block-&gt;numSuccessors();</span>
<span class="lineNum">     254 </span><span class="lineCov">        343 :     while (numSucc--) {</span>
<span class="lineNum">     255 </span><span class="lineCov">        119 :         MBasicBlock* succ = block-&gt;getSuccessor(numSucc);</span>
<span class="lineNum">     256 </span><span class="lineCov">        119 :         if (succ-&gt;isDead())</span>
<span class="lineNum">     257 </span><span class="lineCov">         88 :             continue;</span>
<span class="lineNum">     258 </span><span class="lineCov">         31 :         JitSpew(JitSpew_Prune, &quot;Remove block edge %d -&gt; %d.&quot;, block-&gt;id(), succ-&gt;id());</span>
<span class="lineNum">     259 </span><span class="lineCov">         31 :         succ-&gt;removePredecessor(block);</span>
<span class="lineNum">     260 </span>            :     }
<span class="lineNum">     261 </span><span class="lineCov">        105 : }</span>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<span class="lineNum">     263 </span>            : static void
<span class="lineNum">     264 </span><span class="lineCov">         35 : ConvertToBailingBlock(TempAllocator&amp; alloc, MBasicBlock* block)</span>
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span>            :     // Add a bailout instruction.
<span class="lineNum">     267 </span><span class="lineCov">         35 :     MBail* bail = MBail::New(alloc, Bailout_FirstExecution);</span>
<span class="lineNum">     268 </span><span class="lineCov">         35 :     MInstruction* bailPoint = block-&gt;safeInsertTop();</span>
<span class="lineNum">     269 </span><span class="lineCov">         35 :     block-&gt;insertBefore(block-&gt;safeInsertTop(), bail);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     // Discard all remaining instructions.
<span class="lineNum">     272 </span><span class="lineCov">         35 :     MInstructionIterator clearStart = block-&gt;begin(bailPoint);</span>
<span class="lineNum">     273 </span><span class="lineCov">         35 :     block-&gt;discardAllInstructionsStartingAt(clearStart);</span>
<span class="lineNum">     274 </span><span class="lineCov">         35 :     if (block-&gt;outerResumePoint())</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         block-&gt;clearOuterResumePoint();</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     // And replace the last instruction by the unreachable control instruction.
<span class="lineNum">     278 </span><span class="lineCov">         35 :     block-&gt;end(MUnreachable::New(alloc));</span>
<span class="lineNum">     279 </span><span class="lineCov">         35 : }</span>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : bool
<span class="lineNum">     282 </span><span class="lineCov">          8 : jit::PruneUnusedBranches(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span><span class="lineCov">          8 :     MOZ_ASSERT(!mir-&gt;compilingWasm(), &quot;wasm compilation has no code coverage support.&quot;);</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     // We do a reverse-post-order traversal, marking basic blocks when the block
<span class="lineNum">     287 </span>            :     // have to be converted into bailing blocks, and flagging block as
<span class="lineNum">     288 </span>            :     // unreachable if all predecessors are flagged as bailing or unreachable.
<span class="lineNum">     289 </span><span class="lineCov">          8 :     bool someUnreachable = false;</span>
<span class="lineNum">     290 </span><span class="lineCov">        652 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">     291 </span><span class="lineCov">        644 :         if (mir-&gt;shouldCancel(&quot;Prune unused branches (main loop)&quot;))</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineCov">        644 :         JitSpew(JitSpew_Prune, &quot;Investigate Block %d:&quot;, block-&gt;id());</span>
<span class="lineNum">     295 </span><span class="lineCov">        749 :         JitSpewIndent indent(JitSpew_Prune);</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :         // Do not touch entry basic blocks.
<span class="lineNum">     298 </span><span class="lineCov">        644 :         if (*block == graph.osrBlock() || *block == graph.entryBlock()) {</span>
<span class="lineNum">     299 </span><span class="lineCov">         11 :             JitSpew(JitSpew_Prune, &quot;Block %d is an entry point.&quot;, block-&gt;id());</span>
<span class="lineNum">     300 </span><span class="lineCov">         11 :             continue;</span>
<span class="lineNum">     301 </span>            :         }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :         // Compute if all the predecessors of this block are either bailling out
<span class="lineNum">     304 </span>            :         // or are already flagged as unreachable.
<span class="lineNum">     305 </span><span class="lineCov">        633 :         bool isUnreachable = true;</span>
<span class="lineNum">     306 </span><span class="lineCov">        633 :         bool isLoopHeader = block-&gt;isLoopHeader();</span>
<span class="lineNum">     307 </span><span class="lineCov">        633 :         size_t numPred = block-&gt;numPredecessors();</span>
<span class="lineNum">     308 </span><span class="lineCov">        633 :         size_t i = 0;</span>
<span class="lineNum">     309 </span><span class="lineCov">        853 :         for (; i &lt; numPred; i++) {</span>
<span class="lineNum">     310 </span><span class="lineCov">        673 :             if (mir-&gt;shouldCancel(&quot;Prune unused branches (inner loop 1)&quot;))</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineCov">        673 :             MBasicBlock* pred = block-&gt;getPredecessor(i);</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :             // The backedge is visited after the loop header, but if the loop
<span class="lineNum">     316 </span>            :             // header is unreachable, then we can assume that the backedge would
<span class="lineNum">     317 </span>            :             // be unreachable too.
<span class="lineNum">     318 </span><span class="lineCov">        673 :             if (isLoopHeader &amp;&amp; pred == block-&gt;backedge())</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :             // Break if any of the predecessor can continue in this block.
<span class="lineNum">     322 </span><span class="lineCov">        673 :             if (!pred-&gt;isMarked() &amp;&amp; !pred-&gt;unreachable()) {</span>
<span class="lineNum">     323 </span><span class="lineCov">        563 :                 isUnreachable = false;</span>
<span class="lineNum">     324 </span><span class="lineCov">        563 :                 break;</span>
<span class="lineNum">     325 </span>            :             }
<span class="lineNum">     326 </span>            :         }
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :         // Compute if the block should bailout, based on the trivial heuristic
<span class="lineNum">     329 </span>            :         // which is that if the block never got visited before, then it is
<span class="lineNum">     330 </span>            :         // likely to not be visited after.
<span class="lineNum">     331 </span>            :         bool shouldBailout =
<span class="lineNum">     332 </span><span class="lineCov">       1237 :             block-&gt;getHitState() == MBasicBlock::HitState::Count &amp;&amp;</span>
<span class="lineNum">     333 </span><span class="lineCov">       1237 :             block-&gt;getHitCount() == 0;</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :         // Check if the predecessors got accessed a large number of times in
<span class="lineNum">     336 </span>            :         // comparisons of the current block, in order to know if our attempt at
<span class="lineNum">     337 </span>            :         // removing this block is not premature.
<span class="lineNum">     338 </span><span class="lineCov">        633 :         if (!isUnreachable &amp;&amp; shouldBailout) {</span>
<span class="lineNum">     339 </span><span class="lineCov">         86 :             size_t p = numPred;</span>
<span class="lineNum">     340 </span><span class="lineCov">         86 :             size_t predCount = 0;</span>
<span class="lineNum">     341 </span><span class="lineCov">         86 :             size_t numSuccessorsOfPreds = 1;</span>
<span class="lineNum">     342 </span><span class="lineCov">         86 :             bool isLoopExit = false;</span>
<span class="lineNum">     343 </span><span class="lineCov">        268 :             while (p--) {</span>
<span class="lineNum">     344 </span><span class="lineCov">         91 :                 if (mir-&gt;shouldCancel(&quot;Prune unused branches (inner loop 2)&quot;))</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineCov">         91 :                 MBasicBlock* pred = block-&gt;getPredecessor(p);</span>
<span class="lineNum">     348 </span><span class="lineCov">         91 :                 if (pred-&gt;getHitState() == MBasicBlock::HitState::Count)</span>
<span class="lineNum">     349 </span><span class="lineCov">         89 :                     predCount += pred-&gt;getHitCount();</span>
<span class="lineNum">     350 </span><span class="lineCov">         91 :                 isLoopExit |= pred-&gt;isLoopHeader() &amp;&amp; pred-&gt;backedge() != *block;</span>
<span class="lineNum">     351 </span><span class="lineCov">         91 :                 numSuccessorsOfPreds += pred-&gt;numSuccessors() - 1;</span>
<span class="lineNum">     352 </span>            :             }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :             // Iterate over the approximated set of dominated blocks and count
<span class="lineNum">     355 </span>            :             // the number of instructions which are dominated.  Note that this
<span class="lineNum">     356 </span>            :             // approximation has issues with OSR blocks, but this should not be
<span class="lineNum">     357 </span>            :             // a big deal.
<span class="lineNum">     358 </span><span class="lineCov">         86 :             size_t numDominatedInst = 0;</span>
<span class="lineNum">     359 </span><span class="lineCov">         86 :             size_t numEffectfulInst = 0;</span>
<span class="lineNum">     360 </span><span class="lineCov">         86 :             int numInOutEdges = block-&gt;numPredecessors();</span>
<span class="lineNum">     361 </span><span class="lineCov">         86 :             size_t branchSpan = 0;</span>
<span class="lineNum">     362 </span><span class="lineCov">         86 :             ReversePostorderIterator it(block);</span>
<span class="lineNum">     363 </span><span class="lineCov">       3433 :             do {</span>
<span class="lineNum">     364 </span><span class="lineCov">       1777 :                 if (mir-&gt;shouldCancel(&quot;Prune unused branches (inner loop 3)&quot;))</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :                 // Iterate over dominated blocks, and visit exit blocks as well.
<span class="lineNum">     368 </span><span class="lineCov">       1777 :                 numInOutEdges -= it-&gt;numPredecessors();</span>
<span class="lineNum">     369 </span><span class="lineCov">       1777 :                 if (numInOutEdges &lt; 0)</span>
<span class="lineNum">     370 </span><span class="lineCov">         69 :                     break;</span>
<span class="lineNum">     371 </span><span class="lineCov">       1708 :                 numInOutEdges += it-&gt;numSuccessors();</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :                 // Collect information about the instructions within the block.
<span class="lineNum">     374 </span><span class="lineCov">       5858 :                 for (MDefinitionIterator def(*it); def; def++) {</span>
<span class="lineNum">     375 </span><span class="lineCov">       4150 :                     numDominatedInst++;</span>
<span class="lineNum">     376 </span><span class="lineCov">       4150 :                     if (def-&gt;isEffectful())</span>
<span class="lineNum">     377 </span><span class="lineCov">        497 :                         numEffectfulInst++;</span>
<span class="lineNum">     378 </span>            :                 }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineCov">       1708 :                 it++;</span>
<span class="lineNum">     381 </span><span class="lineCov">       1708 :                 branchSpan++;</span>
<span class="lineNum">     382 </span><span class="lineCov">       5107 :             } while(numInOutEdges &gt; 0 &amp;&amp; it != graph.rpoEnd());</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :             // The goal of branch pruning is to remove branches which are
<span class="lineNum">     385 </span>            :             // preventing other optimization, while keeping branches which would
<span class="lineNum">     386 </span>            :             // be costly if we were to bailout. The following heuristics are
<span class="lineNum">     387 </span>            :             // made to prevent bailouts in branches when we estimate that the
<span class="lineNum">     388 </span>            :             // confidence is not enough to compensate for the cost of a bailout.
<span class="lineNum">     389 </span>            :             //
<span class="lineNum">     390 </span>            :             //   1. Confidence for removal varies with the number of hit counts
<span class="lineNum">     391 </span>            :             //      of the predecessor. The reason being that the likelyhood of
<span class="lineNum">     392 </span>            :             //      taking this branch is decreasing with the number of hit
<span class="lineNum">     393 </span>            :             //      counts of the predecessor.
<span class="lineNum">     394 </span>            :             //
<span class="lineNum">     395 </span>            :             //   2. Confidence for removal varies with the number of dominated
<span class="lineNum">     396 </span>            :             //      instructions. The reason being that the complexity of the
<span class="lineNum">     397 </span>            :             //      branch increases with the number of instructions, thus
<span class="lineNum">     398 </span>            :             //      working against other optimizations.
<span class="lineNum">     399 </span>            :             //
<span class="lineNum">     400 </span>            :             //   3. Confidence for removal varies with the span of the
<span class="lineNum">     401 </span>            :             //      branch. The reason being that a branch that spans over a
<span class="lineNum">     402 </span>            :             //      large set of blocks is likely to remove optimization
<span class="lineNum">     403 </span>            :             //      opportunity as it prevents instructions from the other
<span class="lineNum">     404 </span>            :             //      branches to dominate the blocks which are after.
<span class="lineNum">     405 </span>            :             //
<span class="lineNum">     406 </span>            :             //   4. Confidence for removal varies with the number of effectful
<span class="lineNum">     407 </span>            :             //      instructions. The reason being that an effectful instruction
<span class="lineNum">     408 </span>            :             //      can remove optimization opportunities based on Scalar
<span class="lineNum">     409 </span>            :             //      Replacement, and based on Alias Analysis.
<span class="lineNum">     410 </span>            :             //
<span class="lineNum">     411 </span>            :             // The following converts various units in some form of arbitrary
<span class="lineNum">     412 </span>            :             // score, such that we can compare it to a threshold.
<span class="lineNum">     413 </span><span class="lineCov">         86 :             size_t score = 0;</span>
<span class="lineNum">     414 </span><span class="lineCov">         86 :             MOZ_ASSERT(numSuccessorsOfPreds &gt;= 1);</span>
<span class="lineNum">     415 </span><span class="lineCov">         86 :             score += predCount * JitOptions.branchPruningHitCountFactor / numSuccessorsOfPreds;</span>
<span class="lineNum">     416 </span><span class="lineCov">         86 :             score += numDominatedInst * JitOptions.branchPruningInstFactor;</span>
<span class="lineNum">     417 </span><span class="lineCov">         86 :             score += branchSpan * JitOptions.branchPruningBlockSpanFactor;</span>
<span class="lineNum">     418 </span><span class="lineCov">         86 :             score += numEffectfulInst * JitOptions.branchPruningEffectfulInstFactor;</span>
<span class="lineNum">     419 </span><span class="lineCov">         86 :             if (score &lt; JitOptions.branchPruningThreshold)</span>
<span class="lineNum">     420 </span><span class="lineCov">         31 :                 shouldBailout = false;</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :             // If the predecessors do not have enough hit counts, keep the
<span class="lineNum">     423 </span>            :             // branch, until we recompile this function later, with more
<span class="lineNum">     424 </span>            :             // information.
<span class="lineNum">     425 </span><span class="lineCov">         86 :             if (predCount / numSuccessorsOfPreds &lt; 50)</span>
<span class="lineNum">     426 </span><span class="lineCov">         43 :                 shouldBailout = false;</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :             // There is only a single successors to the predecessors, thus the
<span class="lineNum">     429 </span>            :             // decision should be taken as part of the previous block
<span class="lineNum">     430 </span>            :             // investigation, and this block should be unreachable.
<span class="lineNum">     431 </span><span class="lineCov">         86 :             if (numSuccessorsOfPreds == 1)</span>
<span class="lineNum">     432 </span><span class="lineCov">         11 :                 shouldBailout = false;</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :             // If this is the exit block of a loop, then keep this basic
<span class="lineNum">     435 </span>            :             // block. This heuristic is useful as a bailout is often much more
<span class="lineNum">     436 </span>            :             // costly than a simple exit sequence.
<span class="lineNum">     437 </span><span class="lineCov">         86 :             if (isLoopExit)</span>
<span class="lineNum">     438 </span><span class="lineCov">          1 :                 shouldBailout = false;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :             // Interpreters are often implemented as a table switch within a for
<span class="lineNum">     441 </span>            :             // loop. What might happen is that the interpreter heats up in a
<span class="lineNum">     442 </span>            :             // subset of instructions, but might need other instructions for the
<span class="lineNum">     443 </span>            :             // rest of the evaluation.
<span class="lineNum">     444 </span><span class="lineCov">         86 :             if (numSuccessorsOfPreds &gt; 8)</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 shouldBailout = false;</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">         86 :             JitSpew(JitSpew_Prune, &quot;info: block %d,&quot;</span>
<span class="lineNum">     448 </span>            :                     &quot; predCount: %&quot; PRIuSIZE &quot;, domInst: %&quot; PRIuSIZE
<span class="lineNum">     449 </span>            :                     &quot;, span: %&quot; PRIuSIZE &quot;, effectful: %&quot; PRIuSIZE &quot;, &quot;
<span class="lineNum">     450 </span>            :                     &quot; isLoopExit: %s, numSuccessorsOfPred: %&quot; PRIuSIZE &quot;.&quot;
<span class="lineNum">     451 </span>            :                     &quot; (score: %&quot; PRIuSIZE &quot;, shouldBailout: %s)&quot;,
<span class="lineNum">     452 </span>            :                     block-&gt;id(), predCount, numDominatedInst, branchSpan, numEffectfulInst,
<span class="lineNum">     453 </span>            :                     isLoopExit ? &quot;true&quot; : &quot;false&quot;, numSuccessorsOfPreds,
<span class="lineNum">     454 </span><span class="lineCov">         86 :                     score, shouldBailout ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="lineNum">     455 </span>            :         }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :         // Continue to the next basic block if the current basic block can
<span class="lineNum">     458 </span>            :         // remain unchanged.
<span class="lineNum">     459 </span><span class="lineCov">        633 :         if (!isUnreachable &amp;&amp; !shouldBailout)</span>
<span class="lineNum">     460 </span><span class="lineCov">        528 :             continue;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineCov">        105 :         someUnreachable = true;</span>
<span class="lineNum">     463 </span><span class="lineCov">        105 :         if (isUnreachable) {</span>
<span class="lineNum">     464 </span><span class="lineCov">         70 :             JitSpew(JitSpew_Prune, &quot;Mark block %d as unreachable.&quot;, block-&gt;id());</span>
<span class="lineNum">     465 </span><span class="lineCov">         70 :             block-&gt;setUnreachable();</span>
<span class="lineNum">     466 </span>            :             // If the block is unreachable, then there is no need to convert it
<span class="lineNum">     467 </span>            :             // to a bailing block.
<span class="lineNum">     468 </span><span class="lineCov">         35 :         } else if (shouldBailout) {</span>
<span class="lineNum">     469 </span><span class="lineCov">         35 :             JitSpew(JitSpew_Prune, &quot;Mark block %d as bailing block.&quot;, block-&gt;id());</span>
<span class="lineNum">     470 </span><span class="lineCov">         35 :             block-&gt;markUnchecked();</span>
<span class="lineNum">     471 </span>            :         }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :         // When removing a loop header, we should ensure that its backedge is
<span class="lineNum">     474 </span>            :         // removed first, otherwise this triggers an assertion in
<span class="lineNum">     475 </span>            :         // removePredecessorsWithoutPhiOperands.
<span class="lineNum">     476 </span><span class="lineCov">        105 :         if (block-&gt;isLoopHeader()) {</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             JitSpew(JitSpew_Prune, &quot;Mark block %d as bailing block. (loop backedge)&quot;, block-&gt;backedge()-&gt;id());</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             block-&gt;backedge()-&gt;markUnchecked();</span>
<span class="lineNum">     479 </span>            :         }
<span class="lineNum">     480 </span>            :     }
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     // Returns early if nothing changed.
<span class="lineNum">     483 </span><span class="lineCov">          8 :     if (!someUnreachable)</span>
<span class="lineNum">     484 </span><span class="lineCov">          4 :         return true;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">          4 :     JitSpew(JitSpew_Prune, &quot;Convert basic block to bailing blocks, and remove unreachable blocks:&quot;);</span>
<span class="lineNum">     487 </span><span class="lineCov">          8 :     JitSpewIndent indent(JitSpew_Prune);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :     // As we are going to remove edges and basic block, we have to mark
<span class="lineNum">     490 </span>            :     // instructions which would be needed by baseline if we were to bailout.
<span class="lineNum">     491 </span><span class="lineCov">        597 :     for (PostorderIterator it(graph.poBegin()); it != graph.poEnd();) {</span>
<span class="lineNum">     492 </span><span class="lineCov">        593 :         if (mir-&gt;shouldCancel(&quot;Prune unused branches (marking loop)&quot;))</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineCov">        593 :         MBasicBlock* block = *it++;</span>
<span class="lineNum">     496 </span><span class="lineCov">        593 :         if (!block-&gt;isMarked() &amp;&amp; !block-&gt;unreachable())</span>
<span class="lineNum">     497 </span><span class="lineCov">        488 :             continue;</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineCov">        105 :         FlagAllOperandsAsHavingRemovedUses(mir, block);</span>
<span class="lineNum">     500 </span>            :     }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :     // Remove the blocks in post-order such that consumers are visited before
<span class="lineNum">     503 </span>            :     // the predecessors, the only exception being the Phi nodes of loop headers.
<span class="lineNum">     504 </span><span class="lineCov">        597 :     for (PostorderIterator it(graph.poBegin()); it != graph.poEnd();) {</span>
<span class="lineNum">     505 </span><span class="lineCov">        593 :         if (mir-&gt;shouldCancel(&quot;Prune unused branches (removal loop)&quot;))</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">        593 :         MBasicBlock* block = *it++;</span>
<span class="lineNum">     509 </span><span class="lineCov">        593 :         if (!block-&gt;isMarked() &amp;&amp; !block-&gt;unreachable())</span>
<span class="lineNum">     510 </span><span class="lineCov">        488 :             continue;</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineCov">        105 :         JitSpew(JitSpew_Prune, &quot;Remove / Replace block %d.&quot;, block-&gt;id());</span>
<span class="lineNum">     513 </span><span class="lineCov">        210 :         JitSpewIndent indent(JitSpew_Prune);</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :         // As we are going to replace/remove the last instruction, we first have
<span class="lineNum">     516 </span>            :         // to remove this block from the predecessor list of its successors.
<span class="lineNum">     517 </span><span class="lineCov">        105 :         RemoveFromSuccessors(block);</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :         // Convert the current basic block to a bailing block which ends with an
<span class="lineNum">     520 </span>            :         // Unreachable control instruction.
<span class="lineNum">     521 </span><span class="lineCov">        105 :         if (block-&gt;isMarked()) {</span>
<span class="lineNum">     522 </span><span class="lineCov">         35 :             JitSpew(JitSpew_Prune, &quot;Convert Block %d to a bailing block.&quot;, block-&gt;id());</span>
<span class="lineNum">     523 </span><span class="lineCov">         35 :             if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     525 </span><span class="lineCov">         35 :             ConvertToBailingBlock(graph.alloc(), block);</span>
<span class="lineNum">     526 </span><span class="lineCov">         35 :             block-&gt;unmark();</span>
<span class="lineNum">     527 </span>            :         }
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :         // Remove all instructions.
<span class="lineNum">     530 </span><span class="lineCov">        105 :         if (block-&gt;unreachable()) {</span>
<span class="lineNum">     531 </span><span class="lineCov">         70 :             JitSpew(JitSpew_Prune, &quot;Remove Block %d.&quot;, block-&gt;id());</span>
<span class="lineNum">     532 </span><span class="lineCov">        140 :             JitSpewIndent indent(JitSpew_Prune);</span>
<span class="lineNum">     533 </span><span class="lineCov">         70 :             graph.removeBlock(block);</span>
<span class="lineNum">     534 </span>            :         }
<span class="lineNum">     535 </span>            :     }
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">          4 :     return true;</span>
<span class="lineNum">     538 </span>            : }
<a name="539"><span class="lineNum">     539 </span>            : </a>
<span class="lineNum">     540 </span>            : static bool
<span class="lineNum">     541 </span><span class="lineCov">       3390 : SplitCriticalEdgesForBlock(MIRGraph&amp; graph, MBasicBlock* block)</span>
<span class="lineNum">     542 </span>            : {
<span class="lineNum">     543 </span><span class="lineCov">       3390 :     if (block-&gt;numSuccessors() &lt; 2)</span>
<span class="lineNum">     544 </span><span class="lineCov">       2532 :         return true;</span>
<span class="lineNum">     545 </span><span class="lineCov">       2794 :     for (size_t i = 0; i &lt; block-&gt;numSuccessors(); i++) {</span>
<span class="lineNum">     546 </span><span class="lineCov">       1936 :         MBasicBlock* target = block-&gt;getSuccessor(i);</span>
<span class="lineNum">     547 </span><span class="lineCov">       1936 :         if (target-&gt;numPredecessors() &lt; 2)</span>
<span class="lineNum">     548 </span><span class="lineCov">       1922 :             continue;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :         // Create a simple new block which contains a goto and which split the
<span class="lineNum">     551 </span>            :         // edge between block and target.
<span class="lineNum">     552 </span><span class="lineCov">         14 :         MBasicBlock* split = MBasicBlock::NewSplitEdge(graph, block, i, target);</span>
<span class="lineNum">     553 </span><span class="lineCov">         14 :         if (!split)</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span><span class="lineCov">        858 :     return true;</span>
<span class="lineNum">     557 </span>            : }
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            : // A critical edge is an edge which is neither its successor's only predecessor
<span class="lineNum">     560 </span>            : // nor its predecessor's only successor. Critical edges must be split to
<a name="561"><span class="lineNum">     561 </span>            : // prevent copy-insertion and code motion from affecting other edges.</a>
<span class="lineNum">     562 </span>            : bool
<span class="lineNum">     563 </span><span class="lineCov">        141 : jit::SplitCriticalEdges(MIRGraph&amp; graph)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span><span class="lineCov">       3509 :     for (MBasicBlockIterator iter(graph.begin()); iter != graph.end(); iter++) {</span>
<span class="lineNum">     566 </span><span class="lineCov">       3368 :         MBasicBlock* block = *iter;</span>
<span class="lineNum">     567 </span><span class="lineCov">       3368 :         if (!SplitCriticalEdgesForBlock(graph, block))</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     569 </span>            :     }
<span class="lineNum">     570 </span><span class="lineCov">        141 :     return true;</span>
<span class="lineNum">     571 </span>            : }
<a name="572"><span class="lineNum">     572 </span>            : </a>
<span class="lineNum">     573 </span>            : bool
<span class="lineNum">     574 </span><span class="lineCov">         13 : jit::IsUint32Type(const MDefinition* def)</span>
<span class="lineNum">     575 </span>            : {
<span class="lineNum">     576 </span><span class="lineCov">         13 :     if (def-&gt;isBeta())</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         def = def-&gt;getOperand(0);</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">         13 :     if (def-&gt;type() != MIRType::Int32)</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">         13 :     return def-&gt;isUrsh() &amp;&amp; def-&gt;getOperand(1)-&gt;isConstant() &amp;&amp;</span>
<span class="lineNum">     583 </span><span class="lineCov">         13 :         def-&gt;getOperand(1)-&gt;toConstant()-&gt;type() == MIRType::Int32 &amp;&amp;</span>
<span class="lineNum">     584 </span><span class="lineCov">         13 :         def-&gt;getOperand(1)-&gt;toConstant()-&gt;toInt32() == 0;</span>
<span class="lineNum">     585 </span>            : }
<span class="lineNum">     586 </span>            : 
<a name="587"><span class="lineNum">     587 </span>            : // Return whether a block simply computes the specified constant value.</a>
<span class="lineNum">     588 </span>            : static bool
<span class="lineNum">     589 </span><span class="lineCov">         26 : BlockComputesConstant(MBasicBlock* block, MDefinition* value, bool* constBool)</span>
<span class="lineNum">     590 </span>            : {
<span class="lineNum">     591 </span>            :     // Look for values with no uses. This is used to eliminate constant
<span class="lineNum">     592 </span>            :     // computing blocks in condition statements, and the phi which used to
<span class="lineNum">     593 </span>            :     // consume the constant has already been removed.
<span class="lineNum">     594 </span><span class="lineCov">         26 :     if (value-&gt;hasUses())</span>
<span class="lineNum">     595 </span><span class="lineCov">         20 :         return false;</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineCov">          6 :     if (!value-&gt;isConstant() || value-&gt;block() != block)</span>
<span class="lineNum">     598 </span><span class="lineCov">          6 :         return false;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     if (!block-&gt;phisEmpty())</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     for (MInstructionIterator iter = block-&gt;begin(); iter != block-&gt;end(); ++iter) {</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         if (*iter != value || !iter-&gt;isGoto())</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     return value-&gt;toConstant()-&gt;valueToBoolean(constBool);</span>
<span class="lineNum">     606 </span>            : }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : // Find phis that are redudant:
<span class="lineNum">     609 </span>            : //
<span class="lineNum">     610 </span>            : // 1) phi(a, a)
<span class="lineNum">     611 </span>            : //     can get replaced by a
<span class="lineNum">     612 </span>            : //
<span class="lineNum">     613 </span>            : // 2) phi(filtertypeset(a, type1), filtertypeset(a, type1))
<span class="lineNum">     614 </span>            : //     equals filtertypeset(a, type1)
<span class="lineNum">     615 </span>            : //
<span class="lineNum">     616 </span>            : // 3) phi(a, filtertypeset(a, type1))
<span class="lineNum">     617 </span>            : //     equals filtertypeset(a, type1 union type(a))
<span class="lineNum">     618 </span>            : //     equals filtertypeset(a, type(a))
<span class="lineNum">     619 </span>            : //     equals a
<span class="lineNum">     620 </span>            : //
<span class="lineNum">     621 </span>            : // 4) phi(filtertypeset(a, type1), filtertypeset(a, type2))
<span class="lineNum">     622 </span>            : //    equals filtertypeset(a, type1 union type2)
<span class="lineNum">     623 </span>            : //
<span class="lineNum">     624 </span>            : //    This is the special case. We can only replace this with 'a' iif
<span class="lineNum">     625 </span>            : //    type(a) == type1 union type2. Since optimizations could have
<a name="626"><span class="lineNum">     626 </span>            : //    happened based on a more specific phi type.</a>
<span class="lineNum">     627 </span>            : static bool
<span class="lineNum">     628 </span><span class="lineCov">          8 : IsPhiRedudantFilter(MPhi* phi)</span>
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span>            :     // Handle (1) and (2)
<span class="lineNum">     631 </span><span class="lineCov">          8 :     if (phi-&gt;operandIfRedundant())</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :     // Handle (3)
<span class="lineNum">     635 </span><span class="lineCov">          8 :     bool onlyFilters = false;</span>
<span class="lineNum">     636 </span><span class="lineCov">          8 :     MDefinition* a = phi-&gt;getOperand(0);</span>
<span class="lineNum">     637 </span><span class="lineCov">          8 :     if (a-&gt;isFilterTypeSet()) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         a = a-&gt;toFilterTypeSet()-&gt;input();</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         onlyFilters = true;</span>
<span class="lineNum">     640 </span>            :     }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineCov">         16 :     for (size_t i = 1; i &lt; phi-&gt;numOperands(); i++) {</span>
<span class="lineNum">     643 </span><span class="lineCov">          8 :         MDefinition* operand = phi-&gt;getOperand(i);</span>
<span class="lineNum">     644 </span><span class="lineCov">          8 :         if (operand == a) {</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :             onlyFilters = false;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     647 </span>            :         }
<span class="lineNum">     648 </span><span class="lineCov">          8 :         if (operand-&gt;isFilterTypeSet() &amp;&amp; operand-&gt;toFilterTypeSet()-&gt;input() == a)</span>
<span class="lineNum">     649 </span><span class="lineCov">          8 :             continue;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     651 </span>            :     }
<span class="lineNum">     652 </span><span class="lineCov">          8 :     if (!onlyFilters)</span>
<span class="lineNum">     653 </span><span class="lineCov">          8 :         return true;</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :     // Handle (4)
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(onlyFilters);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     return EqualTypes(a-&gt;type(), a-&gt;resultTypeSet(),</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                       phi-&gt;type(), phi-&gt;resultTypeSet());</span>
<span class="lineNum">     659 </span>            : }
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : // Determine whether phiBlock/testBlock simply compute a phi and perform a
<a name="662"><span class="lineNum">     662 </span>            : // test on it.</a>
<span class="lineNum">     663 </span>            : static bool
<span class="lineNum">     664 </span><span class="lineCov">         22 : BlockIsSingleTest(MBasicBlock* phiBlock, MBasicBlock* testBlock, MPhi** pphi, MTest** ptest)</span>
<span class="lineNum">     665 </span>            : {
<span class="lineNum">     666 </span><span class="lineCov">         22 :     *pphi = nullptr;</span>
<span class="lineNum">     667 </span><span class="lineCov">         22 :     *ptest = nullptr;</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">         22 :     if (phiBlock != testBlock) {</span>
<span class="lineNum">     670 </span><span class="lineCov">          4 :         MOZ_ASSERT(phiBlock-&gt;numSuccessors() == 1 &amp;&amp; phiBlock-&gt;getSuccessor(0) == testBlock);</span>
<span class="lineNum">     671 </span><span class="lineCov">          4 :         if (!phiBlock-&gt;begin()-&gt;isGoto())</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineCov">         22 :     MInstruction* ins = *testBlock-&gt;begin();</span>
<span class="lineNum">     676 </span><span class="lineCov">         22 :     if (!ins-&gt;isTest())</span>
<span class="lineNum">     677 </span><span class="lineCov">          7 :         return false;</span>
<span class="lineNum">     678 </span><span class="lineCov">         15 :     MTest* test = ins-&gt;toTest();</span>
<span class="lineNum">     679 </span><span class="lineCov">         15 :     if (!test-&gt;input()-&gt;isPhi())</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     681 </span><span class="lineCov">         15 :     MPhi* phi = test-&gt;input()-&gt;toPhi();</span>
<span class="lineNum">     682 </span><span class="lineCov">         15 :     if (phi-&gt;block() != phiBlock)</span>
<span class="lineNum">     683 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">         39 :     for (MUseIterator iter = phi-&gt;usesBegin(); iter != phi-&gt;usesEnd(); ++iter) {</span>
<span class="lineNum">     686 </span><span class="lineCov">         26 :         MUse* use = *iter;</span>
<span class="lineNum">     687 </span><span class="lineCov">         26 :         if (use-&gt;consumer() == test)</span>
<span class="lineNum">     688 </span><span class="lineCov">         13 :             continue;</span>
<span class="lineNum">     689 </span><span class="lineCov">         13 :         if (use-&gt;consumer()-&gt;isResumePoint()) {</span>
<span class="lineNum">     690 </span><span class="lineCov">         13 :             MBasicBlock* useBlock = use-&gt;consumer()-&gt;block();</span>
<span class="lineNum">     691 </span><span class="lineCov">         13 :             if (useBlock == phiBlock || useBlock == testBlock)</span>
<span class="lineNum">     692 </span><span class="lineCov">         13 :                 continue;</span>
<span class="lineNum">     693 </span>            :         }
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     695 </span>            :     }
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineCov">         30 :     for (MPhiIterator iter = phiBlock-&gt;phisBegin(); iter != phiBlock-&gt;phisEnd(); ++iter) {</span>
<span class="lineNum">     698 </span><span class="lineCov">         17 :         if (*iter == phi)</span>
<span class="lineNum">     699 </span><span class="lineCov">         13 :             continue;</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineCov">          4 :         if (IsPhiRedudantFilter(*iter))</span>
<span class="lineNum">     702 </span><span class="lineCov">          4 :             continue;</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">         13 :     if (phiBlock != testBlock &amp;&amp; !testBlock-&gt;phisEmpty())</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineCov">         13 :     *pphi = phi;</span>
<span class="lineNum">     711 </span><span class="lineCov">         13 :     *ptest = test;</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">         13 :     return true;</span>
<span class="lineNum">     714 </span>            : }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : // Change block so that it ends in a goto to the specific target block.
<a name="717"><span class="lineNum">     717 </span>            : // existingPred is an existing predecessor of the block.</a>
<span class="lineNum">     718 </span>            : static void
<span class="lineNum">     719 </span><span class="lineCov">         13 : UpdateGotoSuccessor(TempAllocator&amp; alloc, MBasicBlock* block, MBasicBlock* target,</span>
<span class="lineNum">     720 </span>            :                      MBasicBlock* existingPred)
<span class="lineNum">     721 </span>            : {
<span class="lineNum">     722 </span><span class="lineCov">         13 :     MInstruction* ins = block-&gt;lastIns();</span>
<span class="lineNum">     723 </span><span class="lineCov">         13 :     MOZ_ASSERT(ins-&gt;isGoto());</span>
<span class="lineNum">     724 </span><span class="lineCov">         13 :     ins-&gt;toGoto()-&gt;target()-&gt;removePredecessor(block);</span>
<span class="lineNum">     725 </span><span class="lineCov">         13 :     block-&gt;discardLastIns();</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">         13 :     MGoto* newGoto = MGoto::New(alloc, target);</span>
<span class="lineNum">     728 </span><span class="lineCov">         13 :     block-&gt;end(newGoto);</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">         13 :     target-&gt;addPredecessorSameInputsAs(block, existingPred);</span>
<span class="lineNum">     731 </span><span class="lineCov">         13 : }</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : // Change block so that it ends in a test of the specified value, going to
<span class="lineNum">     734 </span>            : // either ifTrue or ifFalse. existingPred is an existing predecessor of ifTrue
<span class="lineNum">     735 </span>            : // or ifFalse with the same values incoming to ifTrue/ifFalse as block.
<span class="lineNum">     736 </span>            : // existingPred is not required to be a predecessor of ifTrue/ifFalse if block
<a name="737"><span class="lineNum">     737 </span>            : // already ends in a test going to that block on a true/false result.</a>
<span class="lineNum">     738 </span>            : static void
<span class="lineNum">     739 </span><span class="lineCov">         26 : UpdateTestSuccessors(TempAllocator&amp; alloc, MBasicBlock* block,</span>
<span class="lineNum">     740 </span>            :                      MDefinition* value, MBasicBlock* ifTrue, MBasicBlock* ifFalse,
<span class="lineNum">     741 </span>            :                      MBasicBlock* existingPred)
<span class="lineNum">     742 </span>            : {
<span class="lineNum">     743 </span><span class="lineCov">         26 :     MInstruction* ins = block-&gt;lastIns();</span>
<span class="lineNum">     744 </span><span class="lineCov">         26 :     if (ins-&gt;isTest()) {</span>
<span class="lineNum">     745 </span><span class="lineCov">         13 :         MTest* test = ins-&gt;toTest();</span>
<span class="lineNum">     746 </span><span class="lineCov">         13 :         MOZ_ASSERT(test-&gt;input() == value);</span>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineCov">         13 :         if (ifTrue != test-&gt;ifTrue()) {</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :             test-&gt;ifTrue()-&gt;removePredecessor(block);</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :             ifTrue-&gt;addPredecessorSameInputsAs(block, existingPred);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(test-&gt;ifTrue() == test-&gt;getSuccessor(0));</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :             test-&gt;replaceSuccessor(0, ifTrue);</span>
<span class="lineNum">     753 </span>            :         }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">         13 :         if (ifFalse != test-&gt;ifFalse()) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :             test-&gt;ifFalse()-&gt;removePredecessor(block);</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :             ifFalse-&gt;addPredecessorSameInputsAs(block, existingPred);</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(test-&gt;ifFalse() == test-&gt;getSuccessor(1));</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :             test-&gt;replaceSuccessor(1, ifFalse);</span>
<span class="lineNum">     760 </span>            :         }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineCov">         13 :         return;</span>
<span class="lineNum">     763 </span>            :     }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineCov">         13 :     MOZ_ASSERT(ins-&gt;isGoto());</span>
<span class="lineNum">     766 </span><span class="lineCov">         13 :     ins-&gt;toGoto()-&gt;target()-&gt;removePredecessor(block);</span>
<span class="lineNum">     767 </span><span class="lineCov">         13 :     block-&gt;discardLastIns();</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">         13 :     MTest* test = MTest::New(alloc, value, ifTrue, ifFalse);</span>
<span class="lineNum">     770 </span><span class="lineCov">         13 :     block-&gt;end(test);</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineCov">         13 :     ifTrue-&gt;addPredecessorSameInputsAs(block, existingPred);</span>
<span class="lineNum">     773 </span><span class="lineCov">         13 :     ifFalse-&gt;addPredecessorSameInputsAs(block, existingPred);</span>
<span class="lineNum">     774 </span>            : }
<a name="775"><span class="lineNum">     775 </span>            : </a>
<span class="lineNum">     776 </span>            : static bool
<span class="lineNum">     777 </span><span class="lineCov">        439 : MaybeFoldConditionBlock(MIRGraph&amp; graph, MBasicBlock* initialBlock)</span>
<span class="lineNum">     778 </span>            : {
<span class="lineNum">     779 </span>            :     // Optimize the MIR graph to improve the code generated for conditional
<span class="lineNum">     780 </span>            :     // operations. A test like 'if (a ? b : c)' normally requires four blocks,
<span class="lineNum">     781 </span>            :     // with a phi for the intermediate value. This can be improved to use three
<span class="lineNum">     782 </span>            :     // blocks with no phi value, and if either b or c is constant,
<span class="lineNum">     783 </span>            :     // e.g. 'if (a ? b : 0)', then the block associated with that constant
<span class="lineNum">     784 </span>            :     // can be eliminated.
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :     /*
<span class="lineNum">     787 </span>            :      * Look for a diamond pattern:
<span class="lineNum">     788 </span>            :      *
<span class="lineNum">     789 </span>            :      *        initialBlock
<span class="lineNum">     790 </span>            :      *          /     \
<span class="lineNum">     791 </span>            :      *  trueBranch  falseBranch
<span class="lineNum">     792 </span>            :      *          \     /
<span class="lineNum">     793 </span>            :      *          phiBlock
<span class="lineNum">     794 </span>            :      *             |
<span class="lineNum">     795 </span>            :      *         testBlock
<span class="lineNum">     796 </span>            :      *
<span class="lineNum">     797 </span>            :      * Where phiBlock contains a single phi combining values pushed onto the
<span class="lineNum">     798 </span>            :      * stack by trueBranch and falseBranch, and testBlock contains a test on
<span class="lineNum">     799 </span>            :      * that phi. phiBlock and testBlock may be the same block; generated code
<span class="lineNum">     800 </span>            :      * will use different blocks if the (?:) op is in an inlined function.
<span class="lineNum">     801 </span>            :      */
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineCov">        439 :     MInstruction* ins = initialBlock-&gt;lastIns();</span>
<span class="lineNum">     804 </span><span class="lineCov">        439 :     if (!ins-&gt;isTest())</span>
<span class="lineNum">     805 </span><span class="lineCov">        293 :         return true;</span>
<span class="lineNum">     806 </span><span class="lineCov">        146 :     MTest* initialTest = ins-&gt;toTest();</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineCov">        146 :     MBasicBlock* trueBranch = initialTest-&gt;ifTrue();</span>
<span class="lineNum">     809 </span><span class="lineCov">        146 :     if (trueBranch-&gt;numPredecessors() != 1 || trueBranch-&gt;numSuccessors() != 1)</span>
<span class="lineNum">     810 </span><span class="lineCov">         67 :         return true;</span>
<span class="lineNum">     811 </span><span class="lineCov">         79 :     MBasicBlock* falseBranch = initialTest-&gt;ifFalse();</span>
<span class="lineNum">     812 </span><span class="lineCov">         79 :     if (falseBranch-&gt;numPredecessors() != 1 || falseBranch-&gt;numSuccessors() != 1)</span>
<span class="lineNum">     813 </span><span class="lineCov">         27 :         return true;</span>
<span class="lineNum">     814 </span><span class="lineCov">         52 :     MBasicBlock* phiBlock = trueBranch-&gt;getSuccessor(0);</span>
<span class="lineNum">     815 </span><span class="lineCov">         52 :     if (phiBlock != falseBranch-&gt;getSuccessor(0))</span>
<span class="lineNum">     816 </span><span class="lineCov">          9 :         return true;</span>
<span class="lineNum">     817 </span><span class="lineCov">         43 :     if (phiBlock-&gt;numPredecessors() != 2)</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">         43 :     if (initialBlock-&gt;isLoopBackedge() || trueBranch-&gt;isLoopBackedge() || falseBranch-&gt;isLoopBackedge())</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">         43 :     MBasicBlock* testBlock = phiBlock;</span>
<span class="lineNum">     824 </span><span class="lineCov">         43 :     if (testBlock-&gt;numSuccessors() == 1) {</span>
<span class="lineNum">     825 </span><span class="lineCov">         25 :         if (testBlock-&gt;isLoopBackedge())</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     827 </span><span class="lineCov">         25 :         testBlock = testBlock-&gt;getSuccessor(0);</span>
<span class="lineNum">     828 </span><span class="lineCov">         25 :         if (testBlock-&gt;numPredecessors() != 1)</span>
<span class="lineNum">     829 </span><span class="lineCov">         21 :             return true;</span>
<span class="lineNum">     830 </span>            :     }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     // Make sure the test block does not have any outgoing loop backedges.
<span class="lineNum">     833 </span><span class="lineCov">         22 :     if (!SplitCriticalEdgesForBlock(graph, testBlock))</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :     MPhi* phi;
<span class="lineNum">     837 </span>            :     MTest* finalTest;
<span class="lineNum">     838 </span><span class="lineCov">         22 :     if (!BlockIsSingleTest(phiBlock, testBlock, &amp;phi, &amp;finalTest))</span>
<span class="lineNum">     839 </span><span class="lineCov">          9 :         return true;</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">         13 :     MDefinition* trueResult = phi-&gt;getOperand(phiBlock-&gt;indexForPredecessor(trueBranch));</span>
<span class="lineNum">     842 </span><span class="lineCov">         13 :     MDefinition* falseResult = phi-&gt;getOperand(phiBlock-&gt;indexForPredecessor(falseBranch));</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :     // OK, we found the desired pattern, now transform the graph.
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :     // Patch up phis that filter their input.
<span class="lineNum">     847 </span><span class="lineCov">         30 :     for (MPhiIterator iter = phiBlock-&gt;phisBegin(); iter != phiBlock-&gt;phisEnd(); ++iter) {</span>
<span class="lineNum">     848 </span><span class="lineCov">         17 :         if (*iter == phi)</span>
<span class="lineNum">     849 </span><span class="lineCov">         13 :             continue;</span>
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span><span class="lineCov">          4 :         MOZ_ASSERT(IsPhiRedudantFilter(*iter));</span>
<span class="lineNum">     852 </span><span class="lineCov">          4 :         MDefinition* redundant = (*iter)-&gt;operandIfRedundant();</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineCov">          4 :         if (!redundant) {</span>
<span class="lineNum">     855 </span><span class="lineCov">          4 :             redundant = (*iter)-&gt;getOperand(0);</span>
<span class="lineNum">     856 </span><span class="lineCov">          4 :             if (redundant-&gt;isFilterTypeSet())</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                 redundant = redundant-&gt;toFilterTypeSet()-&gt;input();</span>
<span class="lineNum">     858 </span>            :         }
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineCov">          4 :         (*iter)-&gt;replaceAllUsesWith(redundant);</span>
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :     // Remove the phi from phiBlock.
<span class="lineNum">     864 </span><span class="lineCov">         13 :     phiBlock-&gt;discardPhi(*phiBlock-&gt;phisBegin());</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :     // If either trueBranch or falseBranch just computes a constant for the
<span class="lineNum">     867 </span>            :     // test, determine the block that branch will end up jumping to and eliminate
<span class="lineNum">     868 </span>            :     // the branch. Otherwise, change the end of the block to a test that jumps
<span class="lineNum">     869 </span>            :     // directly to successors of testBlock, rather than to testBlock itself.
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineCov">         13 :     MBasicBlock* trueTarget = trueBranch;</span>
<span class="lineNum">     872 </span>            :     bool constBool;
<span class="lineNum">     873 </span><span class="lineCov">         13 :     if (BlockComputesConstant(trueBranch, trueResult, &amp;constBool)) {</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         trueTarget = constBool ? finalTest-&gt;ifTrue() : finalTest-&gt;ifFalse();</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         phiBlock-&gt;removePredecessor(trueBranch);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         graph.removeBlock(trueBranch);</span>
<span class="lineNum">     877 </span><span class="lineCov">         13 :     } else if (initialTest-&gt;input() == trueResult) {</span>
<span class="lineNum">     878 </span><span class="lineCov">          6 :         UpdateGotoSuccessor(graph.alloc(), trueBranch, finalTest-&gt;ifTrue(), testBlock);</span>
<span class="lineNum">     879 </span>            :     } else {
<span class="lineNum">     880 </span><span class="lineCov">          7 :         UpdateTestSuccessors(graph.alloc(), trueBranch, trueResult,</span>
<span class="lineNum">     881 </span><span class="lineCov">          7 :                              finalTest-&gt;ifTrue(), finalTest-&gt;ifFalse(), testBlock);</span>
<span class="lineNum">     882 </span>            :     }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">         13 :     MBasicBlock* falseTarget = falseBranch;</span>
<span class="lineNum">     885 </span><span class="lineCov">         13 :     if (BlockComputesConstant(falseBranch, falseResult, &amp;constBool)) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         falseTarget = constBool ? finalTest-&gt;ifTrue() : finalTest-&gt;ifFalse();</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         phiBlock-&gt;removePredecessor(falseBranch);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         graph.removeBlock(falseBranch);</span>
<span class="lineNum">     889 </span><span class="lineCov">         13 :     } else if (initialTest-&gt;input() == falseResult) {</span>
<span class="lineNum">     890 </span><span class="lineCov">          7 :         UpdateGotoSuccessor(graph.alloc(), falseBranch, finalTest-&gt;ifFalse(), testBlock);</span>
<span class="lineNum">     891 </span>            :     } else {
<span class="lineNum">     892 </span><span class="lineCov">          6 :         UpdateTestSuccessors(graph.alloc(), falseBranch, falseResult,</span>
<span class="lineNum">     893 </span><span class="lineCov">          6 :                              finalTest-&gt;ifTrue(), finalTest-&gt;ifFalse(), testBlock);</span>
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :     // Short circuit the initial test to skip any constant branch eliminated above.
<span class="lineNum">     897 </span><span class="lineCov">         13 :     UpdateTestSuccessors(graph.alloc(), initialBlock, initialTest-&gt;input(),</span>
<span class="lineNum">     898 </span><span class="lineCov">         13 :                          trueTarget, falseTarget, testBlock);</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :     // Remove phiBlock, if different from testBlock.
<span class="lineNum">     901 </span><span class="lineCov">         13 :     if (phiBlock != testBlock) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         testBlock-&gt;removePredecessor(phiBlock);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :         graph.removeBlock(phiBlock);</span>
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :     // Remove testBlock itself.
<span class="lineNum">     907 </span><span class="lineCov">         13 :     finalTest-&gt;ifTrue()-&gt;removePredecessor(testBlock);</span>
<span class="lineNum">     908 </span><span class="lineCov">         13 :     finalTest-&gt;ifFalse()-&gt;removePredecessor(testBlock);</span>
<span class="lineNum">     909 </span><span class="lineCov">         13 :     graph.removeBlock(testBlock);</span>
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span><span class="lineCov">         13 :     return true;</span>
<span class="lineNum">     912 </span>            : }
<a name="913"><span class="lineNum">     913 </span>            : </a>
<span class="lineNum">     914 </span>            : bool
<span class="lineNum">     915 </span><span class="lineCov">          8 : jit::FoldTests(MIRGraph&amp; graph)</span>
<span class="lineNum">     916 </span>            : {
<span class="lineNum">     917 </span><span class="lineCov">        447 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">     918 </span><span class="lineCov">        439 :         if (!MaybeFoldConditionBlock(graph, *block))</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     920 </span>            :     }
<span class="lineNum">     921 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">     922 </span>            : }
<a name="923"><span class="lineNum">     923 </span>            : </a>
<span class="lineNum">     924 </span>            : bool
<span class="lineNum">     925 </span><span class="lineCov">          8 : jit::FoldEmptyBlocks(MIRGraph&amp; graph)</span>
<span class="lineNum">     926 </span>            : {
<span class="lineNum">     927 </span><span class="lineCov">        582 :     for (MBasicBlockIterator iter(graph.begin()); iter != graph.end(); ) {</span>
<span class="lineNum">     928 </span><span class="lineCov">        574 :         MBasicBlock* block = *iter;</span>
<span class="lineNum">     929 </span><span class="lineCov">        574 :         iter++;</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">        574 :         if (block-&gt;numPredecessors() != 1 || block-&gt;numSuccessors() != 1)</span>
<span class="lineNum">     932 </span><span class="lineCov">        254 :             continue;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineCov">        320 :         if (!block-&gt;phisEmpty())</span>
<span class="lineNum">     935 </span><span class="lineCov">          5 :             continue;</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineCov">        315 :         if (block-&gt;outerResumePoint())</span>
<span class="lineNum">     938 </span><span class="lineCov">         18 :             continue;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineCov">        297 :         if (*block-&gt;begin() != *block-&gt;rbegin())</span>
<span class="lineNum">     941 </span><span class="lineCov">         99 :             continue;</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineCov">        198 :         MBasicBlock* succ = block-&gt;getSuccessor(0);</span>
<span class="lineNum">     944 </span><span class="lineCov">        198 :         MBasicBlock* pred = block-&gt;getPredecessor(0);</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">        198 :         if (succ-&gt;numPredecessors() != 1)</span>
<span class="lineNum">     947 </span><span class="lineCov">         76 :             continue;</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">        122 :         size_t pos = pred-&gt;getSuccessorIndex(block);</span>
<span class="lineNum">     950 </span><span class="lineCov">        122 :         pred-&gt;lastIns()-&gt;replaceSuccessor(pos, succ);</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineCov">        122 :         graph.removeBlock(block);</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">        122 :         succ-&gt;addPredecessorSameInputsAs(pred, block);</span>
<span class="lineNum">     955 </span><span class="lineCov">        122 :         succ-&gt;removePredecessor(block);</span>
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">     958 </span>            : }
<a name="959"><span class="lineNum">     959 </span>            : </a>
<span class="lineNum">     960 </span>            : static void
<span class="lineNum">     961 </span><span class="lineCov">        614 : EliminateTriviallyDeadResumePointOperands(MIRGraph&amp; graph, MResumePoint* rp)</span>
<span class="lineNum">     962 </span>            : {
<span class="lineNum">     963 </span>            :     // If we will pop the top of the stack immediately after resuming,
<span class="lineNum">     964 </span>            :     // then don't preserve the top value in the resume point.
<span class="lineNum">     965 </span><span class="lineCov">        614 :     if (rp-&gt;mode() != MResumePoint::ResumeAt || *rp-&gt;pc() != JSOP_POP)</span>
<span class="lineNum">     966 </span><span class="lineCov">        611 :         return;</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineCov">          3 :     size_t top = rp-&gt;stackDepth() - 1;</span>
<span class="lineNum">     969 </span><span class="lineCov">          3 :     MOZ_ASSERT(!rp-&gt;isObservableOperand(top));</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineCov">          3 :     MDefinition* def = rp-&gt;getOperand(top);</span>
<span class="lineNum">     972 </span><span class="lineCov">          3 :     if (def-&gt;isConstant())</span>
<span class="lineNum">     973 </span><span class="lineCov">          3 :         return;</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     MConstant* constant = rp-&gt;block()-&gt;optimizedOutConstant(graph.alloc());</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     rp-&gt;replaceOperand(top, constant);</span>
<span class="lineNum">     977 </span>            : }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : // Operands to a resume point which are dead at the point of the resume can be
<span class="lineNum">     980 </span>            : // replaced with a magic value. This analysis supports limited detection of
<span class="lineNum">     981 </span>            : // dead operands, pruning those which are defined in the resume point's basic
<span class="lineNum">     982 </span>            : // block and have no uses outside the block or at points later than the resume
<span class="lineNum">     983 </span>            : // point.
<span class="lineNum">     984 </span>            : //
<span class="lineNum">     985 </span>            : // This is intended to ensure that extra resume points within a basic block
<span class="lineNum">     986 </span>            : // will not artificially extend the lifetimes of any SSA values. This could
<span class="lineNum">     987 </span>            : // otherwise occur if the new resume point captured a value which is created
<a name="988"><span class="lineNum">     988 </span>            : // between the old and new resume point and is dead at the new resume point.</a>
<span class="lineNum">     989 </span>            : bool
<span class="lineNum">     990 </span><span class="lineCov">          8 : jit::EliminateDeadResumePointOperands(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span>            :     // If we are compiling try blocks, locals and arguments may be observable
<span class="lineNum">     993 </span>            :     // from catch or finally blocks (which Ion does not compile). For now just
<span class="lineNum">     994 </span>            :     // disable the pass in this case.
<span class="lineNum">     995 </span><span class="lineCov">          8 :     if (graph.hasTryBlock())</span>
<span class="lineNum">     996 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineCov">        363 :     for (PostorderIterator block = graph.poBegin(); block != graph.poEnd(); block++) {</span>
<span class="lineNum">     999 </span><span class="lineCov">        356 :         if (mir-&gt;shouldCancel(&quot;Eliminate Dead Resume Point Operands (main loop)&quot;))</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineCov">        356 :         if (MResumePoint* rp = block-&gt;entryResumePoint()) {</span>
<span class="lineNum">    1003 </span><span class="lineCov">        356 :             if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1005 </span><span class="lineCov">        356 :             EliminateTriviallyDeadResumePointOperands(graph, rp);</span>
<span class="lineNum">    1006 </span>            :         }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :         // The logic below can get confused on infinite loops.
<span class="lineNum">    1009 </span><span class="lineCov">        356 :         if (block-&gt;isLoopHeader() &amp;&amp; block-&gt;backedge() == *block)</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineCov">       2181 :         for (MInstructionIterator ins = block-&gt;begin(); ins != block-&gt;end(); ins++) {</span>
<span class="lineNum">    1013 </span><span class="lineCov">       1825 :             if (MResumePoint* rp = ins-&gt;resumePoint()) {</span>
<span class="lineNum">    1014 </span><span class="lineCov">        258 :                 if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1016 </span><span class="lineCov">        258 :                 EliminateTriviallyDeadResumePointOperands(graph, rp);</span>
<span class="lineNum">    1017 </span>            :             }
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :             // No benefit to replacing constant operands with other constants.
<span class="lineNum">    1020 </span><span class="lineCov">       1825 :             if (ins-&gt;isConstant())</span>
<span class="lineNum">    1021 </span><span class="lineCov">        596 :                 continue;</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :             // Scanning uses does not give us sufficient information to tell
<span class="lineNum">    1024 </span>            :             // where instructions that are involved in box/unbox operations or
<span class="lineNum">    1025 </span>            :             // parameter passing might be live. Rewriting uses of these terms
<span class="lineNum">    1026 </span>            :             // in resume points may affect the interpreter's behavior. Rather
<span class="lineNum">    1027 </span>            :             // than doing a more sophisticated analysis, just ignore these.
<span class="lineNum">    1028 </span><span class="lineCov">       4523 :             if (ins-&gt;isUnbox() || ins-&gt;isParameter() || ins-&gt;isTypeBarrier() ||</span>
<span class="lineNum">    1029 </span><span class="lineCov">       3133 :                 ins-&gt;isComputeThis() || ins-&gt;isFilterTypeSet())</span>
<span class="lineNum">    1030 </span>            :             {
<span class="lineNum">    1031 </span><span class="lineCov">        295 :                 continue;</span>
<span class="lineNum">    1032 </span>            :             }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :             // Early intermediate values captured by resume points, such as
<span class="lineNum">    1035 </span>            :             // TypedObject, ArrayState and its allocation, may be legitimately
<span class="lineNum">    1036 </span>            :             // dead in Ion code, but are still needed if we bail out. They can
<span class="lineNum">    1037 </span>            :             // recover on bailout.
<span class="lineNum">    1038 </span><span class="lineCov">        934 :             if (ins-&gt;isNewDerivedTypedObject() || ins-&gt;isRecoveredOnBailout()) {</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(ins-&gt;canRecoverOnBailout());</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1041 </span>            :             }
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :             // If the instruction's behavior has been constant folded into a
<span class="lineNum">    1044 </span>            :             // separate instruction, we can't determine precisely where the
<span class="lineNum">    1045 </span>            :             // instruction becomes dead and can't eliminate its uses.
<span class="lineNum">    1046 </span><span class="lineCov">        934 :             if (ins-&gt;isImplicitlyUsed() || ins-&gt;isUseRemoved())</span>
<span class="lineNum">    1047 </span><span class="lineCov">         82 :                 continue;</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :             // Check if this instruction's result is only used within the
<span class="lineNum">    1050 </span>            :             // current block, and keep track of its last use in a definition
<span class="lineNum">    1051 </span>            :             // (not resume point). This requires the instructions in the block
<span class="lineNum">    1052 </span>            :             // to be numbered, ensured by running this immediately after alias
<span class="lineNum">    1053 </span>            :             // analysis.
<span class="lineNum">    1054 </span><span class="lineCov">        852 :             uint32_t maxDefinition = 0;</span>
<span class="lineNum">    1055 </span><span class="lineCov">       1167 :             for (MUseIterator uses(ins-&gt;usesBegin()); uses != ins-&gt;usesEnd(); uses++) {</span>
<span class="lineNum">    1056 </span><span class="lineCov">        428 :                 MNode* consumer = uses-&gt;consumer();</span>
<span class="lineNum">    1057 </span><span class="lineCov">        428 :                 if (consumer-&gt;isResumePoint()) {</span>
<span class="lineNum">    1058 </span>            :                     // If the instruction's is captured by one of the resume point, then
<span class="lineNum">    1059 </span>            :                     // it might be observed indirectly while the frame is live on the
<span class="lineNum">    1060 </span>            :                     // stack, so it has to be computed.
<span class="lineNum">    1061 </span><span class="lineCov">         55 :                     MResumePoint* resume = consumer-&gt;toResumePoint();</span>
<span class="lineNum">    1062 </span><span class="lineCov">         55 :                     if (resume-&gt;isObservableOperand(*uses)) {</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                         maxDefinition = UINT32_MAX;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1065 </span>            :                     }
<span class="lineNum">    1066 </span><span class="lineCov">         55 :                     continue;</span>
<span class="lineNum">    1067 </span>            :                 }
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineCov">        373 :                 MDefinition* def = consumer-&gt;toDefinition();</span>
<span class="lineNum">    1070 </span><span class="lineCov">        373 :                 if (def-&gt;block() != *block || def-&gt;isBox() || def-&gt;isPhi()) {</span>
<span class="lineNum">    1071 </span><span class="lineCov">        113 :                     maxDefinition = UINT32_MAX;</span>
<span class="lineNum">    1072 </span><span class="lineCov">        113 :                     break;</span>
<span class="lineNum">    1073 </span>            :                 }
<span class="lineNum">    1074 </span><span class="lineCov">        260 :                 maxDefinition = Max(maxDefinition, def-&gt;id());</span>
<span class="lineNum">    1075 </span>            :             }
<span class="lineNum">    1076 </span><span class="lineCov">        852 :             if (maxDefinition == UINT32_MAX)</span>
<span class="lineNum">    1077 </span><span class="lineCov">        113 :                 continue;</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :             // Walk the uses a second time, removing any in resume points after
<span class="lineNum">    1080 </span>            :             // the last use in a definition.
<span class="lineNum">    1081 </span><span class="lineCov">       1054 :             for (MUseIterator uses(ins-&gt;usesBegin()); uses != ins-&gt;usesEnd(); ) {</span>
<span class="lineNum">    1082 </span><span class="lineCov">        315 :                 MUse* use = *uses++;</span>
<span class="lineNum">    1083 </span><span class="lineCov">        315 :                 if (use-&gt;consumer()-&gt;isDefinition())</span>
<span class="lineNum">    1084 </span><span class="lineCov">        260 :                     continue;</span>
<span class="lineNum">    1085 </span><span class="lineCov">         55 :                 MResumePoint* mrp = use-&gt;consumer()-&gt;toResumePoint();</span>
<span class="lineNum">    1086 </span><span class="lineCov">        159 :                 if (mrp-&gt;block() != *block ||</span>
<span class="lineNum">    1087 </span><span class="lineCov">         98 :                     !mrp-&gt;instruction() ||</span>
<span class="lineNum">    1088 </span><span class="lineCov">        116 :                     mrp-&gt;instruction() == *ins ||</span>
<span class="lineNum">    1089 </span><span class="lineCov">         12 :                     mrp-&gt;instruction()-&gt;id() &lt;= maxDefinition)</span>
<span class="lineNum">    1090 </span>            :                 {
<span class="lineNum">    1091 </span><span class="lineCov">         55 :                     continue;</span>
<span class="lineNum">    1092 </span>            :                 }
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                 if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            :                 // Store an optimized out magic value in place of all dead
<span class="lineNum">    1098 </span>            :                 // resume point operands. Making any such substitution can in
<span class="lineNum">    1099 </span>            :                 // general alter the interpreter's behavior, even though the
<span class="lineNum">    1100 </span>            :                 // code is dead, as the interpreter will still execute opcodes
<span class="lineNum">    1101 </span>            :                 // whose effects cannot be observed. If the magic value value
<span class="lineNum">    1102 </span>            :                 // were to flow to, say, a dead property access the
<span class="lineNum">    1103 </span>            :                 // interpreter could throw an exception; we avoid this problem
<span class="lineNum">    1104 </span>            :                 // by removing dead operands before removing dead code.
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                 MConstant* constant = MConstant::New(graph.alloc(), MagicValue(JS_OPTIMIZED_OUT));</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                 block-&gt;insertBefore(*(block-&gt;begin()), constant);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                 use-&gt;replaceProducer(constant);</span>
<span class="lineNum">    1108 </span>            :             }
<span class="lineNum">    1109 </span>            :         }
<span class="lineNum">    1110 </span>            :     }
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineCov">          7 :     return true;</span>
<span class="lineNum">    1113 </span>            : }
<span class="lineNum">    1114 </span>            : 
<a name="1115"><span class="lineNum">    1115 </span>            : // Test whether |def| would be needed if it had no uses.</a>
<span class="lineNum">    1116 </span>            : bool
<span class="lineNum">    1117 </span><span class="lineCov">       2977 : js::jit::DeadIfUnused(const MDefinition* def)</span>
<span class="lineNum">    1118 </span>            : {
<span class="lineNum">    1119 </span><span class="lineCov">       5611 :     return !def-&gt;isEffectful() &amp;&amp;</span>
<span class="lineNum">    1120 </span><span class="lineCov">       5288 :            (!def-&gt;isGuard() || def-&gt;block() == def-&gt;block()-&gt;graph().osrBlock()) &amp;&amp;</span>
<span class="lineNum">    1121 </span><span class="lineCov">       4938 :            !def-&gt;isGuardRangeBailouts() &amp;&amp;</span>
<span class="lineNum">    1122 </span><span class="lineCov">       9314 :            !def-&gt;isControlInstruction() &amp;&amp;</span>
<span class="lineNum">    1123 </span><span class="lineCov">       7045 :            (!def-&gt;isInstruction() || !def-&gt;toInstruction()-&gt;resumePoint());</span>
<span class="lineNum">    1124 </span>            : }
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : // Test whether |def| may be safely discarded, due to being dead or due to being
<a name="1127"><span class="lineNum">    1127 </span>            : // located in a basic block which has itself been marked for discarding.</a>
<span class="lineNum">    1128 </span>            : bool
<span class="lineNum">    1129 </span><span class="lineCov">       7162 : js::jit::IsDiscardable(const MDefinition* def)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span><span class="lineCov">       7162 :     return !def-&gt;hasUses() &amp;&amp; (DeadIfUnused(def) || def-&gt;block()-&gt;isMarked());</span>
<span class="lineNum">    1132 </span>            : }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            : // Instructions are useless if they are unused and have no side effects.
<span class="lineNum">    1135 </span>            : // This pass eliminates useless instructions.
<a name="1136"><span class="lineNum">    1136 </span>            : // The graph itself is unchanged.</a>
<span class="lineNum">    1137 </span>            : bool
<span class="lineNum">    1138 </span><span class="lineCov">          8 : jit::EliminateDeadCode(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">    1139 </span>            : {
<span class="lineNum">    1140 </span>            :     // Traverse in postorder so that we hit uses before definitions.
<span class="lineNum">    1141 </span>            :     // Traverse instruction list backwards for the same reason.
<span class="lineNum">    1142 </span><span class="lineCov">        411 :     for (PostorderIterator block = graph.poBegin(); block != graph.poEnd(); block++) {</span>
<span class="lineNum">    1143 </span><span class="lineCov">        403 :         if (mir-&gt;shouldCancel(&quot;Eliminate Dead Code (main loop)&quot;))</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :         // Remove unused instructions.
<span class="lineNum">    1147 </span><span class="lineCov">       1875 :         for (MInstructionReverseIterator iter = block-&gt;rbegin(); iter != block-&gt;rend(); ) {</span>
<span class="lineNum">    1148 </span><span class="lineCov">       1472 :             MInstruction* inst = *iter++;</span>
<span class="lineNum">    1149 </span><span class="lineCov">       1472 :             if (js::jit::IsDiscardable(inst))</span>
<span class="lineNum">    1150 </span>            :             {
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                 block-&gt;discard(inst);</span>
<span class="lineNum">    1152 </span>            :             }
<span class="lineNum">    1153 </span>            :         }
<span class="lineNum">    1154 </span>            :     }
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    1157 </span>            : }
<a name="1158"><span class="lineNum">    1158 </span>            : </a>
<span class="lineNum">    1159 </span>            : static inline bool
<span class="lineNum">    1160 </span><span class="lineCov">       1298 : IsPhiObservable(MPhi* phi, Observability observe)</span>
<span class="lineNum">    1161 </span>            : {
<span class="lineNum">    1162 </span>            :     // If the phi has uses which are not reflected in SSA, then behavior in the
<span class="lineNum">    1163 </span>            :     // interpreter may be affected by removing the phi.
<span class="lineNum">    1164 </span><span class="lineCov">       1298 :     if (phi-&gt;isImplicitlyUsed() || phi-&gt;isUseRemoved())</span>
<span class="lineNum">    1165 </span><span class="lineCov">        220 :         return true;</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span>            :     // Check for uses of this phi node outside of other phi nodes.
<span class="lineNum">    1168 </span>            :     // Note that, initially, we skip reading resume points, which we
<span class="lineNum">    1169 </span>            :     // don't count as actual uses. If the only uses are resume points,
<span class="lineNum">    1170 </span>            :     // then the SSA name is never consumed by the program.  However,
<span class="lineNum">    1171 </span>            :     // after optimizations have been performed, it's possible that the
<span class="lineNum">    1172 </span>            :     // actual uses in the program have been (incorrectly) optimized
<span class="lineNum">    1173 </span>            :     // away, so we must be more conservative and consider resume
<span class="lineNum">    1174 </span>            :     // points as well.
<span class="lineNum">    1175 </span><span class="lineCov">      10170 :     for (MUseIterator iter(phi-&gt;usesBegin()); iter != phi-&gt;usesEnd(); iter++) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">       9517 :         MNode* consumer = iter-&gt;consumer();</span>
<span class="lineNum">    1177 </span><span class="lineCov">       9517 :         if (consumer-&gt;isResumePoint()) {</span>
<span class="lineNum">    1178 </span><span class="lineCov">       8244 :             MResumePoint* resume = consumer-&gt;toResumePoint();</span>
<span class="lineNum">    1179 </span><span class="lineCov">       8244 :             if (observe == ConservativeObservability)</span>
<span class="lineNum">    1180 </span><span class="lineCov">        425 :                 return true;</span>
<span class="lineNum">    1181 </span><span class="lineCov">       8244 :             if (resume-&gt;isObservableOperand(*iter))</span>
<span class="lineNum">    1182 </span><span class="lineCov">        180 :                 return true;</span>
<span class="lineNum">    1183 </span>            :         } else {
<span class="lineNum">    1184 </span><span class="lineCov">       1273 :             MDefinition* def = consumer-&gt;toDefinition();</span>
<span class="lineNum">    1185 </span><span class="lineCov">       1273 :             if (!def-&gt;isPhi())</span>
<span class="lineNum">    1186 </span><span class="lineCov">        245 :                 return true;</span>
<span class="lineNum">    1187 </span>            :         }
<span class="lineNum">    1188 </span>            :     }
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineCov">        653 :     return false;</span>
<span class="lineNum">    1191 </span>            : }
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : // Handles cases like:
<span class="lineNum">    1194 </span>            : //    x is phi(a, x) --&gt; a
<a name="1195"><span class="lineNum">    1195 </span>            : //    x is phi(a, a) --&gt; a</a>
<span class="lineNum">    1196 </span>            : static inline MDefinition*
<span class="lineNum">    1197 </span><span class="lineCov">       3571 : IsPhiRedundant(MPhi* phi)</span>
<span class="lineNum">    1198 </span>            : {
<span class="lineNum">    1199 </span><span class="lineCov">       3571 :     MDefinition* first = phi-&gt;operandIfRedundant();</span>
<span class="lineNum">    1200 </span><span class="lineCov">       3571 :     if (first == nullptr)</span>
<span class="lineNum">    1201 </span><span class="lineCov">       2031 :         return nullptr;</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :     // Propagate the ImplicitlyUsed flag if |phi| is replaced with another phi.
<span class="lineNum">    1204 </span><span class="lineCov">       1540 :     if (phi-&gt;isImplicitlyUsed())</span>
<span class="lineNum">    1205 </span><span class="lineCov">         30 :         first-&gt;setImplicitlyUsedUnchecked();</span>
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span><span class="lineCov">       1540 :     return first;</span>
<span class="lineNum">    1208 </span>            : }
<a name="1209"><span class="lineNum">    1209 </span>            : </a>
<span class="lineNum">    1210 </span>            : bool
<span class="lineNum">    1211 </span><span class="lineCov">        142 : jit::EliminatePhis(MIRGenerator* mir, MIRGraph&amp; graph,</span>
<span class="lineNum">    1212 </span>            :                    Observability observe)
<span class="lineNum">    1213 </span>            : {
<span class="lineNum">    1214 </span>            :     // Eliminates redundant or unobservable phis from the graph.  A
<span class="lineNum">    1215 </span>            :     // redundant phi is something like b = phi(a, a) or b = phi(a, b),
<span class="lineNum">    1216 </span>            :     // both of which can be replaced with a.  An unobservable phi is
<span class="lineNum">    1217 </span>            :     // one that whose value is never used in the program.
<span class="lineNum">    1218 </span>            :     //
<span class="lineNum">    1219 </span>            :     // Note that we must be careful not to eliminate phis representing
<span class="lineNum">    1220 </span>            :     // values that the interpreter will require later.  When the graph
<span class="lineNum">    1221 </span>            :     // is first constructed, we can be more aggressive, because there
<span class="lineNum">    1222 </span>            :     // is a greater correspondence between the CFG and the bytecode.
<span class="lineNum">    1223 </span>            :     // After optimizations such as GVN have been performed, however,
<span class="lineNum">    1224 </span>            :     // the bytecode and CFG may not correspond as closely to one
<span class="lineNum">    1225 </span>            :     // another.  In that case, we must be more conservative.  The flag
<span class="lineNum">    1226 </span>            :     // |conservativeObservability| is used to indicate that eliminate
<span class="lineNum">    1227 </span>            :     // phis is being run after some optimizations have been performed,
<span class="lineNum">    1228 </span>            :     // and thus we should use more conservative rules about
<span class="lineNum">    1229 </span>            :     // observability.  The particular danger is that we can optimize
<span class="lineNum">    1230 </span>            :     // away uses of a phi because we think they are not executable,
<span class="lineNum">    1231 </span>            :     // but the foundation for that assumption is false TI information
<span class="lineNum">    1232 </span>            :     // that will eventually be invalidated.  Therefore, if
<span class="lineNum">    1233 </span>            :     // |conservativeObservability| is set, we will consider any use
<span class="lineNum">    1234 </span>            :     // from a resume point to be observable.  Otherwise, we demand a
<span class="lineNum">    1235 </span>            :     // use from an actual instruction.
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineCov">        284 :     Vector&lt;MPhi*, 16, SystemAllocPolicy&gt; worklist;</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :     // Add all observable phis to a worklist. We use the &quot;in worklist&quot; bit to
<span class="lineNum">    1240 </span>            :     // mean &quot;this phi is live&quot;.
<span class="lineNum">    1241 </span><span class="lineCov">       3607 :     for (PostorderIterator block = graph.poBegin(); block != graph.poEnd(); block++) {</span>
<span class="lineNum">    1242 </span><span class="lineCov">       3465 :         MPhiIterator iter = block-&gt;phisBegin();</span>
<span class="lineNum">    1243 </span><span class="lineCov">       8523 :         while (iter != block-&gt;phisEnd()) {</span>
<span class="lineNum">    1244 </span><span class="lineCov">       2529 :             MPhi* phi = *iter++;</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineCov">       2529 :             if (mir-&gt;shouldCancel(&quot;Eliminate Phis (populate loop)&quot;))</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :             // Flag all as unused, only observable phis would be marked as used
<span class="lineNum">    1250 </span>            :             // when processed by the work list.
<span class="lineNum">    1251 </span><span class="lineCov">       2529 :             phi-&gt;setUnused();</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span>            :             // If the phi is redundant, remove it here.
<span class="lineNum">    1254 </span><span class="lineCov">       2529 :             if (MDefinition* redundant = IsPhiRedundant(phi)) {</span>
<span class="lineNum">    1255 </span><span class="lineCov">       1231 :                 phi-&gt;justReplaceAllUsesWith(redundant);</span>
<span class="lineNum">    1256 </span><span class="lineCov">       1231 :                 block-&gt;discardPhi(phi);</span>
<span class="lineNum">    1257 </span><span class="lineCov">       1231 :                 continue;</span>
<span class="lineNum">    1258 </span>            :             }
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :             // Enqueue observable Phis.
<span class="lineNum">    1261 </span><span class="lineCov">       1298 :             if (IsPhiObservable(phi, observe)) {</span>
<span class="lineNum">    1262 </span><span class="lineCov">        645 :                 phi-&gt;setInWorklist();</span>
<span class="lineNum">    1263 </span><span class="lineCov">        645 :                 if (!worklist.append(phi))</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1265 </span>            :             }
<span class="lineNum">    1266 </span>            :         }
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :     // Iteratively mark all phis reachable from live phis.
<span class="lineNum">    1270 </span><span class="lineCov">       2226 :     while (!worklist.empty()) {</span>
<span class="lineNum">    1271 </span><span class="lineCov">       1042 :         if (mir-&gt;shouldCancel(&quot;Eliminate Phis (worklist)&quot;))</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span><span class="lineCov">       1042 :         MPhi* phi = worklist.popCopy();</span>
<span class="lineNum">    1275 </span><span class="lineCov">       1042 :         MOZ_ASSERT(phi-&gt;isUnused());</span>
<span class="lineNum">    1276 </span><span class="lineCov">       1042 :         phi-&gt;setNotInWorklist();</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :         // The removal of Phis can produce newly redundant phis.
<span class="lineNum">    1279 </span><span class="lineCov">       1042 :         if (MDefinition* redundant = IsPhiRedundant(phi)) {</span>
<span class="lineNum">    1280 </span>            :             // Add to the worklist the used phis which are impacted.
<span class="lineNum">    1281 </span><span class="lineCov">       1148 :             for (MUseDefIterator it(phi); it; it++) {</span>
<span class="lineNum">    1282 </span><span class="lineCov">        839 :                 if (it.def()-&gt;isPhi()) {</span>
<span class="lineNum">    1283 </span><span class="lineCov">        682 :                     MPhi* use = it.def()-&gt;toPhi();</span>
<span class="lineNum">    1284 </span><span class="lineCov">        682 :                     if (!use-&gt;isUnused()) {</span>
<span class="lineNum">    1285 </span><span class="lineCov">        112 :                         use-&gt;setUnusedUnchecked();</span>
<span class="lineNum">    1286 </span><span class="lineCov">        112 :                         use-&gt;setInWorklist();</span>
<span class="lineNum">    1287 </span><span class="lineCov">        112 :                         if (!worklist.append(use))</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :                             return false;</span>
<span class="lineNum">    1289 </span>            :                     }
<span class="lineNum">    1290 </span>            :                 }
<span class="lineNum">    1291 </span>            :             }
<span class="lineNum">    1292 </span><span class="lineCov">        309 :             phi-&gt;justReplaceAllUsesWith(redundant);</span>
<span class="lineNum">    1293 </span>            :         } else {
<span class="lineNum">    1294 </span>            :             // Otherwise flag them as used.
<span class="lineNum">    1295 </span><span class="lineCov">        733 :             phi-&gt;setNotUnused();</span>
<span class="lineNum">    1296 </span>            :         }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :         // The current phi is/was used, so all its operands are used.
<span class="lineNum">    1299 </span><span class="lineCov">       3258 :         for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">    1300 </span><span class="lineCov">       2216 :             MDefinition* in = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1301 </span><span class="lineCov">       2216 :             if (!in-&gt;isPhi() || !in-&gt;isUnused() || in-&gt;isInWorklist())</span>
<span class="lineNum">    1302 </span><span class="lineCov">       1931 :                 continue;</span>
<span class="lineNum">    1303 </span><span class="lineCov">        285 :             in-&gt;setInWorklist();</span>
<span class="lineNum">    1304 </span><span class="lineCov">        285 :             if (!worklist.append(in-&gt;toPhi()))</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1306 </span>            :         }
<span class="lineNum">    1307 </span>            :     }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :     // Sweep dead phis.
<span class="lineNum">    1310 </span><span class="lineCov">       3607 :     for (PostorderIterator block = graph.poBegin(); block != graph.poEnd(); block++) {</span>
<span class="lineNum">    1311 </span><span class="lineCov">       3465 :         MPhiIterator iter = block-&gt;phisBegin();</span>
<span class="lineNum">    1312 </span><span class="lineCov">       6061 :         while (iter != block-&gt;phisEnd()) {</span>
<span class="lineNum">    1313 </span><span class="lineCov">       1298 :             MPhi* phi = *iter++;</span>
<span class="lineNum">    1314 </span><span class="lineCov">       1298 :             if (phi-&gt;isUnused()) {</span>
<span class="lineNum">    1315 </span><span class="lineCov">        677 :                 if (!phi-&gt;optimizeOutAllUses(graph.alloc()))</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1317 </span><span class="lineCov">        677 :                 block-&gt;discardPhi(phi);</span>
<span class="lineNum">    1318 </span>            :             }
<span class="lineNum">    1319 </span>            :         }
<span class="lineNum">    1320 </span>            :     }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineCov">        142 :     return true;</span>
<span class="lineNum">    1323 </span>            : }
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : namespace {
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            : // The type analysis algorithm inserts conversions and box/unbox instructions
<span class="lineNum">    1328 </span>            : // to make the IR graph well-typed for future passes.
<span class="lineNum">    1329 </span>            : //
<span class="lineNum">    1330 </span>            : // Phi adjustment: If a phi's inputs are all the same type, the phi is
<span class="lineNum">    1331 </span>            : // specialized to return that type.
<span class="lineNum">    1332 </span>            : //
<span class="lineNum">    1333 </span>            : // Input adjustment: Each input is asked to apply conversion operations to its
<span class="lineNum">    1334 </span>            : // inputs. This may include Box, Unbox, or other instruction-specific type
<a name="1335"><span class="lineNum">    1335 </span>            : // conversion operations.</a>
<span class="lineNum">    1336 </span>            : //
<span class="lineNum">    1337 </span><span class="lineCov">          8 : class TypeAnalyzer</span>
<span class="lineNum">    1338 </span>            : {
<span class="lineNum">    1339 </span>            :     MIRGenerator* mir;
<span class="lineNum">    1340 </span>            :     MIRGraph&amp; graph;
<a name="1341"><span class="lineNum">    1341 </span>            :     Vector&lt;MPhi*, 0, SystemAllocPolicy&gt; phiWorklist_;</a>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span><span class="lineCov">       3285 :     TempAllocator&amp; alloc() const {</span>
<span class="lineNum">    1344 </span><span class="lineCov">       3285 :         return graph.alloc();</span>
<a name="1345"><span class="lineNum">    1345 </span>            :     }</a>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineCov">         90 :     bool addPhiToWorklist(MPhi* phi) {</span>
<span class="lineNum">    1348 </span><span class="lineCov">         90 :         if (phi-&gt;isInWorklist())</span>
<span class="lineNum">    1349 </span><span class="lineCov">         13 :             return true;</span>
<span class="lineNum">    1350 </span><span class="lineCov">         77 :         if (!phiWorklist_.append(phi))</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1352 </span><span class="lineCov">         77 :         phi-&gt;setInWorklist();</span>
<a name="1353"><span class="lineNum">    1353 </span><span class="lineCov">         77 :         return true;</span></a>
<span class="lineNum">    1354 </span>            :     }
<span class="lineNum">    1355 </span><span class="lineCov">         77 :     MPhi* popPhi() {</span>
<span class="lineNum">    1356 </span><span class="lineCov">         77 :         MPhi* phi = phiWorklist_.popCopy();</span>
<span class="lineNum">    1357 </span><span class="lineCov">         77 :         phi-&gt;setNotInWorklist();</span>
<span class="lineNum">    1358 </span><span class="lineCov">         77 :         return phi;</span>
<span class="lineNum">    1359 </span>            :     }
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :     bool respecialize(MPhi* phi, MIRType type);
<span class="lineNum">    1362 </span>            :     bool propagateSpecialization(MPhi* phi);
<span class="lineNum">    1363 </span>            :     bool specializePhis();
<span class="lineNum">    1364 </span>            :     void replaceRedundantPhi(MPhi* phi);
<span class="lineNum">    1365 </span>            :     bool adjustPhiInputs(MPhi* phi);
<span class="lineNum">    1366 </span>            :     bool adjustInputs(MDefinition* def);
<span class="lineNum">    1367 </span>            :     bool insertConversions();
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            :     bool checkFloatCoherency();
<span class="lineNum">    1370 </span>            :     bool graphContainsFloat32();
<span class="lineNum">    1371 </span>            :     bool markPhiConsumers();
<span class="lineNum">    1372 </span>            :     bool markPhiProducers();
<span class="lineNum">    1373 </span>            :     bool specializeValidFloatOps();
<span class="lineNum">    1374 </span>            :     bool tryEmitFloatOperations();
<a name="1375"><span class="lineNum">    1375 </span>            : </a>
<span class="lineNum">    1376 </span>            :   public:
<span class="lineNum">    1377 </span><span class="lineCov">          8 :     TypeAnalyzer(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">    1378 </span><span class="lineCov">          8 :       : mir(mir), graph(graph)</span>
<span class="lineNum">    1379 </span><span class="lineCov">          8 :     { }</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :     bool analyze();
<span class="lineNum">    1382 </span>            : };
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : } /* anonymous namespace */
<span class="lineNum">    1385 </span>            : 
<a name="1386"><span class="lineNum">    1386 </span>            : // Try to specialize this phi based on its non-cyclic inputs.</a>
<span class="lineNum">    1387 </span>            : static MIRType
<span class="lineNum">    1388 </span><span class="lineCov">        206 : GuessPhiType(MPhi* phi, bool* hasInputsWithEmptyTypes)</span>
<span class="lineNum">    1389 </span>            : {
<span class="lineNum">    1390 </span>            : #ifdef DEBUG
<span class="lineNum">    1391 </span>            :     // Check that different magic constants aren't flowing together. Ignore
<span class="lineNum">    1392 </span>            :     // JS_OPTIMIZED_OUT, since an operand could be legitimately optimized
<span class="lineNum">    1393 </span>            :     // away.
<span class="lineNum">    1394 </span><span class="lineCov">        206 :     MIRType magicType = MIRType::None;</span>
<span class="lineNum">    1395 </span><span class="lineCov">        738 :     for (size_t i = 0; i &lt; phi-&gt;numOperands(); i++) {</span>
<span class="lineNum">    1396 </span><span class="lineCov">        532 :         MDefinition* in = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1397 </span><span class="lineCov">       1596 :         if (in-&gt;type() == MIRType::MagicOptimizedArguments ||</span>
<span class="lineNum">    1398 </span><span class="lineCov">       1064 :             in-&gt;type() == MIRType::MagicHole ||</span>
<span class="lineNum">    1399 </span><span class="lineCov">        532 :             in-&gt;type() == MIRType::MagicIsConstructing)</span>
<span class="lineNum">    1400 </span>            :         {
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :             if (magicType == MIRType::None)</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :                 magicType = in-&gt;type();</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(magicType == in-&gt;type());</span>
<span class="lineNum">    1404 </span>            :         }
<span class="lineNum">    1405 </span>            :     }
<span class="lineNum">    1406 </span>            : #endif
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineCov">        206 :     *hasInputsWithEmptyTypes = false;</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineCov">        206 :     MIRType type = MIRType::None;</span>
<span class="lineNum">    1411 </span><span class="lineCov">        206 :     bool convertibleToFloat32 = false;</span>
<span class="lineNum">    1412 </span><span class="lineCov">        206 :     bool hasPhiInputs = false;</span>
<span class="lineNum">    1413 </span><span class="lineCov">        702 :     for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">    1414 </span><span class="lineCov">        528 :         MDefinition* in = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1415 </span><span class="lineCov">        528 :         if (in-&gt;isPhi()) {</span>
<span class="lineNum">    1416 </span><span class="lineCov">        271 :             hasPhiInputs = true;</span>
<span class="lineNum">    1417 </span><span class="lineCov">        271 :             if (!in-&gt;toPhi()-&gt;triedToSpecialize())</span>
<span class="lineNum">    1418 </span><span class="lineCov">        247 :                 continue;</span>
<span class="lineNum">    1419 </span><span class="lineCov">         24 :             if (in-&gt;type() == MIRType::None) {</span>
<span class="lineNum">    1420 </span>            :                 // The operand is a phi we tried to specialize, but we were
<span class="lineNum">    1421 </span>            :                 // unable to guess its type. propagateSpecialization will
<span class="lineNum">    1422 </span>            :                 // propagate the type to this phi when it becomes known.
<span class="lineNum">    1423 </span><span class="lineCov">          2 :                 continue;</span>
<span class="lineNum">    1424 </span>            :             }
<span class="lineNum">    1425 </span>            :         }
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            :         // Ignore operands which we've never observed.
<span class="lineNum">    1428 </span><span class="lineCov">        279 :         if (in-&gt;resultTypeSet() &amp;&amp; in-&gt;resultTypeSet()-&gt;empty()) {</span>
<span class="lineNum">    1429 </span><span class="lineCov">          1 :             *hasInputsWithEmptyTypes = true;</span>
<span class="lineNum">    1430 </span><span class="lineCov">          1 :             continue;</span>
<span class="lineNum">    1431 </span>            :         }
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span><span class="lineCov">        278 :         if (type == MIRType::None) {</span>
<span class="lineNum">    1434 </span><span class="lineCov">        177 :             type = in-&gt;type();</span>
<span class="lineNum">    1435 </span><span class="lineCov">        177 :             if (in-&gt;canProduceFloat32())</span>
<span class="lineNum">    1436 </span><span class="lineCov">          5 :                 convertibleToFloat32 = true;</span>
<span class="lineNum">    1437 </span><span class="lineCov">        177 :             continue;</span>
<span class="lineNum">    1438 </span>            :         }
<span class="lineNum">    1439 </span><span class="lineCov">        101 :         if (type != in-&gt;type()) {</span>
<span class="lineNum">    1440 </span><span class="lineCov">         32 :             if (convertibleToFloat32 &amp;&amp; in-&gt;type() == MIRType::Float32) {</span>
<span class="lineNum">    1441 </span>            :                 // If we only saw definitions that can be converted into Float32 before and
<span class="lineNum">    1442 </span>            :                 // encounter a Float32 value, promote previous values to Float32
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :                 type = MIRType::Float32;</span>
<span class="lineNum">    1444 </span><span class="lineCov">         32 :             } else if (IsTypeRepresentableAsDouble(type) &amp;&amp;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                        IsTypeRepresentableAsDouble(in-&gt;type()))</span>
<span class="lineNum">    1446 </span>            :             {
<span class="lineNum">    1447 </span>            :                 // Specialize phis with int32 and double operands as double.
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                 type = MIRType::Double;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                 convertibleToFloat32 &amp;= in-&gt;canProduceFloat32();</span>
<span class="lineNum">    1450 </span>            :             } else {
<span class="lineNum">    1451 </span><span class="lineCov">         32 :                 return MIRType::Value;</span>
<span class="lineNum">    1452 </span>            :             }
<span class="lineNum">    1453 </span>            :         }
<span class="lineNum">    1454 </span>            :     }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span><span class="lineCov">        174 :     if (type == MIRType::None &amp;&amp; !hasPhiInputs) {</span>
<span class="lineNum">    1457 </span>            :         // All inputs are non-phis with empty typesets. Use MIRType::Value
<span class="lineNum">    1458 </span>            :         // in this case, as it's impossible to get better type information.
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(*hasInputsWithEmptyTypes);</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :         type = MIRType::Value;</span>
<span class="lineNum">    1461 </span>            :     }
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineCov">        174 :     return type;</span>
<span class="lineNum">    1464 </span>            : }
<a name="1465"><span class="lineNum">    1465 </span>            : </a>
<span class="lineNum">    1466 </span>            : bool
<span class="lineNum">    1467 </span><span class="lineCov">         95 : TypeAnalyzer::respecialize(MPhi* phi, MIRType type)</span>
<span class="lineNum">    1468 </span>            : {
<span class="lineNum">    1469 </span><span class="lineCov">         95 :     if (phi-&gt;type() == type)</span>
<span class="lineNum">    1470 </span><span class="lineCov">          5 :         return true;</span>
<span class="lineNum">    1471 </span><span class="lineCov">         90 :     phi-&gt;specialize(type);</span>
<span class="lineNum">    1472 </span><span class="lineCov">         90 :     return addPhiToWorklist(phi);</span>
<span class="lineNum">    1473 </span>            : }
<a name="1474"><span class="lineNum">    1474 </span>            : </a>
<span class="lineNum">    1475 </span>            : bool
<span class="lineNum">    1476 </span><span class="lineCov">        254 : TypeAnalyzer::propagateSpecialization(MPhi* phi)</span>
<span class="lineNum">    1477 </span>            : {
<span class="lineNum">    1478 </span><span class="lineCov">        254 :     MOZ_ASSERT(phi-&gt;type() != MIRType::None);</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :     // Verify that this specialization matches any phis depending on it.
<span class="lineNum">    1481 </span><span class="lineCov">        937 :     for (MUseDefIterator iter(phi); iter; iter++) {</span>
<span class="lineNum">    1482 </span><span class="lineCov">        683 :         if (!iter.def()-&gt;isPhi())</span>
<span class="lineNum">    1483 </span><span class="lineCov">        309 :             continue;</span>
<span class="lineNum">    1484 </span><span class="lineCov">        374 :         MPhi* use = iter.def()-&gt;toPhi();</span>
<span class="lineNum">    1485 </span><span class="lineCov">        374 :         if (!use-&gt;triedToSpecialize())</span>
<span class="lineNum">    1486 </span><span class="lineCov">         19 :             continue;</span>
<span class="lineNum">    1487 </span><span class="lineCov">        355 :         if (use-&gt;type() == MIRType::None) {</span>
<span class="lineNum">    1488 </span>            :             // We tried to specialize this phi, but were unable to guess its
<span class="lineNum">    1489 </span>            :             // type. Now that we know the type of one of its operands, we can
<span class="lineNum">    1490 </span>            :             // specialize it.
<span class="lineNum">    1491 </span><span class="lineCov">         29 :             if (!respecialize(use, phi-&gt;type()))</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1493 </span><span class="lineCov">         29 :             continue;</span>
<span class="lineNum">    1494 </span>            :         }
<span class="lineNum">    1495 </span><span class="lineCov">        326 :         if (use-&gt;type() != phi-&gt;type()) {</span>
<span class="lineNum">    1496 </span>            :             // Specialize phis with int32 that can be converted to float and float operands as floats.
<span class="lineNum">    1497 </span><span class="lineCov">        132 :             if ((use-&gt;type() == MIRType::Int32 &amp;&amp; use-&gt;canProduceFloat32() &amp;&amp; phi-&gt;type() == MIRType::Float32) ||</span>
<span class="lineNum">    1498 </span><span class="lineCov">         66 :                 (phi-&gt;type() == MIRType::Int32 &amp;&amp; phi-&gt;canProduceFloat32() &amp;&amp; use-&gt;type() == MIRType::Float32))</span>
<span class="lineNum">    1499 </span>            :             {
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :                 if (!respecialize(use, MIRType::Float32))</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1503 </span>            :             }
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :             // Specialize phis with int32 and double operands as double.
<span class="lineNum">    1506 </span><span class="lineCov">         66 :             if (IsTypeRepresentableAsDouble(use-&gt;type()) &amp;&amp;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :                 IsTypeRepresentableAsDouble(phi-&gt;type()))</span>
<span class="lineNum">    1508 </span>            :             {
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :                 if (!respecialize(use, MIRType::Double))</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1512 </span>            :             }
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span>            :             // This phi in our use chain can now no longer be specialized.
<span class="lineNum">    1515 </span><span class="lineCov">         66 :             if (!respecialize(use, MIRType::Value))</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1517 </span>            :         }
<span class="lineNum">    1518 </span>            :     }
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">        254 :     return true;</span>
<span class="lineNum">    1521 </span>            : }
<a name="1522"><span class="lineNum">    1522 </span>            : </a>
<span class="lineNum">    1523 </span>            : bool
<span class="lineNum">    1524 </span><span class="lineCov">          8 : TypeAnalyzer::specializePhis()</span>
<span class="lineNum">    1525 </span>            : {
<span class="lineNum">    1526 </span><span class="lineCov">         16 :     Vector&lt;MPhi*, 0, SystemAllocPolicy&gt; phisWithEmptyInputTypes;</span>
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineCov">        461 :     for (PostorderIterator block(graph.poBegin()); block != graph.poEnd(); block++) {</span>
<span class="lineNum">    1529 </span><span class="lineCov">        453 :         if (mir-&gt;shouldCancel(&quot;Specialize Phis (main loop)&quot;))</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span><span class="lineCov">        659 :         for (MPhiIterator phi(block-&gt;phisBegin()); phi != block-&gt;phisEnd(); phi++) {</span>
<span class="lineNum">    1533 </span><span class="lineCov">        206 :             if (mir-&gt;shouldCancel(&quot;Specialize Phis (inner loop)&quot;))</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            :             bool hasInputsWithEmptyTypes;
<span class="lineNum">    1537 </span><span class="lineCov">        206 :             MIRType type = GuessPhiType(*phi, &amp;hasInputsWithEmptyTypes);</span>
<span class="lineNum">    1538 </span><span class="lineCov">        206 :             phi-&gt;specialize(type);</span>
<span class="lineNum">    1539 </span><span class="lineCov">        206 :             if (type == MIRType::None) {</span>
<span class="lineNum">    1540 </span>            :                 // We tried to guess the type but failed because all operands are
<span class="lineNum">    1541 </span>            :                 // phis we still have to visit. Set the triedToSpecialize flag but
<span class="lineNum">    1542 </span>            :                 // don't propagate the type to other phis, propagateSpecialization
<span class="lineNum">    1543 </span>            :                 // will do that once we know the type of one of the operands.
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            :                 // Edge case: when this phi has a non-phi input with an empty
<span class="lineNum">    1546 </span>            :                 // typeset, it's possible for two phis to have a cyclic
<span class="lineNum">    1547 </span>            :                 // dependency and they will both have MIRType::None. Specialize
<span class="lineNum">    1548 </span>            :                 // such phis to MIRType::Value later on.
<span class="lineNum">    1549 </span><span class="lineCov">         29 :                 if (hasInputsWithEmptyTypes &amp;&amp; !phisWithEmptyInputTypes.append(*phi))</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1551 </span><span class="lineCov">         29 :                 continue;</span>
<span class="lineNum">    1552 </span>            :             }
<span class="lineNum">    1553 </span><span class="lineCov">        177 :             if (!propagateSpecialization(*phi))</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1555 </span>            :         }
<span class="lineNum">    1556 </span>            :     }
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineCov">          8 :     do {</span>
<span class="lineNum">    1559 </span><span class="lineCov">        162 :         while (!phiWorklist_.empty()) {</span>
<span class="lineNum">    1560 </span><span class="lineCov">         77 :             if (mir-&gt;shouldCancel(&quot;Specialize Phis (worklist)&quot;))</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">         77 :             MPhi* phi = popPhi();</span>
<span class="lineNum">    1564 </span><span class="lineCov">         77 :             if (!propagateSpecialization(phi))</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1566 </span>            :         }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            :         // When two phis have a cyclic dependency and inputs that have an empty
<span class="lineNum">    1569 </span>            :         // typeset (which are ignored by GuessPhiType), we may still have to
<span class="lineNum">    1570 </span>            :         // specialize these to MIRType::Value.
<span class="lineNum">    1571 </span><span class="lineCov">          8 :         while (!phisWithEmptyInputTypes.empty()) {</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :             if (mir-&gt;shouldCancel(&quot;Specialize Phis (phisWithEmptyInputTypes)&quot;))</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :             MPhi* phi = phisWithEmptyInputTypes.popCopy();</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :             if (phi-&gt;type() == MIRType::None) {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :                 phi-&gt;specialize(MIRType::Value);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                 if (!propagateSpecialization(phi))</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1580 </span>            :             }
<span class="lineNum">    1581 </span>            :         }
<span class="lineNum">    1582 </span><span class="lineCov">          8 :     } while (!phiWorklist_.empty());</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    1585 </span>            : }
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<span class="lineNum">    1587 </span>            : bool
<span class="lineNum">    1588 </span><span class="lineCov">        202 : TypeAnalyzer::adjustPhiInputs(MPhi* phi)</span>
<span class="lineNum">    1589 </span>            : {
<span class="lineNum">    1590 </span><span class="lineCov">        202 :     MIRType phiType = phi-&gt;type();</span>
<span class="lineNum">    1591 </span><span class="lineCov">        202 :     MOZ_ASSERT(phiType != MIRType::None);</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :     // If we specialized a type that's not Value, there are 3 cases:
<span class="lineNum">    1594 </span>            :     // 1. Every input is of that type.
<span class="lineNum">    1595 </span>            :     // 2. Every observed input is of that type (i.e., some inputs haven't been executed yet).
<span class="lineNum">    1596 </span>            :     // 3. Inputs were doubles and int32s, and was specialized to double.
<span class="lineNum">    1597 </span><span class="lineCov">        202 :     if (phiType != MIRType::Value) {</span>
<span class="lineNum">    1598 </span><span class="lineCov">        336 :         for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">    1599 </span><span class="lineCov">        238 :             MDefinition* in = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1600 </span><span class="lineCov">        238 :             if (in-&gt;type() == phiType)</span>
<span class="lineNum">    1601 </span><span class="lineCov">        238 :                 continue;</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :             if (!alloc().ensureBallast())</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :             if (in-&gt;isBox() &amp;&amp; in-&gt;toBox()-&gt;input()-&gt;type() == phiType) {</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :                 phi-&gt;replaceOperand(i, in-&gt;toBox()-&gt;input());</span>
<span class="lineNum">    1608 </span>            :             } else {
<span class="lineNum">    1609 </span>            :                 MInstruction* replacement;
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :                 if (phiType == MIRType::Double &amp;&amp; IsFloatType(in-&gt;type())) {</span>
<span class="lineNum">    1612 </span>            :                     // Convert int32 operands to double.
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :                     replacement = MToDouble::New(alloc(), in);</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                 } else if (phiType == MIRType::Float32) {</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                     if (in-&gt;type() == MIRType::Int32 || in-&gt;type() == MIRType::Double) {</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                         replacement = MToFloat32::New(alloc(), in);</span>
<span class="lineNum">    1617 </span>            :                     } else {
<span class="lineNum">    1618 </span>            :                         // See comment below
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                         if (in-&gt;type() != MIRType::Value) {</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :                             MBox* box = MBox::New(alloc(), in);</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :                             in-&gt;block()-&gt;insertBefore(in-&gt;block()-&gt;lastIns(), box);</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :                             in = box;</span>
<span class="lineNum">    1623 </span>            :                         }
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                         MUnbox* unbox = MUnbox::New(alloc(), in, MIRType::Double, MUnbox::Fallible);</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :                         in-&gt;block()-&gt;insertBefore(in-&gt;block()-&gt;lastIns(), unbox);</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :                         replacement = MToFloat32::New(alloc(), in);</span>
<span class="lineNum">    1628 </span>            :                     }
<span class="lineNum">    1629 </span>            :                 } else {
<span class="lineNum">    1630 </span>            :                     // If we know this branch will fail to convert to phiType,
<span class="lineNum">    1631 </span>            :                     // insert a box that'll immediately fail in the fallible unbox
<span class="lineNum">    1632 </span>            :                     // below.
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :                     if (in-&gt;type() != MIRType::Value) {</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :                         MBox* box = MBox::New(alloc(), in);</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :                         in-&gt;block()-&gt;insertBefore(in-&gt;block()-&gt;lastIns(), box);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                         in = box;</span>
<span class="lineNum">    1637 </span>            :                     }
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span>            :                     // Be optimistic and insert unboxes when the operand is a
<span class="lineNum">    1640 </span>            :                     // value.
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :                     replacement = MUnbox::New(alloc(), in, phiType, MUnbox::Fallible);</span>
<span class="lineNum">    1642 </span>            :                 }
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :                 in-&gt;block()-&gt;insertBefore(in-&gt;block()-&gt;lastIns(), replacement);</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :                 phi-&gt;replaceOperand(i, replacement);</span>
<span class="lineNum">    1646 </span>            :             }
<span class="lineNum">    1647 </span>            :         }
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span><span class="lineCov">         98 :         return true;</span>
<span class="lineNum">    1650 </span>            :     }
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span>            :     // Box every typed input.
<span class="lineNum">    1653 </span><span class="lineCov">        390 :     for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; i++) {</span>
<span class="lineNum">    1654 </span><span class="lineCov">        286 :         MDefinition* in = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1655 </span><span class="lineCov">        286 :         if (in-&gt;type() == MIRType::Value)</span>
<span class="lineNum">    1656 </span><span class="lineCov">        196 :             continue;</span>
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span>            :         // The input is being explicitly unboxed, so sneak past and grab
<span class="lineNum">    1659 </span>            :         // the original box.
<span class="lineNum">    1660 </span><span class="lineCov">         90 :         if (in-&gt;isUnbox() &amp;&amp; phi-&gt;typeIncludes(in-&gt;toUnbox()-&gt;input()))</span>
<span class="lineNum">    1661 </span><span class="lineCov">          1 :             in = in-&gt;toUnbox()-&gt;input();</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineCov">         90 :         if (in-&gt;type() != MIRType::Value) {</span>
<span class="lineNum">    1664 </span><span class="lineCov">         89 :             if (!alloc().ensureBallast())</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span><span class="lineCov">         89 :             MBasicBlock* pred = phi-&gt;block()-&gt;getPredecessor(i);</span>
<span class="lineNum">    1668 </span><span class="lineCov">         89 :             in = AlwaysBoxAt(alloc(), pred-&gt;lastIns(), in);</span>
<span class="lineNum">    1669 </span>            :         }
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span><span class="lineCov">         90 :         phi-&gt;replaceOperand(i, in);</span>
<span class="lineNum">    1672 </span>            :     }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span><span class="lineCov">        104 :     return true;</span>
<span class="lineNum">    1675 </span>            : }
<a name="1676"><span class="lineNum">    1676 </span>            : </a>
<span class="lineNum">    1677 </span>            : bool
<span class="lineNum">    1678 </span><span class="lineCov">       2304 : TypeAnalyzer::adjustInputs(MDefinition* def)</span>
<span class="lineNum">    1679 </span>            : {
<span class="lineNum">    1680 </span>            :     // Definitions such as MPhi have no type policy.
<span class="lineNum">    1681 </span><span class="lineCov">       2304 :     if (!def-&gt;isInstruction())</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineCov">       2304 :     MInstruction* ins = def-&gt;toInstruction();</span>
<span class="lineNum">    1685 </span><span class="lineCov">       2304 :     TypePolicy* policy = ins-&gt;typePolicy();</span>
<span class="lineNum">    1686 </span><span class="lineCov">       2304 :     if (policy &amp;&amp; !policy-&gt;adjustInputs(alloc(), ins))</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1688 </span><span class="lineCov">       2304 :     return true;</span>
<span class="lineNum">    1689 </span>            : }
<a name="1690"><span class="lineNum">    1690 </span>            : </a>
<span class="lineNum">    1691 </span>            : void
<span class="lineNum">    1692 </span><span class="lineCov">          4 : TypeAnalyzer::replaceRedundantPhi(MPhi* phi)</span>
<span class="lineNum">    1693 </span>            : {
<span class="lineNum">    1694 </span><span class="lineCov">          4 :     MBasicBlock* block = phi-&gt;block();</span>
<span class="lineNum">    1695 </span><span class="lineCov">          4 :     js::Value v;</span>
<span class="lineNum">    1696 </span><span class="lineCov">          4 :     switch (phi-&gt;type()) {</span>
<span class="lineNum">    1697 </span>            :       case MIRType::Undefined:
<span class="lineNum">    1698 </span><span class="lineCov">          4 :         v = UndefinedValue();</span>
<span class="lineNum">    1699 </span><span class="lineCov">          4 :         break;</span>
<span class="lineNum">    1700 </span>            :       case MIRType::Null:
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         v = NullValue();</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1703 </span>            :       case MIRType::MagicOptimizedArguments:
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :         v = MagicValue(JS_OPTIMIZED_ARGUMENTS);</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1706 </span>            :       case MIRType::MagicOptimizedOut:
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :         v = MagicValue(JS_OPTIMIZED_OUT);</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1709 </span>            :       case MIRType::MagicUninitializedLexical:
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         v = MagicValue(JS_UNINITIALIZED_LEXICAL);</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1712 </span>            :       default:
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;unexpected type&quot;);</span>
<span class="lineNum">    1714 </span>            :     }
<span class="lineNum">    1715 </span><span class="lineCov">          4 :     MConstant* c = MConstant::New(alloc(), v);</span>
<span class="lineNum">    1716 </span>            :     // The instruction pass will insert the box
<span class="lineNum">    1717 </span><span class="lineCov">          4 :     block-&gt;insertBefore(*(block-&gt;begin()), c);</span>
<span class="lineNum">    1718 </span><span class="lineCov">          4 :     phi-&gt;justReplaceAllUsesWith(c);</span>
<span class="lineNum">    1719 </span><span class="lineCov">          4 : }</span>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<span class="lineNum">    1721 </span>            : bool
<span class="lineNum">    1722 </span><span class="lineCov">          8 : TypeAnalyzer::insertConversions()</span>
<span class="lineNum">    1723 </span>            : {
<span class="lineNum">    1724 </span>            :     // Instructions are processed in reverse postorder: all uses are defs are
<span class="lineNum">    1725 </span>            :     // seen before uses. This ensures that output adjustment (which may rewrite
<span class="lineNum">    1726 </span>            :     // inputs of uses) does not conflict with input adjustment.
<span class="lineNum">    1727 </span><span class="lineCov">        461 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">    1728 </span><span class="lineCov">        453 :         if (mir-&gt;shouldCancel(&quot;Insert Conversions&quot;))</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span><span class="lineCov">        659 :         for (MPhiIterator iter(block-&gt;phisBegin()), end(block-&gt;phisEnd()); iter != end; ) {</span>
<span class="lineNum">    1732 </span><span class="lineCov">        206 :             MPhi* phi = *iter++;</span>
<span class="lineNum">    1733 </span><span class="lineCov">        614 :             if (phi-&gt;type() == MIRType::Undefined ||</span>
<span class="lineNum">    1734 </span><span class="lineCov">        404 :                 phi-&gt;type() == MIRType::Null ||</span>
<span class="lineNum">    1735 </span><span class="lineCov">        404 :                 phi-&gt;type() == MIRType::MagicOptimizedArguments ||</span>
<span class="lineNum">    1736 </span><span class="lineCov">        610 :                 phi-&gt;type() == MIRType::MagicOptimizedOut ||</span>
<span class="lineNum">    1737 </span><span class="lineCov">        202 :                 phi-&gt;type() == MIRType::MagicUninitializedLexical)</span>
<span class="lineNum">    1738 </span>            :             {
<span class="lineNum">    1739 </span><span class="lineCov">          4 :                 replaceRedundantPhi(phi);</span>
<span class="lineNum">    1740 </span><span class="lineCov">          4 :                 block-&gt;discardPhi(phi);</span>
<span class="lineNum">    1741 </span>            :             } else {
<span class="lineNum">    1742 </span><span class="lineCov">        202 :                 if (!adjustPhiInputs(phi))</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1744 </span>            :             }
<span class="lineNum">    1745 </span>            :         }
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :         // AdjustInputs can add/remove/mutate instructions before and after the
<span class="lineNum">    1748 </span>            :         // current instruction. Only increment the iterator after it is finished.
<span class="lineNum">    1749 </span><span class="lineCov">       2757 :         for (MInstructionIterator iter(block-&gt;begin()); iter != block-&gt;end(); iter++) {</span>
<span class="lineNum">    1750 </span><span class="lineCov">       2304 :             if (!alloc().ensureBallast())</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span><span class="lineCov">       2304 :             if (!adjustInputs(*iter))</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1755 </span>            :         }
<span class="lineNum">    1756 </span>            :     }
<span class="lineNum">    1757 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    1758 </span>            : }
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            : // This function tries to emit Float32 specialized operations whenever it's possible.
<span class="lineNum">    1761 </span>            : // MIR nodes are flagged as:
<span class="lineNum">    1762 </span>            : // - Producers, when they can create Float32 that might need to be coerced into a Double.
<span class="lineNum">    1763 </span>            : //   Loads in Float32 arrays and conversions to Float32 are producers.
<span class="lineNum">    1764 </span>            : // - Consumers, when they can have Float32 as inputs and validate a legal use of a Float32.
<span class="lineNum">    1765 </span>            : //   Stores in Float32 arrays and conversions to Float32 are consumers.
<span class="lineNum">    1766 </span>            : // - Float32 commutative, when using the Float32 instruction instead of the Double instruction
<span class="lineNum">    1767 </span>            : //   does not result in a compound loss of precision. This is the case for +, -, /, * with 2
<span class="lineNum">    1768 </span>            : //   operands, for instance. However, an addition with 3 operands is not commutative anymore,
<span class="lineNum">    1769 </span>            : //   so an intermediate coercion is needed.
<span class="lineNum">    1770 </span>            : // Except for phis, all these flags are known after Ion building, so they cannot change during
<span class="lineNum">    1771 </span>            : // the process.
<span class="lineNum">    1772 </span>            : //
<span class="lineNum">    1773 </span>            : // The idea behind the algorithm is easy: whenever we can prove that a commutative operation
<span class="lineNum">    1774 </span>            : // has only producers as inputs and consumers as uses, we can specialize the operation as a
<span class="lineNum">    1775 </span>            : // float32 operation. Otherwise, we have to convert all float32 inputs to doubles. Even
<span class="lineNum">    1776 </span>            : // if a lot of conversions are produced, GVN will take care of eliminating the redundant ones.
<span class="lineNum">    1777 </span>            : //
<span class="lineNum">    1778 </span>            : // Phis have a special status. Phis need to be flagged as producers or consumers as they can
<span class="lineNum">    1779 </span>            : // be inputs or outputs of commutative instructions. Fortunately, producers and consumers
<span class="lineNum">    1780 </span>            : // properties are such that we can deduce the property using all non phis inputs first (which form
<span class="lineNum">    1781 </span>            : // an initial phi graph) and then propagate all properties from one phi to another using a
<span class="lineNum">    1782 </span>            : // fixed point algorithm. The algorithm is ensured to terminate as each iteration has less or as
<span class="lineNum">    1783 </span>            : // many flagged phis as the previous iteration (so the worst steady state case is all phis being
<span class="lineNum">    1784 </span>            : // flagged as false).
<span class="lineNum">    1785 </span>            : //
<span class="lineNum">    1786 </span>            : // In a nutshell, the algorithm applies three passes:
<span class="lineNum">    1787 </span>            : // 1 - Determine which phis are consumers. Each phi gets an initial value by making a global AND on
<span class="lineNum">    1788 </span>            : // all its non-phi inputs. Then each phi propagates its value to other phis. If after propagation,
<span class="lineNum">    1789 </span>            : // the flag value changed, we have to reapply the algorithm on all phi operands, as a phi is a
<span class="lineNum">    1790 </span>            : // consumer if all of its uses are consumers.
<span class="lineNum">    1791 </span>            : // 2 - Determine which phis are producers. It's the same algorithm, except that we have to reapply
<span class="lineNum">    1792 </span>            : // the algorithm on all phi uses, as a phi is a producer if all of its operands are producers.
<span class="lineNum">    1793 </span>            : // 3 - Go through all commutative operations and ensure their inputs are all producers and their
<a name="1794"><span class="lineNum">    1794 </span>            : // uses are all consumers.</a>
<span class="lineNum">    1795 </span>            : bool
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 : TypeAnalyzer::markPhiConsumers()</span>
<span class="lineNum">    1797 </span>            : {
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(phiWorklist_.empty());</span>
<span class="lineNum">    1799 </span>            : 
<span class="lineNum">    1800 </span>            :     // Iterate in postorder so worklist is initialized to RPO.
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :     for (PostorderIterator block(graph.poBegin()); block != graph.poEnd(); ++block) {</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Consumer Phis - Initial state&quot;))</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :         for (MPhiIterator phi(block-&gt;phisBegin()); phi != block-&gt;phisEnd(); ++phi) {</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(!phi-&gt;isInWorklist());</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :             bool canConsumeFloat32 = true;</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :             for (MUseDefIterator use(*phi); canConsumeFloat32 &amp;&amp; use; use++) {</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :                 MDefinition* usedef = use.def();</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :                 canConsumeFloat32 &amp;= usedef-&gt;isPhi() || usedef-&gt;canConsumeFloat32(use.use());</span>
<span class="lineNum">    1811 </span>            :             }
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :             phi-&gt;setCanConsumeFloat32(canConsumeFloat32);</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :             if (canConsumeFloat32 &amp;&amp; !addPhiToWorklist(*phi))</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1815 </span>            :         }
<span class="lineNum">    1816 </span>            :     }
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :     while (!phiWorklist_.empty()) {</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Consumer Phis - Fixed point&quot;))</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :         MPhi* phi = popPhi();</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(phi-&gt;canConsumeFloat32(nullptr /* unused */));</span>
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :         bool validConsumer = true;</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :         for (MUseDefIterator use(phi); use; use++) {</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :             MDefinition* def = use.def();</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :             if (def-&gt;isPhi() &amp;&amp; !def-&gt;canConsumeFloat32(use.use())) {</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :                 validConsumer = false;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1831 </span>            :             }
<span class="lineNum">    1832 </span>            :         }
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :         if (validConsumer)</span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :         // Propagate invalidated phis
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :         phi-&gt;setCanConsumeFloat32(false);</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :         for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :             MDefinition* input = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :             if (input-&gt;isPhi() &amp;&amp; !input-&gt;isInWorklist() &amp;&amp; input-&gt;canConsumeFloat32(nullptr /* unused */))</span>
<span class="lineNum">    1842 </span>            :             {
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :                 if (!addPhiToWorklist(input-&gt;toPhi()))</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1845 </span>            :             }
<span class="lineNum">    1846 </span>            :         }
<span class="lineNum">    1847 </span>            :     }
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1849 </span>            : }
<a name="1850"><span class="lineNum">    1850 </span>            : </a>
<span class="lineNum">    1851 </span>            : bool
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 : TypeAnalyzer::markPhiProducers()</span>
<span class="lineNum">    1853 </span>            : {
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(phiWorklist_.empty());</span>
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span>            :     // Iterate in reverse postorder so worklist is initialized to PO.
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); ++block) {</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Producer Phis - initial state&quot;))</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         for (MPhiIterator phi(block-&gt;phisBegin()); phi != block-&gt;phisEnd(); ++phi) {</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(!phi-&gt;isInWorklist());</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :             bool canProduceFloat32 = true;</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :             for (size_t i = 0, e = phi-&gt;numOperands(); canProduceFloat32 &amp;&amp; i &lt; e; ++i) {</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :                 MDefinition* input = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :                 canProduceFloat32 &amp;= input-&gt;isPhi() || input-&gt;canProduceFloat32();</span>
<span class="lineNum">    1867 </span>            :             }
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :             phi-&gt;setCanProduceFloat32(canProduceFloat32);</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :             if (canProduceFloat32 &amp;&amp; !addPhiToWorklist(*phi))</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1871 </span>            :         }
<span class="lineNum">    1872 </span>            :     }
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     while (!phiWorklist_.empty()) {</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Producer Phis - Fixed point&quot;))</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :         MPhi* phi = popPhi();</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(phi-&gt;canProduceFloat32());</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         bool validProducer = true;</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :         for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :             MDefinition* input = phi-&gt;getOperand(i);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :             if (input-&gt;isPhi() &amp;&amp; !input-&gt;canProduceFloat32()) {</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :                 validProducer = false;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1887 </span>            :             }
<span class="lineNum">    1888 </span>            :         }
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :         if (validProducer)</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            :         // Propagate invalidated phis
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :         phi-&gt;setCanProduceFloat32(false);</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         for (MUseDefIterator use(phi); use; use++) {</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :             MDefinition* def = use.def();</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :             if (def-&gt;isPhi() &amp;&amp; !def-&gt;isInWorklist() &amp;&amp; def-&gt;canProduceFloat32())</span>
<span class="lineNum">    1898 </span>            :             {
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :                 if (!addPhiToWorklist(def-&gt;toPhi()))</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    1901 </span>            :             }
<span class="lineNum">    1902 </span>            :         }
<span class="lineNum">    1903 </span>            :     }
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1905 </span>            : }
<a name="1906"><span class="lineNum">    1906 </span>            : </a>
<span class="lineNum">    1907 </span>            : bool
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 : TypeAnalyzer::specializeValidFloatOps()</span>
<span class="lineNum">    1909 </span>            : {
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); ++block) {</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Instructions&quot;))</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :         for (MInstructionIterator ins(block-&gt;begin()); ins != block-&gt;end(); ++ins) {</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :             if (!ins-&gt;isFloat32Commutative())</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :             if (ins-&gt;type() == MIRType::Float32)</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :             if (!alloc().ensureBallast())</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            :             // This call will try to specialize the instruction iff all uses are consumers and
<span class="lineNum">    1925 </span>            :             // all inputs are producers.
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :             ins-&gt;trySpecializeFloat32(alloc());</span>
<span class="lineNum">    1927 </span>            :         }
<span class="lineNum">    1928 </span>            :     }
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1930 </span>            : }
<a name="1931"><span class="lineNum">    1931 </span>            : </a>
<span class="lineNum">    1932 </span>            : bool
<span class="lineNum">    1933 </span><span class="lineCov">          8 : TypeAnalyzer::graphContainsFloat32()</span>
<span class="lineNum">    1934 </span>            : {
<span class="lineNum">    1935 </span><span class="lineCov">        461 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); ++block) {</span>
<span class="lineNum">    1936 </span><span class="lineCov">       2506 :         for (MDefinitionIterator def(*block); def; def++) {</span>
<span class="lineNum">    1937 </span><span class="lineCov">       2053 :             if (mir-&gt;shouldCancel(&quot;Ensure Float32 commutativity - Graph contains Float32&quot;))</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineCov">       2053 :             if (def-&gt;type() == MIRType::Float32)</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    1942 </span>            :         }
<span class="lineNum">    1943 </span>            :     }
<span class="lineNum">    1944 </span><span class="lineCov">          8 :     return false;</span>
<span class="lineNum">    1945 </span>            : }
<a name="1946"><span class="lineNum">    1946 </span>            : </a>
<span class="lineNum">    1947 </span>            : bool
<span class="lineNum">    1948 </span><span class="lineCov">          8 : TypeAnalyzer::tryEmitFloatOperations()</span>
<span class="lineNum">    1949 </span>            : {
<span class="lineNum">    1950 </span>            :     // Asm.js uses the ahead of time type checks to specialize operations, no need to check
<span class="lineNum">    1951 </span>            :     // them again at this point.
<span class="lineNum">    1952 </span><span class="lineCov">          8 :     if (mir-&gt;compilingWasm())</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            :     // Check ahead of time that there is at least one definition typed as Float32, otherwise we
<span class="lineNum">    1956 </span>            :     // don't need this pass.
<span class="lineNum">    1957 </span><span class="lineCov">          8 :     if (!graphContainsFloat32())</span>
<span class="lineNum">    1958 </span><span class="lineCov">          8 :         return true;</span>
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     if (!markPhiConsumers())</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :        return false;</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :     if (!markPhiProducers())</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :        return false;</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     if (!specializeValidFloatOps())</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :        return false;</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1967 </span>            : }
<a name="1968"><span class="lineNum">    1968 </span>            : </a>
<span class="lineNum">    1969 </span>            : bool
<span class="lineNum">    1970 </span><span class="lineCov">          8 : TypeAnalyzer::checkFloatCoherency()</span>
<span class="lineNum">    1971 </span>            : {
<span class="lineNum">    1972 </span>            : #ifdef DEBUG
<span class="lineNum">    1973 </span>            :     // Asserts that all Float32 instructions are flowing into Float32 consumers or specialized
<span class="lineNum">    1974 </span>            :     // operations
<span class="lineNum">    1975 </span><span class="lineCov">        461 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); ++block) {</span>
<span class="lineNum">    1976 </span><span class="lineCov">        453 :         if (mir-&gt;shouldCancel(&quot;Check Float32 coherency&quot;))</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span><span class="lineCov">       2736 :         for (MDefinitionIterator def(*block); def; def++) {</span>
<span class="lineNum">    1980 </span><span class="lineCov">       2283 :             if (def-&gt;type() != MIRType::Float32)</span>
<span class="lineNum">    1981 </span><span class="lineCov">       2283 :                 continue;</span>
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :             for (MUseDefIterator use(*def); use; use++) {</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :                 MDefinition* consumer = use.def();</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(consumer-&gt;isConsistentFloat32Use(use.use()));</span>
<span class="lineNum">    1986 </span>            :             }
<span class="lineNum">    1987 </span>            :         }
<span class="lineNum">    1988 </span>            :     }
<span class="lineNum">    1989 </span>            : #endif
<span class="lineNum">    1990 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    1991 </span>            : }
<a name="1992"><span class="lineNum">    1992 </span>            : </a>
<span class="lineNum">    1993 </span>            : bool
<span class="lineNum">    1994 </span><span class="lineCov">          8 : TypeAnalyzer::analyze()</span>
<span class="lineNum">    1995 </span>            : {
<span class="lineNum">    1996 </span><span class="lineCov">          8 :     if (!tryEmitFloatOperations())</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1998 </span><span class="lineCov">          8 :     if (!specializePhis())</span>
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2000 </span><span class="lineCov">          8 :     if (!insertConversions())</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2002 </span><span class="lineCov">          8 :     if (!checkFloatCoherency())</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2004 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    2005 </span>            : }
<a name="2006"><span class="lineNum">    2006 </span>            : </a>
<span class="lineNum">    2007 </span>            : bool
<span class="lineNum">    2008 </span><span class="lineCov">          8 : jit::ApplyTypeInformation(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">    2009 </span>            : {
<span class="lineNum">    2010 </span><span class="lineCov">         16 :     TypeAnalyzer analyzer(mir, graph);</span>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineCov">          8 :     if (!analyzer.analyze())</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    2016 </span>            : }
<span class="lineNum">    2017 </span>            : 
<a name="2018"><span class="lineNum">    2018 </span>            : // Check if `def` is only the N-th operand of `useDef`.</a>
<span class="lineNum">    2019 </span>            : static inline size_t
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 : IsExclusiveNthOperand(MDefinition* useDef, size_t n, MDefinition* def)</span>
<span class="lineNum">    2021 </span>            : {
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :     uint32_t num = useDef-&gt;numOperands();</span>
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :     if (n &gt;= num || useDef-&gt;getOperand(n) != def)</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; num; i++) {</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :         if (i == n)</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :         if (useDef-&gt;getOperand(i) == def)</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2031 </span>            :     }
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2034 </span>            : }
<a name="2035"><span class="lineNum">    2035 </span>            : </a>
<span class="lineNum">    2036 </span>            : static size_t
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 : IsExclusiveThisArg(MCall* call, MDefinition* def)</span>
<span class="lineNum">    2038 </span>            : {
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     return IsExclusiveNthOperand(call, MCall::IndexOfThis(), def);</span>
<span class="lineNum">    2040 </span>            : }
<a name="2041"><span class="lineNum">    2041 </span>            : </a>
<span class="lineNum">    2042 </span>            : static size_t
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 : IsExclusiveFirstArg(MCall* call, MDefinition* def)</span>
<span class="lineNum">    2044 </span>            : {
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :     return IsExclusiveNthOperand(call, MCall::IndexOfArgument(0), def);</span>
<span class="lineNum">    2046 </span>            : }
<a name="2047"><span class="lineNum">    2047 </span>            : </a>
<span class="lineNum">    2048 </span>            : static bool
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 : IsRegExpHoistableCall(MCall* call, MDefinition* def)</span>
<span class="lineNum">    2050 </span>            : {
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :     if (call-&gt;isConstructing())</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            :     JSAtom* name;
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     if (WrappedFunction* fun = call-&gt;getSingleTarget()) {</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         if (!fun-&gt;isSelfHostedBuiltin())</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :         name = GetSelfHostedFunctionName(fun-&gt;rawJSFunction());</span>
<span class="lineNum">    2059 </span>            :     } else {
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         MDefinition* funDef = call-&gt;getFunction();</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         if (funDef-&gt;isDebugCheckSelfHosted())</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :             funDef = funDef-&gt;toDebugCheckSelfHosted()-&gt;input();</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :         if (funDef-&gt;isTypeBarrier())</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :             funDef = funDef-&gt;toTypeBarrier()-&gt;input();</span>
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         if (!funDef-&gt;isCallGetIntrinsicValue())</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :         name = funDef-&gt;toCallGetIntrinsicValue()-&gt;name();</span>
<span class="lineNum">    2069 </span>            :     }
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span>            :     // Hoistable only if the RegExp is the first argument of RegExpBuiltinExec.
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     CompileRuntime* runtime = GetJitContext()-&gt;runtime;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :     if (name == runtime-&gt;names().RegExpBuiltinExec ||</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         name == runtime-&gt;names().UnwrapAndCallRegExpBuiltinExec ||</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         name == runtime-&gt;names().RegExpMatcher ||</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :         name == runtime-&gt;names().RegExpTester ||</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         name == runtime-&gt;names().RegExpSearcher)</span>
<span class="lineNum">    2078 </span>            :     {
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :         return IsExclusiveFirstArg(call, def);</span>
<span class="lineNum">    2080 </span>            :     }
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :     if (name == runtime-&gt;names().RegExp_prototype_Exec)</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         return IsExclusiveThisArg(call, def);</span>
<span class="lineNum">    2084 </span>            : 
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2086 </span>            : }
<a name="2087"><span class="lineNum">    2087 </span>            : </a>
<span class="lineNum">    2088 </span>            : static bool
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 : CanCompareRegExp(MCompare* compare, MDefinition* def)</span>
<span class="lineNum">    2090 </span>            : {
<span class="lineNum">    2091 </span>            :     MDefinition* value;
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :     if (compare-&gt;lhs() == def) {</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :         value = compare-&gt;rhs();</span>
<span class="lineNum">    2094 </span>            :     } else {
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(compare-&gt;rhs() == def);</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :         value = compare-&gt;lhs();</span>
<span class="lineNum">    2097 </span>            :     }
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span>            :     // Comparing two regexp that weren't cloned will give different result
<span class="lineNum">    2100 </span>            :     // than if they were cloned.
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     if (value-&gt;mightBeType(MIRType::Object))</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span>            :     // Make sure @@toPrimitive is not called which could notice
<span class="lineNum">    2105 </span>            :     // the difference between a not cloned/cloned regexp.
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :     JSOp op = compare-&gt;jsop();</span>
<span class="lineNum">    2108 </span>            :     // Strict equality comparison won't invoke @@toPrimitive.
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :     if (op == JSOP_STRICTEQ || op == JSOP_STRICTNE)</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     if (op != JSOP_EQ &amp;&amp; op != JSOP_NE) {</span>
<span class="lineNum">    2113 </span>            :         // Relational comparison always invoke @@toPrimitive.
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(op == JSOP_GT || op == JSOP_GE || op == JSOP_LT || op == JSOP_LE);</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2116 </span>            :     }
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            :     // Loose equality comparison can invoke @@toPrimitive.
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :     if (value-&gt;mightBeType(MIRType::Boolean) || value-&gt;mightBeType(MIRType::String) ||</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         value-&gt;mightBeType(MIRType::Int32) ||</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :         value-&gt;mightBeType(MIRType::Double) || value-&gt;mightBeType(MIRType::Float32) ||</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :         value-&gt;mightBeType(MIRType::Symbol))</span>
<span class="lineNum">    2123 </span>            :     {
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2125 </span>            :     }
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2128 </span>            : }
<a name="2129"><span class="lineNum">    2129 </span>            : </a>
<span class="lineNum">    2130 </span>            : static inline void
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 : SetNotInWorklist(MDefinitionVector&amp; worklist)</span>
<span class="lineNum">    2132 </span>            : {
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; worklist.length(); i++)</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :         worklist[i]-&gt;setNotInWorklist();</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 : }</span>
<a name="2136"><span class="lineNum">    2136 </span>            : </a>
<span class="lineNum">    2137 </span>            : static bool
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 : IsRegExpHoistable(MIRGenerator* mir, MDefinition* regexp, MDefinitionVector&amp; worklist,</span>
<span class="lineNum">    2139 </span>            :                   bool* hoistable)
<span class="lineNum">    2140 </span>            : {
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(worklist.length() == 0);</span>
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :     if (!worklist.append(regexp))</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     regexp-&gt;setInWorklist();</span>
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; worklist.length(); i++) {</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :         MDefinition* def = worklist[i];</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         if (mir-&gt;shouldCancel(&quot;IsRegExpHoistable outer loop&quot;))</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :         for (MUseIterator use = def-&gt;usesBegin(); use != def-&gt;usesEnd(); use++) {</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :             if (mir-&gt;shouldCancel(&quot;IsRegExpHoistable inner loop&quot;))</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span>            :             // Ignore resume points. At this point all uses are listed.
<span class="lineNum">    2157 </span>            :             // No DCE or GVN or something has happened.
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :             if (use-&gt;consumer()-&gt;isResumePoint())</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :             MDefinition* useDef = use-&gt;consumer()-&gt;toDefinition();</span>
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span>            :             // Step through a few white-listed ops.
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :             if (useDef-&gt;isPhi() || useDef-&gt;isFilterTypeSet() || useDef-&gt;isGuardShape()) {</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :                 if (useDef-&gt;isInWorklist())</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :                 if (!worklist.append(useDef))</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :                 useDef-&gt;setInWorklist();</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2172 </span>            :             }
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span>            :             // Instructions that doesn't invoke unknown code that may modify
<span class="lineNum">    2175 </span>            :             // RegExp instance or pass it to elsewhere.
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :             if (useDef-&gt;isRegExpMatcher() || useDef-&gt;isRegExpTester() ||</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                 useDef-&gt;isRegExpSearcher())</span>
<span class="lineNum">    2178 </span>            :             {
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :                 if (IsExclusiveNthOperand(useDef, 0, def))</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :             } else if (useDef-&gt;isLoadFixedSlot() || useDef-&gt;isTypeOf()) {</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :             } else if (useDef-&gt;isCompare()) {</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                 if (CanCompareRegExp(useDef-&gt;toCompare(), def))</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2186 </span>            :             }
<span class="lineNum">    2187 </span>            :             // Instructions that modifies `lastIndex` property.
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :             else if (useDef-&gt;isStoreFixedSlot()) {</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :                 if (IsExclusiveNthOperand(useDef, 0, def)) {</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :                     MStoreFixedSlot* store = useDef-&gt;toStoreFixedSlot();</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :                     if (store-&gt;slot() == RegExpObject::lastIndexSlot())</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2193 </span>            :                 }
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :             } else if (useDef-&gt;isSetPropertyCache()) {</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :                 if (IsExclusiveNthOperand(useDef, 0, def)) {</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                     MSetPropertyCache* setProp = useDef-&gt;toSetPropertyCache();</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                     if (setProp-&gt;idval()-&gt;isConstant()) {</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :                         Value propIdVal = setProp-&gt;idval()-&gt;toConstant()-&gt;toJSValue();</span>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :                         if (propIdVal.isString()) {</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :                             CompileRuntime* runtime = GetJitContext()-&gt;runtime;</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                             if (propIdVal.toString() == runtime-&gt;names().lastIndex)</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    2203 </span>            :                         }
<span class="lineNum">    2204 </span>            :                     }
<span class="lineNum">    2205 </span>            :                 }
<span class="lineNum">    2206 </span>            :             }
<span class="lineNum">    2207 </span>            :             // MCall is safe only for some known safe functions.
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :             else if (useDef-&gt;isCall()) {</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :                 if (IsRegExpHoistableCall(useDef-&gt;toCall(), def))</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2211 </span>            :             }
<span class="lineNum">    2212 </span>            : 
<span class="lineNum">    2213 </span>            :             // Everything else is unsafe.
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :             SetNotInWorklist(worklist);</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :             worklist.clear();</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :             *hoistable = false;</span>
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    2219 </span>            :         }
<span class="lineNum">    2220 </span>            :     }
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :     SetNotInWorklist(worklist);</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     worklist.clear();</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     *hoistable = true;</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2226 </span>            : }
<a name="2227"><span class="lineNum">    2227 </span>            : </a>
<span class="lineNum">    2228 </span>            : bool
<span class="lineNum">    2229 </span><span class="lineCov">          8 : jit::MakeMRegExpHoistable(MIRGenerator* mir, MIRGraph&amp; graph)</span>
<span class="lineNum">    2230 </span>            : {
<span class="lineNum">    2231 </span><span class="lineCov">         16 :     MDefinitionVector worklist(graph.alloc());</span>
<span class="lineNum">    2232 </span>            : 
<span class="lineNum">    2233 </span><span class="lineCov">        652 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">    2234 </span><span class="lineCov">        644 :         if (mir-&gt;shouldCancel(&quot;MakeMRegExpHoistable outer loop&quot;))</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2236 </span>            : 
<span class="lineNum">    2237 </span><span class="lineCov">       2776 :         for (MDefinitionIterator iter(*block); iter; iter++) {</span>
<span class="lineNum">    2238 </span><span class="lineCov">       2132 :             if (!*iter)</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :                 MOZ_CRASH(&quot;confirm bug 1263794.&quot;);</span>
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineCov">       2132 :             if (mir-&gt;shouldCancel(&quot;MakeMRegExpHoistable inner loop&quot;))</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span><span class="lineCov">       2132 :             if (!iter-&gt;isRegExp())</span>
<span class="lineNum">    2245 </span><span class="lineCov">       4264 :                 continue;</span>
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :             MRegExp* regexp = iter-&gt;toRegExp();</span>
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :             bool hoistable = false;</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :             if (!IsRegExpHoistable(mir, regexp, worklist, &amp;hoistable))</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :             if (!hoistable)</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            :             // Make MRegExp hoistable
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :             regexp-&gt;setMovable();</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :             regexp-&gt;setDoNotClone();</span>
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            :             // That would be incorrect for global/sticky, because lastIndex
<span class="lineNum">    2261 </span>            :             // could be wrong.  Therefore setting the lastIndex to 0. That is
<span class="lineNum">    2262 </span>            :             // faster than a not movable regexp.
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :             RegExpObject* source = regexp-&gt;source();</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :             if (source-&gt;sticky() || source-&gt;global()) {</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                 if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                 MConstant* zero = MConstant::New(graph.alloc(), Int32Value(0));</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :                 regexp-&gt;block()-&gt;insertAfter(regexp, zero);</span>
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            :                 MStoreFixedSlot* lastIndex =
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :                     MStoreFixedSlot::New(graph.alloc(), regexp, RegExpObject::lastIndexSlot(), zero);</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :                 regexp-&gt;block()-&gt;insertAfter(zero, lastIndex);</span>
<span class="lineNum">    2273 </span>            :             }
<span class="lineNum">    2274 </span>            :         }
<span class="lineNum">    2275 </span>            :     }
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    2278 </span>            : }
<a name="2279"><span class="lineNum">    2279 </span>            : </a>
<span class="lineNum">    2280 </span>            : void
<span class="lineNum">    2281 </span><span class="lineCov">        141 : jit::RenumberBlocks(MIRGraph&amp; graph)</span>
<span class="lineNum">    2282 </span>            : {
<span class="lineNum">    2283 </span><span class="lineCov">        141 :     size_t id = 0;</span>
<span class="lineNum">    2284 </span><span class="lineCov">       3509 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++)</span>
<span class="lineNum">    2285 </span><span class="lineCov">       3368 :         block-&gt;setId(id++);</span>
<span class="lineNum">    2286 </span><span class="lineCov">        141 : }</span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span>            : // A utility for code which deletes blocks. Renumber the remaining blocks,
<a name="2289"><span class="lineNum">    2289 </span>            : // recompute dominators, and optionally recompute AliasAnalysis dependencies.</a>
<span class="lineNum">    2290 </span>            : bool
<span class="lineNum">    2291 </span><span class="lineCov">          5 : jit::AccountForCFGChanges(MIRGenerator* mir, MIRGraph&amp; graph, bool updateAliasAnalysis,</span>
<span class="lineNum">    2292 </span>            :                           bool underValueNumberer)
<span class="lineNum">    2293 </span>            : {
<span class="lineNum">    2294 </span>            :     // Renumber the blocks and clear out the old dominator info.
<span class="lineNum">    2295 </span><span class="lineCov">          5 :     size_t id = 0;</span>
<span class="lineNum">    2296 </span><span class="lineCov">        387 :     for (ReversePostorderIterator i(graph.rpoBegin()), e(graph.rpoEnd()); i != e; ++i) {</span>
<span class="lineNum">    2297 </span><span class="lineCov">        382 :         i-&gt;clearDominatorInfo();</span>
<span class="lineNum">    2298 </span><span class="lineCov">        382 :         i-&gt;setId(id++);</span>
<span class="lineNum">    2299 </span>            :     }
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            :     // Recompute dominator info.
<span class="lineNum">    2302 </span><span class="lineCov">          5 :     if (!BuildDominatorTree(graph))</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span>            :     // If needed, update alias analysis dependencies.
<span class="lineNum">    2306 </span><span class="lineCov">          5 :     if (updateAliasAnalysis) {</span>
<span class="lineNum">    2307 </span><span class="lineCov">          2 :         TraceLoggerThread* logger = TraceLoggerForCurrentThread();</span>
<span class="lineNum">    2308 </span><span class="lineCov">          4 :         AutoTraceLog log(logger, TraceLogger_AliasAnalysis);</span>
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span><span class="lineCov">          2 :         if (JitOptions.disableFlowAA) {</span>
<span class="lineNum">    2311 </span><span class="lineCov">          2 :             if (!AliasAnalysis(mir, graph).analyze())</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2313 </span>            :         } else {
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :             if (!FlowAliasAnalysis(mir, graph).analyze())</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2316 </span>            :         }
<span class="lineNum">    2317 </span>            :     }
<span class="lineNum">    2318 </span>            : 
<span class="lineNum">    2319 </span><span class="lineCov">          5 :     AssertExtendedGraphCoherency(graph, underValueNumberer);</span>
<span class="lineNum">    2320 </span><span class="lineCov">          5 :     return true;</span>
<span class="lineNum">    2321 </span>            : }
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span>            : // Remove all blocks not marked with isMarked(). Unmark all remaining blocks.
<a name="2324"><span class="lineNum">    2324 </span>            : // Alias analysis dependencies may be invalid after calling this function.</a>
<span class="lineNum">    2325 </span>            : bool
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 : jit::RemoveUnmarkedBlocks(MIRGenerator* mir, MIRGraph&amp; graph, uint32_t numMarkedBlocks)</span>
<span class="lineNum">    2327 </span>            : {
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :     if (numMarkedBlocks == graph.numBlocks()) {</span>
<span class="lineNum">    2329 </span>            :         // If all blocks are marked, no blocks need removal. Just clear the
<span class="lineNum">    2330 </span>            :         // marks. We'll still need to update the dominator tree below though,
<span class="lineNum">    2331 </span>            :         // since we may have removed edges even if we didn't remove any blocks.
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         graph.unmarkBlocks();</span>
<span class="lineNum">    2333 </span>            :     } else {
<span class="lineNum">    2334 </span>            :         // As we are going to remove edges and basic blocks, we have to mark
<span class="lineNum">    2335 </span>            :         // instructions which would be needed by baseline if we were to
<span class="lineNum">    2336 </span>            :         // bailout.
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :         for (PostorderIterator it(graph.poBegin()); it != graph.poEnd();) {</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :             MBasicBlock* block = *it++;</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :             if (!block-&gt;isMarked())</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :             FlagAllOperandsAsHavingRemovedUses(mir, block);</span>
<span class="lineNum">    2343 </span>            :         }
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            :         // Find unmarked blocks and remove them.
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :         for (ReversePostorderIterator iter(graph.rpoBegin()); iter != graph.rpoEnd();) {</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :             MBasicBlock* block = *iter++;</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :             if (block-&gt;isMarked()) {</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                 block-&gt;unmark();</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2352 </span>            :             }
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :             // The block is unreachable. Clear out the loop header flag, as
<span class="lineNum">    2355 </span>            :             // we're doing the sweep of a mark-and-sweep here, so we no longer
<span class="lineNum">    2356 </span>            :             // need to worry about whether an unmarked block is a loop or not.
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :             if (block-&gt;isLoopHeader())</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :                 block-&gt;clearLoopHeader();</span>
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :             for (size_t i = 0, e = block-&gt;numSuccessors(); i != e; ++i)</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :                 block-&gt;getSuccessor(i)-&gt;removePredecessor(block);</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :             graph.removeBlockIncludingPhis(block);</span>
<span class="lineNum">    2363 </span>            :         }
<span class="lineNum">    2364 </span>            :     }
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span>            :     // Renumber the blocks and update the dominator tree.
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     return AccountForCFGChanges(mir, graph, /*updateAliasAnalysis=*/false);</span>
<span class="lineNum">    2368 </span>            : }
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            : // A Simple, Fast Dominance Algorithm by Cooper et al.
<a name="2371"><span class="lineNum">    2371 </span>            : // Modified to support empty intersections for OSR, and in RPO.</a>
<span class="lineNum">    2372 </span>            : static MBasicBlock*
<span class="lineNum">    2373 </span><span class="lineCov">       1401 : IntersectDominators(MBasicBlock* block1, MBasicBlock* block2)</span>
<span class="lineNum">    2374 </span>            : {
<span class="lineNum">    2375 </span><span class="lineCov">       1401 :     MBasicBlock* finger1 = block1;</span>
<span class="lineNum">    2376 </span><span class="lineCov">       1401 :     MBasicBlock* finger2 = block2;</span>
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span><span class="lineCov">       1401 :     MOZ_ASSERT(finger1);</span>
<span class="lineNum">    2379 </span><span class="lineCov">       1401 :     MOZ_ASSERT(finger2);</span>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            :     // In the original paper, the block ID comparisons are on the postorder index.
<span class="lineNum">    2382 </span>            :     // This implementation iterates in RPO, so the comparisons are reversed.
<span class="lineNum">    2383 </span>            : 
<span class="lineNum">    2384 </span>            :     // For this function to be called, the block must have multiple predecessors.
<span class="lineNum">    2385 </span>            :     // If a finger is then found to be self-dominating, it must therefore be
<span class="lineNum">    2386 </span>            :     // reachable from multiple roots through non-intersecting control flow.
<span class="lineNum">    2387 </span>            :     // nullptr is returned in this case, to denote an empty intersection.
<span class="lineNum">    2388 </span>            : 
<span class="lineNum">    2389 </span><span class="lineCov">       4247 :     while (finger1-&gt;id() != finger2-&gt;id()) {</span>
<span class="lineNum">    2390 </span><span class="lineCov">       7319 :         while (finger1-&gt;id() &gt; finger2-&gt;id()) {</span>
<span class="lineNum">    2391 </span><span class="lineCov">       2951 :             MBasicBlock* idom = finger1-&gt;immediateDominator();</span>
<span class="lineNum">    2392 </span><span class="lineCov">       2951 :             if (idom == finger1)</span>
<span class="lineNum">    2393 </span><span class="lineCov">          6 :                 return nullptr; // Empty intersection.</span>
<span class="lineNum">    2394 </span><span class="lineCov">       2945 :             finger1 = idom;</span>
<span class="lineNum">    2395 </span>            :         }
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span><span class="lineCov">       4739 :         while (finger2-&gt;id() &gt; finger1-&gt;id()) {</span>
<span class="lineNum">    2398 </span><span class="lineCov">       1658 :             MBasicBlock* idom = finger2-&gt;immediateDominator();</span>
<span class="lineNum">    2399 </span><span class="lineCov">       1658 :             if (idom == finger2)</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :                 return nullptr; // Empty intersection.</span>
<span class="lineNum">    2401 </span><span class="lineCov">       1658 :             finger2 = idom;</span>
<span class="lineNum">    2402 </span>            :         }
<span class="lineNum">    2403 </span>            :     }
<span class="lineNum">    2404 </span><span class="lineCov">       1395 :     return finger1;</span>
<span class="lineNum">    2405 </span>            : }
<a name="2406"><span class="lineNum">    2406 </span>            : </a>
<span class="lineNum">    2407 </span>            : void
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 : jit::ClearDominatorTree(MIRGraph&amp; graph)</span>
<span class="lineNum">    2409 </span>            : {
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :     for (MBasicBlockIterator iter = graph.begin(); iter != graph.end(); iter++)</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :         iter-&gt;clearDominatorInfo();</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 : }</span>
<a name="2413"><span class="lineNum">    2413 </span>            : </a>
<span class="lineNum">    2414 </span>            : static void
<span class="lineNum">    2415 </span><span class="lineCov">        146 : ComputeImmediateDominators(MIRGraph&amp; graph)</span>
<span class="lineNum">    2416 </span>            : {
<span class="lineNum">    2417 </span>            :     // The default start block is a root and therefore only self-dominates.
<span class="lineNum">    2418 </span><span class="lineCov">        146 :     MBasicBlock* startBlock = graph.entryBlock();</span>
<span class="lineNum">    2419 </span><span class="lineCov">        146 :     startBlock-&gt;setImmediateDominator(startBlock);</span>
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span>            :     // Any OSR block is a root and therefore only self-dominates.
<span class="lineNum">    2422 </span><span class="lineCov">        146 :     MBasicBlock* osrBlock = graph.osrBlock();</span>
<span class="lineNum">    2423 </span><span class="lineCov">        146 :     if (osrBlock)</span>
<span class="lineNum">    2424 </span><span class="lineCov">          6 :         osrBlock-&gt;setImmediateDominator(osrBlock);</span>
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span><span class="lineCov">        146 :     bool changed = true;</span>
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineCov">        714 :     while (changed) {</span>
<span class="lineNum">    2429 </span><span class="lineCov">        284 :         changed = false;</span>
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span><span class="lineCov">        284 :         ReversePostorderIterator block = graph.rpoBegin();</span>
<span class="lineNum">    2432 </span>            : 
<span class="lineNum">    2433 </span>            :         // For each block in RPO, intersect all dominators.
<span class="lineNum">    2434 </span><span class="lineCov">      15268 :         for (; block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">    2435 </span>            :             // If a node has once been found to have no exclusive dominator,
<span class="lineNum">    2436 </span>            :             // it will never have an exclusive dominator, so it may be skipped.
<span class="lineNum">    2437 </span><span class="lineCov">       7492 :             if (block-&gt;immediateDominator() == *block)</span>
<span class="lineNum">    2438 </span><span class="lineCov">        302 :                 continue;</span>
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span>            :             // A block with no predecessors is not reachable from any entry, so
<span class="lineNum">    2441 </span>            :             // it self-dominates.
<span class="lineNum">    2442 </span><span class="lineCov">       7190 :             if (MOZ_UNLIKELY(block-&gt;numPredecessors() == 0)) {</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :                 block-&gt;setImmediateDominator(*block);</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2445 </span>            :             }
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span><span class="lineCov">       7190 :             MBasicBlock* newIdom = block-&gt;getPredecessor(0);</span>
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span>            :             // Find the first common dominator.
<span class="lineNum">    2450 </span><span class="lineCov">       8704 :             for (size_t i = 1; i &lt; block-&gt;numPredecessors(); i++) {</span>
<span class="lineNum">    2451 </span><span class="lineCov">       1520 :                 MBasicBlock* pred = block-&gt;getPredecessor(i);</span>
<span class="lineNum">    2452 </span><span class="lineCov">       1520 :                 if (pred-&gt;immediateDominator() == nullptr)</span>
<span class="lineNum">    2453 </span><span class="lineCov">        119 :                     continue;</span>
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineCov">       1401 :                 newIdom = IntersectDominators(pred, newIdom);</span>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            :                 // If there is no common dominator, the block self-dominates.
<span class="lineNum">    2458 </span><span class="lineCov">       1401 :                 if (newIdom == nullptr) {</span>
<span class="lineNum">    2459 </span><span class="lineCov">          6 :                     block-&gt;setImmediateDominator(*block);</span>
<span class="lineNum">    2460 </span><span class="lineCov">          6 :                     changed = true;</span>
<span class="lineNum">    2461 </span><span class="lineCov">          6 :                     break;</span>
<span class="lineNum">    2462 </span>            :                 }
<span class="lineNum">    2463 </span>            :             }
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span><span class="lineCov">       7190 :             if (newIdom &amp;&amp; block-&gt;immediateDominator() != newIdom) {</span>
<span class="lineNum">    2466 </span><span class="lineCov">       3592 :                 block-&gt;setImmediateDominator(newIdom);</span>
<span class="lineNum">    2467 </span><span class="lineCov">       3592 :                 changed = true;</span>
<span class="lineNum">    2468 </span>            :             }
<span class="lineNum">    2469 </span>            :         }
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span>            : 
<span class="lineNum">    2472 </span>            : #ifdef DEBUG
<span class="lineNum">    2473 </span>            :     // Assert that all blocks have dominator information.
<span class="lineNum">    2474 </span><span class="lineCov">       3896 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    2475 </span><span class="lineCov">       3750 :         MOZ_ASSERT(block-&gt;immediateDominator() != nullptr);</span>
<span class="lineNum">    2476 </span>            :     }
<span class="lineNum">    2477 </span>            : #endif
<span class="lineNum">    2478 </span><span class="lineCov">        146 : }</span>
<a name="2479"><span class="lineNum">    2479 </span>            : </a>
<span class="lineNum">    2480 </span>            : bool
<span class="lineNum">    2481 </span><span class="lineCov">        146 : jit::BuildDominatorTree(MIRGraph&amp; graph)</span>
<span class="lineNum">    2482 </span>            : {
<span class="lineNum">    2483 </span><span class="lineCov">        146 :     ComputeImmediateDominators(graph);</span>
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span><span class="lineCov">        292 :     Vector&lt;MBasicBlock*, 4, JitAllocPolicy&gt; worklist(graph.alloc());</span>
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span>            :     // Traversing through the graph in post-order means that every non-phi use
<span class="lineNum">    2488 </span>            :     // of a definition is visited before the def itself. Since a def
<span class="lineNum">    2489 </span>            :     // dominates its uses, by the time we reach a particular
<span class="lineNum">    2490 </span>            :     // block, we have processed all of its dominated children, so
<span class="lineNum">    2491 </span>            :     // block-&gt;numDominated() is accurate.
<span class="lineNum">    2492 </span><span class="lineCov">       3896 :     for (PostorderIterator i(graph.poBegin()); i != graph.poEnd(); i++) {</span>
<span class="lineNum">    2493 </span><span class="lineCov">       3750 :         MBasicBlock* child = *i;</span>
<span class="lineNum">    2494 </span><span class="lineCov">       3750 :         MBasicBlock* parent = child-&gt;immediateDominator();</span>
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span>            :         // Dominance is defined such that blocks always dominate themselves.
<span class="lineNum">    2497 </span><span class="lineCov">       3750 :         child-&gt;addNumDominated(1);</span>
<span class="lineNum">    2498 </span>            : 
<span class="lineNum">    2499 </span>            :         // If the block only self-dominates, it has no definite parent.
<span class="lineNum">    2500 </span>            :         // Add it to the worklist as a root for pre-order traversal.
<span class="lineNum">    2501 </span>            :         // This includes all roots. Order does not matter.
<span class="lineNum">    2502 </span><span class="lineCov">       3750 :         if (child == parent) {</span>
<span class="lineNum">    2503 </span><span class="lineCov">        158 :             if (!worklist.append(child))</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2505 </span><span class="lineCov">        158 :             continue;</span>
<span class="lineNum">    2506 </span>            :         }
<span class="lineNum">    2507 </span>            : 
<span class="lineNum">    2508 </span><span class="lineCov">       3592 :         if (!parent-&gt;addImmediatelyDominatedBlock(child))</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span><span class="lineCov">       3592 :         parent-&gt;addNumDominated(child-&gt;numDominated());</span>
<span class="lineNum">    2512 </span>            :     }
<span class="lineNum">    2513 </span>            : 
<span class="lineNum">    2514 </span>            : #ifdef DEBUG
<span class="lineNum">    2515 </span>            :     // If compiling with OSR, many blocks will self-dominate.
<span class="lineNum">    2516 </span>            :     // Without OSR, there is only one root block which dominates all.
<span class="lineNum">    2517 </span><span class="lineCov">        146 :     if (!graph.osrBlock())</span>
<span class="lineNum">    2518 </span><span class="lineCov">        140 :         MOZ_ASSERT(graph.entryBlock()-&gt;numDominated() == graph.numBlocks());</span>
<span class="lineNum">    2519 </span>            : #endif
<span class="lineNum">    2520 </span>            :     // Now, iterate through the dominator tree in pre-order and annotate every
<span class="lineNum">    2521 </span>            :     // block with its index in the traversal.
<span class="lineNum">    2522 </span><span class="lineCov">        146 :     size_t index = 0;</span>
<span class="lineNum">    2523 </span><span class="lineCov">       7646 :     while (!worklist.empty()) {</span>
<span class="lineNum">    2524 </span><span class="lineCov">       3750 :         MBasicBlock* block = worklist.popCopy();</span>
<span class="lineNum">    2525 </span><span class="lineCov">       3750 :         block-&gt;setDomIndex(index);</span>
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span><span class="lineCov">       3750 :         if (!worklist.append(block-&gt;immediatelyDominatedBlocksBegin(),</span>
<span class="lineNum">    2528 </span><span class="lineCov">       3750 :                              block-&gt;immediatelyDominatedBlocksEnd())) {</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2530 </span>            :         }
<span class="lineNum">    2531 </span><span class="lineCov">       3750 :         index++;</span>
<span class="lineNum">    2532 </span>            :     }
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span><span class="lineCov">        146 :     return true;</span>
<span class="lineNum">    2535 </span>            : }
<a name="2536"><span class="lineNum">    2536 </span>            : </a>
<span class="lineNum">    2537 </span>            : bool
<span class="lineNum">    2538 </span><span class="lineCov">          8 : jit::BuildPhiReverseMapping(MIRGraph&amp; graph)</span>
<span class="lineNum">    2539 </span>            : {
<span class="lineNum">    2540 </span>            :     // Build a mapping such that given a basic block, whose successor has one or
<span class="lineNum">    2541 </span>            :     // more phis, we can find our specific input to that phi. To make this fast
<span class="lineNum">    2542 </span>            :     // mapping work we rely on a specific property of our structured control
<span class="lineNum">    2543 </span>            :     // flow graph: For a block with phis, its predecessors each have only one
<span class="lineNum">    2544 </span>            :     // successor with phis. Consider each case:
<span class="lineNum">    2545 </span>            :     //   * Blocks with less than two predecessors cannot have phis.
<span class="lineNum">    2546 </span>            :     //   * Breaks. A break always has exactly one successor, and the break
<span class="lineNum">    2547 </span>            :     //             catch block has exactly one predecessor for each break, as
<span class="lineNum">    2548 </span>            :     //             well as a final predecessor for the actual loop exit.
<span class="lineNum">    2549 </span>            :     //   * Continues. A continue always has exactly one successor, and the
<span class="lineNum">    2550 </span>            :     //             continue catch block has exactly one predecessor for each
<span class="lineNum">    2551 </span>            :     //             continue, as well as a final predecessor for the actual
<span class="lineNum">    2552 </span>            :     //             loop continuation. The continue itself has exactly one
<span class="lineNum">    2553 </span>            :     //             successor.
<span class="lineNum">    2554 </span>            :     //   * An if. Each branch as exactly one predecessor.
<span class="lineNum">    2555 </span>            :     //   * A switch. Each branch has exactly one predecessor.
<span class="lineNum">    2556 </span>            :     //   * Loop tail. A new block is always created for the exit, and if a
<span class="lineNum">    2557 </span>            :     //             break statement is present, the exit block will forward
<span class="lineNum">    2558 </span>            :     //             directly to the break block.
<span class="lineNum">    2559 </span><span class="lineCov">        461 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    2560 </span><span class="lineCov">        453 :         if (block-&gt;phisEmpty())</span>
<span class="lineNum">    2561 </span><span class="lineCov">        387 :             continue;</span>
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span>            :         // Assert on the above.
<span class="lineNum">    2564 </span><span class="lineCov">        210 :         for (size_t j = 0; j &lt; block-&gt;numPredecessors(); j++) {</span>
<span class="lineNum">    2565 </span><span class="lineCov">        144 :             MBasicBlock* pred = block-&gt;getPredecessor(j);</span>
<span class="lineNum">    2566 </span>            : 
<span class="lineNum">    2567 </span>            : #ifdef DEBUG
<span class="lineNum">    2568 </span><span class="lineCov">        144 :             size_t numSuccessorsWithPhis = 0;</span>
<span class="lineNum">    2569 </span><span class="lineCov">        288 :             for (size_t k = 0; k &lt; pred-&gt;numSuccessors(); k++) {</span>
<span class="lineNum">    2570 </span><span class="lineCov">        144 :                 MBasicBlock* successor = pred-&gt;getSuccessor(k);</span>
<span class="lineNum">    2571 </span><span class="lineCov">        144 :                 if (!successor-&gt;phisEmpty())</span>
<span class="lineNum">    2572 </span><span class="lineCov">        144 :                     numSuccessorsWithPhis++;</span>
<span class="lineNum">    2573 </span>            :             }
<span class="lineNum">    2574 </span><span class="lineCov">        144 :             MOZ_ASSERT(numSuccessorsWithPhis &lt;= 1);</span>
<span class="lineNum">    2575 </span>            : #endif
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineCov">        144 :             pred-&gt;setSuccessorWithPhis(*block, j);</span>
<span class="lineNum">    2578 </span>            :         }
<span class="lineNum">    2579 </span>            :     }
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    2582 </span>            : }
<span class="lineNum">    2583 </span>            : 
<a name="2584"><span class="lineNum">    2584 </span>            : #ifdef DEBUG</a>
<span class="lineNum">    2585 </span>            : static bool
<span class="lineNum">    2586 </span><span class="lineCov">      17405 : CheckSuccessorImpliesPredecessor(MBasicBlock* A, MBasicBlock* B)</span>
<span class="lineNum">    2587 </span>            : {
<span class="lineNum">    2588 </span>            :     // Assuming B = succ(A), verify A = pred(B).
<span class="lineNum">    2589 </span><span class="lineCov">      22036 :     for (size_t i = 0; i &lt; B-&gt;numPredecessors(); i++) {</span>
<span class="lineNum">    2590 </span><span class="lineCov">      22036 :         if (A == B-&gt;getPredecessor(i))</span>
<span class="lineNum">    2591 </span><span class="lineCov">      17405 :             return true;</span>
<span class="lineNum">    2592 </span>            :     }
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2594 </span>            : }
<a name="2595"><span class="lineNum">    2595 </span>            : </a>
<span class="lineNum">    2596 </span>            : static bool
<span class="lineNum">    2597 </span><span class="lineCov">      17405 : CheckPredecessorImpliesSuccessor(MBasicBlock* A, MBasicBlock* B)</span>
<span class="lineNum">    2598 </span>            : {
<span class="lineNum">    2599 </span>            :     // Assuming B = pred(A), verify A = succ(B).
<span class="lineNum">    2600 </span><span class="lineCov">      21658 :     for (size_t i = 0; i &lt; B-&gt;numSuccessors(); i++) {</span>
<span class="lineNum">    2601 </span><span class="lineCov">      21658 :         if (A == B-&gt;getSuccessor(i))</span>
<span class="lineNum">    2602 </span><span class="lineCov">      17405 :             return true;</span>
<span class="lineNum">    2603 </span>            :     }
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2605 </span>            : }
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            : // If you have issues with the usesBalance assertions, then define the macro
<span class="lineNum">    2608 </span>            : // _DEBUG_CHECK_OPERANDS_USES_BALANCE to spew information on the error output.
<span class="lineNum">    2609 </span>            : // This output can then be processed with the following awk script to filter and
<span class="lineNum">    2610 </span>            : // highlight which checks are missing or if there is an unexpected operand /
<span class="lineNum">    2611 </span>            : // use.
<span class="lineNum">    2612 </span>            : //
<span class="lineNum">    2613 </span>            : // define _DEBUG_CHECK_OPERANDS_USES_BALANCE 1
<span class="lineNum">    2614 </span>            : /*
<span class="lineNum">    2615 </span>            : 
<span class="lineNum">    2616 </span>            : $ ./js 2&gt;stderr.log
<span class="lineNum">    2617 </span>            : $ gawk '
<span class="lineNum">    2618 </span>            :     /^==Check/ { context = &quot;&quot;; state = $2; }
<span class="lineNum">    2619 </span>            :     /^[a-z]/ { context = context &quot;\n\t&quot; $0; }
<span class="lineNum">    2620 </span>            :     /^==End/ {
<span class="lineNum">    2621 </span>            :       if (state == &quot;Operand&quot;) {
<span class="lineNum">    2622 </span>            :         list[context] = list[context] - 1;
<span class="lineNum">    2623 </span>            :       } else if (state == &quot;Use&quot;) {
<span class="lineNum">    2624 </span>            :         list[context] = list[context] + 1;
<span class="lineNum">    2625 </span>            :       }
<span class="lineNum">    2626 </span>            :     }
<span class="lineNum">    2627 </span>            :     END {
<span class="lineNum">    2628 </span>            :       for (ctx in list) {
<span class="lineNum">    2629 </span>            :         if (list[ctx] &gt; 0) {
<span class="lineNum">    2630 </span>            :           print &quot;Missing operand check&quot;, ctx, &quot;\n&quot;
<span class="lineNum">    2631 </span>            :         }
<span class="lineNum">    2632 </span>            :         if (list[ctx] &lt; 0) {
<span class="lineNum">    2633 </span>            :           print &quot;Missing use check&quot;, ctx, &quot;\n&quot;
<span class="lineNum">    2634 </span>            :         }
<span class="lineNum">    2635 </span>            :       };
<span class="lineNum">    2636 </span>            :     }'  &lt; stderr.log
<span class="lineNum">    2637 </span>            : 
<span class="lineNum">    2638 </span>            : */
<a name="2639"><span class="lineNum">    2639 </span>            : </a>
<span class="lineNum">    2640 </span>            : static void
<span class="lineNum">    2641 </span><span class="lineCov">     477809 : CheckOperand(const MNode* consumer, const MUse* use, int32_t* usesBalance)</span>
<span class="lineNum">    2642 </span>            : {
<span class="lineNum">    2643 </span><span class="lineCov">     477809 :     MOZ_ASSERT(use-&gt;hasProducer());</span>
<span class="lineNum">    2644 </span><span class="lineCov">     477809 :     MDefinition* producer = use-&gt;producer();</span>
<span class="lineNum">    2645 </span><span class="lineCov">     477809 :     MOZ_ASSERT(!producer-&gt;isDiscarded());</span>
<span class="lineNum">    2646 </span><span class="lineCov">     477809 :     MOZ_ASSERT(producer-&gt;block() != nullptr);</span>
<span class="lineNum">    2647 </span><span class="lineCov">     477809 :     MOZ_ASSERT(use-&gt;consumer() == consumer);</span>
<span class="lineNum">    2648 </span>            : #ifdef _DEBUG_CHECK_OPERANDS_USES_BALANCE
<span class="lineNum">    2649 </span>            :     Fprinter print(stderr);
<span class="lineNum">    2650 </span>            :     print.printf(&quot;==Check Operand\n&quot;);
<span class="lineNum">    2651 </span>            :     use-&gt;producer()-&gt;dump(print);
<span class="lineNum">    2652 </span>            :     print.printf(&quot;  index: %&quot; PRIuSIZE &quot;\n&quot;, use-&gt;consumer()-&gt;indexOf(use));
<span class="lineNum">    2653 </span>            :     use-&gt;consumer()-&gt;dump(print);
<span class="lineNum">    2654 </span>            :     print.printf(&quot;==End\n&quot;);
<span class="lineNum">    2655 </span>            : #endif
<span class="lineNum">    2656 </span><span class="lineCov">     477809 :     --*usesBalance;</span>
<span class="lineNum">    2657 </span><span class="lineCov">     477809 : }</span>
<a name="2658"><span class="lineNum">    2658 </span>            : </a>
<span class="lineNum">    2659 </span>            : static void
<span class="lineNum">    2660 </span><span class="lineCov">     477809 : CheckUse(const MDefinition* producer, const MUse* use, int32_t* usesBalance)</span>
<span class="lineNum">    2661 </span>            : {
<span class="lineNum">    2662 </span><span class="lineCov">     477809 :     MOZ_ASSERT(!use-&gt;consumer()-&gt;block()-&gt;isDead());</span>
<span class="lineNum">    2663 </span><span class="lineCov">     477809 :     MOZ_ASSERT_IF(use-&gt;consumer()-&gt;isDefinition(),</span>
<span class="lineNum">    2664 </span>            :                   !use-&gt;consumer()-&gt;toDefinition()-&gt;isDiscarded());
<span class="lineNum">    2665 </span><span class="lineCov">     477809 :     MOZ_ASSERT(use-&gt;consumer()-&gt;block() != nullptr);</span>
<span class="lineNum">    2666 </span><span class="lineCov">     477809 :     MOZ_ASSERT(use-&gt;consumer()-&gt;getOperand(use-&gt;index()) == producer);</span>
<span class="lineNum">    2667 </span>            : #ifdef _DEBUG_CHECK_OPERANDS_USES_BALANCE
<span class="lineNum">    2668 </span>            :     Fprinter print(stderr);
<span class="lineNum">    2669 </span>            :     print.printf(&quot;==Check Use\n&quot;);
<span class="lineNum">    2670 </span>            :     use-&gt;producer()-&gt;dump(print);
<span class="lineNum">    2671 </span>            :     print.printf(&quot;  index: %&quot; PRIuSIZE &quot;\n&quot;, use-&gt;consumer()-&gt;indexOf(use));
<span class="lineNum">    2672 </span>            :     use-&gt;consumer()-&gt;dump(print);
<span class="lineNum">    2673 </span>            :     print.printf(&quot;==End\n&quot;);
<span class="lineNum">    2674 </span>            : #endif
<span class="lineNum">    2675 </span><span class="lineCov">     477809 :     ++*usesBalance;</span>
<span class="lineNum">    2676 </span><span class="lineCov">     477809 : }</span>
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            : // To properly encode entry resume points, we have to ensure that all the
<span class="lineNum">    2679 </span>            : // operands of the entry resume point are located before the safeInsertTop
<a name="2680"><span class="lineNum">    2680 </span>            : // location.</a>
<span class="lineNum">    2681 </span>            : static void
<span class="lineNum">    2682 </span><span class="lineCov">      14513 : AssertOperandsBeforeSafeInsertTop(MResumePoint* resume)</span>
<span class="lineNum">    2683 </span>            : {
<span class="lineNum">    2684 </span><span class="lineCov">      14513 :     MBasicBlock* block = resume-&gt;block();</span>
<span class="lineNum">    2685 </span><span class="lineCov">      14513 :     if (block == block-&gt;graph().osrBlock())</span>
<span class="lineNum">    2686 </span><span class="lineCov">         99 :         return;</span>
<span class="lineNum">    2687 </span><span class="lineCov">      14414 :     MInstruction* stop = block-&gt;safeInsertTop();</span>
<span class="lineNum">    2688 </span><span class="lineCov">     254181 :     for (size_t i = 0, e = resume-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    2689 </span><span class="lineCov">     239767 :         MDefinition* def = resume-&gt;getOperand(i);</span>
<span class="lineNum">    2690 </span><span class="lineCov">     239767 :         if (def-&gt;block() != block)</span>
<span class="lineNum">    2691 </span><span class="lineCov">     226922 :             continue;</span>
<span class="lineNum">    2692 </span><span class="lineCov">      12845 :         if (def-&gt;isPhi())</span>
<span class="lineNum">    2693 </span><span class="lineCov">       6408 :             continue;</span>
<span class="lineNum">    2694 </span>            : 
<span class="lineNum">    2695 </span><span class="lineCov">      17260 :         for (MInstructionIterator ins = block-&gt;begin(); true; ins++) {</span>
<span class="lineNum">    2696 </span><span class="lineCov">      28083 :             if (*ins == def)</span>
<span class="lineNum">    2697 </span><span class="lineCov">       6437 :                 break;</span>
<span class="lineNum">    2698 </span><span class="lineCov">      10823 :             MOZ_ASSERT(*ins != stop,</span>
<span class="lineNum">    2699 </span>            :                        &quot;Resume point operand located after the safeInsertTop location&quot;);
<span class="lineNum">    2700 </span>            :         }
<span class="lineNum">    2701 </span>            :     }
<span class="lineNum">    2702 </span>            : }
<span class="lineNum">    2703 </span>            : #endif // DEBUG
<a name="2704"><span class="lineNum">    2704 </span>            : </a>
<span class="lineNum">    2705 </span>            : void
<span class="lineNum">    2706 </span><span class="lineCov">        262 : jit::AssertBasicGraphCoherency(MIRGraph&amp; graph, bool force)</span>
<span class="lineNum">    2707 </span>            : {
<span class="lineNum">    2708 </span>            : #ifdef DEBUG
<span class="lineNum">    2709 </span><span class="lineCov">        262 :     if (!JitOptions.fullDebugChecks &amp;&amp; !force)</span>
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2711 </span>            : 
<span class="lineNum">    2712 </span><span class="lineCov">        262 :     MOZ_ASSERT(graph.entryBlock()-&gt;numPredecessors() == 0);</span>
<span class="lineNum">    2713 </span><span class="lineCov">        262 :     MOZ_ASSERT(graph.entryBlock()-&gt;phisEmpty());</span>
<span class="lineNum">    2714 </span><span class="lineCov">        262 :     MOZ_ASSERT(!graph.entryBlock()-&gt;unreachable());</span>
<span class="lineNum">    2715 </span>            : 
<span class="lineNum">    2716 </span><span class="lineCov">        262 :     if (MBasicBlock* osrBlock = graph.osrBlock()) {</span>
<span class="lineNum">    2717 </span><span class="lineCov">         99 :         MOZ_ASSERT(osrBlock-&gt;numPredecessors() == 0);</span>
<span class="lineNum">    2718 </span><span class="lineCov">         99 :         MOZ_ASSERT(osrBlock-&gt;phisEmpty());</span>
<span class="lineNum">    2719 </span><span class="lineCov">         99 :         MOZ_ASSERT(osrBlock != graph.entryBlock());</span>
<span class="lineNum">    2720 </span><span class="lineCov">         99 :         MOZ_ASSERT(!osrBlock-&gt;unreachable());</span>
<span class="lineNum">    2721 </span>            :     }
<span class="lineNum">    2722 </span>            : 
<span class="lineNum">    2723 </span><span class="lineCov">        262 :     if (MResumePoint* resumePoint = graph.entryResumePoint())</span>
<span class="lineNum">    2724 </span><span class="lineCov">        262 :         MOZ_ASSERT(resumePoint-&gt;block() == graph.entryBlock());</span>
<span class="lineNum">    2725 </span>            : 
<span class="lineNum">    2726 </span>            :     // Assert successor and predecessor list coherency.
<span class="lineNum">    2727 </span><span class="lineCov">        262 :     uint32_t count = 0;</span>
<span class="lineNum">    2728 </span><span class="lineCov">        262 :     int32_t usesBalance = 0;</span>
<span class="lineNum">    2729 </span><span class="lineCov">      14775 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    2730 </span><span class="lineCov">      14513 :         count++;</span>
<span class="lineNum">    2731 </span>            : 
<span class="lineNum">    2732 </span><span class="lineCov">      14513 :         MOZ_ASSERT(&amp;block-&gt;graph() == &amp;graph);</span>
<span class="lineNum">    2733 </span><span class="lineCov">      14513 :         MOZ_ASSERT(!block-&gt;isDead());</span>
<span class="lineNum">    2734 </span><span class="lineCov">      14513 :         MOZ_ASSERT_IF(block-&gt;outerResumePoint() != nullptr,</span>
<span class="lineNum">    2735 </span>            :                       block-&gt;entryResumePoint() != nullptr);
<span class="lineNum">    2736 </span>            : 
<span class="lineNum">    2737 </span><span class="lineCov">      31918 :         for (size_t i = 0; i &lt; block-&gt;numSuccessors(); i++)</span>
<span class="lineNum">    2738 </span><span class="lineCov">      17405 :             MOZ_ASSERT(CheckSuccessorImpliesPredecessor(*block, block-&gt;getSuccessor(i)));</span>
<span class="lineNum">    2739 </span>            : 
<span class="lineNum">    2740 </span><span class="lineCov">      31918 :         for (size_t i = 0; i &lt; block-&gt;numPredecessors(); i++)</span>
<span class="lineNum">    2741 </span><span class="lineCov">      17405 :             MOZ_ASSERT(CheckPredecessorImpliesSuccessor(*block, block-&gt;getPredecessor(i)));</span>
<span class="lineNum">    2742 </span>            : 
<span class="lineNum">    2743 </span><span class="lineCov">      14513 :         if (MResumePoint* resume = block-&gt;entryResumePoint()) {</span>
<span class="lineNum">    2744 </span><span class="lineCov">      14513 :             MOZ_ASSERT(!resume-&gt;instruction());</span>
<span class="lineNum">    2745 </span><span class="lineCov">      14513 :             MOZ_ASSERT(resume-&gt;block() == *block);</span>
<span class="lineNum">    2746 </span><span class="lineCov">      14513 :             AssertOperandsBeforeSafeInsertTop(resume);</span>
<span class="lineNum">    2747 </span>            :         }
<span class="lineNum">    2748 </span><span class="lineCov">      14513 :         if (MResumePoint* resume = block-&gt;outerResumePoint()) {</span>
<span class="lineNum">    2749 </span><span class="lineCov">        673 :             MOZ_ASSERT(!resume-&gt;instruction());</span>
<span class="lineNum">    2750 </span><span class="lineCov">        673 :             MOZ_ASSERT(resume-&gt;block() == *block);</span>
<span class="lineNum">    2751 </span>            :         }
<span class="lineNum">    2752 </span><span class="lineCov">      39979 :         for (MResumePointIterator iter(block-&gt;resumePointsBegin()); iter != block-&gt;resumePointsEnd(); iter++) {</span>
<span class="lineNum">    2753 </span>            :             // We cannot yet assert that is there is no instruction then this is
<span class="lineNum">    2754 </span>            :             // the entry resume point because we are still storing resume points
<span class="lineNum">    2755 </span>            :             // in the InlinePropertyTable.
<span class="lineNum">    2756 </span><span class="lineCov">      25466 :             MOZ_ASSERT_IF(iter-&gt;instruction(), iter-&gt;instruction()-&gt;block() == *block);</span>
<span class="lineNum">    2757 </span><span class="lineCov">     443714 :             for (uint32_t i = 0, e = iter-&gt;numOperands(); i &lt; e; i++)</span>
<span class="lineNum">    2758 </span><span class="lineCov">     418248 :                 CheckOperand(*iter, iter-&gt;getUseFor(i), &amp;usesBalance);</span>
<span class="lineNum">    2759 </span>            :         }
<span class="lineNum">    2760 </span><span class="lineCov">      21358 :         for (MPhiIterator phi(block-&gt;phisBegin()); phi != block-&gt;phisEnd(); phi++) {</span>
<span class="lineNum">    2761 </span><span class="lineCov">       6845 :             MOZ_ASSERT(phi-&gt;numOperands() == block-&gt;numPredecessors());</span>
<span class="lineNum">    2762 </span><span class="lineCov">       6845 :             MOZ_ASSERT(!phi-&gt;isRecoveredOnBailout());</span>
<span class="lineNum">    2763 </span><span class="lineCov">       6845 :             MOZ_ASSERT(phi-&gt;type() != MIRType::None);</span>
<span class="lineNum">    2764 </span><span class="lineCov">       6845 :             MOZ_ASSERT(phi-&gt;dependency() == nullptr);</span>
<span class="lineNum">    2765 </span>            :         }
<span class="lineNum">    2766 </span><span class="lineCov">      66592 :         for (MDefinitionIterator iter(*block); iter; iter++) {</span>
<span class="lineNum">    2767 </span><span class="lineCov">      52079 :             MOZ_ASSERT(iter-&gt;block() == *block);</span>
<span class="lineNum">    2768 </span><span class="lineCov">      52079 :             MOZ_ASSERT_IF(iter-&gt;hasUses(), iter-&gt;type() != MIRType::None);</span>
<span class="lineNum">    2769 </span><span class="lineCov">      52079 :             MOZ_ASSERT(!iter-&gt;isDiscarded());</span>
<span class="lineNum">    2770 </span><span class="lineCov">      52079 :             MOZ_ASSERT_IF(iter-&gt;isStart(),</span>
<span class="lineNum">    2771 </span>            :                           *block == graph.entryBlock() || *block == graph.osrBlock());
<span class="lineNum">    2772 </span><span class="lineCov">      52079 :             MOZ_ASSERT_IF(iter-&gt;isParameter(),</span>
<span class="lineNum">    2773 </span>            :                           *block == graph.entryBlock() || *block == graph.osrBlock());
<span class="lineNum">    2774 </span><span class="lineCov">      52079 :             MOZ_ASSERT_IF(iter-&gt;isOsrEntry(), *block == graph.osrBlock());</span>
<span class="lineNum">    2775 </span><span class="lineCov">      52079 :             MOZ_ASSERT_IF(iter-&gt;isOsrValue(), *block == graph.osrBlock());</span>
<span class="lineNum">    2776 </span>            : 
<span class="lineNum">    2777 </span>            :             // Assert that use chains are valid for this instruction.
<span class="lineNum">    2778 </span><span class="lineCov">     106820 :             for (uint32_t i = 0, end = iter-&gt;numOperands(); i &lt; end; i++)</span>
<span class="lineNum">    2779 </span><span class="lineCov">      54741 :                 CheckOperand(*iter, iter-&gt;getUseFor(i), &amp;usesBalance);</span>
<span class="lineNum">    2780 </span><span class="lineCov">     529888 :             for (MUseIterator use(iter-&gt;usesBegin()); use != iter-&gt;usesEnd(); use++)</span>
<span class="lineNum">    2781 </span><span class="lineCov">     477809 :                 CheckUse(*iter, *use, &amp;usesBalance);</span>
<span class="lineNum">    2782 </span>            : 
<span class="lineNum">    2783 </span><span class="lineCov">      52079 :             if (iter-&gt;isInstruction()) {</span>
<span class="lineNum">    2784 </span><span class="lineCov">      45234 :                 if (MResumePoint* resume = iter-&gt;toInstruction()-&gt;resumePoint()) {</span>
<span class="lineNum">    2785 </span><span class="lineCov">      10280 :                     MOZ_ASSERT(resume-&gt;instruction() == *iter);</span>
<span class="lineNum">    2786 </span><span class="lineCov">      10280 :                     MOZ_ASSERT(resume-&gt;block() == *block);</span>
<span class="lineNum">    2787 </span><span class="lineCov">      10280 :                     MOZ_ASSERT(resume-&gt;block()-&gt;entryResumePoint() != nullptr);</span>
<span class="lineNum">    2788 </span>            :                 }
<span class="lineNum">    2789 </span>            :             }
<span class="lineNum">    2790 </span>            : 
<span class="lineNum">    2791 </span><span class="lineCov">      52079 :             if (iter-&gt;isRecoveredOnBailout())</span>
<span class="lineNum">    2792 </span><span class="lineCov">       1565 :                 MOZ_ASSERT(!iter-&gt;hasLiveDefUses());</span>
<span class="lineNum">    2793 </span>            :         }
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span>            :         // The control instruction is not visited by the MDefinitionIterator.
<span class="lineNum">    2796 </span><span class="lineCov">      14513 :         MControlInstruction* control = block-&gt;lastIns();</span>
<span class="lineNum">    2797 </span><span class="lineCov">      14513 :         MOZ_ASSERT(control-&gt;block() == *block);</span>
<span class="lineNum">    2798 </span><span class="lineCov">      14513 :         MOZ_ASSERT(!control-&gt;hasUses());</span>
<span class="lineNum">    2799 </span><span class="lineCov">      14513 :         MOZ_ASSERT(control-&gt;type() == MIRType::None);</span>
<span class="lineNum">    2800 </span><span class="lineCov">      14513 :         MOZ_ASSERT(!control-&gt;isDiscarded());</span>
<span class="lineNum">    2801 </span><span class="lineCov">      14513 :         MOZ_ASSERT(!control-&gt;isRecoveredOnBailout());</span>
<span class="lineNum">    2802 </span><span class="lineCov">      14513 :         MOZ_ASSERT(control-&gt;resumePoint() == nullptr);</span>
<span class="lineNum">    2803 </span><span class="lineCov">      19333 :         for (uint32_t i = 0, end = control-&gt;numOperands(); i &lt; end; i++)</span>
<span class="lineNum">    2804 </span><span class="lineCov">       4820 :             CheckOperand(control, control-&gt;getUseFor(i), &amp;usesBalance);</span>
<span class="lineNum">    2805 </span><span class="lineCov">      31918 :         for (size_t i = 0; i &lt; control-&gt;numSuccessors(); i++)</span>
<span class="lineNum">    2806 </span><span class="lineCov">      17405 :             MOZ_ASSERT(control-&gt;getSuccessor(i));</span>
<span class="lineNum">    2807 </span>            :     }
<span class="lineNum">    2808 </span>            : 
<span class="lineNum">    2809 </span>            :     // In case issues, see the _DEBUG_CHECK_OPERANDS_USES_BALANCE macro above.
<span class="lineNum">    2810 </span><span class="lineCov">        262 :     MOZ_ASSERT(usesBalance &lt;= 0, &quot;More use checks than operand checks&quot;);</span>
<span class="lineNum">    2811 </span><span class="lineCov">        262 :     MOZ_ASSERT(usesBalance &gt;= 0, &quot;More operand checks than use checks&quot;);</span>
<span class="lineNum">    2812 </span><span class="lineCov">        262 :     MOZ_ASSERT(graph.numBlocks() == count);</span>
<span class="lineNum">    2813 </span>            : #endif
<span class="lineNum">    2814 </span>            : }
<span class="lineNum">    2815 </span>            : 
<a name="2816"><span class="lineNum">    2816 </span>            : #ifdef DEBUG</a>
<span class="lineNum">    2817 </span>            : static void
<span class="lineNum">    2818 </span><span class="lineCov">        214 : AssertReversePostorder(MIRGraph&amp; graph)</span>
<span class="lineNum">    2819 </span>            : {
<span class="lineNum">    2820 </span>            :     // Check that every block is visited after all its predecessors (except backedges).
<span class="lineNum">    2821 </span><span class="lineCov">      11571 :     for (ReversePostorderIterator iter(graph.rpoBegin()); iter != graph.rpoEnd(); ++iter) {</span>
<span class="lineNum">    2822 </span><span class="lineCov">      11357 :         MBasicBlock* block = *iter;</span>
<span class="lineNum">    2823 </span><span class="lineCov">      11357 :         MOZ_ASSERT(!block-&gt;isMarked());</span>
<span class="lineNum">    2824 </span>            : 
<span class="lineNum">    2825 </span><span class="lineCov">      24947 :         for (size_t i = 0; i &lt; block-&gt;numPredecessors(); i++) {</span>
<span class="lineNum">    2826 </span><span class="lineCov">      13590 :             MBasicBlock* pred = block-&gt;getPredecessor(i);</span>
<span class="lineNum">    2827 </span><span class="lineCov">      13590 :             if (!pred-&gt;isMarked()) {</span>
<span class="lineNum">    2828 </span><span class="lineCov">        135 :                 MOZ_ASSERT(pred-&gt;isLoopBackedge());</span>
<span class="lineNum">    2829 </span><span class="lineCov">        135 :                 MOZ_ASSERT(block-&gt;backedge() == pred);</span>
<span class="lineNum">    2830 </span>            :             }
<span class="lineNum">    2831 </span>            :         }
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span><span class="lineCov">      11357 :         block-&gt;mark();</span>
<span class="lineNum">    2834 </span>            :     }
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span><span class="lineCov">        214 :     graph.unmarkBlocks();</span>
<span class="lineNum">    2837 </span><span class="lineCov">        214 : }</span>
<span class="lineNum">    2838 </span>            : #endif
<span class="lineNum">    2839 </span>            : 
<a name="2840"><span class="lineNum">    2840 </span>            : #ifdef DEBUG</a>
<span class="lineNum">    2841 </span>            : static void
<span class="lineNum">    2842 </span><span class="lineCov">        142 : AssertDominatorTree(MIRGraph&amp; graph)</span>
<span class="lineNum">    2843 </span>            : {
<span class="lineNum">    2844 </span>            :     // Check dominators.
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span><span class="lineCov">        142 :     MOZ_ASSERT(graph.entryBlock()-&gt;immediateDominator() == graph.entryBlock());</span>
<span class="lineNum">    2847 </span><span class="lineCov">        142 :     if (MBasicBlock* osrBlock = graph.osrBlock())</span>
<span class="lineNum">    2848 </span><span class="lineCov">         54 :         MOZ_ASSERT(osrBlock-&gt;immediateDominator() == osrBlock);</span>
<span class="lineNum">    2849 </span>            :     else
<span class="lineNum">    2850 </span><span class="lineCov">         88 :         MOZ_ASSERT(graph.entryBlock()-&gt;numDominated() == graph.numBlocks());</span>
<span class="lineNum">    2851 </span>            : 
<span class="lineNum">    2852 </span><span class="lineCov">        142 :     size_t i = graph.numBlocks();</span>
<span class="lineNum">    2853 </span><span class="lineCov">        142 :     size_t totalNumDominated = 0;</span>
<span class="lineNum">    2854 </span><span class="lineCov">       7622 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    2855 </span><span class="lineCov">       7480 :         MOZ_ASSERT(block-&gt;dominates(*block));</span>
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span><span class="lineCov">       7480 :         MBasicBlock* idom = block-&gt;immediateDominator();</span>
<span class="lineNum">    2858 </span><span class="lineCov">       7480 :         MOZ_ASSERT(idom-&gt;dominates(*block));</span>
<span class="lineNum">    2859 </span><span class="lineCov">       7480 :         MOZ_ASSERT(idom == *block || idom-&gt;id() &lt; block-&gt;id());</span>
<span class="lineNum">    2860 </span>            : 
<span class="lineNum">    2861 </span><span class="lineCov">       7480 :         if (idom == *block) {</span>
<span class="lineNum">    2862 </span><span class="lineCov">        250 :             totalNumDominated += block-&gt;numDominated();</span>
<span class="lineNum">    2863 </span>            :         } else {
<span class="lineNum">    2864 </span><span class="lineCov">       7230 :             bool foundInParent = false;</span>
<span class="lineNum">    2865 </span><span class="lineCov">      11979 :             for (size_t j = 0; j &lt; idom-&gt;numImmediatelyDominatedBlocks(); j++) {</span>
<span class="lineNum">    2866 </span><span class="lineCov">      11979 :                 if (idom-&gt;getImmediatelyDominatedBlock(j) == *block) {</span>
<span class="lineNum">    2867 </span><span class="lineCov">       7230 :                     foundInParent = true;</span>
<span class="lineNum">    2868 </span><span class="lineCov">       7230 :                     break;</span>
<span class="lineNum">    2869 </span>            :                 }
<span class="lineNum">    2870 </span>            :             }
<span class="lineNum">    2871 </span><span class="lineCov">       7230 :             MOZ_ASSERT(foundInParent);</span>
<span class="lineNum">    2872 </span>            :         }
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineCov">       7480 :         size_t numDominated = 1;</span>
<span class="lineNum">    2875 </span><span class="lineCov">      14710 :         for (size_t j = 0; j &lt; block-&gt;numImmediatelyDominatedBlocks(); j++) {</span>
<span class="lineNum">    2876 </span><span class="lineCov">       7230 :             MBasicBlock* dom = block-&gt;getImmediatelyDominatedBlock(j);</span>
<span class="lineNum">    2877 </span><span class="lineCov">       7230 :             MOZ_ASSERT(block-&gt;dominates(dom));</span>
<span class="lineNum">    2878 </span><span class="lineCov">       7230 :             MOZ_ASSERT(dom-&gt;id() &gt; block-&gt;id());</span>
<span class="lineNum">    2879 </span><span class="lineCov">       7230 :             MOZ_ASSERT(dom-&gt;immediateDominator() == *block);</span>
<span class="lineNum">    2880 </span>            : 
<span class="lineNum">    2881 </span><span class="lineCov">       7230 :             numDominated += dom-&gt;numDominated();</span>
<span class="lineNum">    2882 </span>            :         }
<span class="lineNum">    2883 </span><span class="lineCov">       7480 :         MOZ_ASSERT(block-&gt;numDominated() == numDominated);</span>
<span class="lineNum">    2884 </span><span class="lineCov">       7480 :         MOZ_ASSERT(block-&gt;numDominated() &lt;= i);</span>
<span class="lineNum">    2885 </span><span class="lineCov">       7480 :         MOZ_ASSERT(block-&gt;numSuccessors() != 0 || block-&gt;numDominated() == 1);</span>
<span class="lineNum">    2886 </span><span class="lineCov">       7480 :         i--;</span>
<span class="lineNum">    2887 </span>            :     }
<span class="lineNum">    2888 </span><span class="lineCov">        142 :     MOZ_ASSERT(i == 0);</span>
<span class="lineNum">    2889 </span><span class="lineCov">        142 :     MOZ_ASSERT(totalNumDominated == graph.numBlocks());</span>
<span class="lineNum">    2890 </span><span class="lineCov">        142 : }</span>
<span class="lineNum">    2891 </span>            : #endif
<a name="2892"><span class="lineNum">    2892 </span>            : </a>
<span class="lineNum">    2893 </span>            : void
<span class="lineNum">    2894 </span><span class="lineCov">        214 : jit::AssertGraphCoherency(MIRGraph&amp; graph, bool force)</span>
<span class="lineNum">    2895 </span>            : {
<span class="lineNum">    2896 </span>            : #ifdef DEBUG
<span class="lineNum">    2897 </span><span class="lineCov">        214 :     if (!JitOptions.checkGraphConsistency)</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2899 </span><span class="lineCov">        214 :     if (!JitOptions.fullDebugChecks &amp;&amp; !force)</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2901 </span><span class="lineCov">        214 :     AssertBasicGraphCoherency(graph, force);</span>
<span class="lineNum">    2902 </span><span class="lineCov">        214 :     AssertReversePostorder(graph);</span>
<span class="lineNum">    2903 </span>            : #endif
<span class="lineNum">    2904 </span>            : }
<span class="lineNum">    2905 </span>            : 
<a name="2906"><span class="lineNum">    2906 </span>            : #ifdef DEBUG</a>
<span class="lineNum">    2907 </span>            : static bool
<span class="lineNum">    2908 </span><span class="lineCov">     214494 : IsResumableMIRType(MIRType type)</span>
<span class="lineNum">    2909 </span>            : {
<span class="lineNum">    2910 </span>            :     // see CodeGeneratorShared::encodeAllocation
<span class="lineNum">    2911 </span><span class="lineCov">     214494 :     switch (type) {</span>
<span class="lineNum">    2912 </span>            :       case MIRType::Undefined:
<span class="lineNum">    2913 </span>            :       case MIRType::Null:
<span class="lineNum">    2914 </span>            :       case MIRType::Boolean:
<span class="lineNum">    2915 </span>            :       case MIRType::Int32:
<span class="lineNum">    2916 </span>            :       case MIRType::Double:
<span class="lineNum">    2917 </span>            :       case MIRType::Float32:
<span class="lineNum">    2918 </span>            :       case MIRType::String:
<span class="lineNum">    2919 </span>            :       case MIRType::Symbol:
<span class="lineNum">    2920 </span>            :       case MIRType::Object:
<span class="lineNum">    2921 </span>            :       case MIRType::MagicOptimizedArguments:
<span class="lineNum">    2922 </span>            :       case MIRType::MagicOptimizedOut:
<span class="lineNum">    2923 </span>            :       case MIRType::MagicUninitializedLexical:
<span class="lineNum">    2924 </span>            :       case MIRType::MagicIsConstructing:
<span class="lineNum">    2925 </span>            :       case MIRType::Value:
<span class="lineNum">    2926 </span>            :       case MIRType::Int32x4:
<span class="lineNum">    2927 </span>            :       case MIRType::Int16x8:
<span class="lineNum">    2928 </span>            :       case MIRType::Int8x16:
<span class="lineNum">    2929 </span>            :       case MIRType::Float32x4:
<span class="lineNum">    2930 </span>            :       case MIRType::Bool32x4:
<span class="lineNum">    2931 </span>            :       case MIRType::Bool16x8:
<span class="lineNum">    2932 </span>            :       case MIRType::Bool8x16:
<span class="lineNum">    2933 </span><span class="lineCov">     214494 :         return true;</span>
<span class="lineNum">    2934 </span>            : 
<span class="lineNum">    2935 </span>            :       case MIRType::MagicHole:
<span class="lineNum">    2936 </span>            :       case MIRType::ObjectOrNull:
<span class="lineNum">    2937 </span>            :       case MIRType::None:
<span class="lineNum">    2938 </span>            :       case MIRType::Slots:
<span class="lineNum">    2939 </span>            :       case MIRType::Elements:
<span class="lineNum">    2940 </span>            :       case MIRType::Pointer:
<span class="lineNum">    2941 </span>            :       case MIRType::Shape:
<span class="lineNum">    2942 </span>            :       case MIRType::ObjectGroup:
<span class="lineNum">    2943 </span>            :       case MIRType::Doublex2: // NYI, see also RSimdBox::recover
<span class="lineNum">    2944 </span>            :       case MIRType::SinCosDouble:
<span class="lineNum">    2945 </span>            :       case MIRType::Int64:
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2947 </span>            :     }
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Unknown MIRType.&quot;);</span>
<span class="lineNum">    2949 </span>            : }
<a name="2950"><span class="lineNum">    2950 </span>            : </a>
<span class="lineNum">    2951 </span>            : static void
<span class="lineNum">    2952 </span><span class="lineCov">      14063 : AssertResumableOperands(MNode* node)</span>
<span class="lineNum">    2953 </span>            : {
<span class="lineNum">    2954 </span><span class="lineCov">     230895 :     for (size_t i = 0, e = node-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    2955 </span><span class="lineCov">     216832 :         MDefinition* op = node-&gt;getOperand(i);</span>
<span class="lineNum">    2956 </span><span class="lineCov">     216832 :         if (op-&gt;isRecoveredOnBailout())</span>
<span class="lineNum">    2957 </span><span class="lineCov">       2338 :             continue;</span>
<span class="lineNum">    2958 </span><span class="lineCov">     214494 :         MOZ_ASSERT(IsResumableMIRType(op-&gt;type()),</span>
<span class="lineNum">    2959 </span>            :                    &quot;Resume point cannot encode its operands&quot;);
<span class="lineNum">    2960 </span>            :     }
<span class="lineNum">    2961 </span><span class="lineCov">      14063 : }</span>
<a name="2962"><span class="lineNum">    2962 </span>            : </a>
<span class="lineNum">    2963 </span>            : static void
<span class="lineNum">    2964 </span><span class="lineCov">      30086 : AssertIfResumableInstruction(MDefinition* def)</span>
<span class="lineNum">    2965 </span>            : {
<span class="lineNum">    2966 </span><span class="lineCov">      30086 :     if (!def-&gt;isRecoveredOnBailout())</span>
<span class="lineNum">    2967 </span><span class="lineCov">      28974 :         return;</span>
<span class="lineNum">    2968 </span><span class="lineCov">       1112 :     AssertResumableOperands(def);</span>
<span class="lineNum">    2969 </span>            : }
<a name="2970"><span class="lineNum">    2970 </span>            : </a>
<span class="lineNum">    2971 </span>            : static void
<span class="lineNum">    2972 </span><span class="lineCov">      12951 : AssertResumePointDominatedByOperands(MResumePoint* resume)</span>
<span class="lineNum">    2973 </span>            : {
<span class="lineNum">    2974 </span><span class="lineCov">     225998 :     for (size_t i = 0, e = resume-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    2975 </span><span class="lineCov">     213047 :         MDefinition* op = resume-&gt;getOperand(i);</span>
<span class="lineNum">    2976 </span><span class="lineCov">     213047 :         if (op-&gt;type() == MIRType::MagicOptimizedArguments)</span>
<span class="lineNum">    2977 </span><span class="lineCov">        249 :             continue;</span>
<span class="lineNum">    2978 </span><span class="lineCov">     212798 :         MOZ_ASSERT(op-&gt;block()-&gt;dominates(resume-&gt;block()),</span>
<span class="lineNum">    2979 </span>            :                    &quot;Resume point is not dominated by its operands&quot;);
<span class="lineNum">    2980 </span>            :     }
<span class="lineNum">    2981 </span><span class="lineCov">      12951 : }</span>
<span class="lineNum">    2982 </span>            : #endif // DEBUG
<a name="2983"><span class="lineNum">    2983 </span>            : </a>
<span class="lineNum">    2984 </span>            : void
<span class="lineNum">    2985 </span><span class="lineCov">        142 : jit::AssertExtendedGraphCoherency(MIRGraph&amp; graph, bool underValueNumberer, bool force)</span>
<span class="lineNum">    2986 </span>            : {
<span class="lineNum">    2987 </span>            :     // Checks the basic GraphCoherency but also other conditions that
<span class="lineNum">    2988 </span>            :     // do not hold immediately (such as the fact that critical edges
<span class="lineNum">    2989 </span>            :     // are split)
<span class="lineNum">    2990 </span>            : 
<span class="lineNum">    2991 </span>            : #ifdef DEBUG
<span class="lineNum">    2992 </span><span class="lineCov">        142 :     if (!JitOptions.checkGraphConsistency)</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2994 </span><span class="lineCov">        142 :     if (!JitOptions.fullDebugChecks &amp;&amp; !force)</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2996 </span>            : 
<span class="lineNum">    2997 </span><span class="lineCov">        142 :     AssertGraphCoherency(graph, force);</span>
<span class="lineNum">    2998 </span>            : 
<span class="lineNum">    2999 </span><span class="lineCov">        142 :     AssertDominatorTree(graph);</span>
<span class="lineNum">    3000 </span>            : 
<span class="lineNum">    3001 </span><span class="lineCov">        284 :     DebugOnly&lt;uint32_t&gt; idx = 0;</span>
<span class="lineNum">    3002 </span><span class="lineCov">       7622 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    3003 </span><span class="lineCov">       7480 :         MOZ_ASSERT(block-&gt;id() == idx);</span>
<span class="lineNum">    3004 </span><span class="lineCov">       7480 :         ++idx;</span>
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span>            :         // No critical edges:
<span class="lineNum">    3007 </span><span class="lineCov">       7480 :         if (block-&gt;numSuccessors() &gt; 1)</span>
<span class="lineNum">    3008 </span><span class="lineCov">       6459 :             for (size_t i = 0; i &lt; block-&gt;numSuccessors(); i++)</span>
<span class="lineNum">    3009 </span><span class="lineCov">       4306 :                 MOZ_ASSERT(block-&gt;getSuccessor(i)-&gt;numPredecessors() == 1);</span>
<span class="lineNum">    3010 </span>            : 
<span class="lineNum">    3011 </span><span class="lineCov">       7480 :         if (block-&gt;isLoopHeader()) {</span>
<span class="lineNum">    3012 </span><span class="lineCov">         90 :             if (underValueNumberer &amp;&amp; block-&gt;numPredecessors() == 3) {</span>
<span class="lineNum">    3013 </span>            :                 // Fixup block.
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(block-&gt;getPredecessor(1)-&gt;numPredecessors() == 0);</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(graph.osrBlock(),</span>
<span class="lineNum">    3016 </span>            :                            &quot;Fixup blocks should only exists if we have an osr block.&quot;);
<span class="lineNum">    3017 </span>            :             } else {
<span class="lineNum">    3018 </span><span class="lineCov">         90 :                 MOZ_ASSERT(block-&gt;numPredecessors() == 2);</span>
<span class="lineNum">    3019 </span>            :             }
<span class="lineNum">    3020 </span><span class="lineCov">         90 :             MBasicBlock* backedge = block-&gt;backedge();</span>
<span class="lineNum">    3021 </span><span class="lineCov">         90 :             MOZ_ASSERT(backedge-&gt;id() &gt;= block-&gt;id());</span>
<span class="lineNum">    3022 </span><span class="lineCov">         90 :             MOZ_ASSERT(backedge-&gt;numSuccessors() == 1);</span>
<span class="lineNum">    3023 </span><span class="lineCov">         90 :             MOZ_ASSERT(backedge-&gt;getSuccessor(0) == *block);</span>
<span class="lineNum">    3024 </span>            :         }
<span class="lineNum">    3025 </span>            : 
<span class="lineNum">    3026 </span><span class="lineCov">       7480 :         if (!block-&gt;phisEmpty()) {</span>
<span class="lineNum">    3027 </span><span class="lineCov">       3618 :             for (size_t i = 0; i &lt; block-&gt;numPredecessors(); i++) {</span>
<span class="lineNum">    3028 </span><span class="lineCov">       2477 :                 MBasicBlock* pred = block-&gt;getPredecessor(i);</span>
<span class="lineNum">    3029 </span><span class="lineCov">       2477 :                 MOZ_ASSERT(pred-&gt;successorWithPhis() == *block);</span>
<span class="lineNum">    3030 </span><span class="lineCov">       2477 :                 MOZ_ASSERT(pred-&gt;positionInPhiSuccessor() == i);</span>
<span class="lineNum">    3031 </span>            :             }
<span class="lineNum">    3032 </span>            :         }
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span><span class="lineCov">       7480 :         uint32_t successorWithPhis = 0;</span>
<span class="lineNum">    3035 </span><span class="lineCov">      16404 :         for (size_t i = 0; i &lt; block-&gt;numSuccessors(); i++)</span>
<span class="lineNum">    3036 </span><span class="lineCov">       8924 :             if (!block-&gt;getSuccessor(i)-&gt;phisEmpty())</span>
<span class="lineNum">    3037 </span><span class="lineCov">       2477 :                 successorWithPhis++;</span>
<span class="lineNum">    3038 </span>            : 
<span class="lineNum">    3039 </span><span class="lineCov">       7480 :         MOZ_ASSERT(successorWithPhis &lt;= 1);</span>
<span class="lineNum">    3040 </span><span class="lineCov">       7480 :         MOZ_ASSERT((successorWithPhis != 0) == (block-&gt;successorWithPhis() != nullptr));</span>
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span>            :         // Verify that phi operands dominate the corresponding CFG predecessor
<span class="lineNum">    3043 </span>            :         // edges.
<span class="lineNum">    3044 </span><span class="lineCov">      10802 :         for (MPhiIterator iter(block-&gt;phisBegin()), end(block-&gt;phisEnd()); iter != end; ++iter) {</span>
<span class="lineNum">    3045 </span><span class="lineCov">       3322 :             MPhi* phi = *iter;</span>
<span class="lineNum">    3046 </span><span class="lineCov">      11541 :             for (size_t i = 0, e = phi-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    3047 </span><span class="lineCov">       8219 :                 MOZ_ASSERT(phi-&gt;getOperand(i)-&gt;block()-&gt;dominates(block-&gt;getPredecessor(i)),</span>
<span class="lineNum">    3048 </span>            :                            &quot;Phi input is not dominated by its operand&quot;);
<span class="lineNum">    3049 </span>            :             }
<span class="lineNum">    3050 </span>            :         }
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span>            :         // Verify that instructions are dominated by their operands.
<span class="lineNum">    3053 </span><span class="lineCov">      37566 :         for (MInstructionIterator iter(block-&gt;begin()), end(block-&gt;end()); iter != end; ++iter) {</span>
<span class="lineNum">    3054 </span><span class="lineCov">      30086 :             MInstruction* ins = *iter;</span>
<span class="lineNum">    3055 </span><span class="lineCov">      53588 :             for (size_t i = 0, e = ins-&gt;numOperands(); i &lt; e; ++i) {</span>
<span class="lineNum">    3056 </span><span class="lineCov">      23502 :                 MDefinition* op = ins-&gt;getOperand(i);</span>
<span class="lineNum">    3057 </span><span class="lineCov">      23502 :                 MBasicBlock* opBlock = op-&gt;block();</span>
<span class="lineNum">    3058 </span><span class="lineCov">      23502 :                 MOZ_ASSERT(opBlock-&gt;dominates(*block),</span>
<span class="lineNum">    3059 </span>            :                            &quot;Instruction is not dominated by its operands&quot;);
<span class="lineNum">    3060 </span>            : 
<span class="lineNum">    3061 </span>            :                 // If the operand is an instruction in the same block, check
<span class="lineNum">    3062 </span>            :                 // that it comes first.
<span class="lineNum">    3063 </span><span class="lineCov">      23502 :                 if (opBlock == *block &amp;&amp; !op-&gt;isPhi()) {</span>
<span class="lineNum">    3064 </span><span class="lineCov">      13218 :                     MInstructionIterator opIter = block-&gt;begin(op-&gt;toInstruction());</span>
<span class="lineNum">    3065 </span><span class="lineCov">      54173 :                     do {</span>
<span class="lineNum">    3066 </span><span class="lineCov">      54173 :                         ++opIter;</span>
<span class="lineNum">    3067 </span><span class="lineCov">      54173 :                         MOZ_ASSERT(opIter != block-&gt;end(),</span>
<span class="lineNum">    3068 </span>            :                                    &quot;Operand in same block as instruction does not precede&quot;);
<span class="lineNum">    3069 </span><span class="lineCov">      54173 :                     } while (*opIter != ins);</span>
<span class="lineNum">    3070 </span>            :                 }
<span class="lineNum">    3071 </span>            :             }
<span class="lineNum">    3072 </span><span class="lineCov">      30086 :             AssertIfResumableInstruction(ins);</span>
<span class="lineNum">    3073 </span><span class="lineCov">      30086 :             if (MResumePoint* resume = ins-&gt;resumePoint()) {</span>
<span class="lineNum">    3074 </span><span class="lineCov">       5098 :                 AssertResumePointDominatedByOperands(resume);</span>
<span class="lineNum">    3075 </span><span class="lineCov">       5098 :                 AssertResumableOperands(resume);</span>
<span class="lineNum">    3076 </span>            :             }
<span class="lineNum">    3077 </span>            :         }
<span class="lineNum">    3078 </span>            : 
<span class="lineNum">    3079 </span>            :         // Verify that the block resume points are dominated by their operands.
<span class="lineNum">    3080 </span><span class="lineCov">       7480 :         if (MResumePoint* resume = block-&gt;entryResumePoint()) {</span>
<span class="lineNum">    3081 </span><span class="lineCov">       7480 :             AssertResumePointDominatedByOperands(resume);</span>
<span class="lineNum">    3082 </span><span class="lineCov">       7480 :             AssertResumableOperands(resume);</span>
<span class="lineNum">    3083 </span>            :         }
<span class="lineNum">    3084 </span><span class="lineCov">       7480 :         if (MResumePoint* resume = block-&gt;outerResumePoint()) {</span>
<span class="lineNum">    3085 </span><span class="lineCov">        373 :             AssertResumePointDominatedByOperands(resume);</span>
<span class="lineNum">    3086 </span><span class="lineCov">        373 :             AssertResumableOperands(resume);</span>
<span class="lineNum">    3087 </span>            :         }
<span class="lineNum">    3088 </span>            :     }
<span class="lineNum">    3089 </span>            : #endif
<span class="lineNum">    3090 </span>            : }
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span>            : 
<span class="lineNum">    3093 </span>            : struct BoundsCheckInfo
<span class="lineNum">    3094 </span>            : {
<span class="lineNum">    3095 </span>            :     MBoundsCheck* check;
<span class="lineNum">    3096 </span>            :     uint32_t validEnd;
<span class="lineNum">    3097 </span>            : };
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span>            : typedef HashMap&lt;uint32_t,
<span class="lineNum">    3100 </span>            :                 BoundsCheckInfo,
<span class="lineNum">    3101 </span>            :                 DefaultHasher&lt;uint32_t&gt;,
<span class="lineNum">    3102 </span>            :                 JitAllocPolicy&gt; BoundsCheckMap;
<span class="lineNum">    3103 </span>            : 
<a name="3104"><span class="lineNum">    3104 </span>            : // Compute a hash for bounds checks which ignores constant offsets in the index.</a>
<span class="lineNum">    3105 </span>            : static HashNumber
<span class="lineNum">    3106 </span><span class="lineCov">          1 : BoundsCheckHashIgnoreOffset(MBoundsCheck* check)</span>
<span class="lineNum">    3107 </span>            : {
<span class="lineNum">    3108 </span><span class="lineCov">          1 :     SimpleLinearSum indexSum = ExtractLinearSum(check-&gt;index());</span>
<span class="lineNum">    3109 </span><span class="lineCov">          1 :     uintptr_t index = indexSum.term ? uintptr_t(indexSum.term) : 0;</span>
<span class="lineNum">    3110 </span><span class="lineCov">          1 :     uintptr_t length = uintptr_t(check-&gt;length());</span>
<span class="lineNum">    3111 </span><span class="lineCov">          1 :     return index ^ length;</span>
<span class="lineNum">    3112 </span>            : }
<a name="3113"><span class="lineNum">    3113 </span>            : </a>
<span class="lineNum">    3114 </span>            : static MBoundsCheck*
<span class="lineNum">    3115 </span><span class="lineCov">          1 : FindDominatingBoundsCheck(BoundsCheckMap&amp; checks, MBoundsCheck* check, size_t index)</span>
<span class="lineNum">    3116 </span>            : {
<span class="lineNum">    3117 </span>            :     // Since we are traversing the dominator tree in pre-order, when we
<span class="lineNum">    3118 </span>            :     // are looking at the |index|-th block, the next numDominated() blocks
<span class="lineNum">    3119 </span>            :     // we traverse are precisely the set of blocks that are dominated.
<span class="lineNum">    3120 </span>            :     //
<span class="lineNum">    3121 </span>            :     // So, this value is visible in all blocks if:
<span class="lineNum">    3122 </span>            :     // index &lt;= index + ins-&gt;block-&gt;numDominated()
<span class="lineNum">    3123 </span>            :     // and becomes invalid after that.
<span class="lineNum">    3124 </span><span class="lineCov">          1 :     HashNumber hash = BoundsCheckHashIgnoreOffset(check);</span>
<span class="lineNum">    3125 </span><span class="lineCov">          1 :     BoundsCheckMap::Ptr p = checks.lookup(hash);</span>
<span class="lineNum">    3126 </span><span class="lineCov">          1 :     if (!p || index &gt;= p-&gt;value().validEnd) {</span>
<span class="lineNum">    3127 </span>            :         // We didn't find a dominating bounds check.
<span class="lineNum">    3128 </span>            :         BoundsCheckInfo info;
<span class="lineNum">    3129 </span><span class="lineCov">          1 :         info.check = check;</span>
<span class="lineNum">    3130 </span><span class="lineCov">          1 :         info.validEnd = index + check-&gt;block()-&gt;numDominated();</span>
<span class="lineNum">    3131 </span>            : 
<span class="lineNum">    3132 </span><span class="lineCov">          1 :         if(!checks.put(hash, info))</span>
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :             return nullptr;</span>
<span class="lineNum">    3134 </span>            : 
<span class="lineNum">    3135 </span><span class="lineCov">          1 :         return check;</span>
<span class="lineNum">    3136 </span>            :     }
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span><span class="lineNoCov">          0 :     return p-&gt;value().check;</span>
<span class="lineNum">    3139 </span>            : }
<a name="3140"><span class="lineNum">    3140 </span>            : </a>
<span class="lineNum">    3141 </span>            : static MathSpace
<span class="lineNum">    3142 </span><span class="lineCov">         14 : ExtractMathSpace(MDefinition* ins)</span>
<span class="lineNum">    3143 </span>            : {
<span class="lineNum">    3144 </span><span class="lineCov">         14 :     MOZ_ASSERT(ins-&gt;isAdd() || ins-&gt;isSub());</span>
<span class="lineNum">    3145 </span><span class="lineCov">         14 :     MBinaryArithInstruction* arith = nullptr;</span>
<span class="lineNum">    3146 </span><span class="lineCov">         14 :     if (ins-&gt;isAdd())</span>
<span class="lineNum">    3147 </span><span class="lineCov">         14 :         arith = ins-&gt;toAdd();</span>
<span class="lineNum">    3148 </span>            :     else
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :         arith = ins-&gt;toSub();</span>
<span class="lineNum">    3150 </span><span class="lineCov">         14 :     switch (arith-&gt;truncateKind()) {</span>
<span class="lineNum">    3151 </span>            :       case MDefinition::NoTruncate:
<span class="lineNum">    3152 </span>            :       case MDefinition::TruncateAfterBailouts:
<span class="lineNum">    3153 </span>            :         // TruncateAfterBailouts is considered as infinite space because the
<span class="lineNum">    3154 </span>            :         // LinearSum will effectively remove the bailout check.
<span class="lineNum">    3155 </span><span class="lineCov">         13 :         return MathSpace::Infinite;</span>
<span class="lineNum">    3156 </span>            :       case MDefinition::IndirectTruncate:
<span class="lineNum">    3157 </span>            :       case MDefinition::Truncate:
<span class="lineNum">    3158 </span><span class="lineCov">          1 :         return MathSpace::Modulo;</span>
<span class="lineNum">    3159 </span>            :     }
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :     MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE(&quot;Unknown TruncateKind&quot;);</span>
<span class="lineNum">    3161 </span>            : }
<span class="lineNum">    3162 </span>            : 
<a name="3163"><span class="lineNum">    3163 </span>            : // Extract a linear sum from ins, if possible (otherwise giving the sum 'ins + 0').</a>
<span class="lineNum">    3164 </span>            : SimpleLinearSum
<span class="lineNum">    3165 </span><span class="lineCov">         74 : jit::ExtractLinearSum(MDefinition* ins, MathSpace space)</span>
<span class="lineNum">    3166 </span>            : {
<span class="lineNum">    3167 </span><span class="lineCov">         74 :     if (ins-&gt;isBeta())</span>
<span class="lineNum">    3168 </span><span class="lineCov">          8 :         ins = ins-&gt;getOperand(0);</span>
<span class="lineNum">    3169 </span>            : 
<span class="lineNum">    3170 </span><span class="lineCov">         74 :     if (ins-&gt;type() != MIRType::Int32)</span>
<span class="lineNum">    3171 </span><span class="lineCov">         16 :         return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3172 </span>            : 
<span class="lineNum">    3173 </span><span class="lineCov">         58 :     if (ins-&gt;isConstant())</span>
<span class="lineNum">    3174 </span><span class="lineCov">         16 :         return SimpleLinearSum(nullptr, ins-&gt;toConstant()-&gt;toInt32());</span>
<span class="lineNum">    3175 </span>            : 
<span class="lineNum">    3176 </span><span class="lineCov">         42 :     if (!ins-&gt;isAdd() &amp;&amp; !ins-&gt;isSub())</span>
<span class="lineNum">    3177 </span><span class="lineCov">         28 :         return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3178 </span>            : 
<span class="lineNum">    3179 </span>            :     // Only allow math which are in the same space.
<span class="lineNum">    3180 </span><span class="lineCov">         14 :     MathSpace insSpace = ExtractMathSpace(ins);</span>
<span class="lineNum">    3181 </span><span class="lineCov">         14 :     if (space == MathSpace::Unknown)</span>
<span class="lineNum">    3182 </span><span class="lineCov">         14 :         space = insSpace;</span>
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :     else if (space != insSpace)</span>
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :         return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3185 </span><span class="lineCov">         14 :     MOZ_ASSERT(space == MathSpace::Modulo || space == MathSpace::Infinite);</span>
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span><span class="lineCov">         14 :     MDefinition* lhs = ins-&gt;getOperand(0);</span>
<span class="lineNum">    3188 </span><span class="lineCov">         14 :     MDefinition* rhs = ins-&gt;getOperand(1);</span>
<span class="lineNum">    3189 </span><span class="lineCov">         14 :     if (lhs-&gt;type() != MIRType::Int32 || rhs-&gt;type() != MIRType::Int32)</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :         return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3191 </span>            : 
<span class="lineNum">    3192 </span>            :     // Extract linear sums of each operand.
<span class="lineNum">    3193 </span><span class="lineCov">         14 :     SimpleLinearSum lsum = ExtractLinearSum(lhs, space);</span>
<span class="lineNum">    3194 </span><span class="lineCov">         14 :     SimpleLinearSum rsum = ExtractLinearSum(rhs, space);</span>
<span class="lineNum">    3195 </span>            : 
<span class="lineNum">    3196 </span>            :     // LinearSum only considers a single term operand, if both sides have
<span class="lineNum">    3197 </span>            :     // terms, then ignore extracted linear sums.
<span class="lineNum">    3198 </span><span class="lineCov">         14 :     if (lsum.term &amp;&amp; rsum.term)</span>
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 :         return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span>            :     // Check if this is of the form &lt;SUM&gt; + n or n + &lt;SUM&gt;.
<span class="lineNum">    3202 </span><span class="lineCov">         14 :     if (ins-&gt;isAdd()) {</span>
<span class="lineNum">    3203 </span>            :         int32_t constant;
<span class="lineNum">    3204 </span><span class="lineCov">         14 :         if (space == MathSpace::Modulo)</span>
<span class="lineNum">    3205 </span><span class="lineCov">          1 :             constant = lsum.constant + rsum.constant;</span>
<span class="lineNum">    3206 </span><span class="lineCov">         13 :         else if (!SafeAdd(lsum.constant, rsum.constant, &amp;constant))</span>
<span class="lineNum">    3207 </span><span class="lineNoCov">          0 :             return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3208 </span><span class="lineCov">         14 :         return SimpleLinearSum(lsum.term ? lsum.term : rsum.term, constant);</span>
<span class="lineNum">    3209 </span>            :     }
<span class="lineNum">    3210 </span>            : 
<span class="lineNum">    3211 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(ins-&gt;isSub());</span>
<span class="lineNum">    3212 </span>            :     // Check if this is of the form &lt;SUM&gt; - n.
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :     if (lsum.term) {</span>
<span class="lineNum">    3214 </span>            :         int32_t constant;
<span class="lineNum">    3215 </span><span class="lineNoCov">          0 :         if (space == MathSpace::Modulo)</span>
<span class="lineNum">    3216 </span><span class="lineNoCov">          0 :             constant = lsum.constant - rsum.constant;</span>
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 :         else if (!SafeSub(lsum.constant, rsum.constant, &amp;constant))</span>
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :             return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :         return SimpleLinearSum(lsum.term, constant);</span>
<span class="lineNum">    3220 </span>            :     }
<span class="lineNum">    3221 </span>            : 
<span class="lineNum">    3222 </span>            :     // Ignore any of the form n - &lt;SUM&gt;.
<span class="lineNum">    3223 </span><span class="lineNoCov">          0 :     return SimpleLinearSum(ins, 0);</span>
<span class="lineNum">    3224 </span>            : }
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span>            : // Extract a linear inequality holding when a boolean test goes in the
<a name="3227"><span class="lineNum">    3227 </span>            : // specified direction, of the form 'lhs + lhsN &lt;= rhs' (or &gt;=).</a>
<span class="lineNum">    3228 </span>            : bool
<span class="lineNum">    3229 </span><span class="lineCov">         11 : jit::ExtractLinearInequality(MTest* test, BranchDirection direction,</span>
<span class="lineNum">    3230 </span>            :                              SimpleLinearSum* plhs, MDefinition** prhs, bool* plessEqual)
<span class="lineNum">    3231 </span>            : {
<span class="lineNum">    3232 </span><span class="lineCov">         11 :     if (!test-&gt;getOperand(0)-&gt;isCompare())</span>
<span class="lineNum">    3233 </span><span class="lineCov">          5 :         return false;</span>
<span class="lineNum">    3234 </span>            : 
<span class="lineNum">    3235 </span><span class="lineCov">          6 :     MCompare* compare = test-&gt;getOperand(0)-&gt;toCompare();</span>
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span><span class="lineCov">          6 :     MDefinition* lhs = compare-&gt;getOperand(0);</span>
<span class="lineNum">    3238 </span><span class="lineCov">          6 :     MDefinition* rhs = compare-&gt;getOperand(1);</span>
<span class="lineNum">    3239 </span>            : 
<span class="lineNum">    3240 </span>            :     // TODO: optimize Compare_UInt32
<span class="lineNum">    3241 </span><span class="lineCov">          6 :     if (!compare-&gt;isInt32Comparison())</span>
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3243 </span>            : 
<span class="lineNum">    3244 </span><span class="lineCov">          6 :     MOZ_ASSERT(lhs-&gt;type() == MIRType::Int32);</span>
<span class="lineNum">    3245 </span><span class="lineCov">          6 :     MOZ_ASSERT(rhs-&gt;type() == MIRType::Int32);</span>
<span class="lineNum">    3246 </span>            : 
<span class="lineNum">    3247 </span><span class="lineCov">          6 :     JSOp jsop = compare-&gt;jsop();</span>
<span class="lineNum">    3248 </span><span class="lineCov">          6 :     if (direction == FALSE_BRANCH)</span>
<span class="lineNum">    3249 </span><span class="lineCov">          4 :         jsop = NegateCompareOp(jsop);</span>
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">          6 :     SimpleLinearSum lsum = ExtractLinearSum(lhs);</span>
<span class="lineNum">    3252 </span><span class="lineCov">          6 :     SimpleLinearSum rsum = ExtractLinearSum(rhs);</span>
<span class="lineNum">    3253 </span>            : 
<span class="lineNum">    3254 </span><span class="lineCov">          6 :     if (!SafeSub(lsum.constant, rsum.constant, &amp;lsum.constant))</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3256 </span>            : 
<span class="lineNum">    3257 </span>            :     // Normalize operations to use &lt;= or &gt;=.
<span class="lineNum">    3258 </span><span class="lineCov">          6 :     switch (jsop) {</span>
<span class="lineNum">    3259 </span>            :       case JSOP_LE:
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :         *plessEqual = true;</span>
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3262 </span>            :       case JSOP_LT:
<span class="lineNum">    3263 </span>            :         /* x &lt; y ==&gt; x + 1 &lt;= y */
<span class="lineNum">    3264 </span><span class="lineNoCov">          0 :         if (!SafeAdd(lsum.constant, 1, &amp;lsum.constant))</span>
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 :         *plessEqual = true;</span>
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3268 </span>            :       case JSOP_GE:
<span class="lineNum">    3269 </span><span class="lineCov">          4 :         *plessEqual = false;</span>
<span class="lineNum">    3270 </span><span class="lineCov">          4 :         break;</span>
<span class="lineNum">    3271 </span>            :       case JSOP_GT:
<span class="lineNum">    3272 </span>            :         /* x &gt; y ==&gt; x - 1 &gt;= y */
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :         if (!SafeSub(lsum.constant, 1, &amp;lsum.constant))</span>
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :         *plessEqual = false;</span>
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3277 </span>            :       default:
<span class="lineNum">    3278 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    3279 </span>            :     }
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span><span class="lineCov">          4 :     *plhs = lsum;</span>
<span class="lineNum">    3282 </span><span class="lineCov">          4 :     *prhs = rsum.term;</span>
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span><span class="lineCov">          4 :     return true;</span>
<span class="lineNum">    3285 </span>            : }
<a name="3286"><span class="lineNum">    3286 </span>            : </a>
<span class="lineNum">    3287 </span>            : static bool
<span class="lineNum">    3288 </span><span class="lineCov">          2 : TryEliminateBoundsCheck(BoundsCheckMap&amp; checks, size_t blockIndex, MBoundsCheck* dominated, bool* eliminated)</span>
<span class="lineNum">    3289 </span>            : {
<span class="lineNum">    3290 </span><span class="lineCov">          2 :     MOZ_ASSERT(!*eliminated);</span>
<span class="lineNum">    3291 </span>            : 
<span class="lineNum">    3292 </span>            :     // Replace all uses of the bounds check with the actual index.
<span class="lineNum">    3293 </span>            :     // This is (a) necessary, because we can coalesce two different
<span class="lineNum">    3294 </span>            :     // bounds checks and would otherwise use the wrong index and
<span class="lineNum">    3295 </span>            :     // (b) helps register allocation. Note that this is safe since
<span class="lineNum">    3296 </span>            :     // no other pass after bounds check elimination moves instructions.
<span class="lineNum">    3297 </span><span class="lineCov">          2 :     dominated-&gt;replaceAllUsesWith(dominated-&gt;index());</span>
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span><span class="lineCov">          2 :     if (!dominated-&gt;isMovable())</span>
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span><span class="lineCov">          2 :     if (!dominated-&gt;fallible())</span>
<span class="lineNum">    3303 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span><span class="lineCov">          1 :     MBoundsCheck* dominating = FindDominatingBoundsCheck(checks, dominated, blockIndex);</span>
<span class="lineNum">    3306 </span><span class="lineCov">          1 :     if (!dominating)</span>
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span><span class="lineCov">          1 :     if (dominating == dominated) {</span>
<span class="lineNum">    3310 </span>            :         // We didn't find a dominating bounds check.
<span class="lineNum">    3311 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    3312 </span>            :     }
<span class="lineNum">    3313 </span>            : 
<span class="lineNum">    3314 </span>            :     // We found two bounds checks with the same hash number, but we still have
<span class="lineNum">    3315 </span>            :     // to make sure the lengths and index terms are equal.
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :     if (dominating-&gt;length() != dominated-&gt;length())</span>
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :     SimpleLinearSum sumA = ExtractLinearSum(dominating-&gt;index());</span>
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :     SimpleLinearSum sumB = ExtractLinearSum(dominated-&gt;index());</span>
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span>            :     // Both terms should be nullptr or the same definition.
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :     if (sumA.term != sumB.term)</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span>            :     // This bounds check is redundant.
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :     *eliminated = true;</span>
<span class="lineNum">    3328 </span>            : 
<span class="lineNum">    3329 </span>            :     // Normalize the ranges according to the constant offsets in the two indexes.
<span class="lineNum">    3330 </span>            :     int32_t minimumA, maximumA, minimumB, maximumB;
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 :     if (!SafeAdd(sumA.constant, dominating-&gt;minimum(), &amp;minimumA) ||</span>
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :         !SafeAdd(sumA.constant, dominating-&gt;maximum(), &amp;maximumA) ||</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :         !SafeAdd(sumB.constant, dominated-&gt;minimum(), &amp;minimumB) ||</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :         !SafeAdd(sumB.constant, dominated-&gt;maximum(), &amp;maximumB))</span>
<span class="lineNum">    3335 </span>            :     {
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3337 </span>            :     }
<span class="lineNum">    3338 </span>            : 
<span class="lineNum">    3339 </span>            :     // Update the dominating check to cover both ranges, denormalizing the
<span class="lineNum">    3340 </span>            :     // result per the constant offset in the index.
<span class="lineNum">    3341 </span>            :     int32_t newMinimum, newMaximum;
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :     if (!SafeSub(Min(minimumA, minimumB), sumA.constant, &amp;newMinimum) ||</span>
<span class="lineNum">    3343 </span><span class="lineNoCov">          0 :         !SafeSub(Max(maximumA, maximumB), sumA.constant, &amp;newMaximum))</span>
<span class="lineNum">    3344 </span>            :     {
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3346 </span>            :     }
<span class="lineNum">    3347 </span>            : 
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :     dominating-&gt;setMinimum(newMinimum);</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :     dominating-&gt;setMaximum(newMaximum);</span>
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3351 </span>            : }
<a name="3352"><span class="lineNum">    3352 </span>            : </a>
<span class="lineNum">    3353 </span>            : static void
<span class="lineNum">    3354 </span><span class="lineCov">          2 : TryEliminateTypeBarrierFromTest(MTypeBarrier* barrier, bool filtersNull, bool filtersUndefined,</span>
<span class="lineNum">    3355 </span>            :                                 MTest* test, BranchDirection direction, bool* eliminated)
<span class="lineNum">    3356 </span>            : {
<span class="lineNum">    3357 </span><span class="lineCov">          2 :     MOZ_ASSERT(filtersNull || filtersUndefined);</span>
<span class="lineNum">    3358 </span>            : 
<span class="lineNum">    3359 </span>            :     // Watch for code patterns similar to 'if (x.f) { ... = x.f }'.  If x.f
<span class="lineNum">    3360 </span>            :     // is either an object or null/undefined, there will be a type barrier on
<span class="lineNum">    3361 </span>            :     // the latter read as the null/undefined value is never realized there.
<span class="lineNum">    3362 </span>            :     // The type barrier can be eliminated, however, by looking at tests
<span class="lineNum">    3363 </span>            :     // performed on the result of the first operation that filter out all
<span class="lineNum">    3364 </span>            :     // types that have been seen in the first access but not the second.
<span class="lineNum">    3365 </span>            : 
<span class="lineNum">    3366 </span>            :     // A test 'if (x.f)' filters both null and undefined.
<span class="lineNum">    3367 </span>            : 
<span class="lineNum">    3368 </span>            :     // Disregard the possible unbox added before the Typebarrier for checking.
<span class="lineNum">    3369 </span><span class="lineCov">          2 :     MDefinition* input = barrier-&gt;input();</span>
<span class="lineNum">    3370 </span><span class="lineCov">          2 :     MUnbox* inputUnbox = nullptr;</span>
<span class="lineNum">    3371 </span><span class="lineCov">          2 :     if (input-&gt;isUnbox() &amp;&amp; input-&gt;toUnbox()-&gt;mode() != MUnbox::Fallible) {</span>
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :         inputUnbox = input-&gt;toUnbox();</span>
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 :         input = inputUnbox-&gt;input();</span>
<span class="lineNum">    3374 </span>            :     }
<span class="lineNum">    3375 </span>            : 
<span class="lineNum">    3376 </span><span class="lineCov">          2 :     MDefinition* subject = nullptr;</span>
<span class="lineNum">    3377 </span>            :     bool removeUndefined;
<span class="lineNum">    3378 </span>            :     bool removeNull;
<span class="lineNum">    3379 </span><span class="lineCov">          2 :     test-&gt;filtersUndefinedOrNull(direction == TRUE_BRANCH, &amp;subject, &amp;removeUndefined, &amp;removeNull);</span>
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span>            :     // The Test doesn't filter undefined nor null.
<span class="lineNum">    3382 </span><span class="lineCov">          2 :     if (!subject)</span>
<span class="lineNum">    3383 </span><span class="lineCov">          4 :         return;</span>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span>            :     // Make sure the subject equals the input to the TypeBarrier.
<span class="lineNum">    3386 </span><span class="lineNoCov">          0 :     if (subject != input)</span>
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3388 </span>            : 
<span class="lineNum">    3389 </span>            :     // When the TypeBarrier filters undefined, the test must at least also do,
<span class="lineNum">    3390 </span>            :     // this, before the TypeBarrier can get removed.
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 :     if (!removeUndefined &amp;&amp; filtersUndefined)</span>
<span class="lineNum">    3392 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span>            :     // When the TypeBarrier filters null, the test must at least also do,
<span class="lineNum">    3395 </span>            :     // this, before the TypeBarrier can get removed.
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :     if (!removeNull &amp;&amp; filtersNull)</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3398 </span>            : 
<span class="lineNum">    3399 </span>            :     // Eliminate the TypeBarrier. The possible TypeBarrier unboxing is kept,
<span class="lineNum">    3400 </span>            :     // but made infallible.
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :     *eliminated = true;</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :     if (inputUnbox)</span>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :         inputUnbox-&gt;makeInfallible();</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :     barrier-&gt;replaceAllUsesWith(barrier-&gt;input());</span>
<span class="lineNum">    3405 </span>            : }
<a name="3406"><span class="lineNum">    3406 </span>            : </a>
<span class="lineNum">    3407 </span>            : static bool
<span class="lineNum">    3408 </span><span class="lineCov">        127 : TryEliminateTypeBarrier(MTypeBarrier* barrier, bool* eliminated)</span>
<span class="lineNum">    3409 </span>            : {
<span class="lineNum">    3410 </span><span class="lineCov">        127 :     MOZ_ASSERT(!*eliminated);</span>
<span class="lineNum">    3411 </span>            : 
<span class="lineNum">    3412 </span><span class="lineCov">        127 :     const TemporaryTypeSet* barrierTypes = barrier-&gt;resultTypeSet();</span>
<span class="lineNum">    3413 </span><span class="lineCov">        127 :     const TemporaryTypeSet* inputTypes = barrier-&gt;input()-&gt;resultTypeSet();</span>
<span class="lineNum">    3414 </span>            : 
<span class="lineNum">    3415 </span>            :     // Disregard the possible unbox added before the Typebarrier.
<span class="lineNum">    3416 </span><span class="lineCov">        127 :     if (barrier-&gt;input()-&gt;isUnbox() &amp;&amp; barrier-&gt;input()-&gt;toUnbox()-&gt;mode() != MUnbox::Fallible)</span>
<span class="lineNum">    3417 </span><span class="lineCov">         75 :         inputTypes = barrier-&gt;input()-&gt;toUnbox()-&gt;input()-&gt;resultTypeSet();</span>
<span class="lineNum">    3418 </span>            : 
<span class="lineNum">    3419 </span><span class="lineCov">        127 :     if (!barrierTypes || !inputTypes)</span>
<span class="lineNum">    3420 </span><span class="lineCov">        126 :         return true;</span>
<span class="lineNum">    3421 </span>            : 
<span class="lineNum">    3422 </span><span class="lineCov">          1 :     bool filtersNull = barrierTypes-&gt;filtersType(inputTypes, TypeSet::NullType());</span>
<span class="lineNum">    3423 </span><span class="lineCov">          1 :     bool filtersUndefined = barrierTypes-&gt;filtersType(inputTypes, TypeSet::UndefinedType());</span>
<span class="lineNum">    3424 </span>            : 
<span class="lineNum">    3425 </span><span class="lineCov">          1 :     if (!filtersNull &amp;&amp; !filtersUndefined)</span>
<span class="lineNum">    3426 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3427 </span>            : 
<span class="lineNum">    3428 </span><span class="lineCov">          1 :     MBasicBlock* block = barrier-&gt;block();</span>
<span class="lineNum">    3429 </span>            :     while (true) {
<span class="lineNum">    3430 </span>            :         BranchDirection direction;
<span class="lineNum">    3431 </span><span class="lineCov">         27 :         MTest* test = block-&gt;immediateDominatorBranch(&amp;direction);</span>
<span class="lineNum">    3432 </span>            : 
<span class="lineNum">    3433 </span><span class="lineCov">         27 :         if (test) {</span>
<span class="lineNum">    3434 </span><span class="lineCov">          2 :             TryEliminateTypeBarrierFromTest(barrier, filtersNull, filtersUndefined,</span>
<span class="lineNum">    3435 </span><span class="lineCov">          4 :                                             test, direction, eliminated);</span>
<span class="lineNum">    3436 </span>            :         }
<span class="lineNum">    3437 </span>            : 
<span class="lineNum">    3438 </span><span class="lineCov">         27 :         MBasicBlock* previous = block-&gt;immediateDominator();</span>
<span class="lineNum">    3439 </span><span class="lineCov">         27 :         if (previous == block)</span>
<span class="lineNum">    3440 </span><span class="lineCov">          1 :             break;</span>
<span class="lineNum">    3441 </span><span class="lineCov">         26 :         block = previous;</span>
<span class="lineNum">    3442 </span><span class="lineCov">         26 :     }</span>
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    3445 </span>            : }
<a name="3446"><span class="lineNum">    3446 </span>            : </a>
<span class="lineNum">    3447 </span>            : static bool
<span class="lineNum">    3448 </span><span class="lineCov">         41 : TryOptimizeLoadObjectOrNull(MDefinition* def, MDefinitionVector* peliminateList)</span>
<span class="lineNum">    3449 </span>            : {
<span class="lineNum">    3450 </span><span class="lineCov">         41 :     if (def-&gt;type() != MIRType::Value)</span>
<span class="lineNum">    3451 </span><span class="lineCov">         12 :         return true;</span>
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span>            :     // Check if this definition can only produce object or null values.
<span class="lineNum">    3454 </span><span class="lineCov">         29 :     TemporaryTypeSet* types = def-&gt;resultTypeSet();</span>
<span class="lineNum">    3455 </span><span class="lineCov">         29 :     if (!types)</span>
<span class="lineNum">    3456 </span><span class="lineCov">         29 :         return true;</span>
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :     if (types-&gt;baseFlags() &amp; ~(TYPE_FLAG_NULL | TYPE_FLAG_ANYOBJECT))</span>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3459 </span>            : 
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 :     MDefinitionVector eliminateList(def-&gt;block()-&gt;graph().alloc());</span>
<span class="lineNum">    3461 </span>            : 
<span class="lineNum">    3462 </span><span class="lineNoCov">          0 :     for (MUseDefIterator iter(def); iter; ++iter) {</span>
<span class="lineNum">    3463 </span><span class="lineNoCov">          0 :         MDefinition* ndef = iter.def();</span>
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :         switch (ndef-&gt;op()) {</span>
<span class="lineNum">    3465 </span>            :           case MDefinition::Op_Compare:
<span class="lineNum">    3466 </span><span class="lineNoCov">          0 :             if (ndef-&gt;toCompare()-&gt;compareType() != MCompare::Compare_Null)</span>
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3468 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3469 </span>            :           case MDefinition::Op_Test:
<span class="lineNum">    3470 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3471 </span>            :           case MDefinition::Op_PostWriteBarrier:
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3473 </span>            :           case MDefinition::Op_StoreFixedSlot:
<span class="lineNum">    3474 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3475 </span>            :           case MDefinition::Op_StoreSlot:
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3477 </span>            :           case MDefinition::Op_ToObjectOrNull:
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :             if (!eliminateList.append(ndef-&gt;toToObjectOrNull()))</span>
<span class="lineNum">    3479 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3481 </span>            :           case MDefinition::Op_Unbox:
<span class="lineNum">    3482 </span><span class="lineNoCov">          0 :             if (ndef-&gt;type() != MIRType::Object)</span>
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3484 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3485 </span>            :           case MDefinition::Op_TypeBarrier:
<span class="lineNum">    3486 </span>            :             // For now, only handle type barriers which are not consumed
<span class="lineNum">    3487 </span>            :             // anywhere and only test that the value is null.
<span class="lineNum">    3488 </span><span class="lineNoCov">          0 :             if (ndef-&gt;hasUses() || ndef-&gt;resultTypeSet()-&gt;getKnownMIRType() != MIRType::Null)</span>
<span class="lineNum">    3489 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3490 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3491 </span>            :           default:
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    3493 </span>            :         }
<span class="lineNum">    3494 </span>            :     }
<span class="lineNum">    3495 </span>            : 
<span class="lineNum">    3496 </span>            :     // On punboxing systems we are better off leaving the value boxed if it
<span class="lineNum">    3497 </span>            :     // is only stored back to the heap.
<span class="lineNum">    3498 </span>            : #ifdef JS_PUNBOX64
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :     bool foundUse = false;</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :     for (MUseDefIterator iter(def); iter; ++iter) {</span>
<span class="lineNum">    3501 </span><span class="lineNoCov">          0 :         MDefinition* ndef = iter.def();</span>
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :         if (!ndef-&gt;isStoreFixedSlot() &amp;&amp; !ndef-&gt;isStoreSlot()) {</span>
<span class="lineNum">    3503 </span><span class="lineNoCov">          0 :             foundUse = true;</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3505 </span>            :         }
<span class="lineNum">    3506 </span>            :     }
<span class="lineNum">    3507 </span><span class="lineNoCov">          0 :     if (!foundUse)</span>
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3509 </span>            : #endif // JS_PUNBOX64
<span class="lineNum">    3510 </span>            : 
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :     def-&gt;setResultType(MIRType::ObjectOrNull);</span>
<span class="lineNum">    3512 </span>            : 
<span class="lineNum">    3513 </span>            :     // Fixup the result type of MTypeBarrier uses.
<span class="lineNum">    3514 </span><span class="lineNoCov">          0 :     for (MUseDefIterator iter(def); iter; ++iter) {</span>
<span class="lineNum">    3515 </span><span class="lineNoCov">          0 :         MDefinition* ndef = iter.def();</span>
<span class="lineNum">    3516 </span><span class="lineNoCov">          0 :         if (ndef-&gt;isTypeBarrier())</span>
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :             ndef-&gt;setResultType(MIRType::ObjectOrNull);</span>
<span class="lineNum">    3518 </span>            :     }
<span class="lineNum">    3519 </span>            : 
<span class="lineNum">    3520 </span>            :     // Eliminate MToObjectOrNull instruction uses.
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; eliminateList.length(); i++) {</span>
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :         MDefinition* ndef = eliminateList[i];</span>
<span class="lineNum">    3523 </span><span class="lineNoCov">          0 :         ndef-&gt;replaceAllUsesWith(def);</span>
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :         if (!peliminateList-&gt;append(ndef))</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3526 </span>            :     }
<span class="lineNum">    3527 </span>            : 
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3529 </span>            : }
<a name="3530"><span class="lineNum">    3530 </span>            : </a>
<span class="lineNum">    3531 </span>            : static inline MDefinition*
<span class="lineNum">    3532 </span><span class="lineCov">       1074 : PassthroughOperand(MDefinition* def)</span>
<span class="lineNum">    3533 </span>            : {
<span class="lineNum">    3534 </span><span class="lineCov">       1074 :     if (def-&gt;isConvertElementsToDoubles())</span>
<span class="lineNum">    3535 </span><span class="lineNoCov">          0 :         return def-&gt;toConvertElementsToDoubles()-&gt;elements();</span>
<span class="lineNum">    3536 </span><span class="lineCov">       1074 :     if (def-&gt;isMaybeCopyElementsForWrite())</span>
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 :         return def-&gt;toMaybeCopyElementsForWrite()-&gt;object();</span>
<span class="lineNum">    3538 </span><span class="lineCov">       1074 :     if (def-&gt;isConvertUnboxedObjectToNative())</span>
<span class="lineNum">    3539 </span><span class="lineNoCov">          0 :         return def-&gt;toConvertUnboxedObjectToNative()-&gt;object();</span>
<span class="lineNum">    3540 </span><span class="lineCov">       1074 :     return nullptr;</span>
<span class="lineNum">    3541 </span>            : }
<span class="lineNum">    3542 </span>            : 
<span class="lineNum">    3543 </span>            : // Eliminate checks which are redundant given each other or other instructions.
<span class="lineNum">    3544 </span>            : //
<span class="lineNum">    3545 </span>            : // A type barrier is considered redundant if all missing types have been tested
<span class="lineNum">    3546 </span>            : // for by earlier control instructions.
<span class="lineNum">    3547 </span>            : //
<span class="lineNum">    3548 </span>            : // A bounds check is considered redundant if it's dominated by another bounds
<span class="lineNum">    3549 </span>            : // check with the same length and the indexes differ by only a constant amount.
<span class="lineNum">    3550 </span>            : // In this case we eliminate the redundant bounds check and update the other one
<span class="lineNum">    3551 </span>            : // to cover the ranges of both checks.
<span class="lineNum">    3552 </span>            : //
<span class="lineNum">    3553 </span>            : // Bounds checks are added to a hash map and since the hash function ignores
<span class="lineNum">    3554 </span>            : // differences in constant offset, this offers a fast way to find redundant
<a name="3555"><span class="lineNum">    3555 </span>            : // checks.</a>
<span class="lineNum">    3556 </span>            : bool
<span class="lineNum">    3557 </span><span class="lineCov">          8 : jit::EliminateRedundantChecks(MIRGraph&amp; graph)</span>
<span class="lineNum">    3558 </span>            : {
<span class="lineNum">    3559 </span><span class="lineCov">         16 :     BoundsCheckMap checks(graph.alloc());</span>
<span class="lineNum">    3560 </span>            : 
<span class="lineNum">    3561 </span><span class="lineCov">          8 :     if (!checks.init())</span>
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3563 </span>            : 
<span class="lineNum">    3564 </span>            :     // Stack for pre-order CFG traversal.
<span class="lineNum">    3565 </span><span class="lineCov">         16 :     Vector&lt;MBasicBlock*, 1, JitAllocPolicy&gt; worklist(graph.alloc());</span>
<span class="lineNum">    3566 </span>            : 
<span class="lineNum">    3567 </span>            :     // The index of the current block in the CFG traversal.
<span class="lineNum">    3568 </span><span class="lineCov">          8 :     size_t index = 0;</span>
<span class="lineNum">    3569 </span>            : 
<span class="lineNum">    3570 </span>            :     // Add all self-dominating blocks to the worklist.
<span class="lineNum">    3571 </span>            :     // This includes all roots. Order does not matter.
<span class="lineNum">    3572 </span><span class="lineCov">        411 :     for (MBasicBlockIterator i(graph.begin()); i != graph.end(); i++) {</span>
<span class="lineNum">    3573 </span><span class="lineCov">        403 :         MBasicBlock* block = *i;</span>
<span class="lineNum">    3574 </span><span class="lineCov">        403 :         if (block-&gt;immediateDominator() == block) {</span>
<span class="lineNum">    3575 </span><span class="lineCov">         14 :             if (!worklist.append(block))</span>
<span class="lineNum">    3576 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3577 </span>            :         }
<span class="lineNum">    3578 </span>            :     }
<span class="lineNum">    3579 </span>            : 
<span class="lineNum">    3580 </span><span class="lineCov">         16 :     MDefinitionVector eliminateList(graph.alloc());</span>
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span>            :     // Starting from each self-dominating block, traverse the CFG in pre-order.
<span class="lineNum">    3583 </span><span class="lineCov">        814 :     while (!worklist.empty()) {</span>
<span class="lineNum">    3584 </span><span class="lineCov">        403 :         MBasicBlock* block = worklist.popCopy();</span>
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span>            :         // Add all immediate dominators to the front of the worklist.
<span class="lineNum">    3587 </span><span class="lineCov">        403 :         if (!worklist.append(block-&gt;immediatelyDominatedBlocksBegin(),</span>
<span class="lineNum">    3588 </span><span class="lineCov">        403 :                              block-&gt;immediatelyDominatedBlocksEnd())) {</span>
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3590 </span>            :         }
<span class="lineNum">    3591 </span>            : 
<span class="lineNum">    3592 </span><span class="lineCov">       1647 :         for (MDefinitionIterator iter(block); iter; ) {</span>
<span class="lineNum">    3593 </span><span class="lineCov">       1244 :             MDefinition* def = *iter++;</span>
<span class="lineNum">    3594 </span>            : 
<span class="lineNum">    3595 </span><span class="lineCov">       1244 :             bool eliminated = false;</span>
<span class="lineNum">    3596 </span>            : 
<span class="lineNum">    3597 </span><span class="lineCov">       1244 :             switch (def-&gt;op()) {</span>
<span class="lineNum">    3598 </span>            :               case MDefinition::Op_BoundsCheck:
<span class="lineNum">    3599 </span><span class="lineCov">          2 :                 if (!TryEliminateBoundsCheck(checks, index, def-&gt;toBoundsCheck(), &amp;eliminated))</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    3601 </span><span class="lineCov">          2 :                 break;</span>
<span class="lineNum">    3602 </span>            :               case MDefinition::Op_TypeBarrier:
<span class="lineNum">    3603 </span><span class="lineCov">        127 :                 if (!TryEliminateTypeBarrier(def-&gt;toTypeBarrier(), &amp;eliminated))</span>
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    3605 </span><span class="lineCov">        127 :                 break;</span>
<span class="lineNum">    3606 </span>            :               case MDefinition::Op_LoadFixedSlot:
<span class="lineNum">    3607 </span>            :               case MDefinition::Op_LoadSlot:
<span class="lineNum">    3608 </span>            :               case MDefinition::Op_LoadUnboxedObjectOrNull:
<span class="lineNum">    3609 </span><span class="lineCov">         41 :                 if (!TryOptimizeLoadObjectOrNull(def, &amp;eliminateList))</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    3611 </span><span class="lineCov">         41 :                 break;</span>
<span class="lineNum">    3612 </span>            :               default:
<span class="lineNum">    3613 </span>            :                 // Now that code motion passes have finished, replace
<span class="lineNum">    3614 </span>            :                 // instructions which pass through one of their operands
<span class="lineNum">    3615 </span>            :                 // (and perform additional checks) with that operand.
<span class="lineNum">    3616 </span><span class="lineCov">       1074 :                 if (MDefinition* passthrough = PassthroughOperand(def))</span>
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :                     def-&gt;replaceAllUsesWith(passthrough);</span>
<span class="lineNum">    3618 </span><span class="lineCov">       1074 :                 break;</span>
<span class="lineNum">    3619 </span>            :             }
<span class="lineNum">    3620 </span>            : 
<span class="lineNum">    3621 </span><span class="lineCov">       1244 :             if (eliminated)</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :                 block-&gt;discardDef(def);</span>
<span class="lineNum">    3623 </span>            :         }
<span class="lineNum">    3624 </span><span class="lineCov">        403 :         index++;</span>
<span class="lineNum">    3625 </span>            :     }
<span class="lineNum">    3626 </span>            : 
<span class="lineNum">    3627 </span><span class="lineCov">          8 :     MOZ_ASSERT(index == graph.numBlocks());</span>
<span class="lineNum">    3628 </span>            : 
<span class="lineNum">    3629 </span><span class="lineCov">          8 :     for (size_t i = 0; i &lt; eliminateList.length(); i++) {</span>
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :         MDefinition* def = eliminateList[i];</span>
<span class="lineNum">    3631 </span><span class="lineNoCov">          0 :         def-&gt;block()-&gt;discardDef(def);</span>
<span class="lineNum">    3632 </span>            :     }
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    3635 </span>            : }
<a name="3636"><span class="lineNum">    3636 </span>            : </a>
<span class="lineNum">    3637 </span>            : static bool
<span class="lineNum">    3638 </span><span class="lineCov">         19 : NeedsKeepAlive(MInstruction* slotsOrElements, MInstruction* use)</span>
<span class="lineNum">    3639 </span>            : {
<span class="lineNum">    3640 </span><span class="lineCov">         19 :     MOZ_ASSERT(slotsOrElements-&gt;type() == MIRType::Elements ||</span>
<span class="lineNum">    3641 </span>            :                slotsOrElements-&gt;type() == MIRType::Slots);
<span class="lineNum">    3642 </span>            : 
<span class="lineNum">    3643 </span><span class="lineCov">         19 :     if (slotsOrElements-&gt;block() != use-&gt;block())</span>
<span class="lineNum">    3644 </span><span class="lineCov">          2 :         return true;</span>
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span><span class="lineCov">         17 :     MBasicBlock* block = use-&gt;block();</span>
<span class="lineNum">    3647 </span><span class="lineCov">         17 :     MInstructionIterator iter(block-&gt;begin(slotsOrElements));</span>
<span class="lineNum">    3648 </span><span class="lineCov">         17 :     MOZ_ASSERT(*iter == slotsOrElements);</span>
<span class="lineNum">    3649 </span><span class="lineCov">         17 :     ++iter;</span>
<span class="lineNum">    3650 </span>            : 
<span class="lineNum">    3651 </span>            :     while (true) {
<span class="lineNum">    3652 </span><span class="lineCov">         25 :         if (*iter == use)</span>
<span class="lineNum">    3653 </span><span class="lineCov">         17 :             return false;</span>
<span class="lineNum">    3654 </span>            : 
<span class="lineNum">    3655 </span><span class="lineCov">          4 :         switch (iter-&gt;op()) {</span>
<span class="lineNum">    3656 </span>            :           case MDefinition::Op_Nop:
<span class="lineNum">    3657 </span>            :           case MDefinition::Op_Constant:
<span class="lineNum">    3658 </span>            :           case MDefinition::Op_KeepAliveObject:
<span class="lineNum">    3659 </span>            :           case MDefinition::Op_Unbox:
<span class="lineNum">    3660 </span>            :           case MDefinition::Op_LoadSlot:
<span class="lineNum">    3661 </span>            :           case MDefinition::Op_StoreSlot:
<span class="lineNum">    3662 </span>            :           case MDefinition::Op_LoadFixedSlot:
<span class="lineNum">    3663 </span>            :           case MDefinition::Op_StoreFixedSlot:
<span class="lineNum">    3664 </span>            :           case MDefinition::Op_LoadElement:
<span class="lineNum">    3665 </span>            :           case MDefinition::Op_StoreElement:
<span class="lineNum">    3666 </span>            :           case MDefinition::Op_InitializedLength:
<span class="lineNum">    3667 </span>            :           case MDefinition::Op_ArrayLength:
<span class="lineNum">    3668 </span>            :           case MDefinition::Op_BoundsCheck:
<span class="lineNum">    3669 </span><span class="lineCov">          4 :             iter++;</span>
<span class="lineNum">    3670 </span><span class="lineCov">          4 :             break;</span>
<span class="lineNum">    3671 </span>            :           default:
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    3673 </span>            :         }
<span class="lineNum">    3674 </span>            :     }
<span class="lineNum">    3675 </span>            : 
<span class="lineNum">    3676 </span>            :     MOZ_CRASH(&quot;Unreachable&quot;);
<span class="lineNum">    3677 </span>            : }
<a name="3678"><span class="lineNum">    3678 </span>            : </a>
<span class="lineNum">    3679 </span>            : bool
<span class="lineNum">    3680 </span><span class="lineCov">          8 : jit::AddKeepAliveInstructions(MIRGraph&amp; graph)</span>
<span class="lineNum">    3681 </span>            : {
<span class="lineNum">    3682 </span><span class="lineCov">        411 :     for (MBasicBlockIterator i(graph.begin()); i != graph.end(); i++) {</span>
<span class="lineNum">    3683 </span><span class="lineCov">        403 :         MBasicBlock* block = *i;</span>
<span class="lineNum">    3684 </span>            : 
<span class="lineNum">    3685 </span><span class="lineCov">       1877 :         for (MInstructionIterator insIter(block-&gt;begin()); insIter != block-&gt;end(); insIter++) {</span>
<span class="lineNum">    3686 </span><span class="lineCov">       1474 :             MInstruction* ins = *insIter;</span>
<span class="lineNum">    3687 </span><span class="lineCov">       1474 :             if (ins-&gt;type() != MIRType::Elements &amp;&amp; ins-&gt;type() != MIRType::Slots)</span>
<span class="lineNum">    3688 </span><span class="lineCov">       2920 :                 continue;</span>
<span class="lineNum">    3689 </span>            : 
<span class="lineNum">    3690 </span>            :             MDefinition* ownerObject;
<span class="lineNum">    3691 </span><span class="lineCov">         14 :             switch (ins-&gt;op()) {</span>
<span class="lineNum">    3692 </span>            :               case MDefinition::Op_ConstantElements:
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3694 </span>            :               case MDefinition::Op_ConvertElementsToDoubles:
<span class="lineNum">    3695 </span>            :                 // EliminateRedundantChecks should have replaced all uses.
<span class="lineNum">    3696 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(!ins-&gt;hasUses());</span>
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3698 </span>            :               case MDefinition::Op_Elements:
<span class="lineNum">    3699 </span>            :               case MDefinition::Op_TypedArrayElements:
<span class="lineNum">    3700 </span>            :               case MDefinition::Op_TypedObjectElements:
<span class="lineNum">    3701 </span><span class="lineCov">          7 :                 MOZ_ASSERT(ins-&gt;numOperands() == 1);</span>
<span class="lineNum">    3702 </span><span class="lineCov">          7 :                 ownerObject = ins-&gt;getOperand(0);</span>
<span class="lineNum">    3703 </span><span class="lineCov">          7 :                 break;</span>
<span class="lineNum">    3704 </span>            :               case MDefinition::Op_Slots:
<span class="lineNum">    3705 </span><span class="lineCov">          7 :                 ownerObject = ins-&gt;toSlots()-&gt;object();</span>
<span class="lineNum">    3706 </span><span class="lineCov">          7 :                 break;</span>
<span class="lineNum">    3707 </span>            :               default:
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :                 MOZ_CRASH(&quot;Unexpected op&quot;);</span>
<span class="lineNum">    3709 </span>            :             }
<span class="lineNum">    3710 </span>            : 
<span class="lineNum">    3711 </span><span class="lineCov">         14 :             MOZ_ASSERT(ownerObject-&gt;type() == MIRType::Object);</span>
<span class="lineNum">    3712 </span>            : 
<span class="lineNum">    3713 </span><span class="lineCov">         14 :             if (ownerObject-&gt;isConstant()) {</span>
<span class="lineNum">    3714 </span>            :                 // Constants are kept alive by other pointers, for instance
<span class="lineNum">    3715 </span>            :                 // ImmGCPtr in JIT code.
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3717 </span>            :             }
<span class="lineNum">    3718 </span>            : 
<span class="lineNum">    3719 </span><span class="lineCov">         34 :             for (MUseDefIterator uses(ins); uses; uses++) {</span>
<span class="lineNum">    3720 </span><span class="lineCov">         20 :                 MInstruction* use = uses.def()-&gt;toInstruction();</span>
<span class="lineNum">    3721 </span>            : 
<span class="lineNum">    3722 </span><span class="lineCov">         20 :                 if (use-&gt;isStoreElementHole()) {</span>
<span class="lineNum">    3723 </span>            :                     // StoreElementHole has an explicit object operand. If GVN
<span class="lineNum">    3724 </span>            :                     // is disabled, we can get different unbox instructions with
<span class="lineNum">    3725 </span>            :                     // the same object as input, so we check for that case.
<span class="lineNum">    3726 </span><span class="lineCov">          1 :                     MOZ_ASSERT_IF(!use-&gt;toStoreElementHole()-&gt;object()-&gt;isUnbox() &amp;&amp; !ownerObject-&gt;isUnbox(),</span>
<span class="lineNum">    3727 </span>            :                                   use-&gt;toStoreElementHole()-&gt;object() == ownerObject);
<span class="lineNum">    3728 </span><span class="lineCov">          1 :                     continue;</span>
<span class="lineNum">    3729 </span>            :                 }
<span class="lineNum">    3730 </span>            : 
<span class="lineNum">    3731 </span><span class="lineCov">         19 :                 if (use-&gt;isFallibleStoreElement()) {</span>
<span class="lineNum">    3732 </span>            :                     // See StoreElementHole case above.
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :                     MOZ_ASSERT_IF(!use-&gt;toFallibleStoreElement()-&gt;object()-&gt;isUnbox() &amp;&amp; !ownerObject-&gt;isUnbox(),</span>
<span class="lineNum">    3734 </span>            :                                   use-&gt;toFallibleStoreElement()-&gt;object() == ownerObject);
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    3736 </span>            :                 }
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span><span class="lineCov">         19 :                 if (use-&gt;isInArray()) {</span>
<span class="lineNum">    3739 </span>            :                     // See StoreElementHole case above.
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :                     MOZ_ASSERT_IF(!use-&gt;toInArray()-&gt;object()-&gt;isUnbox() &amp;&amp; !ownerObject-&gt;isUnbox(),</span>
<span class="lineNum">    3741 </span>            :                                   use-&gt;toInArray()-&gt;object() == ownerObject);
<span class="lineNum">    3742 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    3743 </span>            :                 }
<span class="lineNum">    3744 </span>            : 
<span class="lineNum">    3745 </span><span class="lineCov">         19 :                 if (!NeedsKeepAlive(ins, use))</span>
<span class="lineNum">    3746 </span><span class="lineCov">         17 :                     continue;</span>
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span><span class="lineCov">          2 :                 if (!graph.alloc().ensureBallast())</span>
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :                     return false;</span>
<span class="lineNum">    3750 </span><span class="lineCov">          2 :                 MKeepAliveObject* keepAlive = MKeepAliveObject::New(graph.alloc(), ownerObject);</span>
<span class="lineNum">    3751 </span><span class="lineCov">          2 :                 use-&gt;block()-&gt;insertAfter(use, keepAlive);</span>
<span class="lineNum">    3752 </span>            :             }
<span class="lineNum">    3753 </span>            :         }
<span class="lineNum">    3754 </span>            :     }
<span class="lineNum">    3755 </span>            : 
<span class="lineNum">    3756 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    3757 </span>            : }
<a name="3758"><span class="lineNum">    3758 </span>            : </a>
<span class="lineNum">    3759 </span>            : bool
<span class="lineNum">    3760 </span><span class="lineCov">          3 : LinearSum::multiply(int32_t scale)</span>
<span class="lineNum">    3761 </span>            : {
<span class="lineNum">    3762 </span><span class="lineCov">          9 :     for (size_t i = 0; i &lt; terms_.length(); i++) {</span>
<span class="lineNum">    3763 </span><span class="lineCov">          6 :         if (!SafeMul(scale, terms_[i].scale, &amp;terms_[i].scale))</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3765 </span>            :     }
<span class="lineNum">    3766 </span><span class="lineCov">          3 :     return SafeMul(scale, constant_, &amp;constant_);</span>
<span class="lineNum">    3767 </span>            : }
<a name="3768"><span class="lineNum">    3768 </span>            : </a>
<span class="lineNum">    3769 </span>            : bool
<span class="lineNum">    3770 </span><span class="lineNoCov">          0 : LinearSum::divide(uint32_t scale)</span>
<span class="lineNum">    3771 </span>            : {
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(scale &gt; 0);</span>
<span class="lineNum">    3773 </span>            : 
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; terms_.length(); i++) {</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :         if (terms_[i].scale % scale != 0)</span>
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3777 </span>            :     }
<span class="lineNum">    3778 </span><span class="lineNoCov">          0 :     if (constant_ % scale != 0)</span>
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; terms_.length(); i++)</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :         terms_[i].scale /= scale;</span>
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :     constant_ /= scale;</span>
<span class="lineNum">    3784 </span>            : 
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3786 </span>            : }
<a name="3787"><span class="lineNum">    3787 </span>            : </a>
<span class="lineNum">    3788 </span>            : bool
<span class="lineNum">    3789 </span><span class="lineCov">          3 : LinearSum::add(const LinearSum&amp; other, int32_t scale /* = 1 */)</span>
<span class="lineNum">    3790 </span>            : {
<span class="lineNum">    3791 </span><span class="lineCov">          6 :     for (size_t i = 0; i &lt; other.terms_.length(); i++) {</span>
<span class="lineNum">    3792 </span><span class="lineCov">          3 :         int32_t newScale = scale;</span>
<span class="lineNum">    3793 </span><span class="lineCov">          3 :         if (!SafeMul(scale, other.terms_[i].scale, &amp;newScale))</span>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3795 </span><span class="lineCov">          3 :         if (!add(other.terms_[i].term, newScale))</span>
<span class="lineNum">    3796 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3797 </span>            :     }
<span class="lineNum">    3798 </span><span class="lineCov">          3 :     int32_t newConstant = scale;</span>
<span class="lineNum">    3799 </span><span class="lineCov">          3 :     if (!SafeMul(scale, other.constant_, &amp;newConstant))</span>
<span class="lineNum">    3800 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3801 </span><span class="lineCov">          3 :     return add(newConstant);</span>
<span class="lineNum">    3802 </span>            : }
<a name="3803"><span class="lineNum">    3803 </span>            : </a>
<span class="lineNum">    3804 </span>            : bool
<span class="lineNum">    3805 </span><span class="lineNoCov">          0 : LinearSum::add(SimpleLinearSum other, int32_t scale)</span>
<span class="lineNum">    3806 </span>            : {
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :     if (other.term &amp;&amp; !add(other.term, scale))</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3809 </span>            : 
<span class="lineNum">    3810 </span>            :     int32_t constant;
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :     if (!SafeMul(other.constant, scale, &amp;constant))</span>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3813 </span>            : 
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :     return add(constant);</span>
<span class="lineNum">    3815 </span>            : }
<a name="3816"><span class="lineNum">    3816 </span>            : </a>
<span class="lineNum">    3817 </span>            : bool
<span class="lineNum">    3818 </span><span class="lineCov">         18 : LinearSum::add(MDefinition* term, int32_t scale)</span>
<span class="lineNum">    3819 </span>            : {
<span class="lineNum">    3820 </span><span class="lineCov">         18 :     MOZ_ASSERT(term);</span>
<span class="lineNum">    3821 </span>            : 
<span class="lineNum">    3822 </span><span class="lineCov">         18 :     if (scale == 0)</span>
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3824 </span>            : 
<span class="lineNum">    3825 </span><span class="lineCov">         18 :     if (MConstant* termConst = term-&gt;maybeConstantValue()) {</span>
<span class="lineNum">    3826 </span><span class="lineNoCov">          0 :         int32_t constant = termConst-&gt;toInt32();</span>
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :         if (!SafeMul(constant, scale, &amp;constant))</span>
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3829 </span><span class="lineNoCov">          0 :         return add(constant);</span>
<span class="lineNum">    3830 </span>            :     }
<span class="lineNum">    3831 </span>            : 
<span class="lineNum">    3832 </span><span class="lineCov">         27 :     for (size_t i = 0; i &lt; terms_.length(); i++) {</span>
<span class="lineNum">    3833 </span><span class="lineCov">         12 :         if (term == terms_[i].term) {</span>
<span class="lineNum">    3834 </span><span class="lineCov">          3 :             if (!SafeAdd(scale, terms_[i].scale, &amp;terms_[i].scale))</span>
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3836 </span><span class="lineCov">          3 :             if (terms_[i].scale == 0) {</span>
<span class="lineNum">    3837 </span><span class="lineCov">          3 :                 terms_[i] = terms_.back();</span>
<span class="lineNum">    3838 </span><span class="lineCov">          3 :                 terms_.popBack();</span>
<span class="lineNum">    3839 </span>            :             }
<span class="lineNum">    3840 </span><span class="lineCov">          3 :             return true;</span>
<span class="lineNum">    3841 </span>            :         }
<span class="lineNum">    3842 </span>            :     }
<span class="lineNum">    3843 </span>            : 
<span class="lineNum">    3844 </span><span class="lineCov">         30 :     AutoEnterOOMUnsafeRegion oomUnsafe;</span>
<span class="lineNum">    3845 </span><span class="lineCov">         15 :     if (!terms_.append(LinearTerm(term, scale)))</span>
<span class="lineNum">    3846 </span><span class="lineNoCov">          0 :         oomUnsafe.crash(&quot;LinearSum::add&quot;);</span>
<span class="lineNum">    3847 </span>            : 
<span class="lineNum">    3848 </span><span class="lineCov">         15 :     return true;</span>
<span class="lineNum">    3849 </span>            : }
<a name="3850"><span class="lineNum">    3850 </span>            : </a>
<span class="lineNum">    3851 </span>            : bool
<span class="lineNum">    3852 </span><span class="lineCov">          9 : LinearSum::add(int32_t constant)</span>
<span class="lineNum">    3853 </span>            : {
<span class="lineNum">    3854 </span><span class="lineCov">          9 :     return SafeAdd(constant, constant_, &amp;constant_);</span>
<span class="lineNum">    3855 </span>            : }
<a name="3856"><span class="lineNum">    3856 </span>            : </a>
<span class="lineNum">    3857 </span>            : void
<span class="lineNum">    3858 </span><span class="lineNoCov">          0 : LinearSum::dump(GenericPrinter&amp; out) const</span>
<span class="lineNum">    3859 </span>            : {
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; terms_.length(); i++) {</span>
<span class="lineNum">    3861 </span><span class="lineNoCov">          0 :         int32_t scale = terms_[i].scale;</span>
<span class="lineNum">    3862 </span><span class="lineNoCov">          0 :         int32_t id = terms_[i].term-&gt;id();</span>
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(scale);</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :         if (scale &gt; 0) {</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :             if (i)</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :                 out.printf(&quot;+&quot;);</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :             if (scale == 1)</span>
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :                 out.printf(&quot;#%d&quot;, id);</span>
<span class="lineNum">    3869 </span>            :             else
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :                 out.printf(&quot;%d*#%d&quot;, scale, id);</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :         } else if (scale == -1) {</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :             out.printf(&quot;-#%d&quot;, id);</span>
<span class="lineNum">    3873 </span>            :         } else {
<span class="lineNum">    3874 </span><span class="lineNoCov">          0 :             out.printf(&quot;%d*#%d&quot;, scale, id);</span>
<span class="lineNum">    3875 </span>            :         }
<span class="lineNum">    3876 </span>            :     }
<span class="lineNum">    3877 </span><span class="lineNoCov">          0 :     if (constant_ &gt; 0)</span>
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 :         out.printf(&quot;+%d&quot;, constant_);</span>
<span class="lineNum">    3879 </span><span class="lineNoCov">          0 :     else if (constant_ &lt; 0)</span>
<span class="lineNum">    3880 </span><span class="lineNoCov">          0 :         out.printf(&quot;%d&quot;, constant_);</span>
<span class="lineNum">    3881 </span><span class="lineNoCov">          0 : }</span>
<a name="3882"><span class="lineNum">    3882 </span>            : </a>
<span class="lineNum">    3883 </span>            : void
<span class="lineNum">    3884 </span><span class="lineNoCov">          0 : LinearSum::dump() const</span>
<span class="lineNum">    3885 </span>            : {
<span class="lineNum">    3886 </span><span class="lineNoCov">          0 :     Fprinter out(stderr);</span>
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :     dump(out);</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :     out.finish();</span>
<span class="lineNum">    3889 </span><span class="lineNoCov">          0 : }</span>
<a name="3890"><span class="lineNum">    3890 </span>            : </a>
<span class="lineNum">    3891 </span>            : MDefinition*
<span class="lineNum">    3892 </span><span class="lineCov">          4 : jit::ConvertLinearSum(TempAllocator&amp; alloc, MBasicBlock* block, const LinearSum&amp; sum, bool convertConstant)</span>
<span class="lineNum">    3893 </span>            : {
<span class="lineNum">    3894 </span><span class="lineCov">          4 :     MDefinition* def = nullptr;</span>
<span class="lineNum">    3895 </span>            : 
<span class="lineNum">    3896 </span><span class="lineCov">          8 :     for (size_t i = 0; i &lt; sum.numTerms(); i++) {</span>
<span class="lineNum">    3897 </span><span class="lineCov">          4 :         LinearTerm term = sum.term(i);</span>
<span class="lineNum">    3898 </span><span class="lineCov">          4 :         MOZ_ASSERT(!term.term-&gt;isConstant());</span>
<span class="lineNum">    3899 </span><span class="lineCov">          4 :         if (term.scale == 1) {</span>
<span class="lineNum">    3900 </span><span class="lineCov">          4 :             if (def) {</span>
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 :                 def = MAdd::New(alloc, def, term.term);</span>
<span class="lineNum">    3902 </span><span class="lineNoCov">          0 :                 def-&gt;toAdd()-&gt;setInt32Specialization();</span>
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :                 block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3904 </span><span class="lineNoCov">          0 :                 def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3905 </span>            :             } else {
<span class="lineNum">    3906 </span><span class="lineCov">          4 :                 def = term.term;</span>
<span class="lineNum">    3907 </span>            :             }
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :         } else if (term.scale == -1) {</span>
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :             if (!def) {</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :                 def = MConstant::New(alloc, Int32Value(0));</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :                 block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :                 def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3913 </span>            :             }
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :             def = MSub::New(alloc, def, term.term);</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :             def-&gt;toSub()-&gt;setInt32Specialization();</span>
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :             block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :             def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3918 </span>            :         } else {
<span class="lineNum">    3919 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(term.scale != 0);</span>
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :             MConstant* factor = MConstant::New(alloc, Int32Value(term.scale));</span>
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :             block-&gt;insertAtEnd(factor);</span>
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :             MMul* mul = MMul::New(alloc, term.term, factor);</span>
<span class="lineNum">    3923 </span><span class="lineNoCov">          0 :             mul-&gt;setInt32Specialization();</span>
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :             block-&gt;insertAtEnd(mul);</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :             mul-&gt;computeRange(alloc);</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :             if (def) {</span>
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :                 def = MAdd::New(alloc, def, mul);</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :                 def-&gt;toAdd()-&gt;setInt32Specialization();</span>
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :                 block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :                 def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3931 </span>            :             } else {
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :                 def = mul;</span>
<span class="lineNum">    3933 </span>            :             }
<span class="lineNum">    3934 </span>            :         }
<span class="lineNum">    3935 </span>            :     }
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span><span class="lineCov">          4 :     if (convertConstant &amp;&amp; sum.constant()) {</span>
<span class="lineNum">    3938 </span><span class="lineNoCov">          0 :         MConstant* constant = MConstant::New(alloc, Int32Value(sum.constant()));</span>
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :         block-&gt;insertAtEnd(constant);</span>
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :         constant-&gt;computeRange(alloc);</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :         if (def) {</span>
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 :             def = MAdd::New(alloc, def, constant);</span>
<span class="lineNum">    3943 </span><span class="lineNoCov">          0 :             def-&gt;toAdd()-&gt;setInt32Specialization();</span>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :             block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :             def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3946 </span>            :         } else {
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :             def = constant;</span>
<span class="lineNum">    3948 </span>            :         }
<span class="lineNum">    3949 </span>            :     }
<span class="lineNum">    3950 </span>            : 
<span class="lineNum">    3951 </span><span class="lineCov">          4 :     if (!def) {</span>
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :         def = MConstant::New(alloc, Int32Value(0));</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :         block-&gt;insertAtEnd(def-&gt;toInstruction());</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :         def-&gt;computeRange(alloc);</span>
<span class="lineNum">    3955 </span>            :     }
<span class="lineNum">    3956 </span>            : 
<span class="lineNum">    3957 </span><span class="lineCov">          4 :     return def;</span>
<span class="lineNum">    3958 </span>            : }
<a name="3959"><span class="lineNum">    3959 </span>            : </a>
<span class="lineNum">    3960 </span>            : MCompare*
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 : jit::ConvertLinearInequality(TempAllocator&amp; alloc, MBasicBlock* block, const LinearSum&amp; sum)</span>
<span class="lineNum">    3962 </span>            : {
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :     LinearSum lhs(sum);</span>
<span class="lineNum">    3964 </span>            : 
<span class="lineNum">    3965 </span>            :     // Look for a term with a -1 scale which we can use for the rhs.
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :     MDefinition* rhsDef = nullptr;</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; lhs.numTerms(); i++) {</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :         if (lhs.term(i).scale == -1) {</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :             AutoEnterOOMUnsafeRegion oomUnsafe;</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :             rhsDef = lhs.term(i).term;</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :             if (!lhs.add(rhsDef, 1))</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :                oomUnsafe.crash(&quot;ConvertLinearInequality&quot;);</span>
<span class="lineNum">    3973 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3974 </span>            :         }
<span class="lineNum">    3975 </span>            :     }
<span class="lineNum">    3976 </span>            : 
<span class="lineNum">    3977 </span><span class="lineNoCov">          0 :     MDefinition* lhsDef = nullptr;</span>
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :     JSOp op = JSOP_GE;</span>
<span class="lineNum">    3979 </span>            : 
<span class="lineNum">    3980 </span>            :     do {
<span class="lineNum">    3981 </span><span class="lineNoCov">          0 :         if (!lhs.numTerms()) {</span>
<span class="lineNum">    3982 </span><span class="lineNoCov">          0 :             lhsDef = MConstant::New(alloc, Int32Value(lhs.constant()));</span>
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 :             block-&gt;insertAtEnd(lhsDef-&gt;toInstruction());</span>
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :             lhsDef-&gt;computeRange(alloc);</span>
<span class="lineNum">    3985 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3986 </span>            :         }
<span class="lineNum">    3987 </span>            : 
<span class="lineNum">    3988 </span><span class="lineNoCov">          0 :         lhsDef = ConvertLinearSum(alloc, block, lhs);</span>
<span class="lineNum">    3989 </span><span class="lineNoCov">          0 :         if (lhs.constant() == 0)</span>
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :         if (lhs.constant() == -1) {</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :             op = JSOP_GT;</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3995 </span>            :         }
<span class="lineNum">    3996 </span>            : 
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :         if (!rhsDef) {</span>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 :             int32_t constant = lhs.constant();</span>
<span class="lineNum">    3999 </span><span class="lineNoCov">          0 :             if (SafeMul(constant, -1, &amp;constant)) {</span>
<span class="lineNum">    4000 </span><span class="lineNoCov">          0 :                 rhsDef = MConstant::New(alloc, Int32Value(constant));</span>
<span class="lineNum">    4001 </span><span class="lineNoCov">          0 :                 block-&gt;insertAtEnd(rhsDef-&gt;toInstruction());</span>
<span class="lineNum">    4002 </span><span class="lineNoCov">          0 :                 rhsDef-&gt;computeRange(alloc);</span>
<span class="lineNum">    4003 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4004 </span>            :             }
<span class="lineNum">    4005 </span>            :         }
<span class="lineNum">    4006 </span>            : 
<span class="lineNum">    4007 </span><span class="lineNoCov">          0 :         MDefinition* constant = MConstant::New(alloc, Int32Value(lhs.constant()));</span>
<span class="lineNum">    4008 </span><span class="lineNoCov">          0 :         block-&gt;insertAtEnd(constant-&gt;toInstruction());</span>
<span class="lineNum">    4009 </span><span class="lineNoCov">          0 :         constant-&gt;computeRange(alloc);</span>
<span class="lineNum">    4010 </span><span class="lineNoCov">          0 :         lhsDef = MAdd::New(alloc, lhsDef, constant);</span>
<span class="lineNum">    4011 </span><span class="lineNoCov">          0 :         lhsDef-&gt;toAdd()-&gt;setInt32Specialization();</span>
<span class="lineNum">    4012 </span><span class="lineNoCov">          0 :         block-&gt;insertAtEnd(lhsDef-&gt;toInstruction());</span>
<span class="lineNum">    4013 </span><span class="lineNoCov">          0 :         lhsDef-&gt;computeRange(alloc);</span>
<span class="lineNum">    4014 </span>            :     } while (false);
<span class="lineNum">    4015 </span>            : 
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 :     if (!rhsDef) {</span>
<span class="lineNum">    4017 </span><span class="lineNoCov">          0 :         rhsDef = MConstant::New(alloc, Int32Value(0));</span>
<span class="lineNum">    4018 </span><span class="lineNoCov">          0 :         block-&gt;insertAtEnd(rhsDef-&gt;toInstruction());</span>
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :         rhsDef-&gt;computeRange(alloc);</span>
<span class="lineNum">    4020 </span>            :     }
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span><span class="lineNoCov">          0 :     MCompare* compare = MCompare::New(alloc, lhsDef, rhsDef, op);</span>
<span class="lineNum">    4023 </span><span class="lineNoCov">          0 :     block-&gt;insertAtEnd(compare);</span>
<span class="lineNum">    4024 </span><span class="lineNoCov">          0 :     compare-&gt;setCompareType(MCompare::Compare_Int32);</span>
<span class="lineNum">    4025 </span>            : 
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 :     return compare;</span>
<span class="lineNum">    4027 </span>            : }
<a name="4028"><span class="lineNum">    4028 </span>            : </a>
<span class="lineNum">    4029 </span>            : static bool
<span class="lineNum">    4030 </span><span class="lineCov">          2 : AnalyzePoppedThis(JSContext* cx, ObjectGroup* group,</span>
<span class="lineNum">    4031 </span>            :                   MDefinition* thisValue, MInstruction* ins, bool definitelyExecuted,
<span class="lineNum">    4032 </span>            :                   HandlePlainObject baseobj,
<span class="lineNum">    4033 </span>            :                   Vector&lt;TypeNewScript::Initializer&gt;* initializerList,
<span class="lineNum">    4034 </span>            :                   Vector&lt;PropertyName*&gt;* accessedProperties,
<span class="lineNum">    4035 </span>            :                   bool* phandled)
<span class="lineNum">    4036 </span>            : {
<span class="lineNum">    4037 </span>            :     // Determine the effect that a use of the |this| value when calling |new|
<span class="lineNum">    4038 </span>            :     // on a script has on the properties definitely held by the new object.
<span class="lineNum">    4039 </span>            : 
<span class="lineNum">    4040 </span><span class="lineCov">          2 :     if (ins-&gt;isCallSetProperty()) {</span>
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :         MCallSetProperty* setprop = ins-&gt;toCallSetProperty();</span>
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :         if (setprop-&gt;object() != thisValue)</span>
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4045 </span>            : 
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :         if (setprop-&gt;name() == cx-&gt;names().prototype ||</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :             setprop-&gt;name() == cx-&gt;names().proto ||</span>
<span class="lineNum">    4048 </span><span class="lineNoCov">          0 :             setprop-&gt;name() == cx-&gt;names().constructor)</span>
<span class="lineNum">    4049 </span>            :         {
<span class="lineNum">    4050 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4051 </span>            :         }
<span class="lineNum">    4052 </span>            : 
<span class="lineNum">    4053 </span>            :         // Ignore assignments to properties that were already written to.
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 :         if (baseobj-&gt;lookup(cx, NameToId(setprop-&gt;name()))) {</span>
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :             *phandled = true;</span>
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4057 </span>            :         }
<span class="lineNum">    4058 </span>            : 
<span class="lineNum">    4059 </span>            :         // Don't add definite properties for properties that were already
<span class="lineNum">    4060 </span>            :         // read in the constructor.
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; accessedProperties-&gt;length(); i++) {</span>
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :             if ((*accessedProperties)[i] == setprop-&gt;name())</span>
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    4064 </span>            :         }
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            :         // Assignments to new properties must always execute.
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :         if (!definitelyExecuted)</span>
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span><span class="lineNoCov">          0 :         RootedId id(cx, NameToId(setprop-&gt;name()));</span>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :         if (!AddClearDefiniteGetterSetterForPrototypeChain(cx, group, id)) {</span>
<span class="lineNum">    4072 </span>            :             // The prototype chain already contains a getter/setter for this
<span class="lineNum">    4073 </span>            :             // property, or type information is too imprecise.
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4075 </span>            :         }
<span class="lineNum">    4076 </span>            : 
<span class="lineNum">    4077 </span>            :         // Add the property to the object, being careful not to update type information.
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :         DebugOnly&lt;unsigned&gt; slotSpan = baseobj-&gt;slotSpan();</span>
<span class="lineNum">    4079 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!baseobj-&gt;containsPure(id));</span>
<span class="lineNum">    4080 </span><span class="lineNoCov">          0 :         if (!NativeObject::addDataProperty(cx, baseobj, id, baseobj-&gt;slotSpan(), JSPROP_ENUMERATE))</span>
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(baseobj-&gt;slotSpan() != slotSpan);</span>
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!baseobj-&gt;inDictionaryMode());</span>
<span class="lineNum">    4084 </span>            : 
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :         Vector&lt;MResumePoint*&gt; callerResumePoints(cx);</span>
<span class="lineNum">    4086 </span><span class="lineNoCov">          0 :         for (MResumePoint* rp = ins-&gt;block()-&gt;callerResumePoint();</span>
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :              rp;</span>
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :              rp = rp-&gt;block()-&gt;callerResumePoint())</span>
<span class="lineNum">    4089 </span>            :         {
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 :             if (!callerResumePoints.append(rp))</span>
<span class="lineNum">    4091 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    4092 </span>            :         }
<span class="lineNum">    4093 </span>            : 
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :         for (int i = callerResumePoints.length() - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :             MResumePoint* rp = callerResumePoints[i];</span>
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 :             JSScript* script = rp-&gt;block()-&gt;info().script();</span>
<span class="lineNum">    4097 </span>            :             TypeNewScript::Initializer entry(TypeNewScript::Initializer::SETPROP_FRAME,
<span class="lineNum">    4098 </span><span class="lineNoCov">          0 :                                              script-&gt;pcToOffset(rp-&gt;pc()));</span>
<span class="lineNum">    4099 </span><span class="lineNoCov">          0 :             if (!initializerList-&gt;append(entry))</span>
<span class="lineNum">    4100 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    4101 </span>            :         }
<span class="lineNum">    4102 </span>            : 
<span class="lineNum">    4103 </span><span class="lineNoCov">          0 :         JSScript* script = ins-&gt;block()-&gt;info().script();</span>
<span class="lineNum">    4104 </span>            :         TypeNewScript::Initializer entry(TypeNewScript::Initializer::SETPROP,
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :                                          script-&gt;pcToOffset(setprop-&gt;resumePoint()-&gt;pc()));</span>
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :         if (!initializerList-&gt;append(entry))</span>
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4108 </span>            : 
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :         *phandled = true;</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4111 </span>            :     }
<span class="lineNum">    4112 </span>            : 
<span class="lineNum">    4113 </span><span class="lineCov">          2 :     if (ins-&gt;isCallGetProperty()) {</span>
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :         MCallGetProperty* get = ins-&gt;toCallGetProperty();</span>
<span class="lineNum">    4115 </span>            : 
<span class="lineNum">    4116 </span>            :         /*
<span class="lineNum">    4117 </span>            :          * Properties can be read from the 'this' object if the following hold:
<span class="lineNum">    4118 </span>            :          *
<span class="lineNum">    4119 </span>            :          * - The read is not on a getter along the prototype chain, which
<span class="lineNum">    4120 </span>            :          *   could cause 'this' to escape.
<span class="lineNum">    4121 </span>            :          *
<span class="lineNum">    4122 </span>            :          * - The accessed property is either already a definite property or
<span class="lineNum">    4123 </span>            :          *   is not later added as one. Since the definite properties are
<span class="lineNum">    4124 </span>            :          *   added to the object at the point of its creation, reading a
<span class="lineNum">    4125 </span>            :          *   definite property before it is assigned could incorrectly hit.
<span class="lineNum">    4126 </span>            :          */
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :         RootedId id(cx, NameToId(get-&gt;name()));</span>
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :         if (!baseobj-&gt;lookup(cx, id) &amp;&amp; !accessedProperties-&gt;append(get-&gt;name()))</span>
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 :         if (!AddClearDefiniteGetterSetterForPrototypeChain(cx, group, id)) {</span>
<span class="lineNum">    4132 </span>            :             // The |this| value can escape if any property reads it does go
<span class="lineNum">    4133 </span>            :             // through a getter.
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4135 </span>            :         }
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :         *phandled = true;</span>
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4139 </span>            :     }
<span class="lineNum">    4140 </span>            : 
<span class="lineNum">    4141 </span><span class="lineCov">          2 :     if (ins-&gt;isPostWriteBarrier()) {</span>
<span class="lineNum">    4142 </span><span class="lineCov">          1 :         *phandled = true;</span>
<span class="lineNum">    4143 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    4144 </span>            :     }
<span class="lineNum">    4145 </span>            : 
<span class="lineNum">    4146 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    4147 </span>            : }
<a name="4148"><span class="lineNum">    4148 </span>            : </a>
<span class="lineNum">    4149 </span>            : static int
<span class="lineNum">    4150 </span><span class="lineCov">          1 : CmpInstructions(const void* a, const void* b)</span>
<span class="lineNum">    4151 </span>            : {
<span class="lineNum">    4152 </span><span class="lineCov">          2 :     return (*static_cast&lt;MInstruction * const*&gt;(a))-&gt;id() -</span>
<span class="lineNum">    4153 </span><span class="lineCov">          2 :            (*static_cast&lt;MInstruction * const*&gt;(b))-&gt;id();</span>
<span class="lineNum">    4154 </span>            : }
<a name="4155"><span class="lineNum">    4155 </span>            : </a>
<span class="lineNum">    4156 </span>            : bool
<span class="lineNum">    4157 </span><span class="lineCov">          1 : jit::AnalyzeNewScriptDefiniteProperties(JSContext* cx, HandleFunction fun,</span>
<span class="lineNum">    4158 </span>            :                                         ObjectGroup* group, HandlePlainObject baseobj,
<span class="lineNum">    4159 </span>            :                                         Vector&lt;TypeNewScript::Initializer&gt;* initializerList)
<span class="lineNum">    4160 </span>            : {
<span class="lineNum">    4161 </span><span class="lineCov">          1 :     MOZ_ASSERT(cx-&gt;zone()-&gt;types.activeAnalysis);</span>
<span class="lineNum">    4162 </span>            : 
<span class="lineNum">    4163 </span>            :     // When invoking 'new' on the specified script, try to find some properties
<span class="lineNum">    4164 </span>            :     // which will definitely be added to the created object before it has a
<span class="lineNum">    4165 </span>            :     // chance to escape and be accessed elsewhere.
<span class="lineNum">    4166 </span>            : 
<span class="lineNum">    4167 </span><span class="lineCov">          2 :     RootedScript script(cx, JSFunction::getOrCreateScript(cx, fun));</span>
<span class="lineNum">    4168 </span><span class="lineCov">          1 :     if (!script)</span>
<span class="lineNum">    4169 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4170 </span>            : 
<span class="lineNum">    4171 </span><span class="lineCov">          1 :     if (!jit::IsIonEnabled(cx) || !jit::IsBaselineEnabled(cx) || !script-&gt;canBaselineCompile())</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4173 </span>            : 
<span class="lineNum">    4174 </span>            :     static const uint32_t MAX_SCRIPT_SIZE = 2000;
<span class="lineNum">    4175 </span><span class="lineCov">          1 :     if (script-&gt;length() &gt; MAX_SCRIPT_SIZE)</span>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4177 </span>            : 
<span class="lineNum">    4178 </span><span class="lineCov">          1 :     TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);</span>
<span class="lineNum">    4179 </span><span class="lineCov">          2 :     TraceLoggerEvent event(TraceLogger_AnnotateScripts, script);</span>
<span class="lineNum">    4180 </span><span class="lineCov">          2 :     AutoTraceLog logScript(logger, event);</span>
<span class="lineNum">    4181 </span><span class="lineCov">          2 :     AutoTraceLog logCompile(logger, TraceLogger_IonAnalysis);</span>
<span class="lineNum">    4182 </span>            : 
<span class="lineNum">    4183 </span><span class="lineCov">          2 :     Vector&lt;PropertyName*&gt; accessedProperties(cx);</span>
<span class="lineNum">    4184 </span>            : 
<span class="lineNum">    4185 </span><span class="lineCov">          2 :     LifoAlloc alloc(TempAllocator::PreferredLifoChunkSize);</span>
<span class="lineNum">    4186 </span><span class="lineCov">          2 :     TempAllocator temp(&amp;alloc);</span>
<span class="lineNum">    4187 </span><span class="lineCov">          2 :     JitContext jctx(cx, &amp;temp);</span>
<span class="lineNum">    4188 </span>            : 
<span class="lineNum">    4189 </span><span class="lineCov">          1 :     if (!jit::CanLikelyAllocateMoreExecutableMemory())</span>
<span class="lineNum">    4190 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4191 </span>            : 
<span class="lineNum">    4192 </span><span class="lineCov">          1 :     if (!cx-&gt;compartment()-&gt;ensureJitCompartmentExists(cx))</span>
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4194 </span>            : 
<span class="lineNum">    4195 </span><span class="lineCov">          1 :     if (!script-&gt;hasBaselineScript()) {</span>
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :         MethodStatus status = BaselineCompile(cx, script);</span>
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :         if (status == Method_Error)</span>
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :         if (status != Method_Compiled)</span>
<span class="lineNum">    4200 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4201 </span>            :     }
<span class="lineNum">    4202 </span>            : 
<span class="lineNum">    4203 </span><span class="lineCov">          1 :     TypeScript::SetThis(cx, script, TypeSet::ObjectType(group));</span>
<span class="lineNum">    4204 </span>            : 
<span class="lineNum">    4205 </span><span class="lineCov">          1 :     MIRGraph graph(&amp;temp);</span>
<span class="lineNum">    4206 </span><span class="lineCov">          1 :     InlineScriptTree* inlineScriptTree = InlineScriptTree::New(&amp;temp, nullptr, nullptr, script);</span>
<span class="lineNum">    4207 </span><span class="lineCov">          1 :     if (!inlineScriptTree)</span>
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4209 </span>            : 
<span class="lineNum">    4210 </span>            :     CompileInfo info(script, fun,
<span class="lineNum">    4211 </span>            :                      /* osrPc = */ nullptr,
<span class="lineNum">    4212 </span>            :                      Analysis_DefiniteProperties,
<span class="lineNum">    4213 </span><span class="lineCov">          1 :                      script-&gt;needsArgsObj(),</span>
<span class="lineNum">    4214 </span><span class="lineCov">          2 :                      inlineScriptTree);</span>
<span class="lineNum">    4215 </span>            : 
<span class="lineNum">    4216 </span><span class="lineCov">          1 :     const OptimizationInfo* optimizationInfo = IonOptimizations.get(OptimizationLevel::Normal);</span>
<span class="lineNum">    4217 </span>            : 
<span class="lineNum">    4218 </span><span class="lineCov">          1 :     CompilerConstraintList* constraints = NewCompilerConstraintList(temp);</span>
<span class="lineNum">    4219 </span><span class="lineCov">          1 :     if (!constraints) {</span>
<span class="lineNum">    4220 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4222 </span>            :     }
<span class="lineNum">    4223 </span>            : 
<span class="lineNum">    4224 </span><span class="lineCov">          1 :     BaselineInspector inspector(script);</span>
<span class="lineNum">    4225 </span><span class="lineCov">          1 :     const JitCompileOptions options(cx);</span>
<span class="lineNum">    4226 </span>            : 
<span class="lineNum">    4227 </span>            :     IonBuilder builder(cx, CompileCompartment::get(cx-&gt;compartment()), options, &amp;temp, &amp;graph, constraints,
<span class="lineNum">    4228 </span><span class="lineCov">          2 :                        &amp;inspector, &amp;info, optimizationInfo, /* baselineFrame = */ nullptr);</span>
<span class="lineNum">    4229 </span>            : 
<span class="lineNum">    4230 </span><span class="lineCov">          1 :     AbortReasonOr&lt;Ok&gt; buildResult = builder.build();</span>
<span class="lineNum">    4231 </span><span class="lineCov">          1 :     if (buildResult.isErr()) {</span>
<span class="lineNum">    4232 </span><span class="lineNoCov">          0 :         AbortReason reason = buildResult.unwrapErr();</span>
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :         if (cx-&gt;isThrowingOverRecursed() || cx-&gt;isThrowingOutOfMemory())</span>
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4235 </span><span class="lineNoCov">          0 :         if (reason == AbortReason::Alloc) {</span>
<span class="lineNum">    4236 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    4237 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4238 </span>            :         }
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!cx-&gt;isExceptionPending());</span>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4241 </span>            :     }
<span class="lineNum">    4242 </span>            : 
<span class="lineNum">    4243 </span><span class="lineCov">          1 :     FinishDefinitePropertiesAnalysis(cx, constraints);</span>
<span class="lineNum">    4244 </span>            : 
<span class="lineNum">    4245 </span><span class="lineCov">          1 :     if (!SplitCriticalEdges(graph)) {</span>
<span class="lineNum">    4246 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4248 </span>            :     }
<span class="lineNum">    4249 </span>            : 
<span class="lineNum">    4250 </span><span class="lineCov">          1 :     RenumberBlocks(graph);</span>
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span><span class="lineCov">          1 :     if (!BuildDominatorTree(graph)) {</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4255 </span>            :     }
<span class="lineNum">    4256 </span>            : 
<span class="lineNum">    4257 </span><span class="lineCov">          1 :     if (!EliminatePhis(&amp;builder, graph, AggressiveObservability)) {</span>
<span class="lineNum">    4258 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4260 </span>            :     }
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span><span class="lineCov">          1 :     MDefinition* thisValue = graph.entryBlock()-&gt;getSlot(info.thisSlot());</span>
<span class="lineNum">    4263 </span>            : 
<span class="lineNum">    4264 </span>            :     // Get a list of instructions using the |this| value in the order they
<span class="lineNum">    4265 </span>            :     // appear in the graph.
<span class="lineNum">    4266 </span><span class="lineCov">          2 :     Vector&lt;MInstruction*&gt; instructions(cx);</span>
<span class="lineNum">    4267 </span>            : 
<span class="lineNum">    4268 </span><span class="lineCov">          3 :     for (MUseDefIterator uses(thisValue); uses; uses++) {</span>
<span class="lineNum">    4269 </span><span class="lineCov">          2 :         MDefinition* use = uses.def();</span>
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :         // Don't track |this| through assignments to phis.
<span class="lineNum">    4272 </span><span class="lineCov">          2 :         if (!use-&gt;isInstruction())</span>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    4274 </span>            : 
<span class="lineNum">    4275 </span><span class="lineCov">          2 :         if (!instructions.append(use-&gt;toInstruction()))</span>
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4277 </span>            :     }
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span>            :     // Sort the instructions to visit in increasing order.
<span class="lineNum">    4280 </span><span class="lineCov">          1 :     qsort(instructions.begin(), instructions.length(),</span>
<span class="lineNum">    4281 </span><span class="lineCov">          1 :           sizeof(MInstruction*), CmpInstructions);</span>
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span>            :     // Find all exit blocks in the graph.
<span class="lineNum">    4284 </span><span class="lineCov">          2 :     Vector&lt;MBasicBlock*&gt; exitBlocks(cx);</span>
<span class="lineNum">    4285 </span><span class="lineCov">          4 :     for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    4286 </span><span class="lineCov">          1 :         if (!block-&gt;numSuccessors() &amp;&amp; !exitBlocks.append(*block))</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4288 </span>            :     }
<span class="lineNum">    4289 </span>            : 
<span class="lineNum">    4290 </span>            :     // id of the last block which added a new property.
<span class="lineNum">    4291 </span><span class="lineCov">          1 :     size_t lastAddedBlock = 0;</span>
<span class="lineNum">    4292 </span>            : 
<span class="lineNum">    4293 </span><span class="lineCov">          2 :     for (size_t i = 0; i &lt; instructions.length(); i++) {</span>
<span class="lineNum">    4294 </span><span class="lineCov">          2 :         MInstruction* ins = instructions[i];</span>
<span class="lineNum">    4295 </span>            : 
<span class="lineNum">    4296 </span>            :         // Track whether the use of |this| is in unconditional code, i.e.
<span class="lineNum">    4297 </span>            :         // the block dominates all graph exits.
<span class="lineNum">    4298 </span><span class="lineCov">          2 :         bool definitelyExecuted = true;</span>
<span class="lineNum">    4299 </span><span class="lineCov">          4 :         for (size_t i = 0; i &lt; exitBlocks.length(); i++) {</span>
<span class="lineNum">    4300 </span><span class="lineCov">          4 :             for (MBasicBlock* exit = exitBlocks[i];</span>
<span class="lineNum">    4301 </span><span class="lineCov">          2 :                  exit != ins-&gt;block();</span>
<span class="lineNum">    4302 </span>            :                  exit = exit-&gt;immediateDominator())
<span class="lineNum">    4303 </span>            :             {
<span class="lineNum">    4304 </span><span class="lineNoCov">          0 :                 if (exit == exit-&gt;immediateDominator()) {</span>
<span class="lineNum">    4305 </span><span class="lineNoCov">          0 :                     definitelyExecuted = false;</span>
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    4307 </span>            :                 }
<span class="lineNum">    4308 </span>            :             }
<span class="lineNum">    4309 </span>            :         }
<span class="lineNum">    4310 </span>            : 
<span class="lineNum">    4311 </span>            :         // Also check to see if the instruction is inside a loop body. Even if
<span class="lineNum">    4312 </span>            :         // an access will always execute in the script, if it executes multiple
<span class="lineNum">    4313 </span>            :         // times then we can get confused when rolling back objects while
<span class="lineNum">    4314 </span>            :         // clearing the new script information.
<span class="lineNum">    4315 </span><span class="lineCov">          2 :         if (ins-&gt;block()-&gt;loopDepth() != 0)</span>
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :             definitelyExecuted = false;</span>
<span class="lineNum">    4317 </span>            : 
<span class="lineNum">    4318 </span><span class="lineCov">          2 :         bool handled = false;</span>
<span class="lineNum">    4319 </span><span class="lineCov">          2 :         size_t slotSpan = baseobj-&gt;slotSpan();</span>
<span class="lineNum">    4320 </span><span class="lineCov">          2 :         if (!AnalyzePoppedThis(cx, group, thisValue, ins, definitelyExecuted,</span>
<span class="lineNum">    4321 </span>            :                                baseobj, initializerList, &amp;accessedProperties, &amp;handled))
<span class="lineNum">    4322 </span>            :         {
<span class="lineNum">    4323 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4324 </span>            :         }
<span class="lineNum">    4325 </span><span class="lineCov">          2 :         if (!handled)</span>
<span class="lineNum">    4326 </span><span class="lineCov">          1 :             break;</span>
<span class="lineNum">    4327 </span>            : 
<span class="lineNum">    4328 </span><span class="lineCov">          1 :         if (slotSpan != baseobj-&gt;slotSpan()) {</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(ins-&gt;block()-&gt;id() &gt;= lastAddedBlock);</span>
<span class="lineNum">    4330 </span><span class="lineNoCov">          0 :             lastAddedBlock = ins-&gt;block()-&gt;id();</span>
<span class="lineNum">    4331 </span>            :         }
<span class="lineNum">    4332 </span>            :     }
<span class="lineNum">    4333 </span>            : 
<span class="lineNum">    4334 </span><span class="lineCov">          1 :     if (baseobj-&gt;slotSpan() != 0) {</span>
<span class="lineNum">    4335 </span>            :         // We found some definite properties, but their correctness is still
<span class="lineNum">    4336 </span>            :         // contingent on the correct frames being inlined. Add constraints to
<span class="lineNum">    4337 </span>            :         // invalidate the definite properties if additional functions could be
<span class="lineNum">    4338 </span>            :         // called at the inline frame sites.
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :         Vector&lt;MBasicBlock*&gt; exitBlocks(cx);</span>
<span class="lineNum">    4340 </span><span class="lineNoCov">          0 :         for (MBasicBlockIterator block(graph.begin()); block != graph.end(); block++) {</span>
<span class="lineNum">    4341 </span>            :             // Inlining decisions made after the last new property was added to
<span class="lineNum">    4342 </span>            :             // the object don't need to be frozen.
<span class="lineNum">    4343 </span><span class="lineNoCov">          0 :             if (block-&gt;id() &gt; lastAddedBlock)</span>
<span class="lineNum">    4344 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4345 </span><span class="lineNoCov">          0 :             if (MResumePoint* rp = block-&gt;callerResumePoint()) {</span>
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :                 if (block-&gt;numPredecessors() == 1 &amp;&amp; block-&gt;getPredecessor(0) == rp-&gt;block()) {</span>
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :                     JSScript* script = rp-&gt;block()-&gt;info().script();</span>
<span class="lineNum">    4348 </span><span class="lineNoCov">          0 :                     if (!AddClearDefiniteFunctionUsesInScript(cx, group, script, block-&gt;info().script()))</span>
<span class="lineNum">    4349 </span><span class="lineNoCov">          0 :                         return false;</span>
<span class="lineNum">    4350 </span>            :                 }
<span class="lineNum">    4351 </span>            :             }
<span class="lineNum">    4352 </span>            :         }
<span class="lineNum">    4353 </span>            :     }
<span class="lineNum">    4354 </span>            : 
<span class="lineNum">    4355 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">    4356 </span>            : }
<a name="4357"><span class="lineNum">    4357 </span>            : </a>
<span class="lineNum">    4358 </span>            : static bool
<span class="lineNum">    4359 </span><span class="lineCov">       1027 : ArgumentsUseCanBeLazy(JSContext* cx, JSScript* script, MInstruction* ins, size_t index,</span>
<span class="lineNum">    4360 </span>            :                       bool* argumentsContentsObserved)
<span class="lineNum">    4361 </span>            : {
<span class="lineNum">    4362 </span>            :     // We can read the frame's arguments directly for f.apply(x, arguments).
<span class="lineNum">    4363 </span><span class="lineCov">       1027 :     if (ins-&gt;isCall()) {</span>
<span class="lineNum">    4364 </span><span class="lineCov">        141 :         if (*ins-&gt;toCall()-&gt;resumePoint()-&gt;pc() == JSOP_FUNAPPLY &amp;&amp;</span>
<span class="lineNum">    4365 </span><span class="lineCov">         91 :             ins-&gt;toCall()-&gt;numActualArgs() == 2 &amp;&amp;</span>
<span class="lineNum">    4366 </span><span class="lineCov">         41 :             index == MCall::IndexOfArgument(1))</span>
<span class="lineNum">    4367 </span>            :         {
<span class="lineNum">    4368 </span><span class="lineCov">         41 :             *argumentsContentsObserved = true;</span>
<span class="lineNum">    4369 </span><span class="lineCov">         41 :             return true;</span>
<span class="lineNum">    4370 </span>            :         }
<span class="lineNum">    4371 </span>            :     }
<span class="lineNum">    4372 </span>            : 
<span class="lineNum">    4373 </span>            :     // arguments[i] can read fp-&gt;canonicalActualArg(i) directly.
<span class="lineNum">    4374 </span><span class="lineCov">        986 :     if (ins-&gt;isCallGetElement() &amp;&amp; index == 0) {</span>
<span class="lineNum">    4375 </span><span class="lineCov">        756 :         *argumentsContentsObserved = true;</span>
<span class="lineNum">    4376 </span><span class="lineCov">        756 :         return true;</span>
<span class="lineNum">    4377 </span>            :     }
<span class="lineNum">    4378 </span>            : 
<span class="lineNum">    4379 </span>            :     // MGetArgumentsObjectArg needs to be considered as a use that allows laziness.
<span class="lineNum">    4380 </span><span class="lineCov">        230 :     if (ins-&gt;isGetArgumentsObjectArg() &amp;&amp; index == 0)</span>
<span class="lineNum">    4381 </span><span class="lineCov">          6 :         return true;</span>
<span class="lineNum">    4382 </span>            : 
<span class="lineNum">    4383 </span>            :     // arguments.length length can read fp-&gt;numActualArgs() directly.
<span class="lineNum">    4384 </span>            :     // arguments.callee can read fp-&gt;callee() directly if the arguments object
<span class="lineNum">    4385 </span>            :     // is mapped.
<span class="lineNum">    4386 </span><span class="lineCov">        654 :     if (ins-&gt;isCallGetProperty() &amp;&amp; index == 0 &amp;&amp;</span>
<span class="lineNum">    4387 </span><span class="lineCov">        215 :         (ins-&gt;toCallGetProperty()-&gt;name() == cx-&gt;names().length ||</span>
<span class="lineNum">    4388 </span><span class="lineNoCov">          0 :          (script-&gt;hasMappedArgsObj() &amp;&amp; ins-&gt;toCallGetProperty()-&gt;name() == cx-&gt;names().callee)))</span>
<span class="lineNum">    4389 </span>            :     {
<span class="lineNum">    4390 </span><span class="lineCov">        215 :         return true;</span>
<span class="lineNum">    4391 </span>            :     }
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span><span class="lineCov">          9 :     return false;</span>
<span class="lineNum">    4394 </span>            : }
<a name="4395"><span class="lineNum">    4395 </span>            : </a>
<span class="lineNum">    4396 </span>            : bool
<span class="lineNum">    4397 </span><span class="lineCov">        135 : jit::AnalyzeArgumentsUsage(JSContext* cx, JSScript* scriptArg)</span>
<span class="lineNum">    4398 </span>            : {
<span class="lineNum">    4399 </span><span class="lineCov">        270 :     RootedScript script(cx, scriptArg);</span>
<span class="lineNum">    4400 </span><span class="lineCov">        270 :     AutoEnterAnalysis enter(cx);</span>
<span class="lineNum">    4401 </span>            : 
<span class="lineNum">    4402 </span><span class="lineCov">        135 :     MOZ_ASSERT(!script-&gt;analyzedArgsUsage());</span>
<span class="lineNum">    4403 </span>            : 
<span class="lineNum">    4404 </span>            :     // Treat the script as needing an arguments object until we determine it
<span class="lineNum">    4405 </span>            :     // does not need one. This both allows us to easily see where the arguments
<span class="lineNum">    4406 </span>            :     // object can escape through assignments to the function's named arguments,
<span class="lineNum">    4407 </span>            :     // and also simplifies handling of early returns.
<span class="lineNum">    4408 </span><span class="lineCov">        135 :     script-&gt;setNeedsArgsObj(true);</span>
<span class="lineNum">    4409 </span>            : 
<span class="lineNum">    4410 </span>            :     // Always construct arguments objects when in debug mode, for generator
<span class="lineNum">    4411 </span>            :     // scripts (generators can be suspended when speculation fails) or when
<span class="lineNum">    4412 </span>            :     // direct eval is present.
<span class="lineNum">    4413 </span>            :     //
<span class="lineNum">    4414 </span>            :     // FIXME: Don't build arguments for ES6 generator expressions.
<span class="lineNum">    4415 </span><span class="lineCov">        405 :     if (scriptArg-&gt;isDebuggee() ||</span>
<span class="lineNum">    4416 </span><span class="lineCov">        270 :         script-&gt;isStarGenerator() ||</span>
<span class="lineNum">    4417 </span><span class="lineCov">        270 :         script-&gt;isLegacyGenerator() ||</span>
<span class="lineNum">    4418 </span><span class="lineCov">        405 :         script-&gt;isAsync() ||</span>
<span class="lineNum">    4419 </span><span class="lineCov">        135 :         script-&gt;bindingsAccessedDynamically())</span>
<span class="lineNum">    4420 </span>            :     {
<span class="lineNum">    4421 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4422 </span>            :     }
<span class="lineNum">    4423 </span>            : 
<span class="lineNum">    4424 </span><span class="lineCov">        135 :     if (!jit::IsIonEnabled(cx))</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4426 </span>            : 
<span class="lineNum">    4427 </span>            :     static const uint32_t MAX_SCRIPT_SIZE = 10000;
<span class="lineNum">    4428 </span><span class="lineCov">        135 :     if (script-&gt;length() &gt; MAX_SCRIPT_SIZE)</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4430 </span>            : 
<span class="lineNum">    4431 </span><span class="lineCov">        135 :     if (!script-&gt;ensureHasTypes(cx))</span>
<span class="lineNum">    4432 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4433 </span>            : 
<span class="lineNum">    4434 </span><span class="lineCov">        135 :     TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);</span>
<span class="lineNum">    4435 </span><span class="lineCov">        270 :     TraceLoggerEvent event(TraceLogger_AnnotateScripts, script);</span>
<span class="lineNum">    4436 </span><span class="lineCov">        270 :     AutoTraceLog logScript(logger, event);</span>
<span class="lineNum">    4437 </span><span class="lineCov">        270 :     AutoTraceLog logCompile(logger, TraceLogger_IonAnalysis);</span>
<span class="lineNum">    4438 </span>            : 
<span class="lineNum">    4439 </span><span class="lineCov">        270 :     LifoAlloc alloc(TempAllocator::PreferredLifoChunkSize);</span>
<span class="lineNum">    4440 </span><span class="lineCov">        270 :     TempAllocator temp(&amp;alloc);</span>
<span class="lineNum">    4441 </span><span class="lineCov">        270 :     JitContext jctx(cx, &amp;temp);</span>
<span class="lineNum">    4442 </span>            : 
<span class="lineNum">    4443 </span><span class="lineCov">        135 :     if (!jit::CanLikelyAllocateMoreExecutableMemory())</span>
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4445 </span>            : 
<span class="lineNum">    4446 </span><span class="lineCov">        135 :     if (!cx-&gt;compartment()-&gt;ensureJitCompartmentExists(cx))</span>
<span class="lineNum">    4447 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4448 </span>            : 
<span class="lineNum">    4449 </span><span class="lineCov">        135 :     MIRGraph graph(&amp;temp);</span>
<span class="lineNum">    4450 </span><span class="lineCov">        135 :     InlineScriptTree* inlineScriptTree = InlineScriptTree::New(&amp;temp, nullptr, nullptr, script);</span>
<span class="lineNum">    4451 </span><span class="lineCov">        135 :     if (!inlineScriptTree) {</span>
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4453 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4454 </span>            :     }
<span class="lineNum">    4455 </span>            : 
<span class="lineNum">    4456 </span><span class="lineCov">        135 :     CompileInfo info(script, script-&gt;functionNonDelazifying(),</span>
<span class="lineNum">    4457 </span>            :                      /* osrPc = */ nullptr,
<span class="lineNum">    4458 </span>            :                      Analysis_ArgumentsUsage,
<span class="lineNum">    4459 </span>            :                      /* needsArgsObj = */ true,
<span class="lineNum">    4460 </span><span class="lineCov">        270 :                      inlineScriptTree);</span>
<span class="lineNum">    4461 </span>            : 
<span class="lineNum">    4462 </span><span class="lineCov">        135 :     const OptimizationInfo* optimizationInfo = IonOptimizations.get(OptimizationLevel::Normal);</span>
<span class="lineNum">    4463 </span>            : 
<span class="lineNum">    4464 </span><span class="lineCov">        135 :     CompilerConstraintList* constraints = NewCompilerConstraintList(temp);</span>
<span class="lineNum">    4465 </span><span class="lineCov">        135 :     if (!constraints) {</span>
<span class="lineNum">    4466 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4467 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4468 </span>            :     }
<span class="lineNum">    4469 </span>            : 
<span class="lineNum">    4470 </span><span class="lineCov">        135 :     BaselineInspector inspector(script);</span>
<span class="lineNum">    4471 </span><span class="lineCov">        135 :     const JitCompileOptions options(cx);</span>
<span class="lineNum">    4472 </span>            : 
<span class="lineNum">    4473 </span>            :     IonBuilder builder(nullptr, CompileCompartment::get(cx-&gt;compartment()), options, &amp;temp, &amp;graph, constraints,
<span class="lineNum">    4474 </span><span class="lineCov">        270 :                        &amp;inspector, &amp;info, optimizationInfo, /* baselineFrame = */ nullptr);</span>
<span class="lineNum">    4475 </span>            : 
<span class="lineNum">    4476 </span><span class="lineCov">        135 :     AbortReasonOr&lt;Ok&gt; buildResult = builder.build();</span>
<span class="lineNum">    4477 </span><span class="lineCov">        135 :     if (buildResult.isErr()) {</span>
<span class="lineNum">    4478 </span><span class="lineCov">          3 :         AbortReason reason = buildResult.unwrapErr();</span>
<span class="lineNum">    4479 </span><span class="lineCov">          3 :         if (cx-&gt;isThrowingOverRecursed() || cx-&gt;isThrowingOutOfMemory())</span>
<span class="lineNum">    4480 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4481 </span><span class="lineCov">          3 :         if (reason == AbortReason::Alloc) {</span>
<span class="lineNum">    4482 </span><span class="lineNoCov">          0 :             ReportOutOfMemory(cx);</span>
<span class="lineNum">    4483 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    4484 </span>            :         }
<span class="lineNum">    4485 </span><span class="lineCov">          3 :         MOZ_ASSERT(!cx-&gt;isExceptionPending());</span>
<span class="lineNum">    4486 </span><span class="lineCov">          3 :         return true;</span>
<span class="lineNum">    4487 </span>            :     }
<span class="lineNum">    4488 </span>            : 
<span class="lineNum">    4489 </span><span class="lineCov">        132 :     if (!SplitCriticalEdges(graph)) {</span>
<span class="lineNum">    4490 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4491 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4492 </span>            :     }
<span class="lineNum">    4493 </span>            : 
<span class="lineNum">    4494 </span><span class="lineCov">        132 :     RenumberBlocks(graph);</span>
<span class="lineNum">    4495 </span>            : 
<span class="lineNum">    4496 </span><span class="lineCov">        132 :     if (!BuildDominatorTree(graph)) {</span>
<span class="lineNum">    4497 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4498 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4499 </span>            :     }
<span class="lineNum">    4500 </span>            : 
<span class="lineNum">    4501 </span><span class="lineCov">        132 :     if (!EliminatePhis(&amp;builder, graph, AggressiveObservability)) {</span>
<span class="lineNum">    4502 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">    4503 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4504 </span>            :     }
<span class="lineNum">    4505 </span>            : 
<span class="lineNum">    4506 </span><span class="lineCov">        132 :     MDefinition* argumentsValue = graph.entryBlock()-&gt;getSlot(info.argsObjSlot());</span>
<span class="lineNum">    4507 </span>            : 
<span class="lineNum">    4508 </span><span class="lineCov">        132 :     bool argumentsContentsObserved = false;</span>
<span class="lineNum">    4509 </span>            : 
<span class="lineNum">    4510 </span><span class="lineCov">       1150 :     for (MUseDefIterator uses(argumentsValue); uses; uses++) {</span>
<span class="lineNum">    4511 </span><span class="lineCov">       1027 :         MDefinition* use = uses.def();</span>
<span class="lineNum">    4512 </span>            : 
<span class="lineNum">    4513 </span>            :         // Don't track |arguments| through assignments to phis.
<span class="lineNum">    4514 </span><span class="lineCov">       1027 :         if (!use-&gt;isInstruction())</span>
<span class="lineNum">    4515 </span><span class="lineCov">          9 :             return true;</span>
<span class="lineNum">    4516 </span>            : 
<span class="lineNum">    4517 </span><span class="lineCov">       2054 :         if (!ArgumentsUseCanBeLazy(cx, script, use-&gt;toInstruction(), use-&gt;indexOf(uses.use()),</span>
<span class="lineNum">    4518 </span><span class="lineCov">       1027 :                                    &amp;argumentsContentsObserved))</span>
<span class="lineNum">    4519 </span>            :         {
<span class="lineNum">    4520 </span><span class="lineCov">          9 :             return true;</span>
<span class="lineNum">    4521 </span>            :         }
<span class="lineNum">    4522 </span>            :     }
<span class="lineNum">    4523 </span>            : 
<span class="lineNum">    4524 </span>            :     // If a script explicitly accesses the contents of 'arguments', and has
<span class="lineNum">    4525 </span>            :     // formals which may be stored as part of a call object, don't use lazy
<span class="lineNum">    4526 </span>            :     // arguments. The compiler can then assume that accesses through
<span class="lineNum">    4527 </span>            :     // arguments[i] will be on unaliased variables.
<span class="lineNum">    4528 </span><span class="lineCov">        123 :     if (script-&gt;funHasAnyAliasedFormal() &amp;&amp; argumentsContentsObserved)</span>
<span class="lineNum">    4529 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4530 </span>            : 
<span class="lineNum">    4531 </span><span class="lineCov">        123 :     script-&gt;setNeedsArgsObj(false);</span>
<span class="lineNum">    4532 </span><span class="lineCov">        123 :     return true;</span>
<span class="lineNum">    4533 </span>            : }
<span class="lineNum">    4534 </span>            : 
<span class="lineNum">    4535 </span>            : // Mark all the blocks that are in the loop with the given header.
<span class="lineNum">    4536 </span>            : // Returns the number of blocks marked. Set *canOsr to true if the loop is
<a name="4537"><span class="lineNum">    4537 </span>            : // reachable from both the normal entry and the OSR entry.</a>
<span class="lineNum">    4538 </span>            : size_t
<span class="lineNum">    4539 </span><span class="lineCov">         15 : jit::MarkLoopBlocks(MIRGraph&amp; graph, MBasicBlock* header, bool* canOsr)</span>
<span class="lineNum">    4540 </span>            : {
<span class="lineNum">    4541 </span>            : #ifdef DEBUG
<span class="lineNum">    4542 </span><span class="lineCov">       1158 :     for (ReversePostorderIterator i = graph.rpoBegin(), e = graph.rpoEnd(); i != e; ++i)</span>
<span class="lineNum">    4543 </span><span class="lineCov">       1143 :         MOZ_ASSERT(!i-&gt;isMarked(), &quot;Some blocks already marked&quot;);</span>
<span class="lineNum">    4544 </span>            : #endif
<span class="lineNum">    4545 </span>            : 
<span class="lineNum">    4546 </span><span class="lineCov">         15 :     MBasicBlock* osrBlock = graph.osrBlock();</span>
<span class="lineNum">    4547 </span><span class="lineCov">         15 :     *canOsr = false;</span>
<span class="lineNum">    4548 </span>            : 
<span class="lineNum">    4549 </span>            :     // The blocks are in RPO; start at the loop backedge, which marks the bottom
<span class="lineNum">    4550 </span>            :     // of the loop, and walk up until we get to the header. Loops may be
<span class="lineNum">    4551 </span>            :     // discontiguous, so we trace predecessors to determine which blocks are
<span class="lineNum">    4552 </span>            :     // actually part of the loop. The backedge is always part of the loop, and
<span class="lineNum">    4553 </span>            :     // so are its predecessors, transitively, up to the loop header or an OSR
<span class="lineNum">    4554 </span>            :     // entry.
<span class="lineNum">    4555 </span><span class="lineCov">         15 :     MBasicBlock* backedge = header-&gt;backedge();</span>
<span class="lineNum">    4556 </span><span class="lineCov">         15 :     backedge-&gt;mark();</span>
<span class="lineNum">    4557 </span><span class="lineCov">         15 :     size_t numMarked = 1;</span>
<span class="lineNum">    4558 </span><span class="lineCov">        954 :     for (PostorderIterator i = graph.poBegin(backedge); ; ++i) {</span>
<span class="lineNum">    4559 </span><span class="lineCov">        954 :         MOZ_ASSERT(i != graph.poEnd(),</span>
<span class="lineNum">    4560 </span>            :                    &quot;Reached the end of the graph while searching for the loop header&quot;);
<span class="lineNum">    4561 </span><span class="lineCov">        954 :         MBasicBlock* block = *i;</span>
<span class="lineNum">    4562 </span>            :         // If we've reached the loop header, we're done.
<span class="lineNum">    4563 </span><span class="lineCov">        954 :         if (block == header)</span>
<span class="lineNum">    4564 </span><span class="lineCov">         15 :             break;</span>
<span class="lineNum">    4565 </span>            :         // A block not marked by the time we reach it is not in the loop.
<span class="lineNum">    4566 </span><span class="lineCov">        939 :         if (!block-&gt;isMarked())</span>
<span class="lineNum">    4567 </span><span class="lineCov">         75 :             continue;</span>
<span class="lineNum">    4568 </span>            : 
<span class="lineNum">    4569 </span>            :         // This block is in the loop; trace to its predecessors.
<span class="lineNum">    4570 </span><span class="lineCov">       1926 :         for (size_t p = 0, e = block-&gt;numPredecessors(); p != e; ++p) {</span>
<span class="lineNum">    4571 </span><span class="lineCov">       1062 :             MBasicBlock* pred = block-&gt;getPredecessor(p);</span>
<span class="lineNum">    4572 </span><span class="lineCov">       1062 :             if (pred-&gt;isMarked())</span>
<span class="lineNum">    4573 </span><span class="lineCov">        198 :                 continue;</span>
<span class="lineNum">    4574 </span>            : 
<span class="lineNum">    4575 </span>            :             // Blocks dominated by the OSR entry are not part of the loop
<span class="lineNum">    4576 </span>            :             // (unless they aren't reachable from the normal entry).
<span class="lineNum">    4577 </span><span class="lineCov">       2211 :             if (osrBlock &amp;&amp; pred != header &amp;&amp;</span>
<span class="lineNum">    4578 </span><span class="lineCov">       1533 :                 osrBlock-&gt;dominates(pred) &amp;&amp; !osrBlock-&gt;dominates(header))</span>
<span class="lineNum">    4579 </span>            :             {
<span class="lineNum">    4580 </span><span class="lineNoCov">          0 :                 *canOsr = true;</span>
<span class="lineNum">    4581 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    4582 </span>            :             }
<span class="lineNum">    4583 </span>            : 
<span class="lineNum">    4584 </span><span class="lineCov">        864 :             MOZ_ASSERT(pred-&gt;id() &gt;= header-&gt;id() &amp;&amp; pred-&gt;id() &lt;= backedge-&gt;id(),</span>
<span class="lineNum">    4585 </span>            :                        &quot;Loop block not between loop header and loop backedge&quot;);
<span class="lineNum">    4586 </span>            : 
<span class="lineNum">    4587 </span><span class="lineCov">        864 :             pred-&gt;mark();</span>
<span class="lineNum">    4588 </span><span class="lineCov">        864 :             ++numMarked;</span>
<span class="lineNum">    4589 </span>            : 
<span class="lineNum">    4590 </span>            :             // A nested loop may not exit back to the enclosing loop at its
<span class="lineNum">    4591 </span>            :             // bottom. If we just marked its header, then the whole nested loop
<span class="lineNum">    4592 </span>            :             // is part of the enclosing loop.
<span class="lineNum">    4593 </span><span class="lineCov">        864 :             if (pred-&gt;isLoopHeader()) {</span>
<span class="lineNum">    4594 </span><span class="lineCov">         15 :                 MBasicBlock* innerBackedge = pred-&gt;backedge();</span>
<span class="lineNum">    4595 </span><span class="lineCov">         15 :                 if (!innerBackedge-&gt;isMarked()) {</span>
<span class="lineNum">    4596 </span>            :                     // Mark its backedge so that we add all of its blocks to the
<span class="lineNum">    4597 </span>            :                     // outer loop as we walk upwards.
<span class="lineNum">    4598 </span><span class="lineNoCov">          0 :                     innerBackedge-&gt;mark();</span>
<span class="lineNum">    4599 </span><span class="lineNoCov">          0 :                     ++numMarked;</span>
<span class="lineNum">    4600 </span>            : 
<span class="lineNum">    4601 </span>            :                     // If the nested loop is not contiguous, we may have already
<span class="lineNum">    4602 </span>            :                     // passed its backedge. If this happens, back up.
<span class="lineNum">    4603 </span><span class="lineNoCov">          0 :                     if (innerBackedge-&gt;id() &gt; block-&gt;id()) {</span>
<span class="lineNum">    4604 </span><span class="lineNoCov">          0 :                         i = graph.poBegin(innerBackedge);</span>
<span class="lineNum">    4605 </span><span class="lineNoCov">          0 :                         --i;</span>
<span class="lineNum">    4606 </span>            :                     }
<span class="lineNum">    4607 </span>            :                 }
<span class="lineNum">    4608 </span>            :             }
<span class="lineNum">    4609 </span>            :         }
<span class="lineNum">    4610 </span><span class="lineCov">        939 :     }</span>
<span class="lineNum">    4611 </span>            : 
<span class="lineNum">    4612 </span>            :     // If there's no path connecting the header to the backedge, then this isn't
<span class="lineNum">    4613 </span>            :     // actually a loop. This can happen when the code starts with a loop but GVN
<span class="lineNum">    4614 </span>            :     // folds some branches away.
<span class="lineNum">    4615 </span><span class="lineCov">         15 :     if (!header-&gt;isMarked()) {</span>
<span class="lineNum">    4616 </span><span class="lineNoCov">          0 :         jit::UnmarkLoopBlocks(graph, header);</span>
<span class="lineNum">    4617 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    4618 </span>            :     }
<span class="lineNum">    4619 </span>            : 
<span class="lineNum">    4620 </span><span class="lineCov">         15 :     return numMarked;</span>
<span class="lineNum">    4621 </span>            : }
<span class="lineNum">    4622 </span>            : 
<a name="4623"><span class="lineNum">    4623 </span>            : // Unmark all the blocks that are in the loop with the given header.</a>
<span class="lineNum">    4624 </span>            : void
<span class="lineNum">    4625 </span><span class="lineCov">         10 : jit::UnmarkLoopBlocks(MIRGraph&amp; graph, MBasicBlock* header)</span>
<span class="lineNum">    4626 </span>            : {
<span class="lineNum">    4627 </span><span class="lineCov">         10 :     MBasicBlock* backedge = header-&gt;backedge();</span>
<span class="lineNum">    4628 </span><span class="lineCov">        636 :     for (ReversePostorderIterator i = graph.rpoBegin(header); ; ++i) {</span>
<span class="lineNum">    4629 </span><span class="lineCov">        636 :         MOZ_ASSERT(i != graph.rpoEnd(),</span>
<span class="lineNum">    4630 </span>            :                    &quot;Reached the end of the graph while searching for the backedge&quot;);
<span class="lineNum">    4631 </span><span class="lineCov">        636 :         MBasicBlock* block = *i;</span>
<span class="lineNum">    4632 </span><span class="lineCov">        636 :         if (block-&gt;isMarked()) {</span>
<span class="lineNum">    4633 </span><span class="lineCov">        586 :             block-&gt;unmark();</span>
<span class="lineNum">    4634 </span><span class="lineCov">        586 :             if (block == backedge)</span>
<span class="lineNum">    4635 </span><span class="lineCov">         10 :                 break;</span>
<span class="lineNum">    4636 </span>            :         }
<span class="lineNum">    4637 </span><span class="lineCov">        626 :     }</span>
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span>            : #ifdef DEBUG
<span class="lineNum">    4640 </span><span class="lineCov">        772 :     for (ReversePostorderIterator i = graph.rpoBegin(), e = graph.rpoEnd(); i != e; ++i)</span>
<span class="lineNum">    4641 </span><span class="lineCov">        762 :         MOZ_ASSERT(!i-&gt;isMarked(), &quot;Not all blocks got unmarked&quot;);</span>
<span class="lineNum">    4642 </span>            : #endif
<span class="lineNum">    4643 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">    4644 </span>            : 
<a name="4645"><span class="lineNum">    4645 </span>            : // Reorder the blocks in the loop starting at the given header to be contiguous.</a>
<span class="lineNum">    4646 </span>            : static void
<span class="lineNum">    4647 </span><span class="lineCov">          5 : MakeLoopContiguous(MIRGraph&amp; graph, MBasicBlock* header, size_t numMarked)</span>
<span class="lineNum">    4648 </span>            : {
<span class="lineNum">    4649 </span><span class="lineCov">          5 :     MBasicBlock* backedge = header-&gt;backedge();</span>
<span class="lineNum">    4650 </span>            : 
<span class="lineNum">    4651 </span><span class="lineCov">          5 :     MOZ_ASSERT(header-&gt;isMarked(), &quot;Loop header is not part of loop&quot;);</span>
<span class="lineNum">    4652 </span><span class="lineCov">          5 :     MOZ_ASSERT(backedge-&gt;isMarked(), &quot;Loop backedge is not part of loop&quot;);</span>
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span>            :     // If there are any blocks between the loop header and the loop backedge
<span class="lineNum">    4655 </span>            :     // that are not part of the loop, prepare to move them to the end. We keep
<span class="lineNum">    4656 </span>            :     // them in order, which preserves RPO.
<span class="lineNum">    4657 </span><span class="lineCov">          5 :     ReversePostorderIterator insertIter = graph.rpoBegin(backedge);</span>
<span class="lineNum">    4658 </span><span class="lineCov">          5 :     insertIter++;</span>
<span class="lineNum">    4659 </span><span class="lineCov">          5 :     MBasicBlock* insertPt = *insertIter;</span>
<span class="lineNum">    4660 </span>            : 
<span class="lineNum">    4661 </span>            :     // Visit all the blocks from the loop header to the loop backedge.
<span class="lineNum">    4662 </span><span class="lineCov">          5 :     size_t headerId = header-&gt;id();</span>
<span class="lineNum">    4663 </span><span class="lineCov">          5 :     size_t inLoopId = headerId;</span>
<span class="lineNum">    4664 </span><span class="lineCov">          5 :     size_t notInLoopId = inLoopId + numMarked;</span>
<span class="lineNum">    4665 </span><span class="lineCov">          5 :     ReversePostorderIterator i = graph.rpoBegin(header);</span>
<span class="lineNum">    4666 </span>            :     for (;;) {
<span class="lineNum">    4667 </span><span class="lineCov">        318 :         MBasicBlock* block = *i++;</span>
<span class="lineNum">    4668 </span><span class="lineCov">        318 :         MOZ_ASSERT(block-&gt;id() &gt;= header-&gt;id() &amp;&amp; block-&gt;id() &lt;= backedge-&gt;id(),</span>
<span class="lineNum">    4669 </span>            :                    &quot;Loop backedge should be last block in loop&quot;);
<span class="lineNum">    4670 </span>            : 
<span class="lineNum">    4671 </span><span class="lineCov">        318 :         if (block-&gt;isMarked()) {</span>
<span class="lineNum">    4672 </span>            :             // This block is in the loop.
<span class="lineNum">    4673 </span><span class="lineCov">        293 :             block-&gt;unmark();</span>
<span class="lineNum">    4674 </span><span class="lineCov">        293 :             block-&gt;setId(inLoopId++);</span>
<span class="lineNum">    4675 </span>            :             // If we've reached the loop backedge, we're done!
<span class="lineNum">    4676 </span><span class="lineCov">        293 :             if (block == backedge)</span>
<span class="lineNum">    4677 </span><span class="lineCov">          5 :                 break;</span>
<span class="lineNum">    4678 </span>            :         } else {
<span class="lineNum">    4679 </span>            :             // This block is not in the loop. Move it to the end.
<span class="lineNum">    4680 </span><span class="lineCov">         25 :             graph.moveBlockBefore(insertPt, block);</span>
<span class="lineNum">    4681 </span><span class="lineCov">         25 :             block-&gt;setId(notInLoopId++);</span>
<span class="lineNum">    4682 </span>            :         }
<span class="lineNum">    4683 </span><span class="lineCov">        313 :     }</span>
<span class="lineNum">    4684 </span><span class="lineCov">          5 :     MOZ_ASSERT(header-&gt;id() == headerId, &quot;Loop header id changed&quot;);</span>
<span class="lineNum">    4685 </span><span class="lineCov">          5 :     MOZ_ASSERT(inLoopId == headerId + numMarked, &quot;Wrong number of blocks kept in loop&quot;);</span>
<span class="lineNum">    4686 </span><span class="lineCov">          5 :     MOZ_ASSERT(notInLoopId == (insertIter != graph.rpoEnd() ? insertPt-&gt;id() : graph.numBlocks()),</span>
<span class="lineNum">    4687 </span>            :                &quot;Wrong number of blocks moved out of loop&quot;);
<span class="lineNum">    4688 </span><span class="lineCov">          5 : }</span>
<span class="lineNum">    4689 </span>            : 
<a name="4690"><span class="lineNum">    4690 </span>            : // Reorder the blocks in the graph so that loops are contiguous.</a>
<span class="lineNum">    4691 </span>            : bool
<span class="lineNum">    4692 </span><span class="lineCov">          8 : jit::MakeLoopsContiguous(MIRGraph&amp; graph)</span>
<span class="lineNum">    4693 </span>            : {
<span class="lineNum">    4694 </span>            :     // Visit all loop headers (in any order).
<span class="lineNum">    4695 </span><span class="lineCov">        411 :     for (MBasicBlockIterator i(graph.begin()); i != graph.end(); i++) {</span>
<span class="lineNum">    4696 </span><span class="lineCov">        403 :         MBasicBlock* header = *i;</span>
<span class="lineNum">    4697 </span><span class="lineCov">        403 :         if (!header-&gt;isLoopHeader())</span>
<span class="lineNum">    4698 </span><span class="lineCov">        796 :             continue;</span>
<span class="lineNum">    4699 </span>            : 
<span class="lineNum">    4700 </span>            :         // Mark all blocks that are actually part of the loop.
<span class="lineNum">    4701 </span>            :         bool canOsr;
<span class="lineNum">    4702 </span><span class="lineCov">          5 :         size_t numMarked = MarkLoopBlocks(graph, header, &amp;canOsr);</span>
<span class="lineNum">    4703 </span>            : 
<span class="lineNum">    4704 </span>            :         // If the loop isn't a loop, don't try to optimize it.
<span class="lineNum">    4705 </span><span class="lineCov">          5 :         if (numMarked == 0)</span>
<span class="lineNum">    4706 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span>            :         // If there's an OSR block entering the loop in the middle, it's tricky,
<span class="lineNum">    4709 </span>            :         // so don't try to handle it, for now.
<span class="lineNum">    4710 </span><span class="lineCov">          5 :         if (canOsr) {</span>
<span class="lineNum">    4711 </span><span class="lineNoCov">          0 :             UnmarkLoopBlocks(graph, header);</span>
<span class="lineNum">    4712 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    4713 </span>            :         }
<span class="lineNum">    4714 </span>            : 
<span class="lineNum">    4715 </span>            :         // Move all blocks between header and backedge that aren't marked to
<span class="lineNum">    4716 </span>            :         // the end of the loop, making the loop itself contiguous.
<span class="lineNum">    4717 </span><span class="lineCov">          5 :         MakeLoopContiguous(graph, header, numMarked);</span>
<span class="lineNum">    4718 </span>            :     }
<span class="lineNum">    4719 </span>            : 
<span class="lineNum">    4720 </span><span class="lineCov">          8 :     return true;</span>
<a name="4721"><span class="lineNum">    4721 </span>            : }</a>
<span class="lineNum">    4722 </span>            : 
<span class="lineNum">    4723 </span><span class="lineCov">          8 : MRootList::MRootList(TempAllocator&amp; alloc)</span>
<span class="lineNum">    4724 </span>            : {
<span class="lineNum">    4725 </span>            : #define INIT_VECTOR(name, _0, _1) \
<span class="lineNum">    4726 </span>            :     roots_[JS::RootKind::name].emplace(alloc);
<span class="lineNum">    4727 </span><span class="lineCov">          8 : JS_FOR_EACH_TRACEKIND(INIT_VECTOR)</span>
<span class="lineNum">    4728 </span>            : #undef INIT_VECTOR
<span class="lineNum">    4729 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">    4730 </span>            : 
<a name="4731"><span class="lineNum">    4731 </span>            : template &lt;typename T&gt;</a>
<span class="lineNum">    4732 </span>            : static void
<span class="lineNum">    4733 </span><span class="lineCov">         22 : TraceVector(JSTracer* trc, const MRootList::RootVector&amp; vector, const char* name)</span>
<span class="lineNum">    4734 </span>            : {
<span class="lineNum">    4735 </span><span class="lineCov">        160 :     for (auto ptr : vector) {</span>
<span class="lineNum">    4736 </span><span class="lineCov">        138 :         T ptrT = static_cast&lt;T&gt;(ptr);</span>
<span class="lineNum">    4737 </span><span class="lineCov">        138 :         TraceManuallyBarrieredEdge(trc, &amp;ptrT, name);</span>
<span class="lineNum">    4738 </span><span class="lineCov">        138 :         MOZ_ASSERT(ptr == ptrT, &quot;Shouldn't move without updating MIR pointers&quot;);</span>
<span class="lineNum">    4739 </span>            :     }
<span class="lineNum">    4740 </span><span class="lineCov">         22 : }</span>
<a name="4741"><span class="lineNum">    4741 </span>            : </a>
<span class="lineNum">    4742 </span>            : void
<span class="lineNum">    4743 </span><span class="lineCov">          2 : MRootList::trace(JSTracer* trc)</span>
<span class="lineNum">    4744 </span>            : {
<span class="lineNum">    4745 </span>            : #define TRACE_ROOTS(name, type, _) \
<span class="lineNum">    4746 </span>            :     TraceVector&lt;type*&gt;(trc, *roots_[JS::RootKind::name], &quot;mir-root-&quot; #name);
<span class="lineNum">    4747 </span><span class="lineCov">          2 : JS_FOR_EACH_TRACEKIND(TRACE_ROOTS)</span>
<span class="lineNum">    4748 </span>            : #undef TRACE_ROOTS
<span class="lineNum">    4749 </span><span class="lineCov">          2 : }</span>
<a name="4750"><span class="lineNum">    4750 </span>            : </a>
<span class="lineNum">    4751 </span>            : MOZ_MUST_USE bool
<span class="lineNum">    4752 </span><span class="lineCov">          8 : jit::CreateMIRRootList(IonBuilder&amp; builder)</span>
<span class="lineNum">    4753 </span>            : {
<span class="lineNum">    4754 </span><span class="lineCov">          8 :     MOZ_ASSERT(!builder.info().isAnalysis());</span>
<span class="lineNum">    4755 </span>            : 
<span class="lineNum">    4756 </span><span class="lineCov">          8 :     TempAllocator&amp; alloc = builder.alloc();</span>
<span class="lineNum">    4757 </span><span class="lineCov">          8 :     MIRGraph&amp; graph = builder.graph();</span>
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span><span class="lineCov">          8 :     MRootList* roots = new(alloc.fallible()) MRootList(alloc);</span>
<span class="lineNum">    4760 </span><span class="lineCov">          8 :     if (!roots)</span>
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4762 </span>            : 
<span class="lineNum">    4763 </span><span class="lineCov">          8 :     JSScript* prevScript = nullptr;</span>
<span class="lineNum">    4764 </span>            : 
<span class="lineNum">    4765 </span><span class="lineCov">        652 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">    4766 </span>            : 
<span class="lineNum">    4767 </span><span class="lineCov">        644 :         JSScript* script = block-&gt;info().script();</span>
<span class="lineNum">    4768 </span><span class="lineCov">        644 :         if (script != prevScript) {</span>
<span class="lineNum">    4769 </span><span class="lineCov">         48 :             if (!roots-&gt;append(script))</span>
<span class="lineNum">    4770 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    4771 </span><span class="lineCov">         48 :             prevScript = script;</span>
<span class="lineNum">    4772 </span>            :         }
<span class="lineNum">    4773 </span>            : 
<span class="lineNum">    4774 </span><span class="lineCov">       3107 :         for (MInstructionIterator iter(block-&gt;begin()), end(block-&gt;end()); iter != end; iter++) {</span>
<span class="lineNum">    4775 </span><span class="lineCov">       2463 :             if (!iter-&gt;appendRoots(*roots))</span>
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    4777 </span>            :         }
<span class="lineNum">    4778 </span>            :     }
<span class="lineNum">    4779 </span>            : 
<span class="lineNum">    4780 </span><span class="lineCov">          8 :     builder.setRootList(*roots);</span>
<span class="lineNum">    4781 </span><span class="lineCov">          8 :     return true;</span>
<span class="lineNum">    4782 </span>            : }
<a name="4783"><span class="lineNum">    4783 </span>            : </a>
<span class="lineNum">    4784 </span>            : static void
<span class="lineNum">    4785 </span><span class="lineNoCov">          0 : DumpDefinition(GenericPrinter&amp; out, MDefinition* def, size_t depth)</span>
<span class="lineNum">    4786 </span>            : {
<span class="lineNum">    4787 </span><span class="lineNoCov">          0 :     MDefinition::PrintOpcodeName(out, def-&gt;op());</span>
<span class="lineNum">    4788 </span>            : 
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :     if (depth == 0)</span>
<span class="lineNum">    4790 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    4791 </span>            : 
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; def-&gt;numOperands(); i++) {</span>
<span class="lineNum">    4793 </span><span class="lineNoCov">          0 :         out.printf(&quot; (&quot;);</span>
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :         DumpDefinition(out, def-&gt;getOperand(i), depth - 1);</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :         out.printf(&quot;)&quot;);</span>
<span class="lineNum">    4796 </span>            :     }
<span class="lineNum">    4797 </span>            : }
<a name="4798"><span class="lineNum">    4798 </span>            : </a>
<span class="lineNum">    4799 </span>            : void
<span class="lineNum">    4800 </span><span class="lineCov">          8 : jit::DumpMIRExpressions(MIRGraph&amp; graph)</span>
<span class="lineNum">    4801 </span>            : {
<span class="lineNum">    4802 </span><span class="lineCov">          8 :     if (!JitSpewEnabled(JitSpew_MIRExpressions))</span>
<span class="lineNum">    4803 </span><span class="lineCov">          8 :         return;</span>
<span class="lineNum">    4804 </span>            : 
<span class="lineNum">    4805 </span><span class="lineNoCov">          0 :     size_t depth = 2;</span>
<span class="lineNum">    4806 </span>            : 
<span class="lineNum">    4807 </span><span class="lineNoCov">          0 :     Fprinter&amp; out = JitSpewPrinter();</span>
<span class="lineNum">    4808 </span><span class="lineNoCov">          0 :     for (ReversePostorderIterator block(graph.rpoBegin()); block != graph.rpoEnd(); block++) {</span>
<span class="lineNum">    4809 </span><span class="lineNoCov">          0 :         for (MInstructionIterator iter(block-&gt;begin()), end(block-&gt;end()); iter != end; iter++) {</span>
<span class="lineNum">    4810 </span><span class="lineNoCov">          0 :             DumpDefinition(out, *iter, depth);</span>
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :             out.printf(&quot;\n&quot;);</span>
<span class="lineNum">    4812 </span>            :         }
<span class="lineNum">    4813 </span>            :     }
<span class="lineNum">    4814 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

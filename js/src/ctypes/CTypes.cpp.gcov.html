<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/ctypes/CTypes.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/ctypes</a> - CTypes.cpp<span style="font-size: 80%;"> (source / <a href="CTypes.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">268</td>
            <td class="headerCovTableEntry">3987</td>
            <td class="headerCovTableEntryLo">6.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntry">703</td>
            <td class="headerCovTableEntryLo">4.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;ctypes/CTypes.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/FloatingPoint.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/SizePrintfMacros.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Sprintf.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Vector.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;limits&gt;
<span class="lineNum">      16 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #if defined(XP_WIN)
<span class="lineNum">      20 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      21 </span>            : #endif
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #if defined(SOLARIS)
<span class="lineNum">      24 </span>            : #include &lt;ieeefp.h&gt;
<span class="lineNum">      25 </span>            : #endif
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #ifdef HAVE_SSIZE_T
<span class="lineNum">      28 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      29 </span>            : #endif
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #if defined(XP_UNIX)
<span class="lineNum">      32 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      33 </span>            : #endif
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &quot;jscntxt.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;jsexn.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;jsfun.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;jsnum.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;jsprf.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;jswin.h&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #include &quot;builtin/TypedObject.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;ctypes/Library.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;gc/Policy.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;gc/Zone.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;jit/AtomicOperations.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;js/Vector.h&quot;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #include &quot;jsatominlines.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;jsobjinlines.h&quot;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : using namespace std;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : using JS::AutoCheckCannotGC;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : namespace js {
<span class="lineNum">      57 </span>            : namespace ctypes {
<span class="lineNum">      58 </span>            : 
<a name="59"><span class="lineNum">      59 </span>            : template &lt;typename CharT&gt;</a>
<span class="lineNum">      60 </span>            : size_t
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : GetDeflatedUTF8StringLength(JSContext* maybecx, const CharT* chars,</span>
<span class="lineNum">      62 </span>            :                             size_t nchars)
<span class="lineNum">      63 </span>            : {
<span class="lineNum">      64 </span>            :     size_t nbytes;
<span class="lineNum">      65 </span>            :     const CharT* end;
<span class="lineNum">      66 </span>            :     unsigned c, c2;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     nbytes = nchars;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     for (end = chars + nchars; chars != end; chars++) {</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :         c = *chars;</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :         if (c &lt; 0x80)</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         if (0xD800 &lt;= c &amp;&amp; c &lt;= 0xDFFF) {</span>
<span class="lineNum">      74 </span>            :             /* Surrogate pair. */
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :             chars++;</span>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :             /* nbytes sets 1 length since this is surrogate pair. */
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :             nbytes--;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :             if (c &gt;= 0xDC00 || chars == end)</span>
<span class="lineNum">      80 </span>            :                 goto bad_surrogate;
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :             c2 = *chars;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :             if (c2 &lt; 0xDC00 || c2 &gt; 0xDFFF)</span>
<span class="lineNum">      83 </span>            :                 goto bad_surrogate;
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :             c = ((c - 0xD800) &lt;&lt; 10) + (c2 - 0xDC00) + 0x10000;</span>
<span class="lineNum">      85 </span>            :         }
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         c &gt;&gt;= 11;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         nbytes++;</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         while (c) {</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :             c &gt;&gt;= 5;</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :             nbytes++;</span>
<span class="lineNum">      91 </span>            :         }
<span class="lineNum">      92 </span>            :     }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     return nbytes;</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :   bad_surrogate:
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     if (maybecx) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :         js::gc::AutoSuppressGC suppress(maybecx);</span>
<span class="lineNum">      98 </span>            :         char buffer[10];
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :         SprintfLiteral(buffer, &quot;0x%x&quot;, c);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :         JS_ReportErrorFlagsAndNumberASCII(maybecx, JSREPORT_ERROR,</span>
<span class="lineNum">     101 </span>            :                                           GetErrorMessage,
<span class="lineNum">     102 </span>            :                                           nullptr, JSMSG_BAD_SURROGATE_CHAR,
<span class="lineNum">     103 </span>            :                                           buffer);
<span class="lineNum">     104 </span>            :     }
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     return (size_t) -1;</span>
<span class="lineNum">     106 </span>            : }
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : template size_t
<span class="lineNum">     109 </span>            : GetDeflatedUTF8StringLength(JSContext* maybecx, const Latin1Char* chars,
<span class="lineNum">     110 </span>            :                             size_t nchars);
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : template size_t
<span class="lineNum">     113 </span>            : GetDeflatedUTF8StringLength(JSContext* maybecx, const char16_t* chars,
<span class="lineNum">     114 </span>            :                             size_t nchars);
<a name="115"><span class="lineNum">     115 </span>            : </a>
<span class="lineNum">     116 </span>            : static size_t
<span class="lineNum">     117 </span><span class="lineNoCov">          0 : GetDeflatedUTF8StringLength(JSContext* maybecx, JSLinearString* str)</span>
<span class="lineNum">     118 </span>            : {
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     size_t length = str-&gt;length();</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     return str-&gt;hasLatin1Chars()</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :            ? GetDeflatedUTF8StringLength(maybecx, str-&gt;latin1Chars(nogc), length)</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :            : GetDeflatedUTF8StringLength(maybecx, str-&gt;twoByteChars(nogc), length);</span>
<span class="lineNum">     125 </span>            : }
<span class="lineNum">     126 </span>            : 
<a name="127"><span class="lineNum">     127 </span>            : template &lt;typename CharT&gt;</a>
<span class="lineNum">     128 </span>            : bool
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t srclen,</span>
<span class="lineNum">     130 </span>            :                           char* dst, size_t* dstlenp)
<span class="lineNum">     131 </span>            : {
<span class="lineNum">     132 </span>            :     size_t i, utf8Len;
<span class="lineNum">     133 </span>            :     char16_t c, c2;
<span class="lineNum">     134 </span>            :     uint32_t v;
<span class="lineNum">     135 </span>            :     uint8_t utf8buf[6];
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     size_t dstlen = *dstlenp;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     size_t origDstlen = dstlen;</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     while (srclen) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         c = *src++;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :         srclen--;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         if (c &gt;= 0xDC00 &amp;&amp; c &lt;= 0xDFFF)</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :             goto badSurrogate;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         if (c &lt; 0xD800 || c &gt; 0xDBFF) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :             v = c;</span>
<span class="lineNum">     147 </span>            :         } else {
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :             if (srclen &lt; 1)</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 goto badSurrogate;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :             c2 = *src;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :             if ((c2 &lt; 0xDC00) || (c2 &gt; 0xDFFF))</span>
<span class="lineNum">     152 </span>            :                 goto badSurrogate;
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             src++;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             srclen--;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             v = ((c - 0xD800) &lt;&lt; 10) + (c2 - 0xDC00) + 0x10000;</span>
<span class="lineNum">     156 </span>            :         }
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         if (v &lt; 0x0080) {</span>
<span class="lineNum">     158 </span>            :             /* no encoding necessary - performance hack */
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :             if (dstlen == 0)</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 goto bufferTooSmall;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :             *dst++ = (char) v;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :             utf8Len = 1;</span>
<span class="lineNum">     163 </span>            :         } else {
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :             utf8Len = js::OneUcs4ToUtf8Char(utf8buf, v);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :             if (utf8Len &gt; dstlen)</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :                 goto bufferTooSmall;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :             for (i = 0; i &lt; utf8Len; i++)</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                 *dst++ = (char) utf8buf[i];</span>
<span class="lineNum">     169 </span>            :         }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         dstlen -= utf8Len;</span>
<span class="lineNum">     171 </span>            :     }
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     *dstlenp = (origDstlen - dstlen);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : badSurrogate:
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     *dstlenp = (origDstlen - dstlen);</span>
<span class="lineNum">     177 </span>            :     /* Delegate error reporting to the measurement function. */
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     if (maybecx)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         GetDeflatedUTF8StringLength(maybecx, src - 1, srclen + 1);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : bufferTooSmall:
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     *dstlenp = (origDstlen - dstlen);</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     if (maybecx) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         js::gc::AutoSuppressGC suppress(maybecx);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         JS_ReportErrorNumberASCII(maybecx, GetErrorMessage, nullptr,</span>
<span class="lineNum">     187 </span>            :                                   JSMSG_BUFFER_TOO_SMALL);
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     190 </span>            : }
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : template bool
<span class="lineNum">     193 </span>            : DeflateStringToUTF8Buffer(JSContext* maybecx, const Latin1Char* src, size_t srclen,
<span class="lineNum">     194 </span>            :                           char* dst, size_t* dstlenp);
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : template bool
<span class="lineNum">     197 </span>            : DeflateStringToUTF8Buffer(JSContext* maybecx, const char16_t* src, size_t srclen,
<span class="lineNum">     198 </span>            :                           char* dst, size_t* dstlenp);
<a name="199"><span class="lineNum">     199 </span>            : </a>
<span class="lineNum">     200 </span>            : static bool
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : DeflateStringToUTF8Buffer(JSContext* maybecx, JSLinearString* str, char* dst,</span>
<span class="lineNum">     202 </span>            :                           size_t* dstlenp)
<span class="lineNum">     203 </span>            : {
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     size_t length = str-&gt;length();</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     return str-&gt;hasLatin1Chars()</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :            ? DeflateStringToUTF8Buffer(maybecx, str-&gt;latin1Chars(nogc), length, dst, dstlenp)</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :            : DeflateStringToUTF8Buffer(maybecx, str-&gt;twoByteChars(nogc), length, dst, dstlenp);</span>
<span class="lineNum">     210 </span>            : }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /*******************************************************************************
<span class="lineNum">     213 </span>            : ** JSAPI function prototypes
<span class="lineNum">     214 </span>            : *******************************************************************************/
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : // We use an enclosing struct here out of paranoia about the ability of gcc 4.4
<span class="lineNum">     217 </span>            : // (and maybe 4.5) to correctly compile this if it were a template function.
<span class="lineNum">     218 </span>            : // See also the comments in dom/workers/Events.cpp (and other adjacent files) by
<span class="lineNum">     219 </span>            : // the |struct Property| there.
<span class="lineNum">     220 </span>            : template&lt;JS::IsAcceptableThis Test, JS::NativeImpl Impl&gt;
<span class="lineNum">     221 </span>            : struct Property
<a name="222"><span class="lineNum">     222 </span>            : {</a>
<span class="lineNum">     223 </span>            :   static bool
<span class="lineNum">     224 </span><span class="lineCov">         85 :   Fun(JSContext* cx, unsigned argc, JS::Value* vp)</span>
<span class="lineNum">     225 </span>            :   {
<span class="lineNum">     226 </span><span class="lineCov">         85 :     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);</span>
<span class="lineNum">     227 </span><span class="lineCov">         85 :     return JS::CallNonGenericMethod&lt;Test, Impl&gt;(cx, args);</span>
<span class="lineNum">     228 </span>            :   }
<span class="lineNum">     229 </span>            : };
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : static bool ConstructAbstract(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : namespace CType {
<span class="lineNum">     234 </span>            :   static bool ConstructData(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     235 </span>            :   static bool ConstructBasic(JSContext* cx, HandleObject obj, const CallArgs&amp; args);
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :   static void Trace(JSTracer* trc, JSObject* obj);
<span class="lineNum">     238 </span>            :   static void Finalize(JSFreeOp* fop, JSObject* obj);
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :   bool IsCType(HandleValue v);
<span class="lineNum">     241 </span>            :   bool IsCTypeOrProto(HandleValue v);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   bool PrototypeGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     244 </span>            :   bool NameGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     245 </span>            :   bool SizeGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     246 </span>            :   bool PtrGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   static bool CreateArray(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     249 </span>            :   static bool ToString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     250 </span>            :   static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     251 </span>            :   static bool HasInstance(JSContext* cx, HandleObject obj, MutableHandleValue v, bool* bp);
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   /*
<span class="lineNum">     255 </span>            :    * Get the global &quot;ctypes&quot; object.
<span class="lineNum">     256 </span>            :    *
<span class="lineNum">     257 </span>            :    * |obj| must be a CType object.
<span class="lineNum">     258 </span>            :    *
<span class="lineNum">     259 </span>            :    * This function never returns nullptr.
<span class="lineNum">     260 </span>            :    */
<span class="lineNum">     261 </span>            :   static JSObject* GetGlobalCTypes(JSContext* cx, JSObject* obj);
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : } // namespace CType
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : namespace ABI {
<span class="lineNum">     266 </span>            :   bool IsABI(JSObject* obj);
<span class="lineNum">     267 </span>            :   static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     268 </span>            : } // namespace ABI
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : namespace PointerType {
<span class="lineNum">     271 </span>            :   static bool Create(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     272 </span>            :   static bool ConstructData(JSContext* cx, HandleObject obj, const CallArgs&amp; args);
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   bool IsPointerType(HandleValue v);
<span class="lineNum">     275 </span>            :   bool IsPointer(HandleValue v);
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   bool TargetTypeGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     278 </span>            :   bool ContentsGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     279 </span>            :   bool ContentsSetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   static bool IsNull(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     282 </span>            :   static bool Increment(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     283 </span>            :   static bool Decrement(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     284 </span>            :   // The following is not an instance function, since we don't want to expose arbitrary
<span class="lineNum">     285 </span>            :   // pointer arithmetic at this moment.
<span class="lineNum">     286 </span>            :   static bool OffsetBy(JSContext* cx, const CallArgs&amp; args, int offset);
<span class="lineNum">     287 </span>            : } // namespace PointerType
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : namespace ArrayType {
<span class="lineNum">     290 </span>            :   bool IsArrayType(HandleValue v);
<span class="lineNum">     291 </span>            :   bool IsArrayOrArrayType(HandleValue v);
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   static bool Create(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     294 </span>            :   static bool ConstructData(JSContext* cx, HandleObject obj, const CallArgs&amp; args);
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   bool ElementTypeGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     297 </span>            :   bool LengthGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   static bool Getter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp);
<span class="lineNum">     300 </span>            :   static bool Setter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp,
<span class="lineNum">     301 </span>            :                      ObjectOpResult&amp; result);
<span class="lineNum">     302 </span>            :   static bool AddressOfElement(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     303 </span>            : } // namespace ArrayType
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : namespace StructType {
<span class="lineNum">     306 </span>            :   bool IsStruct(HandleValue v);
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   static bool Create(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     309 </span>            :   static bool ConstructData(JSContext* cx, HandleObject obj, const CallArgs&amp; args);
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   bool FieldsArrayGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :   enum {
<span class="lineNum">     314 </span>            :     SLOT_FIELDNAME
<span class="lineNum">     315 </span>            :   };
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   static bool FieldGetter(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     318 </span>            :   static bool FieldSetter(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     319 </span>            :   static bool AddressOfField(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     320 </span>            :   static bool Define(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     321 </span>            : } // namespace StructType
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : namespace FunctionType {
<span class="lineNum">     324 </span>            :   static bool Create(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     325 </span>            :   static bool ConstructData(JSContext* cx, HandleObject typeObj,
<span class="lineNum">     326 </span>            :     HandleObject dataObj, HandleObject fnObj, HandleObject thisObj, HandleValue errVal);
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :   static bool Call(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   bool IsFunctionType(HandleValue v);
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   bool ArgTypesGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     333 </span>            :   bool ReturnTypeGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     334 </span>            :   bool ABIGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     335 </span>            :   bool IsVariadicGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     336 </span>            : } // namespace FunctionType
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : namespace CClosure {
<span class="lineNum">     339 </span>            :   static void Trace(JSTracer* trc, JSObject* obj);
<span class="lineNum">     340 </span>            :   static void Finalize(JSFreeOp* fop, JSObject* obj);
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   // libffi callback
<span class="lineNum">     343 </span>            :   static void ClosureStub(ffi_cif* cif, void* result, void** args,
<span class="lineNum">     344 </span>            :     void* userData);
<a name="345"><span class="lineNum">     345 </span>            : </a>
<span class="lineNum">     346 </span>            :   struct ArgClosure : public ScriptEnvironmentPreparer::Closure {
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       ArgClosure(ffi_cif* cifArg, void* resultArg, void** argsArg, ClosureInfo* cinfoArg)</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         : cif(cifArg), result(resultArg), args(argsArg), cinfo(cinfoArg) {}</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :       bool operator()(JSContext *cx) override;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :       ffi_cif* cif;
<span class="lineNum">     353 </span>            :       void* result;
<span class="lineNum">     354 </span>            :       void** args;
<span class="lineNum">     355 </span>            :       ClosureInfo* cinfo;
<span class="lineNum">     356 </span>            :   };
<span class="lineNum">     357 </span>            : } // namespace CClosure
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : namespace CData {
<span class="lineNum">     360 </span>            :   static void Finalize(JSFreeOp* fop, JSObject* obj);
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :   bool ValueGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     363 </span>            :   bool ValueSetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :   static bool Address(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     366 </span>            :   static bool ReadString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     367 </span>            :   static bool ReadStringReplaceMalformed(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     368 </span>            :   static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     369 </span>            :   static JSString* GetSourceString(JSContext* cx, HandleObject typeObj,
<span class="lineNum">     370 </span>            :                                    void* data);
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :   bool ErrnoGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : #if defined(XP_WIN)
<span class="lineNum">     375 </span>            :   bool LastErrorGetter(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">     376 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">     377 </span>            : } // namespace CData
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : namespace CDataFinalizer {
<span class="lineNum">     380 </span>            :   /*
<span class="lineNum">     381 </span>            :    * Attach a C function as a finalizer to a JS object.
<span class="lineNum">     382 </span>            :    *
<span class="lineNum">     383 </span>            :    * This function is available from JS as |ctypes.withFinalizer|.
<span class="lineNum">     384 </span>            :    *
<span class="lineNum">     385 </span>            :    * JavaScript signature:
<span class="lineNum">     386 </span>            :    * function(CData, CData):   CDataFinalizer
<span class="lineNum">     387 </span>            :    *          value  finalizer finalizable
<span class="lineNum">     388 </span>            :    *
<span class="lineNum">     389 </span>            :    * Where |finalizer| is a one-argument function taking a value
<span class="lineNum">     390 </span>            :    * with the same type as |value|.
<span class="lineNum">     391 </span>            :    */
<span class="lineNum">     392 </span>            :   static bool Construct(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   /*
<span class="lineNum">     395 </span>            :    * Private data held by |CDataFinalizer|.
<span class="lineNum">     396 </span>            :    *
<span class="lineNum">     397 </span>            :    * See also |enum CDataFinalizerSlot| for the slots of
<span class="lineNum">     398 </span>            :    * |CDataFinalizer|.
<span class="lineNum">     399 </span>            :    *
<span class="lineNum">     400 </span>            :    * Note: the private data may be nullptr, if |dispose|, |forget| or the
<span class="lineNum">     401 </span>            :    * finalizer has already been called.
<span class="lineNum">     402 </span>            :    */
<span class="lineNum">     403 </span>            :   struct Private {
<span class="lineNum">     404 </span>            :     /*
<span class="lineNum">     405 </span>            :      * The C data to pass to the code.
<span class="lineNum">     406 </span>            :      * Finalization/|dispose|/|forget| release this memory.
<span class="lineNum">     407 </span>            :      */
<span class="lineNum">     408 </span>            :     void* cargs;
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :     /*
<span class="lineNum">     411 </span>            :      * The total size of the buffer pointed by |cargs|
<span class="lineNum">     412 </span>            :      */
<span class="lineNum">     413 </span>            :     size_t cargs_size;
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :     /*
<span class="lineNum">     416 </span>            :      * Low-level signature information.
<span class="lineNum">     417 </span>            :      * Finalization/|dispose|/|forget| release this memory.
<span class="lineNum">     418 </span>            :      */
<span class="lineNum">     419 </span>            :     ffi_cif CIF;
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :     /*
<span class="lineNum">     422 </span>            :      * The C function to invoke during finalization.
<span class="lineNum">     423 </span>            :      * Do not deallocate this.
<span class="lineNum">     424 </span>            :      */
<span class="lineNum">     425 </span>            :     uintptr_t code;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :     /*
<span class="lineNum">     428 </span>            :      * A buffer for holding the return value.
<span class="lineNum">     429 </span>            :      * Finalization/|dispose|/|forget| release this memory.
<span class="lineNum">     430 </span>            :      */
<span class="lineNum">     431 </span>            :     void* rvalue;
<span class="lineNum">     432 </span>            :   };
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   /*
<span class="lineNum">     435 </span>            :    * Methods of instances of |CDataFinalizer|
<span class="lineNum">     436 </span>            :    */
<span class="lineNum">     437 </span>            :   namespace Methods {
<span class="lineNum">     438 </span>            :     static bool Dispose(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     439 </span>            :     static bool Forget(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     440 </span>            :     static bool ReadString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     441 </span>            :     static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     442 </span>            :     static bool ToString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     443 </span>            :   } // namespace Methods
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   /*
<span class="lineNum">     446 </span>            :    * Utility functions
<span class="lineNum">     447 </span>            :    *
<span class="lineNum">     448 </span>            :    * @return true if |obj| is a CDataFinalizer, false otherwise.
<span class="lineNum">     449 </span>            :    */
<span class="lineNum">     450 </span>            :   static bool IsCDataFinalizer(JSObject* obj);
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   /*
<span class="lineNum">     453 </span>            :    * Clean up the finalization information of a CDataFinalizer.
<span class="lineNum">     454 </span>            :    *
<span class="lineNum">     455 </span>            :    * Used by |Finalize|, |Dispose| and |Forget|.
<span class="lineNum">     456 </span>            :    *
<span class="lineNum">     457 </span>            :    * @param p The private information of the CDataFinalizer. If nullptr,
<span class="lineNum">     458 </span>            :    * this function does nothing.
<span class="lineNum">     459 </span>            :    * @param obj Either nullptr, if the object should not be cleaned up (i.e.
<span class="lineNum">     460 </span>            :    * during finalization) or a CDataFinalizer JSObject. Always use nullptr
<span class="lineNum">     461 </span>            :    * if you are calling from a finalizer.
<span class="lineNum">     462 </span>            :    */
<span class="lineNum">     463 </span>            :   static void Cleanup(Private* p, JSObject* obj);
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   /*
<span class="lineNum">     466 </span>            :    * Perform the actual call to the finalizer code.
<span class="lineNum">     467 </span>            :    */
<span class="lineNum">     468 </span>            :   static void CallFinalizer(CDataFinalizer::Private* p,
<span class="lineNum">     469 </span>            :                             int* errnoStatus,
<span class="lineNum">     470 </span>            :                             int32_t* lastErrorStatus);
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   /*
<span class="lineNum">     473 </span>            :    * Return the CType of a CDataFinalizer object, or nullptr if the object
<span class="lineNum">     474 </span>            :    * has been cleaned-up already.
<span class="lineNum">     475 </span>            :    */
<span class="lineNum">     476 </span>            :   static JSObject* GetCType(JSContext* cx, JSObject* obj);
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   /*
<span class="lineNum">     479 </span>            :    * Perform finalization of a |CDataFinalizer|
<span class="lineNum">     480 </span>            :    */
<span class="lineNum">     481 </span>            :   static void Finalize(JSFreeOp* fop, JSObject* obj);
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   /*
<span class="lineNum">     484 </span>            :    * Return the Value contained by this finalizer.
<span class="lineNum">     485 </span>            :    *
<span class="lineNum">     486 </span>            :    * Note that the Value is actually not recorded, but converted back from C.
<span class="lineNum">     487 </span>            :    */
<span class="lineNum">     488 </span>            :   static bool GetValue(JSContext* cx, JSObject* obj, MutableHandleValue result);
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : } // namespace CDataFinalizer
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : // Int64Base provides functions common to Int64 and UInt64.
<span class="lineNum">     494 </span>            : namespace Int64Base {
<span class="lineNum">     495 </span>            :   JSObject* Construct(JSContext* cx, HandleObject proto, uint64_t data,
<span class="lineNum">     496 </span>            :     bool isUnsigned);
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   uint64_t GetInt(JSObject* obj);
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   bool ToString(JSContext* cx, JSObject* obj, const CallArgs&amp; args,
<span class="lineNum">     501 </span>            :                 bool isUnsigned);
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   bool ToSource(JSContext* cx, JSObject* obj, const CallArgs&amp; args,
<span class="lineNum">     504 </span>            :                 bool isUnsigned);
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :   static void Finalize(JSFreeOp* fop, JSObject* obj);
<span class="lineNum">     507 </span>            : } // namespace Int64Base
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : namespace Int64 {
<span class="lineNum">     510 </span>            :   static bool Construct(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   static bool ToString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     513 </span>            :   static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :   static bool Compare(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     516 </span>            :   static bool Lo(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     517 </span>            :   static bool Hi(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     518 </span>            :   static bool Join(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     519 </span>            : } // namespace Int64
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : namespace UInt64 {
<span class="lineNum">     522 </span>            :   static bool Construct(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            :   static bool ToString(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     525 </span>            :   static bool ToSource(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   static bool Compare(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     528 </span>            :   static bool Lo(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     529 </span>            :   static bool Hi(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     530 </span>            :   static bool Join(JSContext* cx, unsigned argc, Value* vp);
<span class="lineNum">     531 </span>            : } // namespace UInt64
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : /*******************************************************************************
<span class="lineNum">     534 </span>            : ** JSClass definitions and initialization functions
<span class="lineNum">     535 </span>            : *******************************************************************************/
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            : // Class representing the 'ctypes' object itself. This exists to contain the
<span class="lineNum">     538 </span>            : // JSCTypesCallbacks set of function pointers.
<span class="lineNum">     539 </span>            : static const JSClass sCTypesGlobalClass = {
<span class="lineNum">     540 </span>            :   &quot;ctypes&quot;,
<span class="lineNum">     541 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CTYPESGLOBAL_SLOTS)
<span class="lineNum">     542 </span>            : };
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : static const JSClass sCABIClass = {
<span class="lineNum">     545 </span>            :   &quot;CABI&quot;,
<span class="lineNum">     546 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CABI_SLOTS)
<span class="lineNum">     547 </span>            : };
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : // Class representing ctypes.{C,Pointer,Array,Struct,Function}Type.prototype.
<span class="lineNum">     550 </span>            : // This exists to give said prototypes a class of &quot;CType&quot;, and to provide
<span class="lineNum">     551 </span>            : // reserved slots for stashing various other prototype objects.
<span class="lineNum">     552 </span>            : static const JSClassOps sCTypeProtoClassOps = {
<span class="lineNum">     553 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     554 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     555 </span>            :   nullptr, ConstructAbstract, nullptr, ConstructAbstract
<span class="lineNum">     556 </span>            : };
<span class="lineNum">     557 </span>            : static const JSClass sCTypeProtoClass = {
<span class="lineNum">     558 </span>            :   &quot;CType&quot;,
<span class="lineNum">     559 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CTYPEPROTO_SLOTS),
<span class="lineNum">     560 </span>            :   &amp;sCTypeProtoClassOps
<span class="lineNum">     561 </span>            : };
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : // Class representing ctypes.CData.prototype and the 'prototype' properties
<span class="lineNum">     564 </span>            : // of CTypes. This exists to give said prototypes a class of &quot;CData&quot;.
<span class="lineNum">     565 </span>            : static const JSClass sCDataProtoClass = {
<span class="lineNum">     566 </span>            :   &quot;CData&quot;,
<span class="lineNum">     567 </span>            :   0
<span class="lineNum">     568 </span>            : };
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : static const JSClassOps sCTypeClassOps = {
<span class="lineNum">     571 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     572 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     573 </span>            :   CType::Finalize, CType::ConstructData, CType::HasInstance, CType::ConstructData,
<span class="lineNum">     574 </span>            :   CType::Trace
<span class="lineNum">     575 </span>            : };
<span class="lineNum">     576 </span>            : static const JSClass sCTypeClass = {
<span class="lineNum">     577 </span>            :   &quot;CType&quot;,
<span class="lineNum">     578 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CTYPE_SLOTS) |
<span class="lineNum">     579 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     580 </span>            :   &amp;sCTypeClassOps
<span class="lineNum">     581 </span>            : };
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : static const JSClassOps sCDataClassOps = {
<span class="lineNum">     584 </span>            :   nullptr, nullptr, ArrayType::Getter, ArrayType::Setter,
<span class="lineNum">     585 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     586 </span>            :   CData::Finalize, FunctionType::Call, nullptr, FunctionType::Call
<span class="lineNum">     587 </span>            : };
<span class="lineNum">     588 </span>            : static const JSClass sCDataClass = {
<span class="lineNum">     589 </span>            :   &quot;CData&quot;,
<span class="lineNum">     590 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CDATA_SLOTS) |
<span class="lineNum">     591 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     592 </span>            :   &amp;sCDataClassOps
<span class="lineNum">     593 </span>            : };
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : static const JSClassOps sCClosureClassOps = {
<span class="lineNum">     596 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     597 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     598 </span>            :   CClosure::Finalize, nullptr, nullptr, nullptr,
<span class="lineNum">     599 </span>            :   CClosure::Trace
<span class="lineNum">     600 </span>            : };
<span class="lineNum">     601 </span>            : static const JSClass sCClosureClass = {
<span class="lineNum">     602 </span>            :   &quot;CClosure&quot;,
<span class="lineNum">     603 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CCLOSURE_SLOTS) |
<span class="lineNum">     604 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     605 </span>            :   &amp;sCClosureClassOps
<span class="lineNum">     606 </span>            : };
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : /*
<span class="lineNum">     609 </span>            :  * Class representing the prototype of CDataFinalizer.
<span class="lineNum">     610 </span>            :  */
<span class="lineNum">     611 </span>            : static const JSClass sCDataFinalizerProtoClass = {
<span class="lineNum">     612 </span>            :   &quot;CDataFinalizer&quot;,
<span class="lineNum">     613 </span>            :   0
<span class="lineNum">     614 </span>            : };
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            : /*
<span class="lineNum">     617 </span>            :  * Class representing instances of CDataFinalizer.
<span class="lineNum">     618 </span>            :  *
<span class="lineNum">     619 </span>            :  * Instances of CDataFinalizer have both private data (with type
<span class="lineNum">     620 </span>            :  * |CDataFinalizer::Private|) and slots (see |CDataFinalizerSlots|).
<span class="lineNum">     621 </span>            :  */
<span class="lineNum">     622 </span>            : static const JSClassOps sCDataFinalizerClassOps = {
<span class="lineNum">     623 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     624 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     625 </span>            :   CDataFinalizer::Finalize
<span class="lineNum">     626 </span>            : };
<span class="lineNum">     627 </span>            : static const JSClass sCDataFinalizerClass = {
<span class="lineNum">     628 </span>            :   &quot;CDataFinalizer&quot;,
<span class="lineNum">     629 </span>            :   JSCLASS_HAS_PRIVATE |
<span class="lineNum">     630 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(CDATAFINALIZER_SLOTS) |
<span class="lineNum">     631 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     632 </span>            :   &amp;sCDataFinalizerClassOps
<span class="lineNum">     633 </span>            : };
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : #define CTYPESFN_FLAGS \
<span class="lineNum">     637 </span>            :   (JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            : #define CTYPESCTOR_FLAGS \
<span class="lineNum">     640 </span>            :   (CTYPESFN_FLAGS | JSFUN_CONSTRUCTOR)
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : #define CTYPESACC_FLAGS \
<span class="lineNum">     643 </span>            :   (JSPROP_ENUMERATE | JSPROP_PERMANENT)
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : #define CABIFN_FLAGS \
<span class="lineNum">     646 </span>            :   (JSPROP_READONLY | JSPROP_PERMANENT)
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : #define CDATAFN_FLAGS \
<span class="lineNum">     649 </span>            :   (JSPROP_READONLY | JSPROP_PERMANENT)
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : #define CDATAFINALIZERFN_FLAGS \
<span class="lineNum">     652 </span>            :   (JSPROP_READONLY | JSPROP_PERMANENT)
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : static const JSPropertySpec sCTypeProps[] = {
<span class="lineNum">     655 </span>            :   JS_PSG(&quot;name&quot;,
<span class="lineNum">     656 </span>            :          (Property&lt;CType::IsCType, CType::NameGetter&gt;::Fun),
<span class="lineNum">     657 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     658 </span>            :   JS_PSG(&quot;size&quot;,
<span class="lineNum">     659 </span>            :          (Property&lt;CType::IsCType, CType::SizeGetter&gt;::Fun),
<span class="lineNum">     660 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     661 </span>            :   JS_PSG(&quot;ptr&quot;,
<span class="lineNum">     662 </span>            :          (Property&lt;CType::IsCType, CType::PtrGetter&gt;::Fun),
<span class="lineNum">     663 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     664 </span>            :   JS_PSG(&quot;prototype&quot;,
<span class="lineNum">     665 </span>            :          (Property&lt;CType::IsCTypeOrProto, CType::PrototypeGetter&gt;::Fun),
<span class="lineNum">     666 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     667 </span>            :   JS_PS_END
<span class="lineNum">     668 </span>            : };
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : static const JSFunctionSpec sCTypeFunctions[] = {
<span class="lineNum">     671 </span>            :   JS_FN(&quot;array&quot;, CType::CreateArray, 0, CTYPESFN_FLAGS),
<span class="lineNum">     672 </span>            :   JS_FN(&quot;toString&quot;, CType::ToString, 0, CTYPESFN_FLAGS),
<span class="lineNum">     673 </span>            :   JS_FN(&quot;toSource&quot;, CType::ToSource, 0, CTYPESFN_FLAGS),
<span class="lineNum">     674 </span>            :   JS_FS_END
<span class="lineNum">     675 </span>            : };
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : static const JSFunctionSpec sCABIFunctions[] = {
<span class="lineNum">     678 </span>            :   JS_FN(&quot;toSource&quot;, ABI::ToSource, 0, CABIFN_FLAGS),
<span class="lineNum">     679 </span>            :   JS_FN(&quot;toString&quot;, ABI::ToSource, 0, CABIFN_FLAGS),
<span class="lineNum">     680 </span>            :   JS_FS_END
<span class="lineNum">     681 </span>            : };
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : static const JSPropertySpec sCDataProps[] = {
<span class="lineNum">     684 </span>            :   JS_PSGS(&quot;value&quot;,
<span class="lineNum">     685 </span>            :           (Property&lt;CData::IsCData, CData::ValueGetter&gt;::Fun),
<span class="lineNum">     686 </span>            :           (Property&lt;CData::IsCData, CData::ValueSetter&gt;::Fun),
<span class="lineNum">     687 </span>            :           JSPROP_PERMANENT),
<span class="lineNum">     688 </span>            :   JS_PS_END
<span class="lineNum">     689 </span>            : };
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : static const JSFunctionSpec sCDataFunctions[] = {
<span class="lineNum">     692 </span>            :   JS_FN(&quot;address&quot;, CData::Address, 0, CDATAFN_FLAGS),
<span class="lineNum">     693 </span>            :   JS_FN(&quot;readString&quot;, CData::ReadString, 0, CDATAFN_FLAGS),
<span class="lineNum">     694 </span>            :   JS_FN(&quot;readStringReplaceMalformed&quot;, CData::ReadStringReplaceMalformed, 0, CDATAFN_FLAGS),
<span class="lineNum">     695 </span>            :   JS_FN(&quot;toSource&quot;, CData::ToSource, 0, CDATAFN_FLAGS),
<span class="lineNum">     696 </span>            :   JS_FN(&quot;toString&quot;, CData::ToSource, 0, CDATAFN_FLAGS),
<span class="lineNum">     697 </span>            :   JS_FS_END
<span class="lineNum">     698 </span>            : };
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            : static const JSFunctionSpec sCDataFinalizerFunctions[] = {
<span class="lineNum">     701 </span>            :   JS_FN(&quot;dispose&quot;,  CDataFinalizer::Methods::Dispose,  0, CDATAFINALIZERFN_FLAGS),
<span class="lineNum">     702 </span>            :   JS_FN(&quot;forget&quot;,   CDataFinalizer::Methods::Forget,   0, CDATAFINALIZERFN_FLAGS),
<span class="lineNum">     703 </span>            :   JS_FN(&quot;readString&quot;, CDataFinalizer::Methods::ReadString, 0, CDATAFINALIZERFN_FLAGS),
<span class="lineNum">     704 </span>            :   JS_FN(&quot;toString&quot;, CDataFinalizer::Methods::ToString, 0, CDATAFINALIZERFN_FLAGS),
<span class="lineNum">     705 </span>            :   JS_FN(&quot;toSource&quot;, CDataFinalizer::Methods::ToSource, 0, CDATAFINALIZERFN_FLAGS),
<span class="lineNum">     706 </span>            :   JS_FS_END
<span class="lineNum">     707 </span>            : };
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : static const JSFunctionSpec sPointerFunction =
<span class="lineNum">     710 </span>            :   JS_FN(&quot;PointerType&quot;, PointerType::Create, 1, CTYPESCTOR_FLAGS);
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            : static const JSPropertySpec sPointerProps[] = {
<span class="lineNum">     713 </span>            :   JS_PSG(&quot;targetType&quot;,
<span class="lineNum">     714 </span>            :          (Property&lt;PointerType::IsPointerType, PointerType::TargetTypeGetter&gt;::Fun),
<span class="lineNum">     715 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     716 </span>            :   JS_PS_END
<span class="lineNum">     717 </span>            : };
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : static const JSFunctionSpec sPointerInstanceFunctions[] = {
<span class="lineNum">     720 </span>            :   JS_FN(&quot;isNull&quot;, PointerType::IsNull, 0, CTYPESFN_FLAGS),
<span class="lineNum">     721 </span>            :   JS_FN(&quot;increment&quot;, PointerType::Increment, 0, CTYPESFN_FLAGS),
<span class="lineNum">     722 </span>            :   JS_FN(&quot;decrement&quot;, PointerType::Decrement, 0, CTYPESFN_FLAGS),
<span class="lineNum">     723 </span>            :   JS_FS_END
<span class="lineNum">     724 </span>            : };
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : static const JSPropertySpec sPointerInstanceProps[] = {
<span class="lineNum">     727 </span>            :   JS_PSGS(&quot;contents&quot;,
<span class="lineNum">     728 </span>            :          (Property&lt;PointerType::IsPointer, PointerType::ContentsGetter&gt;::Fun),
<span class="lineNum">     729 </span>            :          (Property&lt;PointerType::IsPointer, PointerType::ContentsSetter&gt;::Fun),
<span class="lineNum">     730 </span>            :           JSPROP_PERMANENT),
<span class="lineNum">     731 </span>            :   JS_PS_END
<span class="lineNum">     732 </span>            : };
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : static const JSFunctionSpec sArrayFunction =
<span class="lineNum">     735 </span>            :   JS_FN(&quot;ArrayType&quot;, ArrayType::Create, 1, CTYPESCTOR_FLAGS);
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : static const JSPropertySpec sArrayProps[] = {
<span class="lineNum">     738 </span>            :   JS_PSG(&quot;elementType&quot;,
<span class="lineNum">     739 </span>            :          (Property&lt;ArrayType::IsArrayType, ArrayType::ElementTypeGetter&gt;::Fun),
<span class="lineNum">     740 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     741 </span>            :   JS_PSG(&quot;length&quot;,
<span class="lineNum">     742 </span>            :          (Property&lt;ArrayType::IsArrayOrArrayType, ArrayType::LengthGetter&gt;::Fun),
<span class="lineNum">     743 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     744 </span>            :   JS_PS_END
<span class="lineNum">     745 </span>            : };
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : static const JSFunctionSpec sArrayInstanceFunctions[] = {
<span class="lineNum">     748 </span>            :   JS_FN(&quot;addressOfElement&quot;, ArrayType::AddressOfElement, 1, CDATAFN_FLAGS),
<span class="lineNum">     749 </span>            :   JS_FS_END
<span class="lineNum">     750 </span>            : };
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            : static const JSPropertySpec sArrayInstanceProps[] = {
<span class="lineNum">     753 </span>            :   JS_PSG(&quot;length&quot;,
<span class="lineNum">     754 </span>            :          (Property&lt;ArrayType::IsArrayOrArrayType, ArrayType::LengthGetter&gt;::Fun),
<span class="lineNum">     755 </span>            :          JSPROP_PERMANENT),
<span class="lineNum">     756 </span>            :   JS_PS_END
<span class="lineNum">     757 </span>            : };
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            : static const JSFunctionSpec sStructFunction =
<span class="lineNum">     760 </span>            :   JS_FN(&quot;StructType&quot;, StructType::Create, 2, CTYPESCTOR_FLAGS);
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            : static const JSPropertySpec sStructProps[] = {
<span class="lineNum">     763 </span>            :   JS_PSG(&quot;fields&quot;,
<span class="lineNum">     764 </span>            :          (Property&lt;StructType::IsStruct, StructType::FieldsArrayGetter&gt;::Fun),
<span class="lineNum">     765 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     766 </span>            :   JS_PS_END
<span class="lineNum">     767 </span>            : };
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : static const JSFunctionSpec sStructFunctions[] = {
<span class="lineNum">     770 </span>            :   JS_FN(&quot;define&quot;, StructType::Define, 1, CDATAFN_FLAGS),
<span class="lineNum">     771 </span>            :   JS_FS_END
<span class="lineNum">     772 </span>            : };
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : static const JSFunctionSpec sStructInstanceFunctions[] = {
<span class="lineNum">     775 </span>            :   JS_FN(&quot;addressOfField&quot;, StructType::AddressOfField, 1, CDATAFN_FLAGS),
<span class="lineNum">     776 </span>            :   JS_FS_END
<span class="lineNum">     777 </span>            : };
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : static const JSFunctionSpec sFunctionFunction =
<span class="lineNum">     780 </span>            :   JS_FN(&quot;FunctionType&quot;, FunctionType::Create, 2, CTYPESCTOR_FLAGS);
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : static const JSPropertySpec sFunctionProps[] = {
<span class="lineNum">     783 </span>            :   JS_PSG(&quot;argTypes&quot;,
<span class="lineNum">     784 </span>            :          (Property&lt;FunctionType::IsFunctionType, FunctionType::ArgTypesGetter&gt;::Fun),
<span class="lineNum">     785 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     786 </span>            :   JS_PSG(&quot;returnType&quot;,
<span class="lineNum">     787 </span>            :          (Property&lt;FunctionType::IsFunctionType, FunctionType::ReturnTypeGetter&gt;::Fun),
<span class="lineNum">     788 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     789 </span>            :   JS_PSG(&quot;abi&quot;,
<span class="lineNum">     790 </span>            :          (Property&lt;FunctionType::IsFunctionType, FunctionType::ABIGetter&gt;::Fun),
<span class="lineNum">     791 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     792 </span>            :   JS_PSG(&quot;isVariadic&quot;,
<span class="lineNum">     793 </span>            :          (Property&lt;FunctionType::IsFunctionType, FunctionType::IsVariadicGetter&gt;::Fun),
<span class="lineNum">     794 </span>            :          CTYPESACC_FLAGS),
<span class="lineNum">     795 </span>            :   JS_PS_END
<span class="lineNum">     796 </span>            : };
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : static const JSFunctionSpec sFunctionInstanceFunctions[] = {
<span class="lineNum">     799 </span>            :   JS_FN(&quot;call&quot;, js::fun_call, 1, CDATAFN_FLAGS),
<span class="lineNum">     800 </span>            :   JS_FN(&quot;apply&quot;, js::fun_apply, 2, CDATAFN_FLAGS),
<span class="lineNum">     801 </span>            :   JS_FS_END
<span class="lineNum">     802 </span>            : };
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : static const JSClass sInt64ProtoClass = {
<span class="lineNum">     805 </span>            :   &quot;Int64&quot;,
<span class="lineNum">     806 </span>            :   0
<span class="lineNum">     807 </span>            : };
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : static const JSClass sUInt64ProtoClass = {
<span class="lineNum">     810 </span>            :   &quot;UInt64&quot;,
<span class="lineNum">     811 </span>            :   0
<span class="lineNum">     812 </span>            : };
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : static const JSClassOps sInt64ClassOps = {
<span class="lineNum">     815 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     816 </span>            :   nullptr, nullptr, nullptr, nullptr,
<span class="lineNum">     817 </span>            :   Int64Base::Finalize
<span class="lineNum">     818 </span>            : };
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : static const JSClass sInt64Class = {
<span class="lineNum">     821 </span>            :   &quot;Int64&quot;,
<span class="lineNum">     822 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(INT64_SLOTS) |
<span class="lineNum">     823 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     824 </span>            :   &amp;sInt64ClassOps
<span class="lineNum">     825 </span>            : };
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : static const JSClass sUInt64Class = {
<span class="lineNum">     828 </span>            :   &quot;UInt64&quot;,
<span class="lineNum">     829 </span>            :   JSCLASS_HAS_RESERVED_SLOTS(INT64_SLOTS) |
<span class="lineNum">     830 </span>            :   JSCLASS_FOREGROUND_FINALIZE,
<span class="lineNum">     831 </span>            :   &amp;sInt64ClassOps
<span class="lineNum">     832 </span>            : };
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            : static const JSFunctionSpec sInt64StaticFunctions[] = {
<span class="lineNum">     835 </span>            :   JS_FN(&quot;compare&quot;, Int64::Compare, 2, CTYPESFN_FLAGS),
<span class="lineNum">     836 </span>            :   JS_FN(&quot;lo&quot;, Int64::Lo, 1, CTYPESFN_FLAGS),
<span class="lineNum">     837 </span>            :   JS_FN(&quot;hi&quot;, Int64::Hi, 1, CTYPESFN_FLAGS),
<span class="lineNum">     838 </span>            :   // &quot;join&quot; is defined specially; see InitInt64Class.
<span class="lineNum">     839 </span>            :   JS_FS_END
<span class="lineNum">     840 </span>            : };
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : static const JSFunctionSpec sUInt64StaticFunctions[] = {
<span class="lineNum">     843 </span>            :   JS_FN(&quot;compare&quot;, UInt64::Compare, 2, CTYPESFN_FLAGS),
<span class="lineNum">     844 </span>            :   JS_FN(&quot;lo&quot;, UInt64::Lo, 1, CTYPESFN_FLAGS),
<span class="lineNum">     845 </span>            :   JS_FN(&quot;hi&quot;, UInt64::Hi, 1, CTYPESFN_FLAGS),
<span class="lineNum">     846 </span>            :   // &quot;join&quot; is defined specially; see InitInt64Class.
<span class="lineNum">     847 </span>            :   JS_FS_END
<span class="lineNum">     848 </span>            : };
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : static const JSFunctionSpec sInt64Functions[] = {
<span class="lineNum">     851 </span>            :   JS_FN(&quot;toString&quot;, Int64::ToString, 0, CTYPESFN_FLAGS),
<span class="lineNum">     852 </span>            :   JS_FN(&quot;toSource&quot;, Int64::ToSource, 0, CTYPESFN_FLAGS),
<span class="lineNum">     853 </span>            :   JS_FS_END
<span class="lineNum">     854 </span>            : };
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : static const JSFunctionSpec sUInt64Functions[] = {
<span class="lineNum">     857 </span>            :   JS_FN(&quot;toString&quot;, UInt64::ToString, 0, CTYPESFN_FLAGS),
<span class="lineNum">     858 </span>            :   JS_FN(&quot;toSource&quot;, UInt64::ToSource, 0, CTYPESFN_FLAGS),
<span class="lineNum">     859 </span>            :   JS_FS_END
<span class="lineNum">     860 </span>            : };
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            : static const JSPropertySpec sModuleProps[] = {
<span class="lineNum">     863 </span>            :   JS_PSG(&quot;errno&quot;,
<span class="lineNum">     864 </span>            :          (Property&lt;IsCTypesGlobal, CData::ErrnoGetter&gt;::Fun),
<span class="lineNum">     865 </span>            :          JSPROP_PERMANENT),
<span class="lineNum">     866 </span>            : #if defined(XP_WIN)
<span class="lineNum">     867 </span>            :   JS_PSG(&quot;winLastError&quot;,
<span class="lineNum">     868 </span>            :          (Property&lt;IsCTypesGlobal, CData::LastErrorGetter&gt;::Fun),
<span class="lineNum">     869 </span>            :          JSPROP_PERMANENT),
<span class="lineNum">     870 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">     871 </span>            :   JS_PS_END
<span class="lineNum">     872 </span>            : };
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : static const JSFunctionSpec sModuleFunctions[] = {
<span class="lineNum">     875 </span>            :   JS_FN(&quot;CDataFinalizer&quot;, CDataFinalizer::Construct, 2, CTYPESFN_FLAGS),
<span class="lineNum">     876 </span>            :   JS_FN(&quot;open&quot;, Library::Open, 1, CTYPESFN_FLAGS),
<span class="lineNum">     877 </span>            :   JS_FN(&quot;cast&quot;, CData::Cast, 2, CTYPESFN_FLAGS),
<span class="lineNum">     878 </span>            :   JS_FN(&quot;getRuntime&quot;, CData::GetRuntime, 1, CTYPESFN_FLAGS),
<span class="lineNum">     879 </span>            :   JS_FN(&quot;libraryName&quot;, Library::Name, 1, CTYPESFN_FLAGS),
<span class="lineNum">     880 </span>            :   JS_FS_END
<span class="lineNum">     881 </span>            : };
<a name="882"><span class="lineNum">     882 </span>            : </a>
<span class="lineNum">     883 </span>            : static MOZ_ALWAYS_INLINE JSString*
<span class="lineNum">     884 </span><span class="lineNoCov">          0 : NewUCString(JSContext* cx, const AutoString&amp; from)</span>
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   return JS_NewUCStringCopyN(cx, from.begin(), from.length());</span>
<span class="lineNum">     887 </span>            : }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            : /*
<span class="lineNum">     890 </span>            :  * Return a size rounded up to a multiple of a power of two.
<span class="lineNum">     891 </span>            :  *
<span class="lineNum">     892 </span>            :  * Note: |align| must be a power of 2.
<a name="893"><span class="lineNum">     893 </span>            :  */</a>
<span class="lineNum">     894 </span>            : static MOZ_ALWAYS_INLINE size_t
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : Align(size_t val, size_t align)</span>
<span class="lineNum">     896 </span>            : {
<span class="lineNum">     897 </span>            :   // Ensure that align is a power of two.
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(align != 0 &amp;&amp; (align &amp; (align - 1)) == 0);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   return ((val - 1) | (align - 1)) + 1;</span>
<span class="lineNum">     900 </span>            : }
<a name="901"><span class="lineNum">     901 </span>            : </a>
<span class="lineNum">     902 </span>            : static ABICode
<span class="lineNum">     903 </span><span class="lineNoCov">          0 : GetABICode(JSObject* obj)</span>
<span class="lineNum">     904 </span>            : {
<span class="lineNum">     905 </span>            :   // make sure we have an object representing a CABI class,
<span class="lineNum">     906 </span>            :   // and extract the enumerated class type from the reserved slot.
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   if (JS_GetClass(obj) != &amp;sCABIClass)</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     return INVALID_ABI;</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   Value result = JS_GetReservedSlot(obj, SLOT_ABICODE);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   return ABICode(result.toInt32());</span>
<span class="lineNum">     912 </span>            : }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : static const JSErrorFormatString ErrorFormatString[CTYPESERR_LIMIT] = {
<span class="lineNum">     915 </span>            : #define MSG_DEF(name, count, exception, format) \
<span class="lineNum">     916 </span>            :   { #name, format, count, exception } ,
<span class="lineNum">     917 </span>            : #include &quot;ctypes/ctypes.msg&quot;
<span class="lineNum">     918 </span>            : #undef MSG_DEF
<span class="lineNum">     919 </span>            : };
<a name="920"><span class="lineNum">     920 </span>            : </a>
<span class="lineNum">     921 </span>            : static const JSErrorFormatString*
<span class="lineNum">     922 </span><span class="lineNoCov">          0 : GetErrorMessage(void* userRef, const unsigned errorNumber)</span>
<span class="lineNum">     923 </span>            : {
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   if (0 &lt; errorNumber &amp;&amp; errorNumber &lt; CTYPESERR_LIMIT)</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     return &amp;ErrorFormatString[errorNumber];</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     927 </span>            : }
<a name="928"><span class="lineNum">     928 </span>            : </a>
<span class="lineNum">     929 </span>            : static const char*
<span class="lineNum">     930 </span><span class="lineNoCov">          0 : EncodeLatin1(JSContext* cx, AutoString&amp; str, JSAutoByteString&amp; bytes)</span>
<span class="lineNum">     931 </span>            : {
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   return bytes.encodeLatin1(cx, NewUCString(cx, str));</span>
<span class="lineNum">     933 </span>            : }
<a name="934"><span class="lineNum">     934 </span>            : </a>
<span class="lineNum">     935 </span>            : static const char*
<span class="lineNum">     936 </span><span class="lineNoCov">          0 : CTypesToSourceForError(JSContext* cx, HandleValue val, JSAutoByteString&amp; bytes)</span>
<span class="lineNum">     937 </span>            : {
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   if (val.isObject() &amp;&amp;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       (CType::IsCType(&amp;val.toObject()) || CData::IsCData(&amp;val.toObject()))) {</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     RootedString str(cx, JS_ValueToSource(cx, val));</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     return bytes.encodeLatin1(cx, str);</span>
<span class="lineNum">     942 </span>            :   }
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   return ValueToSourceForError(cx, val, bytes);</span>
<span class="lineNum">     944 </span>            : }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : static void
<span class="lineNum">     947 </span>            : BuildCStyleFunctionTypeSource(JSContext* cx, HandleObject typeObj,
<span class="lineNum">     948 </span>            :                               HandleString nameStr, unsigned ptrCount,
<span class="lineNum">     949 </span>            :                               AutoString&amp; source);
<a name="950"><span class="lineNum">     950 </span>            : </a>
<span class="lineNum">     951 </span>            : static void
<span class="lineNum">     952 </span><span class="lineNoCov">          0 : BuildCStyleTypeSource(JSContext* cx, JSObject* typeObj_, AutoString&amp; source)</span>
<span class="lineNum">     953 </span>            : {
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, typeObj_);</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(typeObj));</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   switch (CType::GetTypeCode(typeObj)) {</span>
<span class="lineNum">     959 </span>            : #define BUILD_SOURCE(name, fromType, ffiType)                                  \
<span class="lineNum">     960 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">     961 </span>            :     AppendString(source, #name);                                               \
<span class="lineNum">     962 </span>            :     break;
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_TYPE(BUILD_SOURCE)</span>
<span class="lineNum">     964 </span>            : #undef BUILD_SOURCE
<span class="lineNum">     965 </span>            :   case TYPE_void_t:
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;void&quot;);</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     968 </span>            :   case TYPE_pointer: {
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     unsigned ptrCount = 0;</span>
<span class="lineNum">     970 </span>            :     TypeCode type;
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     RootedObject baseTypeObj(cx, typeObj);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :       baseTypeObj = PointerType::GetBaseType(baseTypeObj);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :       ptrCount++;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :       type = CType::GetTypeCode(baseTypeObj);</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     } while (type == TYPE_pointer || type == TYPE_array);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     if (type == TYPE_function) {</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       BuildCStyleFunctionTypeSource(cx, baseTypeObj, nullptr, ptrCount,</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :                                     source);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     981 </span>            :     }
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :     BuildCStyleTypeSource(cx, baseTypeObj, source);</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     AppendChars(source, '*', ptrCount);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     985 </span>            :   }
<span class="lineNum">     986 </span>            :   case TYPE_struct: {
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     RootedString name(cx, CType::GetName(cx, typeObj));</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;struct &quot;);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     AppendString(source, name);</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     991 </span>            :   }
<span class="lineNum">     992 </span>            :   case TYPE_function:
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     BuildCStyleFunctionTypeSource(cx, typeObj, nullptr, 0, source);</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     995 </span>            :   case TYPE_array:
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;TYPE_array shouldn't appear in function type&quot;);</span>
<span class="lineNum">     997 </span>            :   }
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : }</span>
<a name="999"><span class="lineNum">     999 </span>            : </a>
<span class="lineNum">    1000 </span>            : static void
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 : BuildCStyleFunctionTypeSource(JSContext* cx, HandleObject typeObj,</span>
<span class="lineNum">    1002 </span>            :                               HandleString nameStr, unsigned ptrCount,
<span class="lineNum">    1003 </span>            :                               AutoString&amp; source)
<span class="lineNum">    1004 </span>            : {
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(typeObj));</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   BuildCStyleTypeSource(cx, fninfo-&gt;mReturnType, source);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   AppendString(source, &quot; &quot;);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   if (nameStr) {</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(ptrCount == 0);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     AppendString(source, nameStr);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   } else if (ptrCount) {</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;(&quot;);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     AppendChars(source, '*', ptrCount);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;)&quot;);</span>
<span class="lineNum">    1017 </span>            :   }
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   AppendString(source, &quot;(&quot;);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   if (fninfo-&gt;mArgTypes.length() &gt; 0) {</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; fninfo-&gt;mArgTypes.length(); ++i) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       BuildCStyleTypeSource(cx, fninfo-&gt;mArgTypes[i], source);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :       if (i != fninfo-&gt;mArgTypes.length() - 1 || fninfo-&gt;mIsVariadic) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :           AppendString(source, &quot;, &quot;);</span>
<span class="lineNum">    1024 </span>            :       }
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :     if (fninfo-&gt;mIsVariadic) {</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       AppendString(source, &quot;...&quot;);</span>
<span class="lineNum">    1028 </span>            :     }
<span class="lineNum">    1029 </span>            :   }
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   AppendString(source, &quot;)&quot;);</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 : }</span>
<a name="1032"><span class="lineNum">    1032 </span>            : </a>
<span class="lineNum">    1033 </span>            : static void
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 : BuildFunctionTypeSource(JSContext* cx, HandleObject funObj, AutoString&amp; source)</span>
<span class="lineNum">    1035 </span>            : {
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CData::IsCData(funObj) || CType::IsCType(funObj));</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   if (CData::IsCData(funObj)) {</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     Value slot = JS_GetReservedSlot(funObj, SLOT_REFERENT);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     if (!slot.isUndefined() &amp;&amp; Library::IsLibrary(&amp;slot.toObject())) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :       slot = JS_GetReservedSlot(funObj, SLOT_FUNNAME);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(!slot.isUndefined());</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :       RootedObject typeObj(cx, CData::GetCType(funObj));</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :       RootedObject baseTypeObj(cx, PointerType::GetBaseType(typeObj));</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :       RootedString nameStr(cx, slot.toString());</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :       BuildCStyleFunctionTypeSource(cx, baseTypeObj, nameStr, 0, source);</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1048 </span>            :     }
<span class="lineNum">    1049 </span>            :   }
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   RootedValue funVal(cx, ObjectValue(*funObj));</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   RootedString funcStr(cx, JS_ValueToSource(cx, funVal));</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   if (!funcStr) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     JS_ClearPendingException(cx);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;&lt;&lt;error converting function to string&gt;&gt;&quot;);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1057 </span>            :   }
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   AppendString(source, funcStr);</span>
<span class="lineNum">    1059 </span>            : }
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            : enum class ConversionType {
<span class="lineNum">    1062 </span>            :   Argument = 0,
<span class="lineNum">    1063 </span>            :   Construct,
<span class="lineNum">    1064 </span>            :   Finalizer,
<span class="lineNum">    1065 </span>            :   Return,
<span class="lineNum">    1066 </span>            :   Setter
<span class="lineNum">    1067 </span>            : };
<a name="1068"><span class="lineNum">    1068 </span>            : </a>
<span class="lineNum">    1069 </span>            : static void
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 : BuildConversionPosition(JSContext* cx, ConversionType convType,</span>
<span class="lineNum">    1071 </span>            :                         HandleObject funObj, unsigned argIndex,
<span class="lineNum">    1072 </span>            :                         AutoString&amp; source)
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   switch (convType) {</span>
<span class="lineNum">    1075 </span>            :   case ConversionType::Argument: {
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     AppendString(source, &quot; at argument &quot;);</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     AppendUInt(source, argIndex + 1);</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     AppendString(source, &quot; of &quot;);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, source);</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1083 </span>            :   }
<span class="lineNum">    1084 </span>            :   case ConversionType::Finalizer:
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     AppendString(source, &quot; at argument 1 of &quot;);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, source);</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1090 </span>            :   case ConversionType::Return:
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     AppendString(source, &quot; at the return value of &quot;);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, source);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1096 </span>            :   default:
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1099 </span>            :   }
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 : }</span>
<a name="1101"><span class="lineNum">    1101 </span>            : </a>
<span class="lineNum">    1102 </span>            : static JSFlatString*
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 : GetFieldName(HandleObject structObj, unsigned fieldIndex)</span>
<span class="lineNum">    1104 </span>            : {
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   const FieldInfoHash* fields = StructType::GetFieldInfo(structObj);</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront()) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     if (r.front().value().mIndex == fieldIndex) {</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :       return (&amp;r.front())-&gt;key();</span>
<span class="lineNum">    1109 </span>            :     }
<span class="lineNum">    1110 </span>            :   }
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">    1112 </span>            : }
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            : static void
<span class="lineNum">    1115 </span>            : BuildTypeSource(JSContext* cx, JSObject* typeObj_, bool makeShort,
<span class="lineNum">    1116 </span>            :                 AutoString&amp; result);
<a name="1117"><span class="lineNum">    1117 </span>            : </a>
<span class="lineNum">    1118 </span>            : static bool
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 : ConvError(JSContext* cx, const char* expectedStr, HandleValue actual,</span>
<span class="lineNum">    1120 </span>            :           ConversionType convType,
<span class="lineNum">    1121 </span>            :           HandleObject funObj = nullptr, unsigned argIndex = 0,
<span class="lineNum">    1122 </span>            :           HandleObject arrObj = nullptr, unsigned arrIndex = 0)
<span class="lineNum">    1123 </span>            : {
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   if (arrObj) {</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(CType::IsCType(arrObj));</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     switch (CType::GetTypeCode(arrObj)) {</span>
<span class="lineNum">    1133 </span>            :     case TYPE_array: {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :       char indexStr[16];
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :       SprintfLiteral(indexStr, &quot;%u&quot;, arrIndex);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :       AutoString arrSource;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :       JSAutoByteString arrBytes;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :       BuildTypeSource(cx, arrObj, true, arrSource);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :       const char* arrStr = EncodeLatin1(cx, arrSource, arrBytes);</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :       if (!arrStr)</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :       JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1147 </span>            :                                  CTYPESMSG_CONV_ERROR_ARRAY,
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                                  valStr, indexStr, arrStr);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1150 </span>            :     }
<span class="lineNum">    1151 </span>            :     case TYPE_struct: {
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :       JSFlatString* name = GetFieldName(arrObj, arrIndex);</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(name);</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       JSAutoByteString nameBytes;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       const char* nameStr = nameBytes.encodeLatin1(cx, name);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       if (!nameStr)</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       AutoString structSource;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :       JSAutoByteString structBytes;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :       BuildTypeSource(cx, arrObj, true, structSource);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :       const char* structStr = EncodeLatin1(cx, structSource, structBytes);</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       if (!structStr)</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :       JSAutoByteString posBytes;</span>
<span class="lineNum">    1167 </span>            :       const char* posStr;
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :       if (funObj) {</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         AutoString posSource;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         BuildConversionPosition(cx, convType, funObj, argIndex, posSource);</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         posStr = EncodeLatin1(cx, posSource, posBytes);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         if (!posStr)</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    1174 </span>            :       } else {
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         posStr = &quot;&quot;;</span>
<span class="lineNum">    1176 </span>            :       }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :       JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1179 </span>            :                                  CTYPESMSG_CONV_ERROR_STRUCT,
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                                  valStr, nameStr, expectedStr, structStr, posStr);</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1182 </span>            :     }
<span class="lineNum">    1183 </span>            :     default:
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;invalid arrObj value&quot;);</span>
<span class="lineNum">    1185 </span>            :     }
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1187 </span>            :   }
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   switch (convType) {</span>
<span class="lineNum">    1190 </span>            :   case ConversionType::Argument: {
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :     char indexStr[16];
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     SprintfLiteral(indexStr, &quot;%u&quot;, argIndex + 1);</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     AutoString funSource;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     JSAutoByteString funBytes;</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, funSource);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     const char* funStr = EncodeLatin1(cx, funSource, funBytes);</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     if (!funStr)</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :     JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1204 </span>            :                                CTYPESMSG_CONV_ERROR_ARG,
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                                valStr, indexStr, funStr);</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1207 </span>            :   }
<span class="lineNum">    1208 </span>            :   case ConversionType::Finalizer: {
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     AutoString funSource;</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     JSAutoByteString funBytes;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, funSource);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     const char* funStr = EncodeLatin1(cx, funSource, funBytes);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     if (!funStr)</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :     JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                                CTYPESMSG_CONV_ERROR_FIN, valStr, funStr);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1221 </span>            :   }
<span class="lineNum">    1222 </span>            :   case ConversionType::Return: {
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(funObj);</span>
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     AutoString funSource;</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     JSAutoByteString funBytes;</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, funSource);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     const char* funStr = EncodeLatin1(cx, funSource, funBytes);</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     if (!funStr)</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            :     JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                                CTYPESMSG_CONV_ERROR_RET, valStr, funStr);</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1235 </span>            :   }
<span class="lineNum">    1236 </span>            :   case ConversionType::Setter:
<span class="lineNum">    1237 </span>            :   case ConversionType::Construct:
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :     JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                                CTYPESMSG_CONV_ERROR_SET, valStr, expectedStr);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1243 </span>            :   }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1246 </span>            : }
<a name="1247"><span class="lineNum">    1247 </span>            : </a>
<span class="lineNum">    1248 </span>            : static bool
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 : ConvError(JSContext* cx, HandleObject expectedType, HandleValue actual,</span>
<span class="lineNum">    1250 </span>            :           ConversionType convType,
<span class="lineNum">    1251 </span>            :           HandleObject funObj = nullptr, unsigned argIndex = 0,
<span class="lineNum">    1252 </span>            :           HandleObject arrObj = nullptr, unsigned arrIndex = 0)
<span class="lineNum">    1253 </span>            : {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(expectedType));</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   AutoString expectedSource;</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   JSAutoByteString expectedBytes;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, expectedType, true, expectedSource);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   const char* expectedStr = EncodeLatin1(cx, expectedSource, expectedBytes);</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   if (!expectedStr)</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            :   return ConvError(cx, expectedStr, actual, convType, funObj, argIndex,
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :                    arrObj, arrIndex);</span>
<span class="lineNum">    1265 </span>            : }
<a name="1266"><span class="lineNum">    1266 </span>            : </a>
<span class="lineNum">    1267 </span>            : static bool
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 : ArgumentConvError(JSContext* cx, HandleValue actual, const char* funStr,</span>
<span class="lineNum">    1269 </span>            :                   unsigned argIndex)
<span class="lineNum">    1270 </span>            : {
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            :   char indexStr[16];
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   SprintfLiteral(indexStr, &quot;%u&quot;, argIndex + 1);</span>
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                              CTYPESMSG_CONV_ERROR_ARG, valStr, indexStr, funStr);</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1282 </span>            : }
<a name="1283"><span class="lineNum">    1283 </span>            : </a>
<span class="lineNum">    1284 </span>            : static bool
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 : ArgumentLengthError(JSContext* cx, const char* fun, const char* count,</span>
<span class="lineNum">    1286 </span>            :                     const char* s)
<span class="lineNum">    1287 </span>            : {
<span class="lineNum">    1288 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :                              CTYPESMSG_WRONG_ARG_LENGTH, fun, count, s);</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1291 </span>            : }
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<span class="lineNum">    1293 </span>            : static bool
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 : ArrayLengthMismatch(JSContext* cx, unsigned expectedLength, HandleObject arrObj,</span>
<span class="lineNum">    1295 </span>            :                     unsigned actualLength, HandleValue actual,
<span class="lineNum">    1296 </span>            :                     ConversionType convType)
<span class="lineNum">    1297 </span>            : {
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(arrObj &amp;&amp; CType::IsCType(arrObj));</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            :   char expectedLengthStr[16];
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   SprintfLiteral(expectedLengthStr, &quot;%u&quot;, expectedLength);</span>
<span class="lineNum">    1307 </span>            :   char actualLengthStr[16];
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :   SprintfLiteral(actualLengthStr, &quot;%u&quot;, actualLength);</span>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   AutoString arrSource;</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :   JSAutoByteString arrBytes;</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, arrObj, true, arrSource);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   const char* arrStr = EncodeLatin1(cx, arrSource, arrBytes);</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :   if (!arrStr)</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1318 </span>            :                              CTYPESMSG_ARRAY_MISMATCH,
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                              valStr, arrStr, expectedLengthStr, actualLengthStr);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1321 </span>            : }
<a name="1322"><span class="lineNum">    1322 </span>            : </a>
<span class="lineNum">    1323 </span>            : static bool
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 : ArrayLengthOverflow(JSContext* cx, unsigned expectedLength, HandleObject arrObj,</span>
<span class="lineNum">    1325 </span>            :                     unsigned actualLength, HandleValue actual,
<span class="lineNum">    1326 </span>            :                     ConversionType convType)
<span class="lineNum">    1327 </span>            : {
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(arrObj &amp;&amp; CType::IsCType(arrObj));</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :   char expectedLengthStr[16];
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   SprintfLiteral(expectedLengthStr, &quot;%u&quot;, expectedLength);</span>
<span class="lineNum">    1337 </span>            :   char actualLengthStr[16];
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   SprintfLiteral(actualLengthStr, &quot;%u&quot;, actualLength);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :   AutoString arrSource;</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   JSAutoByteString arrBytes;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, arrObj, true, arrSource);</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   const char* arrStr = EncodeLatin1(cx, arrSource, arrBytes);</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :   if (!arrStr)</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1348 </span>            :                              CTYPESMSG_ARRAY_OVERFLOW,
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                              valStr, arrStr, expectedLengthStr, actualLengthStr);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1351 </span>            : }
<a name="1352"><span class="lineNum">    1352 </span>            : </a>
<span class="lineNum">    1353 </span>            : static bool
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 : ArgumentRangeMismatch(JSContext* cx, const char* func, const char* range)</span>
<span class="lineNum">    1355 </span>            : {
<span class="lineNum">    1356 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :                             CTYPESMSG_ARG_RANGE_MISMATCH, func, range);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1359 </span>            : }
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<span class="lineNum">    1361 </span>            : static bool
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 : ArgumentTypeMismatch(JSContext* cx, const char* arg, const char* func,</span>
<span class="lineNum">    1363 </span>            :                      const char* type)
<span class="lineNum">    1364 </span>            : {
<span class="lineNum">    1365 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :                             CTYPESMSG_ARG_TYPE_MISMATCH, arg, func, type);</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1368 </span>            : }
<a name="1369"><span class="lineNum">    1369 </span>            : </a>
<span class="lineNum">    1370 </span>            : static bool
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 : CannotConstructError(JSContext* cx, const char* type)</span>
<span class="lineNum">    1372 </span>            : {
<span class="lineNum">    1373 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                             CTYPESMSG_CANNOT_CONSTRUCT, type);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1376 </span>            : }
<a name="1377"><span class="lineNum">    1377 </span>            : </a>
<span class="lineNum">    1378 </span>            : static bool
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 : DuplicateFieldError(JSContext* cx, Handle&lt;JSFlatString*&gt; name)</span>
<span class="lineNum">    1380 </span>            : {
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :   JSAutoByteString nameBytes;</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   const char* nameStr = nameBytes.encodeLatin1(cx, name);</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :   if (!nameStr)</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                              CTYPESMSG_DUPLICATE_FIELD, nameStr);</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1389 </span>            : }
<a name="1390"><span class="lineNum">    1390 </span>            : </a>
<span class="lineNum">    1391 </span>            : static bool
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 : EmptyFinalizerCallError(JSContext* cx, const char* funName)</span>
<span class="lineNum">    1393 </span>            : {
<span class="lineNum">    1394 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :                             CTYPESMSG_EMPTY_FIN_CALL, funName);</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1397 </span>            : }
<a name="1398"><span class="lineNum">    1398 </span>            : </a>
<span class="lineNum">    1399 </span>            : static bool
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 : EmptyFinalizerError(JSContext* cx, ConversionType convType,</span>
<span class="lineNum">    1401 </span>            :                     HandleObject funObj = nullptr, unsigned argIndex = 0)
<span class="lineNum">    1402 </span>            : {
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :   JSAutoByteString posBytes;</span>
<span class="lineNum">    1404 </span>            :   const char* posStr;
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :   if (funObj) {</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     AutoString posSource;</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :     BuildConversionPosition(cx, convType, funObj, argIndex, posSource);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     posStr = EncodeLatin1(cx, posSource, posBytes);</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     if (!posStr)</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1411 </span>            :   } else {
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     posStr = &quot;&quot;;</span>
<span class="lineNum">    1413 </span>            :   }
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :                              CTYPESMSG_EMPTY_FIN, posStr);</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1418 </span>            : }
<a name="1419"><span class="lineNum">    1419 </span>            : </a>
<span class="lineNum">    1420 </span>            : static bool
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 : FieldCountMismatch(JSContext* cx,</span>
<span class="lineNum">    1422 </span>            :                    unsigned expectedCount, HandleObject structObj,
<span class="lineNum">    1423 </span>            :                    unsigned actualCount, HandleValue actual,
<span class="lineNum">    1424 </span>            :                    ConversionType convType,
<span class="lineNum">    1425 </span>            :                    HandleObject funObj = nullptr, unsigned argIndex = 0)
<span class="lineNum">    1426 </span>            : {
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(structObj &amp;&amp; CType::IsCType(structObj));</span>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   AutoString structSource;</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :   JSAutoByteString structBytes;</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, structObj, true, structSource);</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   const char* structStr = EncodeLatin1(cx, structSource, structBytes);</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :   if (!structStr)</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   char expectedCountStr[16];
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   SprintfLiteral(expectedCountStr, &quot;%u&quot;, expectedCount);</span>
<span class="lineNum">    1443 </span>            :   char actualCountStr[16];
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   SprintfLiteral(actualCountStr, &quot;%u&quot;, actualCount);</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   JSAutoByteString posBytes;</span>
<span class="lineNum">    1447 </span>            :   const char* posStr;
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   if (funObj) {</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :     AutoString posSource;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     BuildConversionPosition(cx, convType, funObj, argIndex, posSource);</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     posStr = EncodeLatin1(cx, posSource, posBytes);</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     if (!posStr)</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1454 </span>            :   } else {
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     posStr = &quot;&quot;;</span>
<span class="lineNum">    1456 </span>            :   }
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1459 </span>            :                              CTYPESMSG_FIELD_MISMATCH,
<span class="lineNum">    1460 </span>            :                              valStr, structStr, expectedCountStr, actualCountStr,
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :                              posStr);</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1463 </span>            : }
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<span class="lineNum">    1465 </span>            : static bool
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 : FieldDescriptorCountError(JSContext* cx, HandleValue typeVal, size_t length)</span>
<span class="lineNum">    1467 </span>            : {
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, typeVal, valBytes);</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :   char lengthStr[16];
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   SprintfLiteral(lengthStr, &quot;%&quot; PRIuSIZE, length);</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_DESC_COUNT, valStr, lengthStr);</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1479 </span>            : }
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<span class="lineNum">    1481 </span>            : static bool
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 : FieldDescriptorNameError(JSContext* cx, HandleId id)</span>
<span class="lineNum">    1483 </span>            : {
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   JSAutoByteString idBytes;</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :   RootedValue idVal(cx, IdToValue(id));</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   const char* propStr = CTypesToSourceForError(cx, idVal, idBytes);</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :   if (!propStr)</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_DESC_NAME, propStr);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1493 </span>            : }
<a name="1494"><span class="lineNum">    1494 </span>            : </a>
<span class="lineNum">    1495 </span>            : static bool
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 : FieldDescriptorSizeError(JSContext* cx, HandleObject typeObj, HandleId id)</span>
<span class="lineNum">    1497 </span>            : {
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :   RootedValue typeVal(cx, ObjectValue(*typeObj));</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :   JSAutoByteString typeBytes;</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   const char* typeStr = CTypesToSourceForError(cx, typeVal, typeBytes);</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   if (!typeStr)</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   RootedString idStr(cx, IdToString(cx, id));</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   JSAutoByteString idBytes;</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   const char* propStr = idBytes.encodeLatin1(cx, idStr);</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   if (!propStr)</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_DESC_SIZE, typeStr, propStr);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1513 </span>            : }
<a name="1514"><span class="lineNum">    1514 </span>            : </a>
<span class="lineNum">    1515 </span>            : static bool
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 : FieldDescriptorNameTypeError(JSContext* cx, HandleValue typeVal)</span>
<span class="lineNum">    1517 </span>            : {
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, typeVal, valBytes);</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_DESC_NAMETYPE, valStr);</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1526 </span>            : }
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<span class="lineNum">    1528 </span>            : static bool
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 : FieldDescriptorTypeError(JSContext* cx, HandleValue poroVal, HandleId id)</span>
<span class="lineNum">    1530 </span>            : {
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   JSAutoByteString typeBytes;</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   const char* typeStr = CTypesToSourceForError(cx, poroVal, typeBytes);</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   if (!typeStr)</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   RootedString idStr(cx, IdToString(cx, id));</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :   JSAutoByteString idBytes;</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :   const char* propStr = idBytes.encodeLatin1(cx, idStr);</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :   if (!propStr)</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_DESC_TYPE, typeStr, propStr);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1545 </span>            : }
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<span class="lineNum">    1547 </span>            : static bool
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 : FieldMissingError(JSContext* cx, JSObject* typeObj, JSFlatString* name_)</span>
<span class="lineNum">    1549 </span>            : {
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :   JSAutoByteString typeBytes;</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   RootedString name(cx, name_);</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   RootedValue typeVal(cx, ObjectValue(*typeObj));</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   const char* typeStr = CTypesToSourceForError(cx, typeVal, typeBytes);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   if (!typeStr)</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   JSAutoByteString nameBytes;</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   const char* nameStr = nameBytes.encodeLatin1(cx, name);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   if (!nameStr)</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIELD_MISSING, typeStr, nameStr);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1565 </span>            : }
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<span class="lineNum">    1567 </span>            : static bool
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 : FinalizerSizeError(JSContext* cx, HandleObject funObj, HandleValue actual)</span>
<span class="lineNum">    1569 </span>            : {
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(funObj));</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :   AutoString funSource;</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :   JSAutoByteString funBytes;</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   BuildFunctionTypeSource(cx, funObj, funSource);</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   const char* funStr = EncodeLatin1(cx, funSource, funBytes);</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   if (!funStr)</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :                              CTYPESMSG_FIN_SIZE_ERROR, funStr, valStr);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1587 </span>            : }
<a name="1588"><span class="lineNum">    1588 </span>            : </a>
<span class="lineNum">    1589 </span>            : static bool
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 : FunctionArgumentLengthMismatch(JSContext* cx,</span>
<span class="lineNum">    1591 </span>            :                                unsigned expectedCount, unsigned actualCount,
<span class="lineNum">    1592 </span>            :                                HandleObject funObj, HandleObject typeObj,
<span class="lineNum">    1593 </span>            :                                bool isVariadic)
<span class="lineNum">    1594 </span>            : {
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :   AutoString funSource;</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   JSAutoByteString funBytes;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(funObj, SLOT_REFERENT);</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :   if (!slot.isUndefined() &amp;&amp; Library::IsLibrary(&amp;slot.toObject())) {</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, funObj, funSource);</span>
<span class="lineNum">    1600 </span>            :   } else {
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :     BuildFunctionTypeSource(cx, typeObj, funSource);</span>
<span class="lineNum">    1602 </span>            :   }
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   const char* funStr = EncodeLatin1(cx, funSource, funBytes);</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   if (!funStr)</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span>            :   char expectedCountStr[16];
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   SprintfLiteral(expectedCountStr, &quot;%u&quot;, expectedCount);</span>
<span class="lineNum">    1609 </span>            :   char actualCountStr[16];
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   SprintfLiteral(actualCountStr, &quot;%u&quot;, actualCount);</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :   const char* variadicStr = isVariadic ? &quot; or more&quot;: &quot;&quot;;</span>
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1615 </span>            :                              CTYPESMSG_ARG_COUNT_MISMATCH,
<span class="lineNum">    1616 </span>            :                              funStr, expectedCountStr, variadicStr,
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :                              actualCountStr);</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1619 </span>            : }
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<span class="lineNum">    1621 </span>            : static bool
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 : FunctionArgumentTypeError(JSContext* cx,</span>
<span class="lineNum">    1623 </span>            :                           uint32_t index, HandleValue typeVal, const char* reason)
<span class="lineNum">    1624 </span>            : {
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, typeVal, valBytes);</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span>            :   char indexStr[16];
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :   SprintfLiteral(indexStr, &quot;%u&quot;, index + 1);</span>
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1634 </span>            :                              CTYPESMSG_ARG_TYPE_ERROR,
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :                              indexStr, reason, valStr);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1637 </span>            : }
<a name="1638"><span class="lineNum">    1638 </span>            : </a>
<span class="lineNum">    1639 </span>            : static bool
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 : FunctionReturnTypeError(JSContext* cx, HandleValue type, const char* reason)</span>
<span class="lineNum">    1641 </span>            : {
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, type, valBytes);</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :                              CTYPESMSG_RET_TYPE_ERROR, reason, valStr);</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1650 </span>            : }
<a name="1651"><span class="lineNum">    1651 </span>            : </a>
<span class="lineNum">    1652 </span>            : static bool
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 : IncompatibleCallee(JSContext* cx, const char* funName, HandleObject actualObj)</span>
<span class="lineNum">    1654 </span>            : {
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   RootedValue val(cx, ObjectValue(*actualObj));</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, val, valBytes);</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                              CTYPESMSG_INCOMPATIBLE_CALLEE, funName, valStr);</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1664 </span>            : }
<a name="1665"><span class="lineNum">    1665 </span>            : </a>
<span class="lineNum">    1666 </span>            : static bool
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 : IncompatibleThisProto(JSContext* cx, const char* funName,</span>
<span class="lineNum">    1668 </span>            :                       const char* actualType)
<span class="lineNum">    1669 </span>            : {
<span class="lineNum">    1670 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1671 </span>            :                              CTYPESMSG_INCOMPATIBLE_THIS,
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :                              funName, actualType);</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1674 </span>            : }
<a name="1675"><span class="lineNum">    1675 </span>            : </a>
<span class="lineNum">    1676 </span>            : static bool
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 : IncompatibleThisProto(JSContext* cx, const char* funName, HandleValue actualVal)</span>
<span class="lineNum">    1678 </span>            : {
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actualVal, valBytes);</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1685 </span>            :                              CTYPESMSG_INCOMPATIBLE_THIS_VAL,
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :                              funName, &quot;incompatible object&quot;, valStr);</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1688 </span>            : }
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<span class="lineNum">    1690 </span>            : static bool
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 : IncompatibleThisType(JSContext* cx, const char* funName, const char* actualType)</span>
<span class="lineNum">    1692 </span>            : {
<span class="lineNum">    1693 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1694 </span>            :                             CTYPESMSG_INCOMPATIBLE_THIS_TYPE,
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :                             funName, actualType);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1697 </span>            : }
<a name="1698"><span class="lineNum">    1698 </span>            : </a>
<span class="lineNum">    1699 </span>            : static bool
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 : IncompatibleThisType(JSContext* cx, const char* funName, const char* actualType,</span>
<span class="lineNum">    1701 </span>            :                      HandleValue actualVal)
<span class="lineNum">    1702 </span>            : {
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actualVal, valBytes);</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1709 </span>            :                              CTYPESMSG_INCOMPATIBLE_THIS_VAL,
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :                              funName, actualType, valStr);</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1712 </span>            : }
<a name="1713"><span class="lineNum">    1713 </span>            : </a>
<span class="lineNum">    1714 </span>            : static bool
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 : InvalidIndexError(JSContext* cx, HandleValue val)</span>
<span class="lineNum">    1716 </span>            : {
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   JSAutoByteString idBytes;</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :   const char* indexStr = CTypesToSourceForError(cx, val, idBytes);</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :   if (!indexStr)</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :                              CTYPESMSG_INVALID_INDEX, indexStr);</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1725 </span>            : }
<a name="1726"><span class="lineNum">    1726 </span>            : </a>
<span class="lineNum">    1727 </span>            : static bool
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 : InvalidIndexError(JSContext* cx, HandleId id)</span>
<span class="lineNum">    1729 </span>            : {
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   RootedValue idVal(cx, IdToValue(id));</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   return InvalidIndexError(cx, idVal);</span>
<span class="lineNum">    1732 </span>            : }
<a name="1733"><span class="lineNum">    1733 </span>            : </a>
<span class="lineNum">    1734 </span>            : static bool
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 : InvalidIndexRangeError(JSContext* cx, size_t index, size_t length)</span>
<span class="lineNum">    1736 </span>            : {
<span class="lineNum">    1737 </span>            :   char indexStr[16];
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   SprintfLiteral(indexStr, &quot;%&quot; PRIuSIZE, index);</span>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :   char lengthStr[16];
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   SprintfLiteral(lengthStr,&quot;%&quot; PRIuSIZE, length);</span>
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :                             CTYPESMSG_INVALID_RANGE, indexStr, lengthStr);</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1746 </span>            : }
<a name="1747"><span class="lineNum">    1747 </span>            : </a>
<span class="lineNum">    1748 </span>            : static bool
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 : NonPrimitiveError(JSContext* cx, HandleObject typeObj)</span>
<span class="lineNum">    1750 </span>            : {
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(typeObj));</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :   AutoString typeSource;</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :   JSAutoByteString typeBytes;</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, typeObj, true, typeSource);</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :   const char* typeStr = EncodeLatin1(cx, typeSource, typeBytes);</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :   if (!typeStr)</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :                              CTYPESMSG_NON_PRIMITIVE, typeStr);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1763 </span>            : }
<a name="1764"><span class="lineNum">    1764 </span>            : </a>
<span class="lineNum">    1765 </span>            : static bool
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 : NonStringBaseError(JSContext* cx, HandleValue thisVal)</span>
<span class="lineNum">    1767 </span>            : {
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, thisVal, valBytes);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :                              CTYPESMSG_NON_STRING_BASE, valStr);</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1776 </span>            : }
<a name="1777"><span class="lineNum">    1777 </span>            : </a>
<span class="lineNum">    1778 </span>            : static bool
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 : NullPointerError(JSContext* cx, const char* action, HandleObject obj)</span>
<span class="lineNum">    1780 </span>            : {
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   RootedValue val(cx, ObjectValue(*obj));</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, val, valBytes);</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :                              CTYPESMSG_NULL_POINTER, action, valStr);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1790 </span>            : }
<a name="1791"><span class="lineNum">    1791 </span>            : </a>
<span class="lineNum">    1792 </span>            : static bool
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 : PropNameNonStringError(JSContext* cx, HandleId id, HandleValue actual,</span>
<span class="lineNum">    1794 </span>            :                        ConversionType convType,
<span class="lineNum">    1795 </span>            :                        HandleObject funObj = nullptr, unsigned argIndex = 0)
<span class="lineNum">    1796 </span>            : {
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :   JSAutoByteString idBytes;</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :   RootedValue idVal(cx, IdToValue(id));</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :   const char* propStr = CTypesToSourceForError(cx, idVal, idBytes);</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :   if (!propStr)</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :   JSAutoByteString posBytes;</span>
<span class="lineNum">    1809 </span>            :   const char* posStr;
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :   if (funObj) {</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :     AutoString posSource;</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :     BuildConversionPosition(cx, convType, funObj, argIndex, posSource);</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :     posStr = EncodeLatin1(cx, posSource, posBytes);</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :     if (!posStr)</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1816 </span>            :   } else {
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :     posStr = &quot;&quot;;</span>
<span class="lineNum">    1818 </span>            :   }
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :                              CTYPESMSG_PROP_NONSTRING, propStr, valStr, posStr);</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1823 </span>            : }
<a name="1824"><span class="lineNum">    1824 </span>            : </a>
<span class="lineNum">    1825 </span>            : static bool
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 : SizeOverflow(JSContext* cx, const char* name, const char* limit)</span>
<span class="lineNum">    1827 </span>            : {
<span class="lineNum">    1828 </span>            :   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :                             CTYPESMSG_SIZE_OVERFLOW, name, limit);</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1831 </span>            : }
<a name="1832"><span class="lineNum">    1832 </span>            : </a>
<span class="lineNum">    1833 </span>            : static bool
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 : TypeError(JSContext* cx, const char* expected, HandleValue actual)</span>
<span class="lineNum">    1835 </span>            : {
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :   JSAutoByteString bytes;</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :   const char* src = CTypesToSourceForError(cx, actual, bytes);</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :   if (!src)</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :                              CTYPESMSG_TYPE_ERROR, expected, src);</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1844 </span>            : }
<a name="1845"><span class="lineNum">    1845 </span>            : </a>
<span class="lineNum">    1846 </span>            : static bool
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 : TypeOverflow(JSContext* cx, const char* expected, HandleValue actual)</span>
<span class="lineNum">    1848 </span>            : {
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :                              CTYPESMSG_TYPE_OVERFLOW, valStr, expected);</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1857 </span>            : }
<a name="1858"><span class="lineNum">    1858 </span>            : </a>
<span class="lineNum">    1859 </span>            : static bool
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 : UndefinedSizeCastError(JSContext* cx, HandleObject targetTypeObj)</span>
<span class="lineNum">    1861 </span>            : {
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :   AutoString targetTypeSource;</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :   JSAutoByteString targetTypeBytes;</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, targetTypeObj, true, targetTypeSource);</span>
<span class="lineNum">    1865 </span>            :   const char* targetTypeStr = EncodeLatin1(cx, targetTypeSource,
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :                                            targetTypeBytes);</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :   if (!targetTypeStr)</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :                              CTYPESMSG_UNDEFINED_SIZE_CAST, targetTypeStr);</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1873 </span>            : }
<a name="1874"><span class="lineNum">    1874 </span>            : </a>
<span class="lineNum">    1875 </span>            : static bool
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 : SizeMismatchCastError(JSContext* cx,</span>
<span class="lineNum">    1877 </span>            :                       HandleObject sourceTypeObj, HandleObject targetTypeObj,
<span class="lineNum">    1878 </span>            :                       size_t sourceSize, size_t targetSize)
<span class="lineNum">    1879 </span>            : {
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :   AutoString sourceTypeSource;</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :   JSAutoByteString sourceTypeBytes;</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, sourceTypeObj, true, sourceTypeSource);</span>
<span class="lineNum">    1883 </span>            :   const char* sourceTypeStr = EncodeLatin1(cx, sourceTypeSource,
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :                                            sourceTypeBytes);</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :   if (!sourceTypeStr)</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   AutoString targetTypeSource;</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :   JSAutoByteString targetTypeBytes;</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, targetTypeObj, true, targetTypeSource);</span>
<span class="lineNum">    1891 </span>            :   const char* targetTypeStr = EncodeLatin1(cx, targetTypeSource,
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :                                            targetTypeBytes);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :   if (!targetTypeStr)</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span>            :   char sourceSizeStr[16];
<span class="lineNum">    1897 </span>            :   char targetSizeStr[16];
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   SprintfLiteral(sourceSizeStr, &quot;%&quot; PRIuSIZE, sourceSize);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   SprintfLiteral(targetSizeStr, &quot;%&quot; PRIuSIZE, targetSize);</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1902 </span>            :                              CTYPESMSG_SIZE_MISMATCH_CAST,
<span class="lineNum">    1903 </span>            :                              targetTypeStr, sourceTypeStr,
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                              targetSizeStr, sourceSizeStr);</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1906 </span>            : }
<a name="1907"><span class="lineNum">    1907 </span>            : </a>
<span class="lineNum">    1908 </span>            : static bool
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 : UndefinedSizePointerError(JSContext* cx, const char* action, HandleObject obj)</span>
<span class="lineNum">    1910 </span>            : {
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :   RootedValue val(cx, ObjectValue(*obj));</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, val, valBytes);</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :                              CTYPESMSG_UNDEFINED_SIZE, action, valStr);</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1920 </span>            : }
<a name="1921"><span class="lineNum">    1921 </span>            : </a>
<span class="lineNum">    1922 </span>            : static bool
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 : VariadicArgumentTypeError(JSContext* cx, uint32_t index, HandleValue actual)</span>
<span class="lineNum">    1924 </span>            : {
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :   JSAutoByteString valBytes;</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :   if (!valStr)</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            :   char indexStr[16];
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :   SprintfLiteral(indexStr, &quot;%u&quot;, index + 1);</span>
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            :   JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                              CTYPESMSG_VARG_TYPE_ERROR, indexStr, valStr);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1936 </span>            : }
<a name="1937"><span class="lineNum">    1937 </span>            : </a>
<span class="lineNum">    1938 </span>            : static JSObject*
<span class="lineNum">    1939 </span><span class="lineCov">          2 : InitCTypeClass(JSContext* cx, HandleObject ctypesObj)</span>
<span class="lineNum">    1940 </span>            : {
<span class="lineNum">    1941 </span><span class="lineCov">          2 :   JSFunction* fun = JS_DefineFunction(cx, ctypesObj, &quot;CType&quot;, ConstructAbstract, 0,</span>
<span class="lineNum">    1942 </span><span class="lineCov">          2 :                                       CTYPESCTOR_FLAGS);</span>
<span class="lineNum">    1943 </span><span class="lineCov">          2 :   if (!fun)</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineCov">          4 :   RootedObject ctor(cx, JS_GetFunctionObject(fun));</span>
<span class="lineNum">    1947 </span><span class="lineCov">          4 :   RootedObject fnproto(cx);</span>
<span class="lineNum">    1948 </span><span class="lineCov">          2 :   if (!JS_GetPrototype(cx, ctor, &amp;fnproto))</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1950 </span><span class="lineCov">          2 :   MOZ_ASSERT(ctor);</span>
<span class="lineNum">    1951 </span><span class="lineCov">          2 :   MOZ_ASSERT(fnproto);</span>
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span>            :   // Set up ctypes.CType.prototype.
<span class="lineNum">    1954 </span><span class="lineCov">          4 :   RootedObject prototype(cx, JS_NewObjectWithGivenProto(cx, &amp;sCTypeProtoClass, fnproto));</span>
<span class="lineNum">    1955 </span><span class="lineCov">          2 :   if (!prototype)</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctor, &quot;prototype&quot;, prototype,</span>
<span class="lineNum">    1959 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, prototype, &quot;constructor&quot;, ctor,</span>
<span class="lineNum">    1963 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            :   // Define properties and functions common to all CTypes.
<span class="lineNum">    1967 </span><span class="lineCov">          8 :   if (!JS_DefineProperties(cx, prototype, sCTypeProps) ||</span>
<span class="lineNum">    1968 </span><span class="lineCov">          6 :       !JS_DefineFunctions(cx, prototype, sCTypeFunctions))</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineCov">          2 :   if (!JS_FreezeObject(cx, ctor) || !JS_FreezeObject(cx, prototype))</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span><span class="lineCov">          2 :   return prototype;</span>
<span class="lineNum">    1975 </span>            : }
<a name="1976"><span class="lineNum">    1976 </span>            : </a>
<span class="lineNum">    1977 </span>            : static JSObject*
<span class="lineNum">    1978 </span><span class="lineCov">          2 : InitABIClass(JSContext* cx)</span>
<span class="lineNum">    1979 </span>            : {
<span class="lineNum">    1980 </span><span class="lineCov">          4 :   RootedObject obj(cx, JS_NewPlainObject(cx));</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineCov">          2 :   if (!obj)</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineCov">          2 :   if (!JS_DefineFunctions(cx, obj, sCABIFunctions))</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1987 </span>            : 
<span class="lineNum">    1988 </span><span class="lineCov">          2 :   return obj;</span>
<span class="lineNum">    1989 </span>            : }
<span class="lineNum">    1990 </span>            : 
<a name="1991"><span class="lineNum">    1991 </span>            : </a>
<span class="lineNum">    1992 </span>            : static JSObject*
<span class="lineNum">    1993 </span><span class="lineCov">          2 : InitCDataClass(JSContext* cx, HandleObject parent, HandleObject CTypeProto)</span>
<span class="lineNum">    1994 </span>            : {
<span class="lineNum">    1995 </span><span class="lineCov">          2 :   JSFunction* fun = JS_DefineFunction(cx, parent, &quot;CData&quot;, ConstructAbstract, 0,</span>
<span class="lineNum">    1996 </span><span class="lineCov">          2 :                       CTYPESCTOR_FLAGS);</span>
<span class="lineNum">    1997 </span><span class="lineCov">          2 :   if (!fun)</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span><span class="lineCov">          4 :   RootedObject ctor(cx, JS_GetFunctionObject(fun));</span>
<span class="lineNum">    2001 </span><span class="lineCov">          2 :   MOZ_ASSERT(ctor);</span>
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span>            :   // Set up ctypes.CData.__proto__ === ctypes.CType.prototype.
<span class="lineNum">    2004 </span>            :   // (Note that 'ctypes.CData instanceof Function' is still true, thanks to the
<span class="lineNum">    2005 </span>            :   // prototype chain.)
<span class="lineNum">    2006 </span><span class="lineCov">          2 :   if (!JS_SetPrototype(cx, ctor, CTypeProto))</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span>            :   // Set up ctypes.CData.prototype.
<span class="lineNum">    2010 </span><span class="lineCov">          4 :   RootedObject prototype(cx, JS_NewObject(cx, &amp;sCDataProtoClass));</span>
<span class="lineNum">    2011 </span><span class="lineCov">          2 :   if (!prototype)</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctor, &quot;prototype&quot;, prototype,</span>
<span class="lineNum">    2015 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2017 </span>            : 
<span class="lineNum">    2018 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, prototype, &quot;constructor&quot;, ctor,</span>
<span class="lineNum">    2019 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :   // Define properties and functions common to all CDatas.
<span class="lineNum">    2023 </span><span class="lineCov">          8 :   if (!JS_DefineProperties(cx, prototype, sCDataProps) ||</span>
<span class="lineNum">    2024 </span><span class="lineCov">          6 :       !JS_DefineFunctions(cx, prototype, sCDataFunctions))</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2026 </span>            : 
<span class="lineNum">    2027 </span><span class="lineCov">          4 :   if (//!JS_FreezeObject(cx, prototype) || // XXX fixme - see bug 541212!</span>
<span class="lineNum">    2028 </span><span class="lineCov">          4 :       !JS_FreezeObject(cx, ctor))</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">          2 :   return prototype;</span>
<span class="lineNum">    2032 </span>            : }
<a name="2033"><span class="lineNum">    2033 </span>            : </a>
<span class="lineNum">    2034 </span>            : static bool
<span class="lineNum">    2035 </span><span class="lineCov">          8 : DefineABIConstant(JSContext* cx,</span>
<span class="lineNum">    2036 </span>            :                   HandleObject ctypesObj,
<span class="lineNum">    2037 </span>            :                   const char* name,
<span class="lineNum">    2038 </span>            :                   ABICode code,
<span class="lineNum">    2039 </span>            :                   HandleObject prototype)
<span class="lineNum">    2040 </span>            : {
<span class="lineNum">    2041 </span><span class="lineCov">         16 :   RootedObject obj(cx, JS_NewObjectWithGivenProto(cx, &amp;sCABIClass, prototype));</span>
<span class="lineNum">    2042 </span><span class="lineCov">          8 :   if (!obj)</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2044 </span><span class="lineCov">          8 :   JS_SetReservedSlot(obj, SLOT_ABICODE, Int32Value(code));</span>
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span><span class="lineCov">          8 :   if (!JS_FreezeObject(cx, obj))</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span><span class="lineCov">         16 :   return JS_DefineProperty(cx, ctypesObj, name, obj,</span>
<span class="lineNum">    2050 </span><span class="lineCov">          8 :                            JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT);</span>
<span class="lineNum">    2051 </span>            : }
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            : // Set up a single type constructor for
<a name="2054"><span class="lineNum">    2054 </span>            : // ctypes.{Pointer,Array,Struct,Function}Type.</a>
<span class="lineNum">    2055 </span>            : static bool
<span class="lineNum">    2056 </span><span class="lineCov">          8 : InitTypeConstructor(JSContext* cx,</span>
<span class="lineNum">    2057 </span>            :                     HandleObject parent,
<span class="lineNum">    2058 </span>            :                     HandleObject CTypeProto,
<span class="lineNum">    2059 </span>            :                     HandleObject CDataProto,
<span class="lineNum">    2060 </span>            :                     const JSFunctionSpec spec,
<span class="lineNum">    2061 </span>            :                     const JSFunctionSpec* fns,
<span class="lineNum">    2062 </span>            :                     const JSPropertySpec* props,
<span class="lineNum">    2063 </span>            :                     const JSFunctionSpec* instanceFns,
<span class="lineNum">    2064 </span>            :                     const JSPropertySpec* instanceProps,
<span class="lineNum">    2065 </span>            :                     MutableHandleObject typeProto,
<span class="lineNum">    2066 </span>            :                     MutableHandleObject dataProto)
<span class="lineNum">    2067 </span>            : {
<span class="lineNum">    2068 </span><span class="lineCov">         24 :   JSFunction* fun = js::DefineFunctionWithReserved(cx, parent, spec.name, spec.call.op,</span>
<span class="lineNum">    2069 </span><span class="lineCov">         32 :                       spec.nargs, spec.flags);</span>
<span class="lineNum">    2070 </span><span class="lineCov">          8 :   if (!fun)</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span><span class="lineCov">         16 :   RootedObject obj(cx, JS_GetFunctionObject(fun));</span>
<span class="lineNum">    2074 </span><span class="lineCov">          8 :   if (!obj)</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            :   // Set up the .prototype and .prototype.constructor properties.
<span class="lineNum">    2078 </span><span class="lineCov">          8 :   typeProto.set(JS_NewObjectWithGivenProto(cx, &amp;sCTypeProtoClass, CTypeProto));</span>
<span class="lineNum">    2079 </span><span class="lineCov">          8 :   if (!typeProto)</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span>            :   // Define property before proceeding, for GC safety.
<span class="lineNum">    2083 </span><span class="lineCov">          8 :   if (!JS_DefineProperty(cx, obj, &quot;prototype&quot;, typeProto,</span>
<span class="lineNum">    2084 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span><span class="lineCov">          8 :   if (fns &amp;&amp; !JS_DefineFunctions(cx, typeProto, fns))</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span><span class="lineCov">          8 :   if (!JS_DefineProperties(cx, typeProto, props))</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span><span class="lineCov">          8 :   if (!JS_DefineProperty(cx, typeProto, &quot;constructor&quot;, obj,</span>
<span class="lineNum">    2094 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span>            :   // Stash ctypes.{Pointer,Array,Struct}Type.prototype on a reserved slot of
<span class="lineNum">    2098 </span>            :   // the type constructor, for faster lookup.
<span class="lineNum">    2099 </span><span class="lineCov">          8 :   js::SetFunctionNativeReserved(obj, SLOT_FN_CTORPROTO, ObjectValue(*typeProto));</span>
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span>            :   // Create an object to serve as the common ancestor for all CData objects
<span class="lineNum">    2102 </span>            :   // created from the given type constructor. This has ctypes.CData.prototype
<span class="lineNum">    2103 </span>            :   // as its prototype, such that it inherits the properties and functions
<span class="lineNum">    2104 </span>            :   // common to all CDatas.
<span class="lineNum">    2105 </span><span class="lineCov">          8 :   dataProto.set(JS_NewObjectWithGivenProto(cx, &amp;sCDataProtoClass, CDataProto));</span>
<span class="lineNum">    2106 </span><span class="lineCov">          8 :   if (!dataProto)</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span>            :   // Define functions and properties on the 'dataProto' object that are common
<span class="lineNum">    2110 </span>            :   // to all CData objects created from this type constructor. (These will
<span class="lineNum">    2111 </span>            :   // become functions and properties on CData objects created from this type.)
<span class="lineNum">    2112 </span><span class="lineCov">          8 :   if (instanceFns &amp;&amp; !JS_DefineFunctions(cx, dataProto, instanceFns))</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span><span class="lineCov">          8 :   if (instanceProps &amp;&amp; !JS_DefineProperties(cx, dataProto, instanceProps))</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            :   // Link the type prototype to the data prototype.
<span class="lineNum">    2119 </span><span class="lineCov">          8 :   JS_SetReservedSlot(typeProto, SLOT_OURDATAPROTO, ObjectValue(*dataProto));</span>
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span><span class="lineCov">         32 :   if (!JS_FreezeObject(cx, obj) ||</span>
<span class="lineNum">    2122 </span>            :       //!JS_FreezeObject(cx, dataProto) || // XXX fixme - see bug 541212!
<span class="lineNum">    2123 </span><span class="lineCov">         24 :       !JS_FreezeObject(cx, typeProto))</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span><span class="lineCov">          8 :   return true;</span>
<span class="lineNum">    2127 </span>            : }
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<span class="lineNum">    2129 </span>            : static JSObject*
<span class="lineNum">    2130 </span><span class="lineCov">          4 : InitInt64Class(JSContext* cx,</span>
<span class="lineNum">    2131 </span>            :                HandleObject parent,
<span class="lineNum">    2132 </span>            :                const JSClass* clasp,
<span class="lineNum">    2133 </span>            :                JSNative construct,
<span class="lineNum">    2134 </span>            :                const JSFunctionSpec* fs,
<span class="lineNum">    2135 </span>            :                const JSFunctionSpec* static_fs)
<span class="lineNum">    2136 </span>            : {
<span class="lineNum">    2137 </span>            :   // Init type class and constructor
<span class="lineNum">    2138 </span><span class="lineCov">          8 :   RootedObject prototype(cx, JS_InitClass(cx, parent, nullptr, clasp, construct,</span>
<span class="lineNum">    2139 </span><span class="lineCov">          8 :                                           0, nullptr, fs, nullptr, static_fs));</span>
<span class="lineNum">    2140 </span><span class="lineCov">          4 :   if (!prototype)</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span><span class="lineCov">          8 :   RootedObject ctor(cx, JS_GetConstructor(cx, prototype));</span>
<span class="lineNum">    2144 </span><span class="lineCov">          4 :   if (!ctor)</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span>            :   // Define the 'join' function as an extended native and stash
<span class="lineNum">    2148 </span>            :   // ctypes.{Int64,UInt64}.prototype in a reserved slot of the new function.
<span class="lineNum">    2149 </span><span class="lineCov">          4 :   MOZ_ASSERT(clasp == &amp;sInt64ProtoClass || clasp == &amp;sUInt64ProtoClass);</span>
<span class="lineNum">    2150 </span><span class="lineCov">          4 :   JSNative native = (clasp == &amp;sInt64ProtoClass) ? Int64::Join : UInt64::Join;</span>
<span class="lineNum">    2151 </span><span class="lineCov">          4 :   JSFunction* fun = js::DefineFunctionWithReserved(cx, ctor, &quot;join&quot;, native,</span>
<span class="lineNum">    2152 </span><span class="lineCov">          8 :                       2, CTYPESFN_FLAGS);</span>
<span class="lineNum">    2153 </span><span class="lineCov">          4 :   if (!fun)</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span><span class="lineCov">          4 :   js::SetFunctionNativeReserved(fun, SLOT_FN_INT64PROTO, ObjectValue(*prototype));</span>
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span><span class="lineCov">          4 :   if (!JS_FreezeObject(cx, ctor))</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2160 </span><span class="lineCov">          4 :   if (!JS_FreezeObject(cx, prototype))</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span><span class="lineCov">          4 :   return prototype;</span>
<span class="lineNum">    2164 </span>            : }
<a name="2165"><span class="lineNum">    2165 </span>            : </a>
<span class="lineNum">    2166 </span>            : static void
<span class="lineNum">    2167 </span><span class="lineCov">         10 : AttachProtos(JSObject* proto, const AutoObjectVector&amp; protos)</span>
<span class="lineNum">    2168 </span>            : {
<span class="lineNum">    2169 </span>            :   // For a given 'proto' of [[Class]] &quot;CTypeProto&quot;, attach each of the 'protos'
<span class="lineNum">    2170 </span>            :   // to the appropriate CTypeProtoSlot. (SLOT_CTYPES is the last slot
<span class="lineNum">    2171 </span>            :   // of [[Class]] &quot;CTypeProto&quot; that we fill in this automated manner.)
<span class="lineNum">    2172 </span><span class="lineCov">        130 :   for (uint32_t i = 0; i &lt;= SLOT_CTYPES; ++i)</span>
<span class="lineNum">    2173 </span><span class="lineCov">        120 :     JS_SetReservedSlot(proto, i, ObjectOrNullValue(protos[i]));</span>
<span class="lineNum">    2174 </span><span class="lineCov">         10 : }</span>
<a name="2175"><span class="lineNum">    2175 </span>            : </a>
<span class="lineNum">    2176 </span>            : static bool
<span class="lineNum">    2177 </span><span class="lineCov">          2 : InitTypeClasses(JSContext* cx, HandleObject ctypesObj)</span>
<span class="lineNum">    2178 </span>            : {
<span class="lineNum">    2179 </span>            :   // Initialize the ctypes.CType class. This acts as an abstract base class for
<span class="lineNum">    2180 </span>            :   // the various types, and provides the common API functions. It has:
<span class="lineNum">    2181 </span>            :   //   * [[Class]] &quot;Function&quot;
<span class="lineNum">    2182 </span>            :   //   * __proto__ === Function.prototype
<span class="lineNum">    2183 </span>            :   //   * A constructor that throws a TypeError. (You can't construct an
<span class="lineNum">    2184 </span>            :   //     abstract type!)
<span class="lineNum">    2185 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2186 </span>            :   //     * [[Class]] &quot;CTypeProto&quot;
<span class="lineNum">    2187 </span>            :   //     * __proto__ === Function.prototype
<span class="lineNum">    2188 </span>            :   //     * A constructor that throws a TypeError. (You can't construct an
<span class="lineNum">    2189 </span>            :   //       abstract type instance!)
<span class="lineNum">    2190 </span>            :   //     * 'constructor' property === ctypes.CType
<span class="lineNum">    2191 </span>            :   //     * Provides properties and functions common to all CTypes.
<span class="lineNum">    2192 </span><span class="lineCov">          4 :   RootedObject CTypeProto(cx, InitCTypeClass(cx, ctypesObj));</span>
<span class="lineNum">    2193 </span><span class="lineCov">          2 :   if (!CTypeProto)</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span>            :   // Initialize the ctypes.CData class. This acts as an abstract base class for
<span class="lineNum">    2197 </span>            :   // instances of the various types, and provides the common API functions.
<span class="lineNum">    2198 </span>            :   // It has:
<span class="lineNum">    2199 </span>            :   //   * [[Class]] &quot;Function&quot;
<span class="lineNum">    2200 </span>            :   //   * __proto__ === Function.prototype
<span class="lineNum">    2201 </span>            :   //   * A constructor that throws a TypeError. (You can't construct an
<span class="lineNum">    2202 </span>            :   //     abstract type instance!)
<span class="lineNum">    2203 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2204 </span>            :   //     * [[Class]] &quot;CDataProto&quot;
<span class="lineNum">    2205 </span>            :   //     * 'constructor' property === ctypes.CData
<span class="lineNum">    2206 </span>            :   //     * Provides properties and functions common to all CDatas.
<span class="lineNum">    2207 </span><span class="lineCov">          4 :   RootedObject CDataProto(cx, InitCDataClass(cx, ctypesObj, CTypeProto));</span>
<span class="lineNum">    2208 </span><span class="lineCov">          2 :   if (!CDataProto)</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span>            :   // Link CTypeProto to CDataProto.
<span class="lineNum">    2212 </span><span class="lineCov">          2 :   JS_SetReservedSlot(CTypeProto, SLOT_OURDATAPROTO, ObjectValue(*CDataProto));</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :   // Create and attach the special class constructors: ctypes.PointerType,
<span class="lineNum">    2215 </span>            :   // ctypes.ArrayType, ctypes.StructType, and ctypes.FunctionType.
<span class="lineNum">    2216 </span>            :   // Each of these constructors 'c' has, respectively:
<span class="lineNum">    2217 </span>            :   //   * [[Class]] &quot;Function&quot;
<span class="lineNum">    2218 </span>            :   //   * __proto__ === Function.prototype
<span class="lineNum">    2219 </span>            :   //   * A constructor that creates a user-defined type.
<span class="lineNum">    2220 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2221 </span>            :   //     * [[Class]] &quot;CTypeProto&quot;
<span class="lineNum">    2222 </span>            :   //     * __proto__ === ctypes.CType.prototype
<span class="lineNum">    2223 </span>            :   //     * 'constructor' property === 'c'
<span class="lineNum">    2224 </span>            :   // We also construct an object 'p' to serve, given a type object 't'
<span class="lineNum">    2225 </span>            :   // constructed from one of these type constructors, as
<span class="lineNum">    2226 </span>            :   // 't.prototype.__proto__'. This object has:
<span class="lineNum">    2227 </span>            :   //   * [[Class]] &quot;CDataProto&quot;
<span class="lineNum">    2228 </span>            :   //   * __proto__ === ctypes.CData.prototype
<span class="lineNum">    2229 </span>            :   //   * Properties and functions common to all CDatas.
<span class="lineNum">    2230 </span>            :   // Therefore an instance 't' of ctypes.{Pointer,Array,Struct,Function}Type
<span class="lineNum">    2231 </span>            :   // will have, resp.:
<span class="lineNum">    2232 </span>            :   //   * [[Class]] &quot;CType&quot;
<span class="lineNum">    2233 </span>            :   //   * __proto__ === ctypes.{Pointer,Array,Struct,Function}Type.prototype
<span class="lineNum">    2234 </span>            :   //   * A constructor which creates and returns a CData object, containing
<span class="lineNum">    2235 </span>            :   //     binary data of the given type.
<span class="lineNum">    2236 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2237 </span>            :   //     * [[Class]] &quot;CDataProto&quot;
<span class="lineNum">    2238 </span>            :   //     * __proto__ === 'p', the prototype object from above
<span class="lineNum">    2239 </span>            :   //     * 'constructor' property === 't'
<span class="lineNum">    2240 </span><span class="lineCov">          4 :   AutoObjectVector protos(cx);</span>
<span class="lineNum">    2241 </span><span class="lineCov">          2 :   if (!protos.resize(CTYPEPROTO_SLOTS))</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2243 </span><span class="lineCov">          2 :   if (!InitTypeConstructor(cx, ctypesObj, CTypeProto, CDataProto,</span>
<span class="lineNum">    2244 </span>            :          sPointerFunction, nullptr, sPointerProps,
<span class="lineNum">    2245 </span>            :          sPointerInstanceFunctions, sPointerInstanceProps,
<span class="lineNum">    2246 </span>            :          protos[SLOT_POINTERPROTO], protos[SLOT_POINTERDATAPROTO]))
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span><span class="lineCov">          2 :   if (!InitTypeConstructor(cx, ctypesObj, CTypeProto, CDataProto,</span>
<span class="lineNum">    2250 </span>            :          sArrayFunction, nullptr, sArrayProps,
<span class="lineNum">    2251 </span>            :          sArrayInstanceFunctions, sArrayInstanceProps,
<span class="lineNum">    2252 </span>            :          protos[SLOT_ARRAYPROTO], protos[SLOT_ARRAYDATAPROTO]))
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span><span class="lineCov">          2 :   if (!InitTypeConstructor(cx, ctypesObj, CTypeProto, CDataProto,</span>
<span class="lineNum">    2256 </span>            :          sStructFunction, sStructFunctions, sStructProps,
<span class="lineNum">    2257 </span>            :          sStructInstanceFunctions, nullptr,
<span class="lineNum">    2258 </span>            :          protos[SLOT_STRUCTPROTO], protos[SLOT_STRUCTDATAPROTO]))
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineCov">          2 :   if (!InitTypeConstructor(cx, ctypesObj, CTypeProto, protos[SLOT_POINTERDATAPROTO],</span>
<span class="lineNum">    2262 </span>            :          sFunctionFunction, nullptr, sFunctionProps, sFunctionInstanceFunctions, nullptr,
<span class="lineNum">    2263 </span>            :          protos[SLOT_FUNCTIONPROTO], protos[SLOT_FUNCTIONDATAPROTO]))
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span><span class="lineCov">          2 :   protos[SLOT_CDATAPROTO].set(CDataProto);</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            :   // Create and attach the ctypes.{Int64,UInt64} constructors.
<span class="lineNum">    2269 </span>            :   // Each of these has, respectively:
<span class="lineNum">    2270 </span>            :   //   * [[Class]] &quot;Function&quot;
<span class="lineNum">    2271 </span>            :   //   * __proto__ === Function.prototype
<span class="lineNum">    2272 </span>            :   //   * A constructor that creates a ctypes.{Int64,UInt64} object, respectively.
<span class="lineNum">    2273 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2274 </span>            :   //     * [[Class]] {&quot;Int64Proto&quot;,&quot;UInt64Proto&quot;}
<span class="lineNum">    2275 </span>            :   //     * 'constructor' property === ctypes.{Int64,UInt64}
<span class="lineNum">    2276 </span><span class="lineCov">          4 :   protos[SLOT_INT64PROTO].set(InitInt64Class(cx, ctypesObj, &amp;sInt64ProtoClass,</span>
<span class="lineNum">    2277 </span><span class="lineCov">          2 :     Int64::Construct, sInt64Functions, sInt64StaticFunctions));</span>
<span class="lineNum">    2278 </span><span class="lineCov">          2 :   if (!protos[SLOT_INT64PROTO])</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2280 </span><span class="lineCov">          4 :   protos[SLOT_UINT64PROTO].set(InitInt64Class(cx, ctypesObj, &amp;sUInt64ProtoClass,</span>
<span class="lineNum">    2281 </span><span class="lineCov">          2 :     UInt64::Construct, sUInt64Functions, sUInt64StaticFunctions));</span>
<span class="lineNum">    2282 </span><span class="lineCov">          2 :   if (!protos[SLOT_UINT64PROTO])</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span>            :   // Finally, store a pointer to the global ctypes object.
<span class="lineNum">    2286 </span>            :   // Note that there is no other reliable manner of locating this object.
<span class="lineNum">    2287 </span><span class="lineCov">          2 :   protos[SLOT_CTYPES].set(ctypesObj);</span>
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            :   // Attach the prototypes just created to each of ctypes.CType.prototype,
<span class="lineNum">    2290 </span>            :   // and the special type constructors, so we can access them when constructing
<span class="lineNum">    2291 </span>            :   // instances of those types.
<span class="lineNum">    2292 </span><span class="lineCov">          2 :   AttachProtos(CTypeProto, protos);</span>
<span class="lineNum">    2293 </span><span class="lineCov">          2 :   AttachProtos(protos[SLOT_POINTERPROTO], protos);</span>
<span class="lineNum">    2294 </span><span class="lineCov">          2 :   AttachProtos(protos[SLOT_ARRAYPROTO], protos);</span>
<span class="lineNum">    2295 </span><span class="lineCov">          2 :   AttachProtos(protos[SLOT_STRUCTPROTO], protos);</span>
<span class="lineNum">    2296 </span><span class="lineCov">          2 :   AttachProtos(protos[SLOT_FUNCTIONPROTO], protos);</span>
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span><span class="lineCov">          4 :   RootedObject ABIProto(cx, InitABIClass(cx));</span>
<span class="lineNum">    2299 </span><span class="lineCov">          2 :   if (!ABIProto)</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span>            :   // Attach objects representing ABI constants.
<span class="lineNum">    2303 </span><span class="lineCov">         12 :   if (!DefineABIConstant(cx, ctypesObj, &quot;default_abi&quot;, ABI_DEFAULT, ABIProto) ||</span>
<span class="lineNum">    2304 </span><span class="lineCov">         10 :       !DefineABIConstant(cx, ctypesObj, &quot;stdcall_abi&quot;, ABI_STDCALL, ABIProto) ||</span>
<span class="lineNum">    2305 </span><span class="lineCov">         16 :       !DefineABIConstant(cx, ctypesObj, &quot;thiscall_abi&quot;, ABI_THISCALL, ABIProto) ||</span>
<span class="lineNum">    2306 </span><span class="lineCov">          6 :       !DefineABIConstant(cx, ctypesObj, &quot;winapi_abi&quot;, ABI_WINAPI, ABIProto))</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span>            :   // Create objects representing the builtin types, and attach them to the
<span class="lineNum">    2310 </span>            :   // ctypes object. Each type object 't' has:
<span class="lineNum">    2311 </span>            :   //   * [[Class]] &quot;CType&quot;
<span class="lineNum">    2312 </span>            :   //   * __proto__ === ctypes.CType.prototype
<span class="lineNum">    2313 </span>            :   //   * A constructor which creates and returns a CData object, containing
<span class="lineNum">    2314 </span>            :   //     binary data of the given type.
<span class="lineNum">    2315 </span>            :   //   * 'prototype' property:
<span class="lineNum">    2316 </span>            :   //     * [[Class]] &quot;CDataProto&quot;
<span class="lineNum">    2317 </span>            :   //     * __proto__ === ctypes.CData.prototype
<span class="lineNum">    2318 </span>            :   //     * 'constructor' property === 't'
<span class="lineNum">    2319 </span>            : #define DEFINE_TYPE(name, type, ffiType)                                       \
<span class="lineNum">    2320 </span>            :   RootedObject typeObj_##name(cx);                                             \
<span class="lineNum">    2321 </span>            :   {                                                                            \
<span class="lineNum">    2322 </span>            :     RootedValue typeVal(cx, Int32Value(sizeof(type)));                         \
<span class="lineNum">    2323 </span>            :     RootedValue alignVal(cx, Int32Value(ffiType.alignment));                   \
<span class="lineNum">    2324 </span>            :     typeObj_##name = CType::DefineBuiltin(cx, ctypesObj, #name, CTypeProto,    \
<span class="lineNum">    2325 </span>            :                                           CDataProto, #name, TYPE_##name,      \
<span class="lineNum">    2326 </span>            :                                           typeVal, alignVal, &amp;ffiType);        \
<span class="lineNum">    2327 </span>            :     if (!typeObj_##name)                                                       \
<span class="lineNum">    2328 </span>            :       return false;                                                            \
<span class="lineNum">    2329 </span>            :   }
<span class="lineNum">    2330 </span><span class="lineCov">          4 :   CTYPES_FOR_EACH_TYPE(DEFINE_TYPE)</span>
<span class="lineNum">    2331 </span>            : #undef DEFINE_TYPE
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            :   // Alias 'ctypes.unsigned' as 'ctypes.unsigned_int', since they represent
<span class="lineNum">    2334 </span>            :   // the same type in C.
<span class="lineNum">    2335 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctypesObj, &quot;unsigned&quot;, typeObj_unsigned_int,</span>
<span class="lineNum">    2336 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span>            :   // Alias 'ctypes.jschar' as 'ctypes.char16_t' to prevent breaking addons
<span class="lineNum">    2340 </span>            :   // that are still using jschar (bug 1064935).
<span class="lineNum">    2341 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctypesObj, &quot;jschar&quot;, typeObj_char16_t,</span>
<span class="lineNum">    2342 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            :   // Create objects representing the special types void_t and voidptr_t.
<span class="lineNum">    2346 </span>            :   RootedObject typeObj(cx,
<span class="lineNum">    2347 </span><span class="lineCov">          6 :     CType::DefineBuiltin(cx, ctypesObj, &quot;void_t&quot;, CTypeProto, CDataProto, &quot;void&quot;,</span>
<span class="lineNum">    2348 </span>            :                          TYPE_void_t, JS::UndefinedHandleValue, JS::UndefinedHandleValue,
<span class="lineNum">    2349 </span><span class="lineCov">          8 :                          &amp;ffi_type_void));</span>
<span class="lineNum">    2350 </span><span class="lineCov">          2 :   if (!typeObj)</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span><span class="lineCov">          2 :   typeObj = PointerType::CreateInternal(cx, typeObj);</span>
<span class="lineNum">    2354 </span><span class="lineCov">          2 :   if (!typeObj)</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2356 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctypesObj, &quot;voidptr_t&quot;, typeObj,</span>
<span class="lineNum">    2357 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span><span class="lineCov">          2 :   return true;</span>
<span class="lineNum">    2361 </span>            : }
<a name="2362"><span class="lineNum">    2362 </span>            : </a>
<span class="lineNum">    2363 </span>            : bool
<span class="lineNum">    2364 </span><span class="lineCov">          2 : IsCTypesGlobal(JSObject* obj)</span>
<span class="lineNum">    2365 </span>            : {
<span class="lineNum">    2366 </span><span class="lineCov">          2 :   return JS_GetClass(obj) == &amp;sCTypesGlobalClass;</span>
<span class="lineNum">    2367 </span>            : }
<a name="2368"><span class="lineNum">    2368 </span>            : </a>
<span class="lineNum">    2369 </span>            : bool
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 : IsCTypesGlobal(HandleValue v)</span>
<span class="lineNum">    2371 </span>            : {
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :   return v.isObject() &amp;&amp; IsCTypesGlobal(&amp;v.toObject());</span>
<span class="lineNum">    2373 </span>            : }
<span class="lineNum">    2374 </span>            : 
<a name="2375"><span class="lineNum">    2375 </span>            : // Get the JSCTypesCallbacks struct from the 'ctypes' object 'obj'.</a>
<span class="lineNum">    2376 </span>            : const JSCTypesCallbacks*
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 : GetCallbacks(JSObject* obj)</span>
<span class="lineNum">    2378 </span>            : {
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsCTypesGlobal(obj));</span>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :   Value result = JS_GetReservedSlot(obj, SLOT_CALLBACKS);</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :   if (result.isUndefined())</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :   return static_cast&lt;const JSCTypesCallbacks*&gt;(result.toPrivate());</span>
<span class="lineNum">    2386 </span>            : }
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            : // Utility function to access a property of an object as an object
<a name="2389"><span class="lineNum">    2389 </span>            : // returns false and sets the error if the property does not exist</a>
<span class="lineNum">    2390 </span>            : // or is not an object
<span class="lineNum">    2391 </span><span class="lineCov">          2 : static bool GetObjectProperty(JSContext* cx, HandleObject obj,</span>
<span class="lineNum">    2392 </span>            :                               const char* property, MutableHandleObject result)
<span class="lineNum">    2393 </span>            : {
<span class="lineNum">    2394 </span><span class="lineCov">          4 :   RootedValue val(cx);</span>
<span class="lineNum">    2395 </span><span class="lineCov">          2 :   if (!JS_GetProperty(cx, obj, property, &amp;val)) {</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2397 </span>            :   }
<span class="lineNum">    2398 </span>            : 
<span class="lineNum">    2399 </span><span class="lineCov">          2 :   if (val.isPrimitive()) {</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;missing or non-object field&quot;);</span>
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2402 </span>            :   }
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span><span class="lineCov">          2 :   result.set(val.toObjectOrNull());</span>
<span class="lineNum">    2405 </span><span class="lineCov">          2 :   return true;</span>
<span class="lineNum">    2406 </span>            : }
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span>            : } /* namespace ctypes */
<span class="lineNum">    2409 </span>            : } /* namespace js */
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span>            : using namespace js;
<span class="lineNum">    2412 </span>            : using namespace js::ctypes;
<a name="2413"><span class="lineNum">    2413 </span>            : </a>
<span class="lineNum">    2414 </span>            : JS_PUBLIC_API(bool)
<span class="lineNum">    2415 </span><span class="lineCov">          2 : JS_InitCTypesClass(JSContext* cx, HandleObject global)</span>
<span class="lineNum">    2416 </span>            : {
<span class="lineNum">    2417 </span>            :   // attach ctypes property to global object
<span class="lineNum">    2418 </span><span class="lineCov">          4 :   RootedObject ctypes(cx, JS_NewObject(cx, &amp;sCTypesGlobalClass));</span>
<span class="lineNum">    2419 </span><span class="lineCov">          2 :   if (!ctypes)</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, global, &quot;ctypes&quot;, ctypes,</span>
<span class="lineNum">    2423 </span>            :                          JSPROP_READONLY | JSPROP_PERMANENT,
<span class="lineNum">    2424 </span>            :                          JS_STUBGETTER, JS_STUBSETTER)){
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2426 </span>            :   }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineCov">          2 :   if (!InitTypeClasses(cx, ctypes))</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span>            :   // attach API functions and properties
<span class="lineNum">    2432 </span><span class="lineCov">          8 :   if (!JS_DefineFunctions(cx, ctypes, sModuleFunctions) ||</span>
<span class="lineNum">    2433 </span><span class="lineCov">          6 :       !JS_DefineProperties(cx, ctypes, sModuleProps))</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2435 </span>            : 
<span class="lineNum">    2436 </span>            :   // Set up ctypes.CDataFinalizer.prototype.
<span class="lineNum">    2437 </span><span class="lineCov">          4 :   RootedObject ctor(cx);</span>
<span class="lineNum">    2438 </span><span class="lineCov">          2 :   if (!GetObjectProperty(cx, ctypes, &quot;CDataFinalizer&quot;, &amp;ctor))</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span><span class="lineCov">          4 :   RootedObject prototype(cx, JS_NewObject(cx, &amp;sCDataFinalizerProtoClass));</span>
<span class="lineNum">    2442 </span><span class="lineCov">          2 :   if (!prototype)</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span><span class="lineCov">          2 :   if (!JS_DefineFunctions(cx, prototype, sCDataFinalizerFunctions))</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, ctor, &quot;prototype&quot;, prototype,</span>
<span class="lineNum">    2449 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineCov">          2 :   if (!JS_DefineProperty(cx, prototype, &quot;constructor&quot;, ctor,</span>
<span class="lineNum">    2453 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2455 </span>            : 
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            :   // Seal the ctypes object, to prevent modification.
<span class="lineNum">    2458 </span><span class="lineCov">          2 :   return JS_FreezeObject(cx, ctypes);</span>
<span class="lineNum">    2459 </span>            : }
<a name="2460"><span class="lineNum">    2460 </span>            : </a>
<span class="lineNum">    2461 </span>            : JS_PUBLIC_API(void)
<span class="lineNum">    2462 </span><span class="lineCov">          2 : JS_SetCTypesCallbacks(JSObject* ctypesObj, const JSCTypesCallbacks* callbacks)</span>
<span class="lineNum">    2463 </span>            : {
<span class="lineNum">    2464 </span><span class="lineCov">          2 :   MOZ_ASSERT(callbacks);</span>
<span class="lineNum">    2465 </span><span class="lineCov">          2 :   MOZ_ASSERT(IsCTypesGlobal(ctypesObj));</span>
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span>            :   // Set the callbacks on a reserved slot.
<span class="lineNum">    2468 </span>            :   JS_SetReservedSlot(ctypesObj, SLOT_CALLBACKS,
<span class="lineNum">    2469 </span><span class="lineCov">          2 :                      PrivateValue(const_cast&lt;JSCTypesCallbacks*&gt;(callbacks)));</span>
<span class="lineNum">    2470 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    2471 </span>            : 
<span class="lineNum">    2472 </span>            : namespace js {
<a name="2473"><span class="lineNum">    2473 </span>            : </a>
<span class="lineNum">    2474 </span>            : JS_FRIEND_API(size_t)
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 : SizeOfDataIfCDataObject(mozilla::MallocSizeOf mallocSizeOf, JSObject* obj)</span>
<span class="lineNum">    2476 </span>            : {
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :     if (!CData::IsCData(obj))</span>
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :     size_t n = 0;</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     Value slot = JS_GetReservedSlot(obj, ctypes::SLOT_OWNS);</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :     if (!slot.isUndefined()) {</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :         bool owns = slot.toBoolean();</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :         slot = JS_GetReservedSlot(obj, ctypes::SLOT_DATA);</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :         if (!slot.isUndefined()) {</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :             char** buffer = static_cast&lt;char**&gt;(slot.toPrivate());</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :             n += mallocSizeOf(buffer);</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :             if (owns)</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :                 n += mallocSizeOf(*buffer);</span>
<span class="lineNum">    2490 </span>            :         }
<span class="lineNum">    2491 </span>            :     }
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :     return n;</span>
<span class="lineNum">    2493 </span>            : }
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            : namespace ctypes {
<span class="lineNum">    2496 </span>            : 
<span class="lineNum">    2497 </span>            : /*******************************************************************************
<span class="lineNum">    2498 </span>            : ** Type conversion functions
<span class="lineNum">    2499 </span>            : *******************************************************************************/
<span class="lineNum">    2500 </span>            : 
<span class="lineNum">    2501 </span>            : // Enforce some sanity checks on type widths and properties.
<span class="lineNum">    2502 </span>            : // Where the architecture is 64-bit, make sure it's LP64 or LLP64. (ctypes.int
<span class="lineNum">    2503 </span>            : // autoconverts to a primitive JS number; to support ILP64 architectures, it
<span class="lineNum">    2504 </span>            : // would need to autoconvert to an Int64 object instead. Therefore we enforce
<span class="lineNum">    2505 </span>            : // this invariant here.)
<span class="lineNum">    2506 </span>            : JS_STATIC_ASSERT(sizeof(bool) == 1 || sizeof(bool) == 4);
<span class="lineNum">    2507 </span>            : JS_STATIC_ASSERT(sizeof(char) == 1);
<span class="lineNum">    2508 </span>            : JS_STATIC_ASSERT(sizeof(short) == 2);
<span class="lineNum">    2509 </span>            : JS_STATIC_ASSERT(sizeof(int) == 4);
<span class="lineNum">    2510 </span>            : JS_STATIC_ASSERT(sizeof(unsigned) == 4);
<span class="lineNum">    2511 </span>            : JS_STATIC_ASSERT(sizeof(long) == 4 || sizeof(long) == 8);
<span class="lineNum">    2512 </span>            : JS_STATIC_ASSERT(sizeof(long long) == 8);
<span class="lineNum">    2513 </span>            : JS_STATIC_ASSERT(sizeof(size_t) == sizeof(uintptr_t));
<span class="lineNum">    2514 </span>            : JS_STATIC_ASSERT(sizeof(float) == 4);
<span class="lineNum">    2515 </span>            : JS_STATIC_ASSERT(sizeof(PRFuncPtr) == sizeof(void*));
<span class="lineNum">    2516 </span>            : JS_STATIC_ASSERT(numeric_limits&lt;double&gt;::is_signed);
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span>            : // Templated helper to convert FromType to TargetType, for the default case
<span class="lineNum">    2519 </span>            : // where the trivial POD constructor will do.
<a name="2520"><span class="lineNum">    2520 </span>            : template&lt;class TargetType, class FromType&gt;</a>
<span class="lineNum">    2521 </span>            : struct ConvertImpl {
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE TargetType Convert(FromType d) {</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :     return TargetType(d);</span>
<span class="lineNum">    2524 </span>            :   }
<span class="lineNum">    2525 </span>            : };
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span>            : #ifdef _MSC_VER
<span class="lineNum">    2528 </span>            : // MSVC can't perform double to unsigned __int64 conversion when the
<span class="lineNum">    2529 </span>            : // double is greater than 2^63 - 1. Help it along a little.
<span class="lineNum">    2530 </span>            : template&lt;&gt;
<span class="lineNum">    2531 </span>            : struct ConvertImpl&lt;uint64_t, double&gt; {
<span class="lineNum">    2532 </span>            :   static MOZ_ALWAYS_INLINE uint64_t Convert(double d) {
<span class="lineNum">    2533 </span>            :     return d &gt; 0x7fffffffffffffffui64 ?
<span class="lineNum">    2534 </span>            :            uint64_t(d - 0x8000000000000000ui64) + 0x8000000000000000ui64 :
<span class="lineNum">    2535 </span>            :            uint64_t(d);
<span class="lineNum">    2536 </span>            :   }
<span class="lineNum">    2537 </span>            : };
<span class="lineNum">    2538 </span>            : #endif
<span class="lineNum">    2539 </span>            : 
<span class="lineNum">    2540 </span>            : // C++ doesn't guarantee that exact values are the only ones that will
<span class="lineNum">    2541 </span>            : // round-trip. In fact, on some platforms, including SPARC, there are pairs of
<span class="lineNum">    2542 </span>            : // values, a uint64_t and a double, such that neither value is exactly
<span class="lineNum">    2543 </span>            : // representable in the other type, but they cast to each other.
<span class="lineNum">    2544 </span>            : #if defined(SPARC) || defined(__powerpc__)
<span class="lineNum">    2545 </span>            : // Simulate x86 overflow behavior
<span class="lineNum">    2546 </span>            : template&lt;&gt;
<span class="lineNum">    2547 </span>            : struct ConvertImpl&lt;uint64_t, double&gt; {
<span class="lineNum">    2548 </span>            :   static MOZ_ALWAYS_INLINE uint64_t Convert(double d) {
<span class="lineNum">    2549 </span>            :     return d &gt;= 0xffffffffffffffff ?
<span class="lineNum">    2550 </span>            :            0x8000000000000000 : uint64_t(d);
<span class="lineNum">    2551 </span>            :   }
<span class="lineNum">    2552 </span>            : };
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span>            : template&lt;&gt;
<span class="lineNum">    2555 </span>            : struct ConvertImpl&lt;int64_t, double&gt; {
<span class="lineNum">    2556 </span>            :   static MOZ_ALWAYS_INLINE int64_t Convert(double d) {
<span class="lineNum">    2557 </span>            :     return d &gt;= 0x7fffffffffffffff ?
<span class="lineNum">    2558 </span>            :            0x8000000000000000 : int64_t(d);
<span class="lineNum">    2559 </span>            :   }
<span class="lineNum">    2560 </span>            : };
<span class="lineNum">    2561 </span>            : #endif
<a name="2562"><span class="lineNum">    2562 </span>            : </a>
<span class="lineNum">    2563 </span>            : template&lt;class TargetType, class FromType&gt;
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 : static MOZ_ALWAYS_INLINE TargetType Convert(FromType d)</span>
<span class="lineNum">    2565 </span>            : {
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :   return ConvertImpl&lt;TargetType, FromType&gt;::Convert(d);</span>
<span class="lineNum">    2567 </span>            : }
<a name="2568"><span class="lineNum">    2568 </span>            : </a>
<span class="lineNum">    2569 </span>            : template&lt;class TargetType, class FromType&gt;
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 : static MOZ_ALWAYS_INLINE bool IsAlwaysExact()</span>
<span class="lineNum">    2571 </span>            : {
<span class="lineNum">    2572 </span>            :   // Return 'true' if TargetType can always exactly represent FromType.
<span class="lineNum">    2573 </span>            :   // This means that:
<span class="lineNum">    2574 </span>            :   // 1) TargetType must be the same or more bits wide as FromType. For integers
<span class="lineNum">    2575 </span>            :   //    represented in 'n' bits, unsigned variants will have 'n' digits while
<span class="lineNum">    2576 </span>            :   //    signed will have 'n - 1'. For floating point types, 'digits' is the
<span class="lineNum">    2577 </span>            :   //    mantissa width.
<span class="lineNum">    2578 </span>            :   // 2) If FromType is signed, TargetType must also be signed. (Floating point
<span class="lineNum">    2579 </span>            :   //    types are always signed.)
<span class="lineNum">    2580 </span>            :   // 3) If TargetType is an exact integral type, FromType must be also.
<span class="lineNum">    2581 </span>            :   if (numeric_limits&lt;TargetType&gt;::digits &lt; numeric_limits&lt;FromType&gt;::digits)
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2583 </span>            : 
<span class="lineNum">    2584 </span>            :   if (numeric_limits&lt;FromType&gt;::is_signed &amp;&amp;
<span class="lineNum">    2585 </span>            :       !numeric_limits&lt;TargetType&gt;::is_signed)
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2587 </span>            : 
<span class="lineNum">    2588 </span>            :   if (!numeric_limits&lt;FromType&gt;::is_exact &amp;&amp;
<span class="lineNum">    2589 </span>            :       numeric_limits&lt;TargetType&gt;::is_exact)
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2591 </span>            : 
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2593 </span>            : }
<span class="lineNum">    2594 </span>            : 
<span class="lineNum">    2595 </span>            : // Templated helper to determine if FromType 'i' converts losslessly to
<span class="lineNum">    2596 </span>            : // TargetType 'j'. Default case where both types are the same signedness.
<a name="2597"><span class="lineNum">    2597 </span>            : template&lt;class TargetType, class FromType, bool TargetSigned, bool FromSigned&gt;</a>
<span class="lineNum">    2598 </span>            : struct IsExactImpl {
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE bool Test(FromType i, TargetType j) {</span>
<span class="lineNum">    2600 </span>            :     JS_STATIC_ASSERT(numeric_limits&lt;TargetType&gt;::is_exact);
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :     return FromType(j) == i;</span>
<span class="lineNum">    2602 </span>            :   }
<span class="lineNum">    2603 </span>            : };
<span class="lineNum">    2604 </span>            : 
<span class="lineNum">    2605 </span>            : // Specialization where TargetType is unsigned, FromType is signed.
<a name="2606"><span class="lineNum">    2606 </span>            : template&lt;class TargetType, class FromType&gt;</a>
<span class="lineNum">    2607 </span>            : struct IsExactImpl&lt;TargetType, FromType, false, true&gt; {
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE bool Test(FromType i, TargetType j) {</span>
<span class="lineNum">    2609 </span>            :     JS_STATIC_ASSERT(numeric_limits&lt;TargetType&gt;::is_exact);
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :     return i &gt;= 0 &amp;&amp; FromType(j) == i;</span>
<span class="lineNum">    2611 </span>            :   }
<span class="lineNum">    2612 </span>            : };
<span class="lineNum">    2613 </span>            : 
<span class="lineNum">    2614 </span>            : // Specialization where TargetType is signed, FromType is unsigned.
<a name="2615"><span class="lineNum">    2615 </span>            : template&lt;class TargetType, class FromType&gt;</a>
<span class="lineNum">    2616 </span>            : struct IsExactImpl&lt;TargetType, FromType, true, false&gt; {
<span class="lineNum">    2617 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE bool Test(FromType i, TargetType j) {</span>
<span class="lineNum">    2618 </span>            :     JS_STATIC_ASSERT(numeric_limits&lt;TargetType&gt;::is_exact);
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :     return TargetType(i) &gt;= 0 &amp;&amp; FromType(j) == i;</span>
<span class="lineNum">    2620 </span>            :   }
<span class="lineNum">    2621 </span>            : };
<span class="lineNum">    2622 </span>            : 
<span class="lineNum">    2623 </span>            : // Convert FromType 'i' to TargetType 'result', returning true iff 'result'
<a name="2624"><span class="lineNum">    2624 </span>            : // is an exact representation of 'i'.</a>
<span class="lineNum">    2625 </span>            : template&lt;class TargetType, class FromType&gt;
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 : static MOZ_ALWAYS_INLINE bool ConvertExact(FromType i, TargetType* result)</span>
<span class="lineNum">    2627 </span>            : {
<span class="lineNum">    2628 </span>            :   // Require that TargetType is integral, to simplify conversion.
<span class="lineNum">    2629 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;TargetType&gt;::is_exact);
<span class="lineNum">    2630 </span>            : 
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :   *result = Convert&lt;TargetType&gt;(i);</span>
<span class="lineNum">    2632 </span>            : 
<span class="lineNum">    2633 </span>            :   // See if we can avoid a dynamic check.
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :   if (IsAlwaysExact&lt;TargetType, FromType&gt;())</span>
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span>            :   // Return 'true' if 'i' is exactly representable in 'TargetType'.
<span class="lineNum">    2638 </span>            :   return IsExactImpl&lt;TargetType,
<span class="lineNum">    2639 </span>            :                      FromType,
<span class="lineNum">    2640 </span>            :                      numeric_limits&lt;TargetType&gt;::is_signed,
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :                      numeric_limits&lt;FromType&gt;::is_signed&gt;::Test(i, *result);</span>
<span class="lineNum">    2642 </span>            : }
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span>            : // Templated helper to determine if Type 'i' is negative. Default case
<span class="lineNum">    2645 </span>            : // where IntegerType is unsigned.
<a name="2646"><span class="lineNum">    2646 </span>            : template&lt;class Type, bool IsSigned&gt;</a>
<span class="lineNum">    2647 </span>            : struct IsNegativeImpl {
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE bool Test(Type i) {</span>
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2650 </span>            :   }
<span class="lineNum">    2651 </span>            : };
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span>            : // Specialization where Type is signed.
<a name="2654"><span class="lineNum">    2654 </span>            : template&lt;class Type&gt;</a>
<span class="lineNum">    2655 </span>            : struct IsNegativeImpl&lt;Type, true&gt; {
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :   static MOZ_ALWAYS_INLINE bool Test(Type i) {</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :     return i &lt; 0;</span>
<span class="lineNum">    2658 </span>            :   }
<span class="lineNum">    2659 </span>            : };
<span class="lineNum">    2660 </span>            : 
<a name="2661"><span class="lineNum">    2661 </span>            : // Determine whether Type 'i' is negative.</a>
<span class="lineNum">    2662 </span>            : template&lt;class Type&gt;
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 : static MOZ_ALWAYS_INLINE bool IsNegative(Type i)</span>
<span class="lineNum">    2664 </span>            : {
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :   return IsNegativeImpl&lt;Type, numeric_limits&lt;Type&gt;::is_signed&gt;::Test(i);</span>
<span class="lineNum">    2666 </span>            : }
<span class="lineNum">    2667 </span>            : 
<span class="lineNum">    2668 </span>            : // Implicitly convert val to bool, allowing bool, int, and double
<a name="2669"><span class="lineNum">    2669 </span>            : // arguments numerically equal to 0 or 1.</a>
<span class="lineNum">    2670 </span>            : static bool
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 : jsvalToBool(JSContext* cx, HandleValue val, bool* result)</span>
<span class="lineNum">    2672 </span>            : {
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :   if (val.isBoolean()) {</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :     *result = val.toBoolean();</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2676 </span>            :   }
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :   if (val.isInt32()) {</span>
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :     int32_t i = val.toInt32();</span>
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :     *result = i != 0;</span>
<span class="lineNum">    2680 </span><span class="lineNoCov">          0 :     return i == 0 || i == 1;</span>
<span class="lineNum">    2681 </span>            :   }
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :     double d = val.toDouble();</span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :     *result = d != 0;</span>
<span class="lineNum">    2685 </span>            :     // Allow -0.
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 :     return d == 1 || d == 0;</span>
<span class="lineNum">    2687 </span>            :   }
<span class="lineNum">    2688 </span>            :   // Don't silently convert null to bool. It's probably a mistake.
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2690 </span>            : }
<span class="lineNum">    2691 </span>            : 
<span class="lineNum">    2692 </span>            : // Implicitly convert val to IntegerType, allowing bool, int, double,
<span class="lineNum">    2693 </span>            : // Int64, UInt64, and CData integer types 't' where all values of 't' are
<span class="lineNum">    2694 </span>            : // representable by IntegerType.
<a name="2695"><span class="lineNum">    2695 </span>            : template&lt;class IntegerType&gt;</a>
<span class="lineNum">    2696 </span>            : static bool
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 : jsvalToInteger(JSContext* cx, HandleValue val, IntegerType* result)</span>
<span class="lineNum">    2698 </span>            : {
<span class="lineNum">    2699 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    2700 </span>            : 
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :   if (val.isInt32()) {</span>
<span class="lineNum">    2702 </span>            :     // Make sure the integer fits in the alotted precision, and has the right
<span class="lineNum">    2703 </span>            :     // sign.
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :     int32_t i = val.toInt32();</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :     return ConvertExact(i, result);</span>
<span class="lineNum">    2706 </span>            :   }
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    2708 </span>            :     // Don't silently lose bits here -- check that val really is an
<span class="lineNum">    2709 </span>            :     // integer value, and has the right sign.
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :     double d = val.toDouble();</span>
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :     return ConvertExact(d, result);</span>
<span class="lineNum">    2712 </span>            :   }
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :     JSObject* obj = &amp;val.toObject();</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :     if (CData::IsCData(obj)) {</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :       JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :       void* data = CData::GetData(obj);</span>
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            :       // Check whether the source type is always representable, with exact
<span class="lineNum">    2720 </span>            :       // precision, by the target type. If it is, convert the value.
<span class="lineNum">    2721 </span><span class="lineNoCov">          0 :       switch (CType::GetTypeCode(typeObj)) {</span>
<span class="lineNum">    2722 </span>            : #define INTEGER_CASE(name, fromType, ffiType)                                  \
<span class="lineNum">    2723 </span>            :       case TYPE_##name:                                                        \
<span class="lineNum">    2724 </span>            :         if (!IsAlwaysExact&lt;IntegerType, fromType&gt;())                           \
<span class="lineNum">    2725 </span>            :           return false;                                                        \
<span class="lineNum">    2726 </span>            :         *result = IntegerType(*static_cast&lt;fromType*&gt;(data));                  \
<span class="lineNum">    2727 </span>            :         return true;
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :       CTYPES_FOR_EACH_INT_TYPE(INTEGER_CASE)</span>
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :       CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGER_CASE)</span>
<span class="lineNum">    2730 </span>            : #undef INTEGER_CASE
<span class="lineNum">    2731 </span>            :       case TYPE_void_t:
<span class="lineNum">    2732 </span>            :       case TYPE_bool:
<span class="lineNum">    2733 </span>            :       case TYPE_float:
<span class="lineNum">    2734 </span>            :       case TYPE_double:
<span class="lineNum">    2735 </span>            :       case TYPE_float32_t:
<span class="lineNum">    2736 </span>            :       case TYPE_float64_t:
<span class="lineNum">    2737 </span>            :       case TYPE_char:
<span class="lineNum">    2738 </span>            :       case TYPE_signed_char:
<span class="lineNum">    2739 </span>            :       case TYPE_unsigned_char:
<span class="lineNum">    2740 </span>            :       case TYPE_char16_t:
<span class="lineNum">    2741 </span>            :       case TYPE_pointer:
<span class="lineNum">    2742 </span>            :       case TYPE_function:
<span class="lineNum">    2743 </span>            :       case TYPE_array:
<span class="lineNum">    2744 </span>            :       case TYPE_struct:
<span class="lineNum">    2745 </span>            :         // Not a compatible number type.
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2747 </span>            :       }
<span class="lineNum">    2748 </span>            :     }
<span class="lineNum">    2749 </span>            : 
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :     if (Int64::IsInt64(obj)) {</span>
<span class="lineNum">    2751 </span>            :       // Make sure the integer fits in IntegerType.
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :       int64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :       return ConvertExact(i, result);</span>
<span class="lineNum">    2754 </span>            :     }
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :     if (UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    2757 </span>            :       // Make sure the integer fits in IntegerType.
<span class="lineNum">    2758 </span><span class="lineNoCov">          0 :       uint64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :       return ConvertExact(i, result);</span>
<span class="lineNum">    2760 </span>            :     }
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :     if (CDataFinalizer::IsCDataFinalizer(obj)) {</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :       RootedValue innerData(cx);</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :       if (!CDataFinalizer::GetValue(cx, obj, &amp;innerData)) {</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :         return false; // Nothing to convert</span>
<span class="lineNum">    2766 </span>            :       }
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :       return jsvalToInteger(cx, innerData, result);</span>
<span class="lineNum">    2768 </span>            :     }
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2771 </span>            :   }
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :   if (val.isBoolean()) {</span>
<span class="lineNum">    2773 </span>            :     // Implicitly promote boolean values to 0 or 1, like C.
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :     *result = val.toBoolean();</span>
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(*result == 0 || *result == 1);</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2777 </span>            :   }
<span class="lineNum">    2778 </span>            :   // Don't silently convert null to an integer. It's probably a mistake.
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2780 </span>            : }
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span>            : // Implicitly convert val to FloatType, allowing int, double,
<span class="lineNum">    2783 </span>            : // Int64, UInt64, and CData numeric types 't' where all values of 't' are
<span class="lineNum">    2784 </span>            : // representable by FloatType.
<a name="2785"><span class="lineNum">    2785 </span>            : template&lt;class FloatType&gt;</a>
<span class="lineNum">    2786 </span>            : static bool
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 : jsvalToFloat(JSContext* cx, HandleValue val, FloatType* result)</span>
<span class="lineNum">    2788 </span>            : {
<span class="lineNum">    2789 </span>            :   JS_STATIC_ASSERT(!numeric_limits&lt;FloatType&gt;::is_exact);
<span class="lineNum">    2790 </span>            : 
<span class="lineNum">    2791 </span>            :   // The following casts may silently throw away some bits, but there's
<span class="lineNum">    2792 </span>            :   // no good way around it. Sternly requiring that the 64-bit double
<span class="lineNum">    2793 </span>            :   // argument be exactly representable as a 32-bit float is
<span class="lineNum">    2794 </span>            :   // unrealistic: it would allow 1/2 to pass but not 1/3.
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :   if (val.isInt32()) {</span>
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 :     *result = FloatType(val.toInt32());</span>
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2798 </span>            :   }
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     *result = FloatType(val.toDouble());</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2802 </span>            :   }
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :     JSObject* obj = &amp;val.toObject();</span>
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :     if (CData::IsCData(obj)) {</span>
<span class="lineNum">    2806 </span><span class="lineNoCov">          0 :       JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :       void* data = CData::GetData(obj);</span>
<span class="lineNum">    2808 </span>            : 
<span class="lineNum">    2809 </span>            :       // Check whether the source type is always representable, with exact
<span class="lineNum">    2810 </span>            :       // precision, by the target type. If it is, convert the value.
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :       switch (CType::GetTypeCode(typeObj)) {</span>
<span class="lineNum">    2812 </span>            : #define NUMERIC_CASE(name, fromType, ffiType)                                  \
<span class="lineNum">    2813 </span>            :       case TYPE_##name:                                                        \
<span class="lineNum">    2814 </span>            :         if (!IsAlwaysExact&lt;FloatType, fromType&gt;())                             \
<span class="lineNum">    2815 </span>            :           return false;                                                        \
<span class="lineNum">    2816 </span>            :         *result = FloatType(*static_cast&lt;fromType*&gt;(data));                    \
<span class="lineNum">    2817 </span>            :         return true;
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :       CTYPES_FOR_EACH_FLOAT_TYPE(NUMERIC_CASE)</span>
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :       CTYPES_FOR_EACH_INT_TYPE(NUMERIC_CASE)</span>
<span class="lineNum">    2820 </span><span class="lineNoCov">          0 :       CTYPES_FOR_EACH_WRAPPED_INT_TYPE(NUMERIC_CASE)</span>
<span class="lineNum">    2821 </span>            : #undef NUMERIC_CASE
<span class="lineNum">    2822 </span>            :       case TYPE_void_t:
<span class="lineNum">    2823 </span>            :       case TYPE_bool:
<span class="lineNum">    2824 </span>            :       case TYPE_char:
<span class="lineNum">    2825 </span>            :       case TYPE_signed_char:
<span class="lineNum">    2826 </span>            :       case TYPE_unsigned_char:
<span class="lineNum">    2827 </span>            :       case TYPE_char16_t:
<span class="lineNum">    2828 </span>            :       case TYPE_pointer:
<span class="lineNum">    2829 </span>            :       case TYPE_function:
<span class="lineNum">    2830 </span>            :       case TYPE_array:
<span class="lineNum">    2831 </span>            :       case TYPE_struct:
<span class="lineNum">    2832 </span>            :         // Not a compatible number type.
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2834 </span>            :       }
<span class="lineNum">    2835 </span>            :     }
<span class="lineNum">    2836 </span>            :   }
<span class="lineNum">    2837 </span>            :   // Don't silently convert true to 1.0 or false to 0.0, even though C/C++
<span class="lineNum">    2838 </span>            :   // does it. It's likely to be a mistake.
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2840 </span>            : }
<span class="lineNum">    2841 </span>            : 
<a name="2842"><span class="lineNum">    2842 </span>            : template &lt;class IntegerType, class CharT&gt;</a>
<span class="lineNum">    2843 </span>            : static bool
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 : StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result,</span>
<span class="lineNum">    2845 </span>            :                 bool* overflow)
<span class="lineNum">    2846 </span>            : {
<span class="lineNum">    2847 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    2848 </span>            : 
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :   const CharT* end = cp + length;</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :   if (cp == end)</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2852 </span>            : 
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :   IntegerType sign = 1;</span>
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :   if (cp[0] == '-') {</span>
<span class="lineNum">    2855 </span>            :     if (!numeric_limits&lt;IntegerType&gt;::is_signed)
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2857 </span>            : 
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :     sign = -1;</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :     ++cp;</span>
<span class="lineNum">    2860 </span>            :   }
<span class="lineNum">    2861 </span>            : 
<span class="lineNum">    2862 </span>            :   // Assume base-10, unless the string begins with '0x' or '0X'.
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   IntegerType base = 10;</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :   if (end - cp &gt; 2 &amp;&amp; cp[0] == '0' &amp;&amp; (cp[1] == 'x' || cp[1] == 'X')) {</span>
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :     cp += 2;</span>
<span class="lineNum">    2866 </span><span class="lineNoCov">          0 :     base = 16;</span>
<span class="lineNum">    2867 </span>            :   }
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span>            :   // Scan the string left to right and build the number,
<span class="lineNum">    2870 </span>            :   // checking for valid characters 0 - 9, a - f, A - F and overflow.
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :   IntegerType i = 0;</span>
<span class="lineNum">    2872 </span><span class="lineNoCov">          0 :   while (cp != end) {</span>
<span class="lineNum">    2873 </span><span class="lineNoCov">          0 :     char16_t c = *cp++;</span>
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :     if (c &gt;= '0' &amp;&amp; c &lt;= '9')</span>
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :       c -= '0';</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :     else if (base == 16 &amp;&amp; c &gt;= 'a' &amp;&amp; c &lt;= 'f')</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :       c = c - 'a' + 10;</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :     else if (base == 16 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'F')</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :       c = c - 'A' + 10;</span>
<span class="lineNum">    2880 </span>            :     else
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :     IntegerType ii = i;</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :     i = ii * base + sign * c;</span>
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :     if (i / base != ii) {</span>
<span class="lineNum">    2886 </span><span class="lineNoCov">          0 :       *overflow = true;</span>
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2888 </span>            :     }
<span class="lineNum">    2889 </span>            :   }
<span class="lineNum">    2890 </span>            : 
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :   *result = i;</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2893 </span>            : }
<span class="lineNum">    2894 </span>            : 
<a name="2895"><span class="lineNum">    2895 </span>            : template&lt;class IntegerType&gt;</a>
<span class="lineNum">    2896 </span>            : static bool
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 : StringToInteger(JSContext* cx, JSString* string, IntegerType* result,</span>
<span class="lineNum">    2898 </span>            :                 bool* overflow)
<span class="lineNum">    2899 </span>            : {
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :   JSLinearString* linear = string-&gt;ensureLinear(cx);</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :   if (!linear)</span>
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2903 </span>            : 
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :   AutoCheckCannotGC nogc;</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :   size_t length = linear-&gt;length();</span>
<span class="lineNum">    2906 </span><span class="lineNoCov">          0 :   return string-&gt;hasLatin1Chars()</span>
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :          ? StringToInteger&lt;IntegerType&gt;(cx, linear-&gt;latin1Chars(nogc), length,</span>
<span class="lineNum">    2908 </span>            :                                         result, overflow)
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :          : StringToInteger&lt;IntegerType&gt;(cx, linear-&gt;twoByteChars(nogc), length,</span>
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :                                         result, overflow);</span>
<span class="lineNum">    2911 </span>            : }
<span class="lineNum">    2912 </span>            : 
<span class="lineNum">    2913 </span>            : // Implicitly convert val to IntegerType, allowing int, double,
<span class="lineNum">    2914 </span>            : // Int64, UInt64, and optionally a decimal or hexadecimal string argument.
<span class="lineNum">    2915 </span>            : // (This is common code shared by jsvalToSize and the Int64/UInt64 constructors.)
<a name="2916"><span class="lineNum">    2916 </span>            : template&lt;class IntegerType&gt;</a>
<span class="lineNum">    2917 </span>            : static bool
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 : jsvalToBigInteger(JSContext* cx,</span>
<span class="lineNum">    2919 </span>            :                   HandleValue val,
<span class="lineNum">    2920 </span>            :                   bool allowString,
<span class="lineNum">    2921 </span>            :                   IntegerType* result,
<span class="lineNum">    2922 </span>            :                   bool* overflow)
<span class="lineNum">    2923 </span>            : {
<span class="lineNum">    2924 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    2925 </span>            : 
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :   if (val.isInt32()) {</span>
<span class="lineNum">    2927 </span>            :     // Make sure the integer fits in the alotted precision, and has the right
<span class="lineNum">    2928 </span>            :     // sign.
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :     int32_t i = val.toInt32();</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :     return ConvertExact(i, result);</span>
<span class="lineNum">    2931 </span>            :   }
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    2933 </span>            :     // Don't silently lose bits here -- check that val really is an
<span class="lineNum">    2934 </span>            :     // integer value, and has the right sign.
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :     double d = val.toDouble();</span>
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :     return ConvertExact(d, result);</span>
<span class="lineNum">    2937 </span>            :   }
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :   if (allowString &amp;&amp; val.isString()) {</span>
<span class="lineNum">    2939 </span>            :     // Allow conversion from base-10 or base-16 strings, provided the result
<span class="lineNum">    2940 </span>            :     // fits in IntegerType. (This allows an Int64 or UInt64 object to be passed
<span class="lineNum">    2941 </span>            :     // to the JS array element operator, which will automatically call
<span class="lineNum">    2942 </span>            :     // toString() on the object for us.)
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :     return StringToInteger(cx, val.toString(), result, overflow);</span>
<span class="lineNum">    2944 </span>            :   }
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    2946 </span>            :     // Allow conversion from an Int64 or UInt64 object directly.
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :     JSObject* obj = &amp;val.toObject();</span>
<span class="lineNum">    2948 </span>            : 
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :     if (UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    2950 </span>            :       // Make sure the integer fits in IntegerType.
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :       uint64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :       return ConvertExact(i, result);</span>
<span class="lineNum">    2953 </span>            :     }
<span class="lineNum">    2954 </span>            : 
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :     if (Int64::IsInt64(obj)) {</span>
<span class="lineNum">    2956 </span>            :       // Make sure the integer fits in IntegerType.
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :       int64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :       return ConvertExact(i, result);</span>
<span class="lineNum">    2959 </span>            :     }
<span class="lineNum">    2960 </span>            : 
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :     if (CDataFinalizer::IsCDataFinalizer(obj)) {</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :       RootedValue innerData(cx);</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :       if (!CDataFinalizer::GetValue(cx, obj, &amp;innerData)) {</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :         return false; // Nothing to convert</span>
<span class="lineNum">    2965 </span>            :       }
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :       return jsvalToBigInteger(cx, innerData, allowString, result, overflow);</span>
<span class="lineNum">    2967 </span>            :     }
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            :   }
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2971 </span>            : }
<span class="lineNum">    2972 </span>            : 
<span class="lineNum">    2973 </span>            : // Implicitly convert val to a size value, where the size value is represented
<a name="2974"><span class="lineNum">    2974 </span>            : // by size_t but must also fit in a double.</a>
<span class="lineNum">    2975 </span>            : static bool
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 : jsvalToSize(JSContext* cx, HandleValue val, bool allowString, size_t* result)</span>
<span class="lineNum">    2977 </span>            : {
<span class="lineNum">    2978 </span>            :   bool dummy;
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :   if (!jsvalToBigInteger(cx, val, allowString, result, &amp;dummy))</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span>            :   // Also check that the result fits in a double.
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :   return Convert&lt;size_t&gt;(double(*result)) == *result;</span>
<span class="lineNum">    2984 </span>            : }
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span>            : // Implicitly convert val to IntegerType, allowing int, double,
<span class="lineNum">    2987 </span>            : // Int64, UInt64, and optionally a decimal or hexadecimal string argument.
<span class="lineNum">    2988 </span>            : // (This is common code shared by jsvalToSize and the Int64/UInt64 constructors.)
<a name="2989"><span class="lineNum">    2989 </span>            : template&lt;class IntegerType&gt;</a>
<span class="lineNum">    2990 </span>            : static bool
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 : jsidToBigInteger(JSContext* cx,</span>
<span class="lineNum">    2992 </span>            :                  jsid val,
<span class="lineNum">    2993 </span>            :                  bool allowString,
<span class="lineNum">    2994 </span>            :                  IntegerType* result)
<span class="lineNum">    2995 </span>            : {
<span class="lineNum">    2996 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    2997 </span>            : 
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :   if (JSID_IS_INT(val)) {</span>
<span class="lineNum">    2999 </span>            :     // Make sure the integer fits in the alotted precision, and has the right
<span class="lineNum">    3000 </span>            :     // sign.
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :     int32_t i = JSID_TO_INT(val);</span>
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :     return ConvertExact(i, result);</span>
<span class="lineNum">    3003 </span>            :   }
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :   if (allowString &amp;&amp; JSID_IS_STRING(val)) {</span>
<span class="lineNum">    3005 </span>            :     // Allow conversion from base-10 or base-16 strings, provided the result
<span class="lineNum">    3006 </span>            :     // fits in IntegerType. (This allows an Int64 or UInt64 object to be passed
<span class="lineNum">    3007 </span>            :     // to the JS array element operator, which will automatically call
<span class="lineNum">    3008 </span>            :     // toString() on the object for us.)
<span class="lineNum">    3009 </span>            :     bool dummy;
<span class="lineNum">    3010 </span><span class="lineNoCov">          0 :     return StringToInteger(cx, JSID_TO_STRING(val), result, &amp;dummy);</span>
<span class="lineNum">    3011 </span>            :   }
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    3013 </span>            : }
<span class="lineNum">    3014 </span>            : 
<span class="lineNum">    3015 </span>            : // Implicitly convert val to a size value, where the size value is represented
<a name="3016"><span class="lineNum">    3016 </span>            : // by size_t but must also fit in a double.</a>
<span class="lineNum">    3017 </span>            : static bool
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 : jsidToSize(JSContext* cx, jsid val, bool allowString, size_t* result)</span>
<span class="lineNum">    3019 </span>            : {
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :   if (!jsidToBigInteger(cx, val, allowString, result))</span>
<span class="lineNum">    3021 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3022 </span>            : 
<span class="lineNum">    3023 </span>            :   // Also check that the result fits in a double.
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :   return Convert&lt;size_t&gt;(double(*result)) == *result;</span>
<span class="lineNum">    3025 </span>            : }
<span class="lineNum">    3026 </span>            : 
<span class="lineNum">    3027 </span>            : // Implicitly convert a size value to a Value, ensuring that the size_t value
<a name="3028"><span class="lineNum">    3028 </span>            : // fits in a double.</a>
<span class="lineNum">    3029 </span>            : static bool
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 : SizeTojsval(JSContext* cx, size_t size, MutableHandleValue result)</span>
<span class="lineNum">    3031 </span>            : {
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :   if (Convert&lt;size_t&gt;(double(size)) != size) {</span>
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3034 </span>            :   }
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :   result.setNumber(double(size));</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    3038 </span>            : }
<span class="lineNum">    3039 </span>            : 
<span class="lineNum">    3040 </span>            : // Forcefully convert val to IntegerType when explicitly requested.
<a name="3041"><span class="lineNum">    3041 </span>            : template&lt;class IntegerType&gt;</a>
<span class="lineNum">    3042 </span>            : static bool
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 : jsvalToIntegerExplicit(HandleValue val, IntegerType* result)</span>
<span class="lineNum">    3044 </span>            : {
<span class="lineNum">    3045 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    3046 </span>            : 
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    3048 </span>            :     // Convert -Inf, Inf, and NaN to 0; otherwise, convert by C-style cast.
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :     double d = val.toDouble();</span>
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :     *result = mozilla::IsFinite(d) ? IntegerType(d) : 0;</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3052 </span>            :   }
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    3054 </span>            :     // Convert Int64 and UInt64 values by C-style cast.
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :     JSObject* obj = &amp;val.toObject();</span>
<span class="lineNum">    3056 </span><span class="lineNoCov">          0 :     if (Int64::IsInt64(obj)) {</span>
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :       int64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :       *result = IntegerType(i);</span>
<span class="lineNum">    3059 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    3060 </span>            :     }
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :     if (UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :       uint64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :       *result = IntegerType(i);</span>
<span class="lineNum">    3064 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    3065 </span>            :     }
<span class="lineNum">    3066 </span>            :   }
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    3068 </span>            : }
<span class="lineNum">    3069 </span>            : 
<a name="3070"><span class="lineNum">    3070 </span>            : // Forcefully convert val to a pointer value when explicitly requested.</a>
<span class="lineNum">    3071 </span>            : static bool
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 : jsvalToPtrExplicit(JSContext* cx, HandleValue val, uintptr_t* result)</span>
<span class="lineNum">    3073 </span>            : {
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :   if (val.isInt32()) {</span>
<span class="lineNum">    3075 </span>            :     // int32_t always fits in intptr_t. If the integer is negative, cast through
<span class="lineNum">    3076 </span>            :     // an intptr_t intermediate to sign-extend.
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :     int32_t i = val.toInt32();</span>
<span class="lineNum">    3078 </span><span class="lineNoCov">          0 :     *result = i &lt; 0 ? uintptr_t(intptr_t(i)) : uintptr_t(i);</span>
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3080 </span>            :   }
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :   if (val.isDouble()) {</span>
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :     double d = val.toDouble();</span>
<span class="lineNum">    3083 </span><span class="lineNoCov">          0 :     if (d &lt; 0) {</span>
<span class="lineNum">    3084 </span>            :       // Cast through an intptr_t intermediate to sign-extend.
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :       intptr_t i = Convert&lt;intptr_t&gt;(d);</span>
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :       if (double(i) != d)</span>
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span><span class="lineNoCov">          0 :       *result = uintptr_t(i);</span>
<span class="lineNum">    3090 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    3091 </span>            :     }
<span class="lineNum">    3092 </span>            : 
<span class="lineNum">    3093 </span>            :     // Don't silently lose bits here -- check that val really is an
<span class="lineNum">    3094 </span>            :     // integer value, and has the right sign.
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 :     *result = Convert&lt;uintptr_t&gt;(d);</span>
<span class="lineNum">    3096 </span><span class="lineNoCov">          0 :     return double(*result) == d;</span>
<span class="lineNum">    3097 </span>            :   }
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :     JSObject* obj = &amp;val.toObject();</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :     if (Int64::IsInt64(obj)) {</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :       int64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :       intptr_t p = intptr_t(i);</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            :       // Make sure the integer fits in the alotted precision.
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 :       if (int64_t(p) != i)</span>
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :       *result = uintptr_t(p);</span>
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    3109 </span>            :     }
<span class="lineNum">    3110 </span>            : 
<span class="lineNum">    3111 </span><span class="lineNoCov">          0 :     if (UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :       uint64_t i = Int64Base::GetInt(obj);</span>
<span class="lineNum">    3113 </span>            : 
<span class="lineNum">    3114 </span>            :       // Make sure the integer fits in the alotted precision.
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :       *result = uintptr_t(i);</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :       return uint64_t(*result) == i;</span>
<span class="lineNum">    3117 </span>            :     }
<span class="lineNum">    3118 </span>            :   }
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    3120 </span>            : }
<span class="lineNum">    3121 </span>            : 
<a name="3122"><span class="lineNum">    3122 </span>            : template&lt;class IntegerType, class CharType, size_t N, class AP&gt;</a>
<span class="lineNum">    3123 </span>            : void
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 : IntegerToString(IntegerType i, int radix, mozilla::Vector&lt;CharType, N, AP&gt;&amp; result)</span>
<span class="lineNum">    3125 </span>            : {
<span class="lineNum">    3126 </span>            :   JS_STATIC_ASSERT(numeric_limits&lt;IntegerType&gt;::is_exact);
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            :   // The buffer must be big enough for all the bits of IntegerType to fit,
<span class="lineNum">    3129 </span>            :   // in base-2, including '-'.
<span class="lineNum">    3130 </span>            :   CharType buffer[sizeof(IntegerType) * 8 + 1];
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :   CharType* end = buffer + sizeof(buffer) / sizeof(CharType);</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :   CharType* cp = end;</span>
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span>            :   // Build the string in reverse. We use multiplication and subtraction
<span class="lineNum">    3135 </span>            :   // instead of modulus because that's much faster.
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :   const bool isNegative = IsNegative(i);</span>
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :   size_t sign = isNegative ? -1 : 1;</span>
<span class="lineNum">    3138 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :     IntegerType ii = i / IntegerType(radix);</span>
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :     size_t index = sign * size_t(i - ii * IntegerType(radix));</span>
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :     *--cp = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;[index];</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :     i = ii;</span>
<span class="lineNum">    3143 </span><span class="lineNoCov">          0 :   } while (i != 0);</span>
<span class="lineNum">    3144 </span>            : 
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :   if (isNegative)</span>
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :     *--cp = '-';</span>
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(cp &gt;= buffer);</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :   if (!result.append(cp, end))</span>
<span class="lineNum">    3150 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3151 </span>            : }
<span class="lineNum">    3152 </span>            : 
<a name="3153"><span class="lineNum">    3153 </span>            : template&lt;class CharType&gt;</a>
<span class="lineNum">    3154 </span>            : static size_t
<span class="lineNum">    3155 </span><span class="lineNoCov">          0 : strnlen(const CharType* begin, size_t max)</span>
<span class="lineNum">    3156 </span>            : {
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :   for (const CharType* s = begin; s != begin + max; ++s)</span>
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :     if (*s == 0)</span>
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 :       return s - begin;</span>
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span><span class="lineNoCov">          0 :   return max;</span>
<span class="lineNum">    3162 </span>            : }
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span>            : // Convert C binary value 'data' of CType 'typeObj' to a JS primitive, where
<span class="lineNum">    3165 </span>            : // possible; otherwise, construct and return a CData object. The following
<span class="lineNum">    3166 </span>            : // semantics apply when constructing a CData object for return:
<span class="lineNum">    3167 </span>            : // * If 'wantPrimitive' is true, the caller indicates that 'result' must be
<span class="lineNum">    3168 </span>            : //   a JS primitive, and ConvertToJS will fail if 'result' would be a CData
<span class="lineNum">    3169 </span>            : //   object. Otherwise:
<span class="lineNum">    3170 </span>            : // * If a CData object 'parentObj' is supplied, the new CData object is
<span class="lineNum">    3171 </span>            : //   dependent on the given parent and its buffer refers to a slice of the
<span class="lineNum">    3172 </span>            : //   parent's buffer.
<span class="lineNum">    3173 </span>            : // * If 'parentObj' is null, the new CData object may or may not own its
<a name="3174"><span class="lineNum">    3174 </span>            : //   resulting buffer depending on the 'ownResult' argument.</a>
<span class="lineNum">    3175 </span>            : static bool
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 : ConvertToJS(JSContext* cx,</span>
<span class="lineNum">    3177 </span>            :             HandleObject typeObj,
<span class="lineNum">    3178 </span>            :             HandleObject parentObj,
<span class="lineNum">    3179 </span>            :             void* data,
<span class="lineNum">    3180 </span>            :             bool wantPrimitive,
<span class="lineNum">    3181 </span>            :             bool ownResult,
<span class="lineNum">    3182 </span>            :             MutableHandleValue result)
<span class="lineNum">    3183 </span>            : {
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!parentObj || CData::IsCData(parentObj));</span>
<span class="lineNum">    3185 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!parentObj || !ownResult);</span>
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!wantPrimitive || !ownResult);</span>
<span class="lineNum">    3187 </span>            : 
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(typeObj);</span>
<span class="lineNum">    3189 </span>            : 
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :   switch (typeCode) {</span>
<span class="lineNum">    3191 </span>            :   case TYPE_void_t:
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :     result.setUndefined();</span>
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3194 </span>            :   case TYPE_bool:
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     result.setBoolean(*static_cast&lt;bool*&gt;(data));</span>
<span class="lineNum">    3196 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3197 </span>            : #define INT_CASE(name, type, ffiType)                                          \
<span class="lineNum">    3198 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3199 </span>            :     type value = *static_cast&lt;type*&gt;(data);                                    \
<span class="lineNum">    3200 </span>            :     if (sizeof(type) &lt; 4)                                                      \
<span class="lineNum">    3201 </span>            :       result.setInt32(int32_t(value));                                         \
<span class="lineNum">    3202 </span>            :     else                                                                       \
<span class="lineNum">    3203 </span>            :       result.setDouble(double(value));                                         \
<span class="lineNum">    3204 </span>            :     break;                                                                     \
<span class="lineNum">    3205 </span>            :   }
<span class="lineNum">    3206 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_INT_TYPE(INT_CASE)</span>
<span class="lineNum">    3207 </span>            : #undef INT_CASE
<span class="lineNum">    3208 </span>            : #define WRAPPED_INT_CASE(name, type, ffiType)                                  \
<span class="lineNum">    3209 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3210 </span>            :     /* Return an Int64 or UInt64 object - do not convert to a JS number. */    \
<span class="lineNum">    3211 </span>            :     uint64_t value;                                                            \
<span class="lineNum">    3212 </span>            :     RootedObject proto(cx);                                                    \
<span class="lineNum">    3213 </span>            :     if (!numeric_limits&lt;type&gt;::is_signed) {                                    \
<span class="lineNum">    3214 </span>            :       value = *static_cast&lt;type*&gt;(data);                                       \
<span class="lineNum">    3215 </span>            :       /* Get ctypes.UInt64.prototype from ctypes.CType.prototype. */           \
<span class="lineNum">    3216 </span>            :       proto = CType::GetProtoFromType(cx, typeObj, SLOT_UINT64PROTO);          \
<span class="lineNum">    3217 </span>            :       if (!proto)                                                              \
<span class="lineNum">    3218 </span>            :         return false;                                                          \
<span class="lineNum">    3219 </span>            :     } else {                                                                   \
<span class="lineNum">    3220 </span>            :       value = int64_t(*static_cast&lt;type*&gt;(data));                              \
<span class="lineNum">    3221 </span>            :       /* Get ctypes.Int64.prototype from ctypes.CType.prototype. */            \
<span class="lineNum">    3222 </span>            :       proto = CType::GetProtoFromType(cx, typeObj, SLOT_INT64PROTO);           \
<span class="lineNum">    3223 </span>            :       if (!proto)                                                              \
<span class="lineNum">    3224 </span>            :         return false;                                                          \
<span class="lineNum">    3225 </span>            :     }                                                                          \
<span class="lineNum">    3226 </span>            :                                                                                \
<span class="lineNum">    3227 </span>            :     JSObject* obj = Int64Base::Construct(cx, proto, value,                     \
<span class="lineNum">    3228 </span>            :       !numeric_limits&lt;type&gt;::is_signed);                                       \
<span class="lineNum">    3229 </span>            :     if (!obj)                                                                  \
<span class="lineNum">    3230 </span>            :       return false;                                                            \
<span class="lineNum">    3231 </span>            :     result.setObject(*obj);                                                    \
<span class="lineNum">    3232 </span>            :     break;                                                                     \
<span class="lineNum">    3233 </span>            :   }
<span class="lineNum">    3234 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_WRAPPED_INT_TYPE(WRAPPED_INT_CASE)</span>
<span class="lineNum">    3235 </span>            : #undef WRAPPED_INT_CASE
<span class="lineNum">    3236 </span>            : #define FLOAT_CASE(name, type, ffiType)                                        \
<span class="lineNum">    3237 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3238 </span>            :     type value = *static_cast&lt;type*&gt;(data);                                    \
<span class="lineNum">    3239 </span>            :     result.setDouble(double(value));                                           \
<span class="lineNum">    3240 </span>            :     break;                                                                     \
<span class="lineNum">    3241 </span>            :   }
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_FLOAT_TYPE(FLOAT_CASE)</span>
<span class="lineNum">    3243 </span>            : #undef FLOAT_CASE
<span class="lineNum">    3244 </span>            : #define CHAR_CASE(name, type, ffiType)                                         \
<span class="lineNum">    3245 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    3246 </span>            :     /* Convert to an integer. We have no idea what character encoding to */    \
<span class="lineNum">    3247 </span>            :     /* use, if any. */                                                         \
<span class="lineNum">    3248 </span>            :     result.setInt32(*static_cast&lt;type*&gt;(data));                                \
<span class="lineNum">    3249 </span>            :     break;
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR_TYPE(CHAR_CASE)</span>
<span class="lineNum">    3251 </span>            : #undef CHAR_CASE
<span class="lineNum">    3252 </span>            :   case TYPE_char16_t: {
<span class="lineNum">    3253 </span>            :     // Convert the char16_t to a 1-character string.
<span class="lineNum">    3254 </span><span class="lineNoCov">          0 :     JSString* str = JS_NewUCStringCopyN(cx, static_cast&lt;char16_t*&gt;(data), 1);</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :     if (!str)</span>
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :     result.setString(str);</span>
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3260 </span>            :   }
<span class="lineNum">    3261 </span>            :   case TYPE_pointer:
<span class="lineNum">    3262 </span>            :   case TYPE_array:
<span class="lineNum">    3263 </span>            :   case TYPE_struct: {
<span class="lineNum">    3264 </span>            :     // We're about to create a new CData object to return. If the caller doesn't
<span class="lineNum">    3265 </span>            :     // want this, return early.
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 :     if (wantPrimitive) {</span>
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :       return NonPrimitiveError(cx, typeObj);</span>
<span class="lineNum">    3268 </span>            :     }
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :     JSObject* obj = CData::Create(cx, typeObj, parentObj, data, ownResult);</span>
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :     if (!obj)</span>
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    3273 </span>            : 
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :     result.setObject(*obj);</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3276 </span>            :   }
<span class="lineNum">    3277 </span>            :   case TYPE_function:
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;cannot return a FunctionType&quot;);</span>
<span class="lineNum">    3279 </span>            :   }
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    3282 </span>            : }
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span>            : // Determine if the contents of a typed array can be converted without
<a name="3285"><span class="lineNum">    3285 </span>            : // ambiguity to a C type. Elements of a Int8Array are converted to</a>
<span class="lineNum">    3286 </span>            : // ctypes.int8_t, UInt8Array to ctypes.uint8_t, etc.
<span class="lineNum">    3287 </span><span class="lineNoCov">          0 : bool CanConvertTypedArrayItemTo(JSObject* baseType, JSObject* valObj, JSContext* cx) {</span>
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :   TypeCode baseTypeCode = CType::GetTypeCode(baseType);</span>
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :   if (baseTypeCode == TYPE_void_t || baseTypeCode == TYPE_char) {</span>
<span class="lineNum">    3290 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3291 </span>            :   }
<span class="lineNum">    3292 </span>            :   TypeCode elementTypeCode;
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :   switch (JS_GetArrayBufferViewType(valObj)) {</span>
<span class="lineNum">    3294 </span>            :   case Scalar::Int8:
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_int8_t;</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3297 </span>            :   case Scalar::Uint8:
<span class="lineNum">    3298 </span>            :   case Scalar::Uint8Clamped:
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_uint8_t;</span>
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3301 </span>            :   case Scalar::Int16:
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_int16_t;</span>
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3304 </span>            :   case Scalar::Uint16:
<span class="lineNum">    3305 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_uint16_t;</span>
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3307 </span>            :   case Scalar::Int32:
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_int32_t;</span>
<span class="lineNum">    3309 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3310 </span>            :   case Scalar::Uint32:
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_uint32_t;</span>
<span class="lineNum">    3312 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3313 </span>            :   case Scalar::Float32:
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_float32_t;</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3316 </span>            :   case Scalar::Float64:
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :     elementTypeCode = TYPE_float64_t;</span>
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3319 </span>            :   default:
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3321 </span>            :   }
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :   return elementTypeCode == baseTypeCode;</span>
<span class="lineNum">    3324 </span>            : }
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span>            : // Implicitly convert Value 'val' to a C binary representation of CType
<span class="lineNum">    3327 </span>            : // 'targetType', storing the result in 'buffer'. Adequate space must be
<span class="lineNum">    3328 </span>            : // provided in 'buffer' by the caller. This function generally does minimal
<span class="lineNum">    3329 </span>            : // coercion between types. There are two cases in which this function is used:
<span class="lineNum">    3330 </span>            : // 1) The target buffer is internal to a CData object; we simply write data
<span class="lineNum">    3331 </span>            : //    into it.
<span class="lineNum">    3332 </span>            : // 2) We are converting an argument for an ffi call, in which case 'convType'
<span class="lineNum">    3333 </span>            : //    will be 'ConversionType::Argument'. This allows us to handle a special
<span class="lineNum">    3334 </span>            : //    case: if necessary, we can autoconvert a JS string primitive to a
<span class="lineNum">    3335 </span>            : //    pointer-to-character type. In this case, ownership of the allocated string
<a name="3336"><span class="lineNum">    3336 </span>            : //    is handed off to the caller; 'freePointer' will be set to indicate this.</a>
<span class="lineNum">    3337 </span>            : static bool
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 : ImplicitConvert(JSContext* cx,</span>
<span class="lineNum">    3339 </span>            :                 HandleValue val,
<span class="lineNum">    3340 </span>            :                 JSObject* targetType_,
<span class="lineNum">    3341 </span>            :                 void* buffer,
<span class="lineNum">    3342 </span>            :                 ConversionType convType,
<span class="lineNum">    3343 </span>            :                 bool* freePointer,
<span class="lineNum">    3344 </span>            :                 HandleObject funObj = nullptr, unsigned argIndex = 0,
<span class="lineNum">    3345 </span>            :                 HandleObject arrObj = nullptr, unsigned arrIndex = 0)
<span class="lineNum">    3346 </span>            : {
<span class="lineNum">    3347 </span><span class="lineNoCov">          0 :   RootedObject targetType(cx, targetType_);</span>
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsSizeDefined(targetType));</span>
<span class="lineNum">    3349 </span>            : 
<span class="lineNum">    3350 </span>            :   // First, check if val is either a CData object or a CDataFinalizer
<span class="lineNum">    3351 </span>            :   // of type targetType.
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :   JSObject* sourceData = nullptr;</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :   JSObject* sourceType = nullptr;</span>
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :   RootedObject valObj(cx, nullptr);</span>
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :   if (val.isObject()) {</span>
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :     valObj = &amp;val.toObject();</span>
<span class="lineNum">    3357 </span><span class="lineNoCov">          0 :     if (CData::IsCData(valObj)) {</span>
<span class="lineNum">    3358 </span><span class="lineNoCov">          0 :       sourceData = valObj;</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 :       sourceType = CData::GetCType(sourceData);</span>
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span>            :       // If the types are equal, copy the buffer contained within the CData.
<span class="lineNum">    3362 </span>            :       // (Note that the buffers may overlap partially or completely.)
<span class="lineNum">    3363 </span><span class="lineNoCov">          0 :       if (CType::TypesEqual(sourceType, targetType)) {</span>
<span class="lineNum">    3364 </span><span class="lineNoCov">          0 :         size_t size = CType::GetSize(sourceType);</span>
<span class="lineNum">    3365 </span><span class="lineNoCov">          0 :         memmove(buffer, CData::GetData(sourceData), size);</span>
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3367 </span>            :       }
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :     } else if (CDataFinalizer::IsCDataFinalizer(valObj)) {</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :       sourceData = valObj;</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :       sourceType = CDataFinalizer::GetCType(cx, sourceData);</span>
<span class="lineNum">    3371 </span>            : 
<span class="lineNum">    3372 </span>            :       CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 :         JS_GetPrivate(sourceData);</span>
<span class="lineNum">    3374 </span>            : 
<span class="lineNum">    3375 </span><span class="lineNoCov">          0 :       if (!p) {</span>
<span class="lineNum">    3376 </span>            :         // We have called |dispose| or |forget| already.
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 :         return EmptyFinalizerError(cx, convType, funObj, argIndex);</span>
<span class="lineNum">    3378 </span>            :       }
<span class="lineNum">    3379 </span>            : 
<span class="lineNum">    3380 </span>            :       // If the types are equal, copy the buffer contained within the CData.
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :       if (CType::TypesEqual(sourceType, targetType)) {</span>
<span class="lineNum">    3382 </span><span class="lineNoCov">          0 :         memmove(buffer, p-&gt;cargs, p-&gt;cargs_size);</span>
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3384 </span>            :       }
<span class="lineNum">    3385 </span>            :     }
<span class="lineNum">    3386 </span>            :   }
<span class="lineNum">    3387 </span>            : 
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :   TypeCode targetCode = CType::GetTypeCode(targetType);</span>
<span class="lineNum">    3389 </span>            : 
<span class="lineNum">    3390 </span><span class="lineNoCov">          0 :   switch (targetCode) {</span>
<span class="lineNum">    3391 </span>            :   case TYPE_bool: {
<span class="lineNum">    3392 </span>            :     // Do not implicitly lose bits, but allow the values 0, 1, and -0.
<span class="lineNum">    3393 </span>            :     // Programs can convert explicitly, if needed, using `Boolean(v)` or `!!v`.
<span class="lineNum">    3394 </span>            :     bool result;
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :     if (!jsvalToBool(cx, val, &amp;result))</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :       return ConvError(cx, &quot;boolean&quot;, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :                        arrObj, arrIndex);</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :     *static_cast&lt;bool*&gt;(buffer) = result;</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3400 </span>            :   }
<span class="lineNum">    3401 </span>            : #define CHAR16_CASE(name, type, ffiType)                                       \
<span class="lineNum">    3402 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3403 </span>            :     /* Convert from a 1-character string, regardless of encoding, */           \
<span class="lineNum">    3404 </span>            :     /* or from an integer, provided the result fits in 'type'. */              \
<span class="lineNum">    3405 </span>            :     type result;                                                               \
<span class="lineNum">    3406 </span>            :     if (val.isString()) {                                                      \
<span class="lineNum">    3407 </span>            :       JSString* str = val.toString();                                          \
<span class="lineNum">    3408 </span>            :       if (str-&gt;length() != 1)                                                  \
<span class="lineNum">    3409 </span>            :         return ConvError(cx, #name, val, convType, funObj, argIndex,           \
<span class="lineNum">    3410 </span>            :                          arrObj, arrIndex);                                    \
<span class="lineNum">    3411 </span>            :       JSLinearString* linear = str-&gt;ensureLinear(cx);                          \
<span class="lineNum">    3412 </span>            :       if (!linear)                                                             \
<span class="lineNum">    3413 </span>            :         return false;                                                          \
<span class="lineNum">    3414 </span>            :       result = linear-&gt;latin1OrTwoByteChar(0);                                 \
<span class="lineNum">    3415 </span>            :     } else if (!jsvalToInteger(cx, val, &amp;result)) {                            \
<span class="lineNum">    3416 </span>            :       return ConvError(cx, #name, val, convType, funObj, argIndex,             \
<span class="lineNum">    3417 </span>            :                        arrObj, arrIndex);                                      \
<span class="lineNum">    3418 </span>            :     }                                                                          \
<span class="lineNum">    3419 </span>            :     *static_cast&lt;type*&gt;(buffer) = result;                                      \
<span class="lineNum">    3420 </span>            :     break;                                                                     \
<span class="lineNum">    3421 </span>            :   }
<span class="lineNum">    3422 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR16_TYPE(CHAR16_CASE)</span>
<span class="lineNum">    3423 </span>            : #undef CHAR16_CASE
<span class="lineNum">    3424 </span>            : #define INTEGRAL_CASE(name, type, ffiType)                                     \
<span class="lineNum">    3425 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3426 </span>            :     /* Do not implicitly lose bits. */                                         \
<span class="lineNum">    3427 </span>            :     type result;                                                               \
<span class="lineNum">    3428 </span>            :     if (!jsvalToInteger(cx, val, &amp;result))                                     \
<span class="lineNum">    3429 </span>            :       return ConvError(cx, #name, val, convType, funObj, argIndex,             \
<span class="lineNum">    3430 </span>            :                        arrObj, arrIndex);                                      \
<span class="lineNum">    3431 </span>            :     *static_cast&lt;type*&gt;(buffer) = result;                                      \
<span class="lineNum">    3432 </span>            :     break;                                                                     \
<span class="lineNum">    3433 </span>            :   }
<span class="lineNum">    3434 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3436 </span>            :   // It's hard to believe ctypes.char16_t(&quot;f&quot;) should work yet ctypes.char(&quot;f&quot;)
<span class="lineNum">    3437 </span>            :   // should not.  Ditto for ctypes.{un,}signed_char.  But this is how ctypes
<span class="lineNum">    3438 </span>            :   // has always worked, so preserve these semantics, and don't switch to an
<span class="lineNum">    3439 </span>            :   // algorithm similar to that in DEFINE_CHAR16_TYPE above, just yet.
<span class="lineNum">    3440 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3441 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    3442 </span>            : #define FLOAT_CASE(name, type, ffiType)                                        \
<span class="lineNum">    3443 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3444 </span>            :     type result;                                                               \
<span class="lineNum">    3445 </span>            :     if (!jsvalToFloat(cx, val, &amp;result))                                       \
<span class="lineNum">    3446 </span>            :       return ConvError(cx, #name, val, convType, funObj, argIndex,             \
<span class="lineNum">    3447 </span>            :                        arrObj, arrIndex);                                      \
<span class="lineNum">    3448 </span>            :     *static_cast&lt;type*&gt;(buffer) = result;                                      \
<span class="lineNum">    3449 </span>            :     break;                                                                     \
<span class="lineNum">    3450 </span>            :   }
<span class="lineNum">    3451 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_FLOAT_TYPE(FLOAT_CASE)</span>
<span class="lineNum">    3452 </span>            : #undef FLOAT_CASE
<span class="lineNum">    3453 </span>            :   case TYPE_pointer: {
<span class="lineNum">    3454 </span><span class="lineNoCov">          0 :     if (val.isNull()) {</span>
<span class="lineNum">    3455 </span>            :       // Convert to a null pointer.
<span class="lineNum">    3456 </span><span class="lineNoCov">          0 :       *static_cast&lt;void**&gt;(buffer) = nullptr;</span>
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3458 </span>            :     }
<span class="lineNum">    3459 </span>            : 
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 :     JS::Rooted&lt;JSObject*&gt; baseType(cx, PointerType::GetBaseType(targetType));</span>
<span class="lineNum">    3461 </span><span class="lineNoCov">          0 :     if (sourceData) {</span>
<span class="lineNum">    3462 </span>            :       // First, determine if the targetType is ctypes.void_t.ptr.
<span class="lineNum">    3463 </span><span class="lineNoCov">          0 :       TypeCode sourceCode = CType::GetTypeCode(sourceType);</span>
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :       void* sourceBuffer = CData::GetData(sourceData);</span>
<span class="lineNum">    3465 </span><span class="lineNoCov">          0 :       bool voidptrTarget = CType::GetTypeCode(baseType) == TYPE_void_t;</span>
<span class="lineNum">    3466 </span>            : 
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 :       if (sourceCode == TYPE_pointer &amp;&amp; voidptrTarget) {</span>
<span class="lineNum">    3468 </span>            :         // Autoconvert if targetType is ctypes.voidptr_t.
<span class="lineNum">    3469 </span><span class="lineNoCov">          0 :         *static_cast&lt;void**&gt;(buffer) = *static_cast&lt;void**&gt;(sourceBuffer);</span>
<span class="lineNum">    3470 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3471 </span>            :       }
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :       if (sourceCode == TYPE_array) {</span>
<span class="lineNum">    3473 </span>            :         // Autoconvert an array to a ctypes.void_t.ptr or to
<span class="lineNum">    3474 </span>            :         // sourceType.elementType.ptr, just like C.
<span class="lineNum">    3475 </span><span class="lineNoCov">          0 :         JSObject* elementType = ArrayType::GetBaseType(sourceType);</span>
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :         if (voidptrTarget || CType::TypesEqual(baseType, elementType)) {</span>
<span class="lineNum">    3477 </span><span class="lineNoCov">          0 :           *static_cast&lt;void**&gt;(buffer) = sourceBuffer;</span>
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    3479 </span>            :         }
<span class="lineNum">    3480 </span>            :       }
<span class="lineNum">    3481 </span>            : 
<span class="lineNum">    3482 </span><span class="lineNoCov">          0 :     } else if (convType == ConversionType::Argument &amp;&amp; val.isString()) {</span>
<span class="lineNum">    3483 </span>            :       // Convert the string for the ffi call. This requires allocating space
<span class="lineNum">    3484 </span>            :       // which the caller assumes ownership of.
<span class="lineNum">    3485 </span>            :       // TODO: Extend this so we can safely convert strings at other times also.
<span class="lineNum">    3486 </span><span class="lineNoCov">          0 :       JSString* sourceString = val.toString();</span>
<span class="lineNum">    3487 </span><span class="lineNoCov">          0 :       size_t sourceLength = sourceString-&gt;length();</span>
<span class="lineNum">    3488 </span><span class="lineNoCov">          0 :       JSLinearString* sourceLinear = sourceString-&gt;ensureLinear(cx);</span>
<span class="lineNum">    3489 </span><span class="lineNoCov">          0 :       if (!sourceLinear)</span>
<span class="lineNum">    3490 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3491 </span>            : 
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :       switch (CType::GetTypeCode(baseType)) {</span>
<span class="lineNum">    3493 </span>            :       case TYPE_char:
<span class="lineNum">    3494 </span>            :       case TYPE_signed_char:
<span class="lineNum">    3495 </span>            :       case TYPE_unsigned_char: {
<span class="lineNum">    3496 </span>            :         // Convert from UTF-16 to UTF-8.
<span class="lineNum">    3497 </span><span class="lineNoCov">          0 :         size_t nbytes = GetDeflatedUTF8StringLength(cx, sourceLinear);</span>
<span class="lineNum">    3498 </span><span class="lineNoCov">          0 :         if (nbytes == (size_t) -1)</span>
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3500 </span>            : 
<span class="lineNum">    3501 </span><span class="lineNoCov">          0 :         char** charBuffer = static_cast&lt;char**&gt;(buffer);</span>
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :         *charBuffer = cx-&gt;pod_malloc&lt;char&gt;(nbytes + 1);</span>
<span class="lineNum">    3503 </span><span class="lineNoCov">          0 :         if (!*charBuffer) {</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :           JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3506 </span>            :         }
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         ASSERT_OK(DeflateStringToUTF8Buffer(cx, sourceLinear, *charBuffer, &amp;nbytes));</span>
<span class="lineNum">    3509 </span><span class="lineNoCov">          0 :         (*charBuffer)[nbytes] = 0;</span>
<span class="lineNum">    3510 </span><span class="lineNoCov">          0 :         *freePointer = true;</span>
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3512 </span>            :       }
<span class="lineNum">    3513 </span>            :       case TYPE_char16_t: {
<span class="lineNum">    3514 </span>            :         // Copy the char16_t string data. (We could provide direct access to the
<span class="lineNum">    3515 </span>            :         // JSString's buffer, but this approach is safer if the caller happens
<span class="lineNum">    3516 </span>            :         // to modify the string.)
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :         char16_t** char16Buffer = static_cast&lt;char16_t**&gt;(buffer);</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :         *char16Buffer = cx-&gt;pod_malloc&lt;char16_t&gt;(sourceLength + 1);</span>
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :         if (!*char16Buffer) {</span>
<span class="lineNum">    3520 </span><span class="lineNoCov">          0 :           JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3522 </span>            :         }
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :         *freePointer = true;</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :         if (sourceLinear-&gt;hasLatin1Chars()) {</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :             AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :             CopyAndInflateChars(*char16Buffer, sourceLinear-&gt;latin1Chars(nogc), sourceLength);</span>
<span class="lineNum">    3528 </span>            :         } else {
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :             AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3530 </span><span class="lineNoCov">          0 :             mozilla::PodCopy(*char16Buffer, sourceLinear-&gt;twoByteChars(nogc), sourceLength);</span>
<span class="lineNum">    3531 </span>            :         }
<span class="lineNum">    3532 </span><span class="lineNoCov">          0 :         (*char16Buffer)[sourceLength] = 0;</span>
<span class="lineNum">    3533 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3534 </span>            :       }
<span class="lineNum">    3535 </span>            :       default:
<span class="lineNum">    3536 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3538 </span>            :       }
<span class="lineNum">    3539 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3540 </span><span class="lineNoCov">          0 :     } else if (val.isObject() &amp;&amp; JS_IsArrayBufferObject(valObj)) {</span>
<span class="lineNum">    3541 </span>            :       // Convert ArrayBuffer to pointer without any copy. This is only valid
<span class="lineNum">    3542 </span>            :       // when converting an argument to a function call, as it is possible for
<span class="lineNum">    3543 </span>            :       // the pointer to be invalidated by anything that runs JS code. (It is
<span class="lineNum">    3544 </span>            :       // invalid to invoke JS code from a ctypes function call.)
<span class="lineNum">    3545 </span><span class="lineNoCov">          0 :       if (convType != ConversionType::Argument) {</span>
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3547 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3548 </span>            :       }
<span class="lineNum">    3549 </span>            :       void* ptr;
<span class="lineNum">    3550 </span>            :       {
<span class="lineNum">    3551 </span><span class="lineNoCov">          0 :           JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3552 </span>            :           bool isShared;
<span class="lineNum">    3553 </span><span class="lineNoCov">          0 :           ptr = JS_GetArrayBufferData(valObj, &amp;isShared, nogc);</span>
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!isShared); // Because ArrayBuffer</span>
<span class="lineNum">    3555 </span>            :       }
<span class="lineNum">    3556 </span><span class="lineNoCov">          0 :       if (!ptr) {</span>
<span class="lineNum">    3557 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3559 </span>            :       }
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :       *static_cast&lt;void**&gt;(buffer) = ptr;</span>
<span class="lineNum">    3561 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :     } else if (val.isObject() &amp;&amp; JS_IsSharedArrayBufferObject(valObj)) {</span>
<span class="lineNum">    3563 </span>            :       // CTypes has not yet opted in to allowing shared memory pointers
<span class="lineNum">    3564 </span>            :       // to escape.  Exporting a pointer to the shared buffer without
<span class="lineNum">    3565 </span>            :       // indicating sharedness would expose client code to races.
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 :       return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :                        arrObj, arrIndex);</span>
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :     } else if (val.isObject() &amp;&amp; JS_IsArrayBufferViewObject(valObj)) {</span>
<span class="lineNum">    3569 </span>            :       // Same as ArrayBuffer, above, though note that this will take the
<span class="lineNum">    3570 </span>            :       // offset of the view into account.
<span class="lineNum">    3571 </span><span class="lineNoCov">          0 :       if(!CanConvertTypedArrayItemTo(baseType, valObj, cx)) {</span>
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3574 </span>            :       }
<span class="lineNum">    3575 </span><span class="lineNoCov">          0 :       if (convType != ConversionType::Argument) {</span>
<span class="lineNum">    3576 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3578 </span>            :       }
<span class="lineNum">    3579 </span>            :       void* ptr;
<span class="lineNum">    3580 </span>            :       {
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :           JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3582 </span>            :           bool isShared;
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :           ptr = JS_GetArrayBufferViewData(valObj, &amp;isShared, nogc);</span>
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :           if (isShared) {</span>
<span class="lineNum">    3585 </span>            :               // Opt out of shared memory, for now.  Exporting a
<span class="lineNum">    3586 </span>            :               // pointer to the shared buffer without indicating
<span class="lineNum">    3587 </span>            :               // sharedness would expose client code to races.
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :               ptr = nullptr;</span>
<span class="lineNum">    3589 </span>            :           }
<span class="lineNum">    3590 </span>            :       }
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :       if (!ptr) {</span>
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3593 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3594 </span>            :       }
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :       *static_cast&lt;void**&gt;(buffer) = ptr;</span>
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3597 </span>            :     }
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :     return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :                      arrObj, arrIndex);</span>
<span class="lineNum">    3600 </span>            :   }
<span class="lineNum">    3601 </span>            :   case TYPE_array: {
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :     RootedObject baseType(cx, ArrayType::GetBaseType(targetType));</span>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 :     size_t targetLength = ArrayType::GetLength(targetType);</span>
<span class="lineNum">    3606 </span>            : 
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :     if (val.isString()) {</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :       JSString* sourceString = val.toString();</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :       size_t sourceLength = sourceString-&gt;length();</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :       JSLinearString* sourceLinear = sourceString-&gt;ensureLinear(cx);</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :       if (!sourceLinear)</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3613 </span>            : 
<span class="lineNum">    3614 </span><span class="lineNoCov">          0 :       switch (CType::GetTypeCode(baseType)) {</span>
<span class="lineNum">    3615 </span>            :       case TYPE_char:
<span class="lineNum">    3616 </span>            :       case TYPE_signed_char:
<span class="lineNum">    3617 </span>            :       case TYPE_unsigned_char: {
<span class="lineNum">    3618 </span>            :         // Convert from UTF-16 or Latin1 to UTF-8.
<span class="lineNum">    3619 </span>            :         size_t nbytes =
<span class="lineNum">    3620 </span><span class="lineNoCov">          0 :           GetDeflatedUTF8StringLength(cx, sourceLinear);</span>
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 :         if (nbytes == (size_t) -1)</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3623 </span>            : 
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :         if (targetLength &lt; nbytes) {</span>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3626 </span><span class="lineNoCov">          0 :           return ArrayLengthOverflow(cx, targetLength, targetType, nbytes, val,</span>
<span class="lineNum">    3627 </span><span class="lineNoCov">          0 :                                      convType);</span>
<span class="lineNum">    3628 </span>            :         }
<span class="lineNum">    3629 </span>            : 
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :         char* charBuffer = static_cast&lt;char*&gt;(buffer);</span>
<span class="lineNum">    3631 </span><span class="lineNoCov">          0 :         ASSERT_OK(DeflateStringToUTF8Buffer(cx, sourceLinear, charBuffer,</span>
<span class="lineNum">    3632 </span><span class="lineNoCov">          0 :                                             &amp;nbytes));</span>
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span><span class="lineNoCov">          0 :         if (targetLength &gt; nbytes)</span>
<span class="lineNum">    3635 </span><span class="lineNoCov">          0 :           charBuffer[nbytes] = 0;</span>
<span class="lineNum">    3636 </span>            : 
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3638 </span>            :       }
<span class="lineNum">    3639 </span>            :       case TYPE_char16_t: {
<span class="lineNum">    3640 </span>            :         // Copy the string data, char16_t for char16_t, including the terminator
<span class="lineNum">    3641 </span>            :         // if there's space.
<span class="lineNum">    3642 </span><span class="lineNoCov">          0 :         if (targetLength &lt; sourceLength) {</span>
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3644 </span><span class="lineNoCov">          0 :           return ArrayLengthOverflow(cx, targetLength, targetType,</span>
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :                                      sourceLength, val, convType);</span>
<span class="lineNum">    3646 </span>            :         }
<span class="lineNum">    3647 </span>            : 
<span class="lineNum">    3648 </span><span class="lineNoCov">          0 :         char16_t* dest = static_cast&lt;char16_t*&gt;(buffer);</span>
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :         if (sourceLinear-&gt;hasLatin1Chars()) {</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :             AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :             CopyAndInflateChars(dest, sourceLinear-&gt;latin1Chars(nogc), sourceLength);</span>
<span class="lineNum">    3652 </span>            :         } else {
<span class="lineNum">    3653 </span><span class="lineNoCov">          0 :             AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3654 </span><span class="lineNoCov">          0 :             mozilla::PodCopy(dest, sourceLinear-&gt;twoByteChars(nogc), sourceLength);</span>
<span class="lineNum">    3655 </span>            :         }
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 :         if (targetLength &gt; sourceLength)</span>
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :           dest[sourceLength] = 0;</span>
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3661 </span>            :       }
<span class="lineNum">    3662 </span>            :       default:
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3664 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3665 </span>            :       }
<span class="lineNum">    3666 </span>            :     } else {
<span class="lineNum">    3667 </span>            :       ESClass cls;
<span class="lineNum">    3668 </span><span class="lineNoCov">          0 :       if (!GetClassOfValue(cx, val, &amp;cls))</span>
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3670 </span>            : 
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :       if (cls == ESClass::Array) {</span>
<span class="lineNum">    3672 </span>            :         // Convert each element of the array by calling ImplicitConvert.
<span class="lineNum">    3673 </span>            :         uint32_t sourceLength;
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :         if (!JS_GetArrayLength(cx, valObj, &amp;sourceLength) ||</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :             targetLength != size_t(sourceLength)) {</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :           return ArrayLengthMismatch(cx, targetLength, targetType,</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :                                      size_t(sourceLength), val, convType);</span>
<span class="lineNum">    3679 </span>            :         }
<span class="lineNum">    3680 </span>            : 
<span class="lineNum">    3681 </span>            :         // Convert into an intermediate, in case of failure.
<span class="lineNum">    3682 </span><span class="lineNoCov">          0 :         size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    3683 </span><span class="lineNoCov">          0 :         size_t arraySize = elementSize * targetLength;</span>
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 :         auto intermediate = cx-&gt;make_pod_array&lt;char&gt;(arraySize);</span>
<span class="lineNum">    3685 </span><span class="lineNoCov">          0 :         if (!intermediate) {</span>
<span class="lineNum">    3686 </span><span class="lineNoCov">          0 :           JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    3687 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3688 </span>            :         }
<span class="lineNum">    3689 </span>            : 
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 :         RootedValue item(cx);</span>
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; i &lt; sourceLength; ++i) {</span>
<span class="lineNum">    3692 </span><span class="lineNoCov">          0 :           if (!JS_GetElement(cx, valObj, i, &amp;item))</span>
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3694 </span>            : 
<span class="lineNum">    3695 </span><span class="lineNoCov">          0 :           char* data = intermediate.get() + elementSize * i;</span>
<span class="lineNum">    3696 </span><span class="lineNoCov">          0 :           if (!ImplicitConvert(cx, item, baseType, data, convType, nullptr,</span>
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :                                funObj, argIndex, targetType, i))</span>
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3699 </span>            :         }
<span class="lineNum">    3700 </span>            : 
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :         memcpy(buffer, intermediate.get(), arraySize);</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :       } else if (cls == ESClass::ArrayBuffer || cls == ESClass::SharedArrayBuffer) {</span>
<span class="lineNum">    3703 </span>            :         // Check that array is consistent with type, then
<span class="lineNum">    3704 </span>            :         // copy the array.
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :         const bool bufferShared = cls == ESClass::SharedArrayBuffer;</span>
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 :         uint32_t sourceLength = bufferShared ? JS_GetSharedArrayBufferByteLength(valObj)</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :             : JS_GetArrayBufferByteLength(valObj);</span>
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :         size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :         size_t arraySize = elementSize * targetLength;</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :         if (arraySize != size_t(sourceLength)) {</span>
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :           return ArrayLengthMismatch(cx, arraySize, targetType,</span>
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :                                      size_t(sourceLength), val, convType);</span>
<span class="lineNum">    3714 </span>            :         }
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :         SharedMem&lt;void*&gt; target = SharedMem&lt;void*&gt;::unshared(buffer);</span>
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :         JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3717 </span>            :         bool isShared;
<span class="lineNum">    3718 </span>            :         SharedMem&lt;void*&gt; src =
<span class="lineNum">    3719 </span>            :             (bufferShared ?
<span class="lineNum">    3720 </span><span class="lineNoCov">          0 :              SharedMem&lt;void*&gt;::shared(JS_GetSharedArrayBufferData(valObj, &amp;isShared, nogc)) :</span>
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :              SharedMem&lt;void*&gt;::unshared(JS_GetArrayBufferData(valObj, &amp;isShared, nogc)));</span>
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(isShared == bufferShared);</span>
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 :         jit::AtomicOperations::memcpySafeWhenRacy(target, src, sourceLength);</span>
<span class="lineNum">    3724 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3725 </span><span class="lineNoCov">          0 :       } else if (JS_IsTypedArrayObject(valObj)) {</span>
<span class="lineNum">    3726 </span>            :         // Check that array is consistent with type, then
<span class="lineNum">    3727 </span>            :         // copy the array.  It is OK to copy from shared to unshared
<span class="lineNum">    3728 </span>            :         // or vice versa.
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :         if (!CanConvertTypedArrayItemTo(baseType, valObj, cx)) {</span>
<span class="lineNum">    3730 </span><span class="lineNoCov">          0 :           return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :                            arrObj, arrIndex);</span>
<span class="lineNum">    3732 </span>            :         }
<span class="lineNum">    3733 </span>            : 
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :         uint32_t sourceLength = JS_GetTypedArrayByteLength(valObj);</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :         size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 :         size_t arraySize = elementSize * targetLength;</span>
<span class="lineNum">    3737 </span><span class="lineNoCov">          0 :         if (arraySize != size_t(sourceLength)) {</span>
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(!funObj);</span>
<span class="lineNum">    3739 </span><span class="lineNoCov">          0 :           return ArrayLengthMismatch(cx, arraySize, targetType,</span>
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :                                      size_t(sourceLength), val, convType);</span>
<span class="lineNum">    3741 </span>            :         }
<span class="lineNum">    3742 </span><span class="lineNoCov">          0 :         SharedMem&lt;void*&gt; target = SharedMem&lt;void*&gt;::unshared(buffer);</span>
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :         JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">    3744 </span>            :         bool isShared;
<span class="lineNum">    3745 </span>            :         SharedMem&lt;void*&gt; src =
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :             SharedMem&lt;void*&gt;::shared(JS_GetArrayBufferViewData(valObj, &amp;isShared, nogc));</span>
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :         jit::AtomicOperations::memcpySafeWhenRacy(target, src, sourceLength);</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3749 </span>            :       } else {
<span class="lineNum">    3750 </span>            :         // Don't implicitly convert to string. Users can implicitly convert
<span class="lineNum">    3751 </span>            :         // with `String(x)` or `&quot;&quot;+x`.
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :         return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :                          arrObj, arrIndex);</span>
<span class="lineNum">    3754 </span>            :       }
<span class="lineNum">    3755 </span>            :     }
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3757 </span>            :   }
<span class="lineNum">    3758 </span>            :   case TYPE_struct: {
<span class="lineNum">    3759 </span><span class="lineNoCov">          0 :     if (val.isObject() &amp;&amp; !sourceData) {</span>
<span class="lineNum">    3760 </span>            :       // Enumerate the properties of the object; if they match the struct
<span class="lineNum">    3761 </span>            :       // specification, convert the fields.
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :       Rooted&lt;IdVector&gt; props(cx, IdVector(cx));</span>
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :       if (!JS_Enumerate(cx, valObj, &amp;props))</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3765 </span>            : 
<span class="lineNum">    3766 </span>            :       // Convert into an intermediate, in case of failure.
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :       size_t structSize = CType::GetSize(targetType);</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :       auto intermediate = cx-&gt;make_pod_array&lt;char&gt;(structSize);</span>
<span class="lineNum">    3769 </span><span class="lineNoCov">          0 :       if (!intermediate) {</span>
<span class="lineNum">    3770 </span><span class="lineNoCov">          0 :         JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    3771 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3772 </span>            :       }
<span class="lineNum">    3773 </span>            : 
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :       const FieldInfoHash* fields = StructType::GetFieldInfo(targetType);</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :       if (props.length() != fields-&gt;count()) {</span>
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :         return FieldCountMismatch(cx, fields-&gt;count(), targetType,</span>
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :                                   props.length(), val, convType,</span>
<span class="lineNum">    3778 </span><span class="lineNoCov">          0 :                                   funObj, argIndex);</span>
<span class="lineNum">    3779 </span>            :       }
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :       RootedId id(cx);</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; props.length(); ++i) {</span>
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :         id = props[i];</span>
<span class="lineNum">    3784 </span>            : 
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :         if (!JSID_IS_STRING(id)) {</span>
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 :           return PropNameNonStringError(cx, id, val, convType,</span>
<span class="lineNum">    3787 </span><span class="lineNoCov">          0 :                                         funObj, argIndex);</span>
<span class="lineNum">    3788 </span>            :         }
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :         JSFlatString* name = JSID_TO_FLAT_STRING(id);</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :         const FieldInfo* field = StructType::LookupField(cx, targetType, name);</span>
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :         if (!field)</span>
<span class="lineNum">    3793 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span><span class="lineNoCov">          0 :         RootedValue prop(cx);</span>
<span class="lineNum">    3796 </span><span class="lineNoCov">          0 :         if (!JS_GetPropertyById(cx, valObj, id, &amp;prop))</span>
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span>            :         // Convert the field via ImplicitConvert().
<span class="lineNum">    3800 </span><span class="lineNoCov">          0 :         char* fieldData = intermediate.get() + field-&gt;mOffset;</span>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :         if (!ImplicitConvert(cx, prop, field-&gt;mType, fieldData, convType,</span>
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :                              nullptr, funObj, argIndex, targetType, i))</span>
<span class="lineNum">    3803 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    3804 </span>            :       }
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :       memcpy(buffer, intermediate.get(), structSize);</span>
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3808 </span>            :     }
<span class="lineNum">    3809 </span>            : 
<span class="lineNum">    3810 </span><span class="lineNoCov">          0 :     return ConvError(cx, targetType, val, convType, funObj, argIndex,</span>
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :                      arrObj, arrIndex);</span>
<span class="lineNum">    3812 </span>            :   }
<span class="lineNum">    3813 </span>            :   case TYPE_void_t:
<span class="lineNum">    3814 </span>            :   case TYPE_function:
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;invalid type&quot;);</span>
<span class="lineNum">    3816 </span>            :   }
<span class="lineNum">    3817 </span>            : 
<span class="lineNum">    3818 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    3819 </span>            : }
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span>            : // Convert Value 'val' to a C binary representation of CType 'targetType',
<span class="lineNum">    3822 </span>            : // storing the result in 'buffer'. This function is more forceful than
<a name="3823"><span class="lineNum">    3823 </span>            : // ImplicitConvert.</a>
<span class="lineNum">    3824 </span>            : static bool
<span class="lineNum">    3825 </span><span class="lineNoCov">          0 : ExplicitConvert(JSContext* cx, HandleValue val, HandleObject targetType,</span>
<span class="lineNum">    3826 </span>            :                 void* buffer, ConversionType convType)
<span class="lineNum">    3827 </span>            : {
<span class="lineNum">    3828 </span>            :   // If ImplicitConvert succeeds, use that result.
<span class="lineNum">    3829 </span><span class="lineNoCov">          0 :   if (ImplicitConvert(cx, val, targetType, buffer, convType, nullptr))</span>
<span class="lineNum">    3830 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3831 </span>            : 
<span class="lineNum">    3832 </span>            :   // If ImplicitConvert failed, and there is no pending exception, then assume
<span class="lineNum">    3833 </span>            :   // hard failure (out of memory, or some other similarly serious condition).
<span class="lineNum">    3834 </span>            :   // We store any pending exception in case we need to re-throw it.
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :   RootedValue ex(cx);</span>
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :   if (!JS_GetPendingException(cx, &amp;ex))</span>
<span class="lineNum">    3837 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3838 </span>            : 
<span class="lineNum">    3839 </span>            :   // Otherwise, assume soft failure. Clear the pending exception so that we
<span class="lineNum">    3840 </span>            :   // can throw a different one as required.
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 :   JS_ClearPendingException(cx);</span>
<span class="lineNum">    3842 </span>            : 
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :   TypeCode type = CType::GetTypeCode(targetType);</span>
<span class="lineNum">    3844 </span>            : 
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 :   switch (type) {</span>
<span class="lineNum">    3846 </span>            :   case TYPE_bool: {
<span class="lineNum">    3847 </span><span class="lineNoCov">          0 :     *static_cast&lt;bool*&gt;(buffer) = ToBoolean(val);</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3849 </span>            :   }
<span class="lineNum">    3850 </span>            : #define INTEGRAL_CASE(name, type, ffiType)                                     \
<span class="lineNum">    3851 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    3852 </span>            :     /* Convert numeric values with a C-style cast, and */                      \
<span class="lineNum">    3853 </span>            :     /* allow conversion from a base-10 or base-16 string. */                   \
<span class="lineNum">    3854 </span>            :     type result;                                                               \
<span class="lineNum">    3855 </span>            :     bool overflow = false;                                                     \
<span class="lineNum">    3856 </span>            :     if (!jsvalToIntegerExplicit(val, &amp;result) &amp;&amp;                               \
<span class="lineNum">    3857 </span>            :         (!val.isString() ||                                                    \
<span class="lineNum">    3858 </span>            :          !StringToInteger(cx, val.toString(), &amp;result, &amp;overflow))) {          \
<span class="lineNum">    3859 </span>            :       if (overflow) {                                                          \
<span class="lineNum">    3860 </span>            :         return TypeOverflow(cx, #name, val);                                   \
<span class="lineNum">    3861 </span>            :       }                                                                        \
<span class="lineNum">    3862 </span>            :       return ConvError(cx, #name, val, convType);                              \
<span class="lineNum">    3863 </span>            :     }                                                                          \
<span class="lineNum">    3864 </span>            :     *static_cast&lt;type*&gt;(buffer) = result;                                      \
<span class="lineNum">    3865 </span>            :     break;                                                                     \
<span class="lineNum">    3866 </span>            :   }
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR16_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    3871 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    3872 </span>            :   case TYPE_pointer: {
<span class="lineNum">    3873 </span>            :     // Convert a number, Int64 object, or UInt64 object to a pointer.
<span class="lineNum">    3874 </span>            :     uintptr_t result;
<span class="lineNum">    3875 </span><span class="lineNoCov">          0 :     if (!jsvalToPtrExplicit(cx, val, &amp;result))</span>
<span class="lineNum">    3876 </span><span class="lineNoCov">          0 :       return ConvError(cx, targetType, val, convType);</span>
<span class="lineNum">    3877 </span><span class="lineNoCov">          0 :     *static_cast&lt;uintptr_t*&gt;(buffer) = result;</span>
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3879 </span>            :   }
<span class="lineNum">    3880 </span>            :   case TYPE_float32_t:
<span class="lineNum">    3881 </span>            :   case TYPE_float64_t:
<span class="lineNum">    3882 </span>            :   case TYPE_float:
<span class="lineNum">    3883 </span>            :   case TYPE_double:
<span class="lineNum">    3884 </span>            :   case TYPE_array:
<span class="lineNum">    3885 </span>            :   case TYPE_struct:
<span class="lineNum">    3886 </span>            :     // ImplicitConvert is sufficient. Re-throw the exception it generated.
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :     JS_SetPendingException(cx, ex);</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3889 </span>            :   case TYPE_void_t:
<span class="lineNum">    3890 </span>            :   case TYPE_function:
<span class="lineNum">    3891 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;invalid type&quot;);</span>
<span class="lineNum">    3892 </span>            :   }
<span class="lineNum">    3893 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    3894 </span>            : }
<span class="lineNum">    3895 </span>            : 
<span class="lineNum">    3896 </span>            : // Given a CType 'typeObj', generate a string describing the C type declaration
<span class="lineNum">    3897 </span>            : // corresponding to 'typeObj'. For instance, the CType constructed from
<span class="lineNum">    3898 </span>            : // 'ctypes.int32_t.ptr.array(4).ptr.ptr' will result in the type string
<a name="3899"><span class="lineNum">    3899 </span>            : // 'int32_t*(**)[4]'.</a>
<span class="lineNum">    3900 </span>            : static JSString*
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 : BuildTypeName(JSContext* cx, JSObject* typeObj_)</span>
<span class="lineNum">    3902 </span>            : {
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :   AutoString result;</span>
<span class="lineNum">    3904 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, typeObj_);</span>
<span class="lineNum">    3905 </span>            : 
<span class="lineNum">    3906 </span>            :   // Walk the hierarchy of types, outermost to innermost, building up the type
<span class="lineNum">    3907 </span>            :   // string. This consists of the base type, which goes on the left.
<span class="lineNum">    3908 </span>            :   // Derived type modifiers (* and []) build from the inside outward, with
<span class="lineNum">    3909 </span>            :   // pointers on the left and arrays on the right. An excellent description
<span class="lineNum">    3910 </span>            :   // of the rules for building C type declarations can be found at:
<span class="lineNum">    3911 </span>            :   // http://unixwiz.net/techtips/reading-cdecl.html
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :   TypeCode prevGrouping = CType::GetTypeCode(typeObj), currentGrouping;</span>
<span class="lineNum">    3913 </span>            :   while (true) {
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :     currentGrouping = CType::GetTypeCode(typeObj);</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :     switch (currentGrouping) {</span>
<span class="lineNum">    3916 </span>            :     case TYPE_pointer: {
<span class="lineNum">    3917 </span>            :       // Pointer types go on the left.
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :       PrependString(result, &quot;*&quot;);</span>
<span class="lineNum">    3919 </span>            : 
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :       typeObj = PointerType::GetBaseType(typeObj);</span>
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :       prevGrouping = currentGrouping;</span>
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3923 </span>            :     }
<span class="lineNum">    3924 </span>            :     case TYPE_array: {
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :       if (prevGrouping == TYPE_pointer) {</span>
<span class="lineNum">    3926 </span>            :         // Outer type is pointer, inner type is array. Grouping is required.
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :         PrependString(result, &quot;(&quot;);</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    3929 </span>            :       }
<span class="lineNum">    3930 </span>            : 
<span class="lineNum">    3931 </span>            :       // Array types go on the right.
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;[&quot;);</span>
<span class="lineNum">    3933 </span>            :       size_t length;
<span class="lineNum">    3934 </span><span class="lineNoCov">          0 :       if (ArrayType::GetSafeLength(typeObj, &amp;length))</span>
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :         IntegerToString(length, 10, result);</span>
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;]&quot;);</span>
<span class="lineNum">    3938 </span>            : 
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :       typeObj = ArrayType::GetBaseType(typeObj);</span>
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :       prevGrouping = currentGrouping;</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3942 </span>            :     }
<span class="lineNum">    3943 </span>            :     case TYPE_function: {
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :       FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    3945 </span>            : 
<span class="lineNum">    3946 </span>            :       // Add in the calling convention, if it's not cdecl.
<span class="lineNum">    3947 </span>            :       // There's no trailing or leading space needed here, as none of the
<span class="lineNum">    3948 </span>            :       // modifiers can produce a string beginning with an identifier ---
<span class="lineNum">    3949 </span>            :       // except for TYPE_function itself, which is fine because functions
<span class="lineNum">    3950 </span>            :       // can't return functions.
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :       ABICode abi = GetABICode(fninfo-&gt;mABI);</span>
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :       if (abi == ABI_STDCALL)</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :         PrependString(result, &quot;__stdcall&quot;);</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :       else if (abi == ABI_THISCALL)</span>
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :         PrependString(result, &quot;__thiscall&quot;);</span>
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :       else if (abi == ABI_WINAPI)</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :         PrependString(result, &quot;WINAPI&quot;);</span>
<span class="lineNum">    3958 </span>            : 
<span class="lineNum">    3959 </span>            :       // Function application binds more tightly than dereferencing, so
<span class="lineNum">    3960 </span>            :       // wrap pointer types in parens. Functions can't return functions
<span class="lineNum">    3961 </span>            :       // (only pointers to them), and arrays can't hold functions
<span class="lineNum">    3962 </span>            :       // (similarly), so we don't need to address those cases.
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :       if (prevGrouping == TYPE_pointer) {</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :         PrependString(result, &quot;(&quot;);</span>
<span class="lineNum">    3965 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    3966 </span>            :       }
<span class="lineNum">    3967 </span>            : 
<span class="lineNum">    3968 </span>            :       // Argument list goes on the right.
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;(&quot;);</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; fninfo-&gt;mArgTypes.length(); ++i) {</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :         RootedObject argType(cx, fninfo-&gt;mArgTypes[i]);</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :         JSString* argName = CType::GetName(cx, argType);</span>
<span class="lineNum">    3973 </span><span class="lineNoCov">          0 :         AppendString(result, argName);</span>
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :         if (i != fninfo-&gt;mArgTypes.length() - 1 ||</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :             fninfo-&gt;mIsVariadic)</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :           AppendString(result, &quot;, &quot;);</span>
<span class="lineNum">    3977 </span>            :       }
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :       if (fninfo-&gt;mIsVariadic)</span>
<span class="lineNum">    3979 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;...&quot;);</span>
<span class="lineNum">    3980 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    3981 </span>            : 
<span class="lineNum">    3982 </span>            :       // Set 'typeObj' to the return type, and let the loop process it.
<span class="lineNum">    3983 </span>            :       // 'prevGrouping' doesn't matter here, because functions cannot return
<span class="lineNum">    3984 </span>            :       // arrays -- thus the parenthetical rules don't get tickled.
<span class="lineNum">    3985 </span><span class="lineNoCov">          0 :       typeObj = fninfo-&gt;mReturnType;</span>
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3987 </span>            :     }
<span class="lineNum">    3988 </span>            :     default:
<span class="lineNum">    3989 </span>            :       // Either a basic or struct type. Use the type's name as the base type.
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3991 </span>            :     }
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3994 </span>            : 
<span class="lineNum">    3995 </span>            :   // If prepending the base type name directly would splice two
<span class="lineNum">    3996 </span>            :   // identifiers, insert a space.
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :   if (('a' &lt;= result[0] &amp;&amp; result[0] &lt;= 'z') ||</span>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 :       ('A' &lt;= result[0] &amp;&amp; result[0] &lt;= 'Z') ||</span>
<span class="lineNum">    3999 </span><span class="lineNoCov">          0 :       (result[0] == '_'))</span>
<span class="lineNum">    4000 </span><span class="lineNoCov">          0 :     PrependString(result, &quot; &quot;);</span>
<span class="lineNum">    4001 </span>            : 
<span class="lineNum">    4002 </span>            :   // Stick the base type and derived type parts together.
<span class="lineNum">    4003 </span><span class="lineNoCov">          0 :   JSString* baseName = CType::GetName(cx, typeObj);</span>
<span class="lineNum">    4004 </span><span class="lineNoCov">          0 :   PrependString(result, baseName);</span>
<span class="lineNum">    4005 </span><span class="lineNoCov">          0 :   return NewUCString(cx, result);</span>
<span class="lineNum">    4006 </span>            : }
<span class="lineNum">    4007 </span>            : 
<span class="lineNum">    4008 </span>            : // Given a CType 'typeObj', generate a string 'result' such that 'eval(result)'
<span class="lineNum">    4009 </span>            : // would construct the same CType. If 'makeShort' is true, assume that any
<span class="lineNum">    4010 </span>            : // StructType 't' is bound to an in-scope variable of name 't.name', and use
<span class="lineNum">    4011 </span>            : // that variable in place of generating a string to construct the type 't'.
<span class="lineNum">    4012 </span>            : // (This means the type comparison function CType::TypesEqual will return true
<span class="lineNum">    4013 </span>            : // when comparing the input and output of BuildTypeSource, since struct
<a name="4014"><span class="lineNum">    4014 </span>            : // equality is determined by strict JSObject pointer equality.)</a>
<span class="lineNum">    4015 </span>            : static void
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 : BuildTypeSource(JSContext* cx,</span>
<span class="lineNum">    4017 </span>            :                 JSObject* typeObj_,
<span class="lineNum">    4018 </span>            :                 bool makeShort,
<span class="lineNum">    4019 </span>            :                 AutoString&amp; result)
<span class="lineNum">    4020 </span>            : {
<span class="lineNum">    4021 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, typeObj_);</span>
<span class="lineNum">    4022 </span>            : 
<span class="lineNum">    4023 </span>            :   // Walk the types, building up the toSource() string.
<span class="lineNum">    4024 </span><span class="lineNoCov">          0 :   switch (CType::GetTypeCode(typeObj)) {</span>
<span class="lineNum">    4025 </span>            :   case TYPE_void_t:
<span class="lineNum">    4026 </span>            : #define CASE_FOR_TYPE(name, type, ffiType)  case TYPE_##name:
<span class="lineNum">    4027 </span>            :   CTYPES_FOR_EACH_TYPE(CASE_FOR_TYPE)
<span class="lineNum">    4028 </span>            : #undef CASE_FOR_TYPE
<span class="lineNum">    4029 </span>            :   {
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;ctypes.&quot;);</span>
<span class="lineNum">    4031 </span><span class="lineNoCov">          0 :     JSString* nameStr = CType::GetName(cx, typeObj);</span>
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 :     AppendString(result, nameStr);</span>
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4034 </span>            :   }
<span class="lineNum">    4035 </span>            :   case TYPE_pointer: {
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :     RootedObject baseType(cx, PointerType::GetBaseType(typeObj));</span>
<span class="lineNum">    4037 </span>            : 
<span class="lineNum">    4038 </span>            :     // Specialcase ctypes.voidptr_t.
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :     if (CType::GetTypeCode(baseType) == TYPE_void_t) {</span>
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;ctypes.voidptr_t&quot;);</span>
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4042 </span>            :     }
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span>            :     // Recursively build the source string, and append '.ptr'.
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :     BuildTypeSource(cx, baseType, makeShort, result);</span>
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;.ptr&quot;);</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4048 </span>            :   }
<span class="lineNum">    4049 </span>            :   case TYPE_function: {
<span class="lineNum">    4050 </span><span class="lineNoCov">          0 :     FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    4051 </span>            : 
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;ctypes.FunctionType(&quot;);</span>
<span class="lineNum">    4053 </span>            : 
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 :     switch (GetABICode(fninfo-&gt;mABI)) {</span>
<span class="lineNum">    4055 </span>            :     case ABI_DEFAULT:
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;ctypes.default_abi, &quot;);</span>
<span class="lineNum">    4057 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4058 </span>            :     case ABI_STDCALL:
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;ctypes.stdcall_abi, &quot;);</span>
<span class="lineNum">    4060 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4061 </span>            :     case ABI_THISCALL:
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;ctypes.thiscall_abi, &quot;);</span>
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4064 </span>            :     case ABI_WINAPI:
<span class="lineNum">    4065 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;ctypes.winapi_abi, &quot;);</span>
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4067 </span>            :     case INVALID_ABI:
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;invalid abi&quot;);</span>
<span class="lineNum">    4069 </span>            :     }
<span class="lineNum">    4070 </span>            : 
<span class="lineNum">    4071 </span>            :     // Recursively build the source string describing the function return and
<span class="lineNum">    4072 </span>            :     // argument types.
<span class="lineNum">    4073 </span><span class="lineNoCov">          0 :     BuildTypeSource(cx, fninfo-&gt;mReturnType, true, result);</span>
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :     if (fninfo-&gt;mArgTypes.length() &gt; 0) {</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;, [&quot;);</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; fninfo-&gt;mArgTypes.length(); ++i) {</span>
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :         BuildTypeSource(cx, fninfo-&gt;mArgTypes[i], true, result);</span>
<span class="lineNum">    4079 </span><span class="lineNoCov">          0 :         if (i != fninfo-&gt;mArgTypes.length() - 1 ||</span>
<span class="lineNum">    4080 </span><span class="lineNoCov">          0 :             fninfo-&gt;mIsVariadic)</span>
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :           AppendString(result, &quot;, &quot;);</span>
<span class="lineNum">    4082 </span>            :       }
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 :       if (fninfo-&gt;mIsVariadic)</span>
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;\&quot;...\&quot;&quot;);</span>
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;]&quot;);</span>
<span class="lineNum">    4086 </span>            :     }
<span class="lineNum">    4087 </span>            : 
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4090 </span>            :   }
<span class="lineNum">    4091 </span>            :   case TYPE_array: {
<span class="lineNum">    4092 </span>            :     // Recursively build the source string, and append '.array(n)',
<span class="lineNum">    4093 </span>            :     // where n is the array length, or the empty string if the array length
<span class="lineNum">    4094 </span>            :     // is undefined.
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :     JSObject* baseType = ArrayType::GetBaseType(typeObj);</span>
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 :     BuildTypeSource(cx, baseType, makeShort, result);</span>
<span class="lineNum">    4097 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;.array(&quot;);</span>
<span class="lineNum">    4098 </span>            : 
<span class="lineNum">    4099 </span>            :     size_t length;
<span class="lineNum">    4100 </span><span class="lineNoCov">          0 :     if (ArrayType::GetSafeLength(typeObj, &amp;length))</span>
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :       IntegerToString(length, 10, result);</span>
<span class="lineNum">    4102 </span>            : 
<span class="lineNum">    4103 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4105 </span>            :   }
<span class="lineNum">    4106 </span>            :   case TYPE_struct: {
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :     JSString* name = CType::GetName(cx, typeObj);</span>
<span class="lineNum">    4108 </span>            : 
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :     if (makeShort) {</span>
<span class="lineNum">    4110 </span>            :       // Shorten the type declaration by assuming that StructType 't' is bound
<span class="lineNum">    4111 </span>            :       // to an in-scope variable of name 't.name'.
<span class="lineNum">    4112 </span><span class="lineNoCov">          0 :       AppendString(result, name);</span>
<span class="lineNum">    4113 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4114 </span>            :     }
<span class="lineNum">    4115 </span>            : 
<span class="lineNum">    4116 </span>            :     // Write the full struct declaration.
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;ctypes.StructType(\&quot;&quot;);</span>
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :     AppendString(result, name);</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;\&quot;&quot;);</span>
<span class="lineNum">    4120 </span>            : 
<span class="lineNum">    4121 </span>            :     // If it's an opaque struct, we're done.
<span class="lineNum">    4122 </span><span class="lineNoCov">          0 :     if (!CType::IsSizeDefined(typeObj)) {</span>
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4125 </span>            :     }
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;, [&quot;);</span>
<span class="lineNum">    4128 </span>            : 
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 :     const FieldInfoHash* fields = StructType::GetFieldInfo(typeObj);</span>
<span class="lineNum">    4130 </span><span class="lineNoCov">          0 :     size_t length = fields-&gt;count();</span>
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 :     Vector&lt;const FieldInfoHash::Entry*, 64, SystemAllocPolicy&gt; fieldsArray;</span>
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 :     if (!fieldsArray.resize(length))</span>
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4134 </span>            : 
<span class="lineNum">    4135 </span><span class="lineNoCov">          0 :     for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront())</span>
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :       fieldsArray[r.front().value().mIndex] = &amp;r.front();</span>
<span class="lineNum">    4137 </span>            : 
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">    4139 </span><span class="lineNoCov">          0 :       const FieldInfoHash::Entry* entry = fieldsArray[i];</span>
<span class="lineNum">    4140 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;{ \&quot;&quot;);</span>
<span class="lineNum">    4141 </span><span class="lineNoCov">          0 :       AppendString(result, entry-&gt;key());</span>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;\&quot;: &quot;);</span>
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :       BuildTypeSource(cx, entry-&gt;value().mType, true, result);</span>
<span class="lineNum">    4144 </span><span class="lineNoCov">          0 :       AppendString(result, &quot; }&quot;);</span>
<span class="lineNum">    4145 </span><span class="lineNoCov">          0 :       if (i != length - 1)</span>
<span class="lineNum">    4146 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;, &quot;);</span>
<span class="lineNum">    4147 </span>            :     }
<span class="lineNum">    4148 </span>            : 
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;])&quot;);</span>
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4151 </span>            :   }
<span class="lineNum">    4152 </span>            :   }
<span class="lineNum">    4153 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4154 </span>            : 
<span class="lineNum">    4155 </span>            : // Given a CData object of CType 'typeObj' with binary value 'data', generate a
<span class="lineNum">    4156 </span>            : // string 'result' such that 'eval(result)' would construct a CData object with
<span class="lineNum">    4157 </span>            : // the same CType and containing the same binary value. This assumes that any
<span class="lineNum">    4158 </span>            : // StructType 't' is bound to an in-scope variable of name 't.name'. (This means
<span class="lineNum">    4159 </span>            : // the type comparison function CType::TypesEqual will return true when
<span class="lineNum">    4160 </span>            : // comparing the types, since struct equality is determined by strict JSObject
<span class="lineNum">    4161 </span>            : // pointer equality.) Further, if 'isImplicit' is true, ensure that the
<span class="lineNum">    4162 </span>            : // resulting string can ImplicitConvert successfully if passed to another data
<span class="lineNum">    4163 </span>            : // constructor. (This is important when called recursively, since fields of
<a name="4164"><span class="lineNum">    4164 </span>            : // structs and arrays are converted with ImplicitConvert.)</a>
<span class="lineNum">    4165 </span>            : static bool
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 : BuildDataSource(JSContext* cx,</span>
<span class="lineNum">    4167 </span>            :                 HandleObject typeObj,
<span class="lineNum">    4168 </span>            :                 void* data,
<span class="lineNum">    4169 </span>            :                 bool isImplicit,
<span class="lineNum">    4170 </span>            :                 AutoString&amp; result)
<span class="lineNum">    4171 </span>            : {
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :   TypeCode type = CType::GetTypeCode(typeObj);</span>
<span class="lineNum">    4173 </span><span class="lineNoCov">          0 :   switch (type) {</span>
<span class="lineNum">    4174 </span>            :   case TYPE_bool:
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :     if (*static_cast&lt;bool*&gt;(data))</span>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;true&quot;);</span>
<span class="lineNum">    4177 </span>            :     else
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;false&quot;);</span>
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4180 </span>            : #define INTEGRAL_CASE(name, type, ffiType)                                     \
<span class="lineNum">    4181 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    4182 </span>            :     /* Serialize as a primitive decimal integer. */                            \
<span class="lineNum">    4183 </span>            :     IntegerToString(*static_cast&lt;type*&gt;(data), 10, result);                    \
<span class="lineNum">    4184 </span>            :     break;
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    4186 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    4187 </span>            : #define WRAPPED_INT_CASE(name, type, ffiType)                                  \
<span class="lineNum">    4188 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    4189 </span>            :     /* Serialize as a wrapped decimal integer. */                              \
<span class="lineNum">    4190 </span>            :     if (!numeric_limits&lt;type&gt;::is_signed)                                      \
<span class="lineNum">    4191 </span>            :       AppendString(result, &quot;ctypes.UInt64(\&quot;&quot;);                                \
<span class="lineNum">    4192 </span>            :     else                                                                       \
<span class="lineNum">    4193 </span>            :       AppendString(result, &quot;ctypes.Int64(\&quot;&quot;);                                 \
<span class="lineNum">    4194 </span>            :                                                                                \
<span class="lineNum">    4195 </span>            :     IntegerToString(*static_cast&lt;type*&gt;(data), 10, result);                    \
<span class="lineNum">    4196 </span>            :     AppendString(result, &quot;\&quot;)&quot;);                                               \
<span class="lineNum">    4197 </span>            :     break;
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_WRAPPED_INT_TYPE(WRAPPED_INT_CASE)</span>
<span class="lineNum">    4199 </span>            : #undef WRAPPED_INT_CASE
<span class="lineNum">    4200 </span>            : #define FLOAT_CASE(name, type, ffiType)                                        \
<span class="lineNum">    4201 </span>            :   case TYPE_##name: {                                                          \
<span class="lineNum">    4202 </span>            :     /* Serialize as a primitive double. */                                     \
<span class="lineNum">    4203 </span>            :     double fp = *static_cast&lt;type*&gt;(data);                                     \
<span class="lineNum">    4204 </span>            :     ToCStringBuf cbuf;                                                         \
<span class="lineNum">    4205 </span>            :     char* str = NumberToCString(cx, &amp;cbuf, fp);                                \
<span class="lineNum">    4206 </span>            :     if (!str || !result.append(str, strlen(str))) {                            \
<span class="lineNum">    4207 </span>            :       JS_ReportOutOfMemory(cx);                                                \
<span class="lineNum">    4208 </span>            :       return false;                                                            \
<span class="lineNum">    4209 </span>            :     }                                                                          \
<span class="lineNum">    4210 </span>            :     break;                                                                     \
<span class="lineNum">    4211 </span>            :   }
<span class="lineNum">    4212 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_FLOAT_TYPE(FLOAT_CASE)</span>
<span class="lineNum">    4213 </span>            : #undef FLOAT_CASE
<span class="lineNum">    4214 </span>            : #define CHAR_CASE(name, type, ffiType)                                         \
<span class="lineNum">    4215 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    4216 </span>            :     /* Serialize as an integer. */                                             \
<span class="lineNum">    4217 </span>            :     IntegerToString(*static_cast&lt;type*&gt;(data), 10, result);                    \
<span class="lineNum">    4218 </span>            :     break;
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR_TYPE(CHAR_CASE)</span>
<span class="lineNum">    4220 </span>            : #undef CHAR_CASE
<span class="lineNum">    4221 </span>            :   case TYPE_char16_t: {
<span class="lineNum">    4222 </span>            :     // Serialize as a 1-character JS string.
<span class="lineNum">    4223 </span><span class="lineNoCov">          0 :     JSString* str = JS_NewUCStringCopyN(cx, static_cast&lt;char16_t*&gt;(data), 1);</span>
<span class="lineNum">    4224 </span><span class="lineNoCov">          0 :     if (!str)</span>
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4226 </span>            : 
<span class="lineNum">    4227 </span>            :     // Escape characters, and quote as necessary.
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :     RootedValue valStr(cx, StringValue(str));</span>
<span class="lineNum">    4229 </span><span class="lineNoCov">          0 :     JSString* src = JS_ValueToSource(cx, valStr);</span>
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :     if (!src)</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4232 </span>            : 
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :     AppendString(result, src);</span>
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4235 </span>            :   }
<span class="lineNum">    4236 </span>            :   case TYPE_pointer:
<span class="lineNum">    4237 </span>            :   case TYPE_function: {
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :     if (isImplicit) {</span>
<span class="lineNum">    4239 </span>            :       // The result must be able to ImplicitConvert successfully.
<span class="lineNum">    4240 </span>            :       // Wrap in a type constructor, then serialize for ExplicitConvert.
<span class="lineNum">    4241 </span><span class="lineNoCov">          0 :       BuildTypeSource(cx, typeObj, true, result);</span>
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;(&quot;);</span>
<span class="lineNum">    4243 </span>            :     }
<span class="lineNum">    4244 </span>            : 
<span class="lineNum">    4245 </span>            :     // Serialize the pointer value as a wrapped hexadecimal integer.
<span class="lineNum">    4246 </span><span class="lineNoCov">          0 :     uintptr_t ptr = *static_cast&lt;uintptr_t*&gt;(data);</span>
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;ctypes.UInt64(\&quot;0x&quot;);</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :     IntegerToString(ptr, 16, result);</span>
<span class="lineNum">    4249 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;\&quot;)&quot;);</span>
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span><span class="lineNoCov">          0 :     if (isImplicit)</span>
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;)&quot;);</span>
<span class="lineNum">    4253 </span>            : 
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4255 </span>            :   }
<span class="lineNum">    4256 </span>            :   case TYPE_array: {
<span class="lineNum">    4257 </span>            :     // Serialize each element of the array recursively. Each element must
<span class="lineNum">    4258 </span>            :     // be able to ImplicitConvert successfully.
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :     RootedObject baseType(cx, ArrayType::GetBaseType(typeObj));</span>
<span class="lineNum">    4260 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;[&quot;);</span>
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :     size_t length = ArrayType::GetLength(typeObj);</span>
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :     size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    4264 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">    4265 </span><span class="lineNoCov">          0 :       char* element = static_cast&lt;char*&gt;(data) + elementSize * i;</span>
<span class="lineNum">    4266 </span><span class="lineNoCov">          0 :       if (!BuildDataSource(cx, baseType, element, true, result))</span>
<span class="lineNum">    4267 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4268 </span>            : 
<span class="lineNum">    4269 </span><span class="lineNoCov">          0 :       if (i + 1 &lt; length)</span>
<span class="lineNum">    4270 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;, &quot;);</span>
<span class="lineNum">    4271 </span>            :     }
<span class="lineNum">    4272 </span><span class="lineNoCov">          0 :     AppendString(result, &quot;]&quot;);</span>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4274 </span>            :   }
<span class="lineNum">    4275 </span>            :   case TYPE_struct: {
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :     if (isImplicit) {</span>
<span class="lineNum">    4277 </span>            :       // The result must be able to ImplicitConvert successfully.
<span class="lineNum">    4278 </span>            :       // Serialize the data as an object with properties, rather than
<span class="lineNum">    4279 </span>            :       // a sequence of arguments to the StructType constructor.
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;{&quot;);</span>
<span class="lineNum">    4281 </span>            :     }
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span>            :     // Serialize each field of the struct recursively. Each field must
<span class="lineNum">    4284 </span>            :     // be able to ImplicitConvert successfully.
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :     const FieldInfoHash* fields = StructType::GetFieldInfo(typeObj);</span>
<span class="lineNum">    4286 </span><span class="lineNoCov">          0 :     size_t length = fields-&gt;count();</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :     Vector&lt;const FieldInfoHash::Entry*, 64, SystemAllocPolicy&gt; fieldsArray;</span>
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :     if (!fieldsArray.resize(length))</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4290 </span>            : 
<span class="lineNum">    4291 </span><span class="lineNoCov">          0 :     for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront())</span>
<span class="lineNum">    4292 </span><span class="lineNoCov">          0 :       fieldsArray[r.front().value().mIndex] = &amp;r.front();</span>
<span class="lineNum">    4293 </span>            : 
<span class="lineNum">    4294 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">    4295 </span><span class="lineNoCov">          0 :       const FieldInfoHash::Entry* entry = fieldsArray[i];</span>
<span class="lineNum">    4296 </span>            : 
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :       if (isImplicit) {</span>
<span class="lineNum">    4298 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;\&quot;&quot;);</span>
<span class="lineNum">    4299 </span><span class="lineNoCov">          0 :         AppendString(result, entry-&gt;key());</span>
<span class="lineNum">    4300 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;\&quot;: &quot;);</span>
<span class="lineNum">    4301 </span>            :       }
<span class="lineNum">    4302 </span>            : 
<span class="lineNum">    4303 </span><span class="lineNoCov">          0 :       char* fieldData = static_cast&lt;char*&gt;(data) + entry-&gt;value().mOffset;</span>
<span class="lineNum">    4304 </span><span class="lineNoCov">          0 :       RootedObject entryType(cx, entry-&gt;value().mType);</span>
<span class="lineNum">    4305 </span><span class="lineNoCov">          0 :       if (!BuildDataSource(cx, entryType, fieldData, true, result))</span>
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4307 </span>            : 
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :       if (i + 1 != length)</span>
<span class="lineNum">    4309 </span><span class="lineNoCov">          0 :         AppendString(result, &quot;, &quot;);</span>
<span class="lineNum">    4310 </span>            :     }
<span class="lineNum">    4311 </span>            : 
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :     if (isImplicit)</span>
<span class="lineNum">    4313 </span><span class="lineNoCov">          0 :       AppendString(result, &quot;}&quot;);</span>
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4316 </span>            :   }
<span class="lineNum">    4317 </span>            :   case TYPE_void_t:
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;invalid type&quot;);</span>
<span class="lineNum">    4319 </span>            :   }
<span class="lineNum">    4320 </span>            : 
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4322 </span>            : }
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : /*******************************************************************************
<span class="lineNum">    4325 </span>            : ** JSAPI callback function implementations
<span class="lineNum">    4326 </span>            : *******************************************************************************/
<a name="4327"><span class="lineNum">    4327 </span>            : </a>
<span class="lineNum">    4328 </span>            : bool
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 : ConstructAbstract(JSContext* cx,</span>
<span class="lineNum">    4330 </span>            :                   unsigned argc,
<span class="lineNum">    4331 </span>            :                   Value* vp)
<span class="lineNum">    4332 </span>            : {
<span class="lineNum">    4333 </span>            :   // Calling an abstract base class constructor is disallowed.
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 :   return CannotConstructError(cx, &quot;abstract type&quot;);</span>
<span class="lineNum">    4335 </span>            : }
<span class="lineNum">    4336 </span>            : 
<span class="lineNum">    4337 </span>            : /*******************************************************************************
<span class="lineNum">    4338 </span>            : ** CType implementation
<span class="lineNum">    4339 </span>            : *******************************************************************************/
<a name="4340"><span class="lineNum">    4340 </span>            : </a>
<span class="lineNum">    4341 </span>            : bool
<span class="lineNum">    4342 </span><span class="lineNoCov">          0 : CType::ConstructData(JSContext* cx,</span>
<span class="lineNum">    4343 </span>            :                      unsigned argc,
<span class="lineNum">    4344 </span>            :                      Value* vp)
<span class="lineNum">    4345 </span>            : {
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    4347 </span>            :   // get the callee object...
<span class="lineNum">    4348 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.callee());</span>
<span class="lineNum">    4349 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj)) {</span>
<span class="lineNum">    4350 </span><span class="lineNoCov">          0 :     return IncompatibleCallee(cx, &quot;CType constructor&quot;, obj);</span>
<span class="lineNum">    4351 </span>            :   }
<span class="lineNum">    4352 </span>            : 
<span class="lineNum">    4353 </span>            :   // How we construct the CData object depends on what type we represent.
<span class="lineNum">    4354 </span>            :   // An instance 'd' of a CData object of type 't' has:
<span class="lineNum">    4355 </span>            :   //   * [[Class]] &quot;CData&quot;
<span class="lineNum">    4356 </span>            :   //   * __proto__ === t.prototype
<span class="lineNum">    4357 </span><span class="lineNoCov">          0 :   switch (GetTypeCode(obj)) {</span>
<span class="lineNum">    4358 </span>            :   case TYPE_void_t:
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :     return CannotConstructError(cx, &quot;void_t&quot;);</span>
<span class="lineNum">    4360 </span>            :   case TYPE_function:
<span class="lineNum">    4361 </span>            :     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
<span class="lineNum">    4362 </span><span class="lineNoCov">          0 :                               CTYPESMSG_FUNCTION_CONSTRUCT);</span>
<span class="lineNum">    4363 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4364 </span>            :   case TYPE_pointer:
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :     return PointerType::ConstructData(cx, obj, args);</span>
<span class="lineNum">    4366 </span>            :   case TYPE_array:
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 :     return ArrayType::ConstructData(cx, obj, args);</span>
<span class="lineNum">    4368 </span>            :   case TYPE_struct:
<span class="lineNum">    4369 </span><span class="lineNoCov">          0 :     return StructType::ConstructData(cx, obj, args);</span>
<span class="lineNum">    4370 </span>            :   default:
<span class="lineNum">    4371 </span><span class="lineNoCov">          0 :     return ConstructBasic(cx, obj, args);</span>
<span class="lineNum">    4372 </span>            :   }
<span class="lineNum">    4373 </span>            : }
<a name="4374"><span class="lineNum">    4374 </span>            : </a>
<span class="lineNum">    4375 </span>            : bool
<span class="lineNum">    4376 </span><span class="lineNoCov">          0 : CType::ConstructBasic(JSContext* cx,</span>
<span class="lineNum">    4377 </span>            :                       HandleObject obj,
<span class="lineNum">    4378 </span>            :                       const CallArgs&amp; args)
<span class="lineNum">    4379 </span>            : {
<span class="lineNum">    4380 </span><span class="lineNoCov">          0 :   if (args.length() &gt; 1) {</span>
<span class="lineNum">    4381 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CType constructor&quot;, &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    4382 </span>            :   }
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            :   // construct a CData object
<span class="lineNum">    4385 </span><span class="lineNoCov">          0 :   RootedObject result(cx, CData::Create(cx, obj, nullptr, nullptr, true));</span>
<span class="lineNum">    4386 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4388 </span>            : 
<span class="lineNum">    4389 </span><span class="lineNoCov">          0 :   if (args.length() == 1) {</span>
<span class="lineNum">    4390 </span><span class="lineNoCov">          0 :     if (!ExplicitConvert(cx, args[0], obj, CData::GetData(result),</span>
<span class="lineNum">    4391 </span>            :                          ConversionType::Construct))
<span class="lineNum">    4392 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4393 </span>            :   }
<span class="lineNum">    4394 </span>            : 
<span class="lineNum">    4395 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    4396 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4397 </span>            : }
<a name="4398"><span class="lineNum">    4398 </span>            : </a>
<span class="lineNum">    4399 </span>            : JSObject*
<span class="lineNum">    4400 </span><span class="lineCov">         72 : CType::Create(JSContext* cx,</span>
<span class="lineNum">    4401 </span>            :               HandleObject typeProto,
<span class="lineNum">    4402 </span>            :               HandleObject dataProto,
<span class="lineNum">    4403 </span>            :               TypeCode type,
<span class="lineNum">    4404 </span>            :               JSString* name_,
<span class="lineNum">    4405 </span>            :               HandleValue size,
<span class="lineNum">    4406 </span>            :               HandleValue align,
<span class="lineNum">    4407 </span>            :               ffi_type* ffiType)
<span class="lineNum">    4408 </span>            : {
<span class="lineNum">    4409 </span><span class="lineCov">        144 :   RootedString name(cx, name_);</span>
<span class="lineNum">    4410 </span>            : 
<span class="lineNum">    4411 </span>            :   // Create a CType object with the properties and slots common to all CTypes.
<span class="lineNum">    4412 </span>            :   // Each type object 't' has:
<span class="lineNum">    4413 </span>            :   //   * [[Class]] &quot;CType&quot;
<span class="lineNum">    4414 </span>            :   //   * __proto__ === 'typeProto'; one of ctypes.{CType,PointerType,ArrayType,
<span class="lineNum">    4415 </span>            :   //     StructType}.prototype
<span class="lineNum">    4416 </span>            :   //   * A constructor which creates and returns a CData object, containing
<span class="lineNum">    4417 </span>            :   //     binary data of the given type.
<span class="lineNum">    4418 </span>            :   //   * 'prototype' property:
<span class="lineNum">    4419 </span>            :   //     * [[Class]] &quot;CDataProto&quot;
<span class="lineNum">    4420 </span>            :   //     * __proto__ === 'dataProto'; an object containing properties and
<span class="lineNum">    4421 </span>            :   //       functions common to all CData objects of types derived from
<span class="lineNum">    4422 </span>            :   //       'typeProto'. (For instance, this could be ctypes.CData.prototype
<span class="lineNum">    4423 </span>            :   //       for simple types, or something representing structs for StructTypes.)
<span class="lineNum">    4424 </span>            :   //     * 'constructor' property === 't'
<span class="lineNum">    4425 </span>            :   //     * Additional properties specified by 'ps', as appropriate for the
<span class="lineNum">    4426 </span>            :   //       specific type instance 't'.
<span class="lineNum">    4427 </span><span class="lineCov">        144 :   RootedObject typeObj(cx, JS_NewObjectWithGivenProto(cx, &amp;sCTypeClass, typeProto));</span>
<span class="lineNum">    4428 </span><span class="lineCov">         72 :   if (!typeObj)</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4430 </span>            : 
<span class="lineNum">    4431 </span>            :   // Set up the reserved slots.
<span class="lineNum">    4432 </span><span class="lineCov">         72 :   JS_SetReservedSlot(typeObj, SLOT_TYPECODE, Int32Value(type));</span>
<span class="lineNum">    4433 </span><span class="lineCov">         72 :   if (ffiType)</span>
<span class="lineNum">    4434 </span><span class="lineCov">         68 :     JS_SetReservedSlot(typeObj, SLOT_FFITYPE, PrivateValue(ffiType));</span>
<span class="lineNum">    4435 </span><span class="lineCov">         72 :   if (name)</span>
<span class="lineNum">    4436 </span><span class="lineCov">         66 :     JS_SetReservedSlot(typeObj, SLOT_NAME, StringValue(name));</span>
<span class="lineNum">    4437 </span><span class="lineCov">         72 :   JS_SetReservedSlot(typeObj, SLOT_SIZE, size);</span>
<span class="lineNum">    4438 </span><span class="lineCov">         72 :   JS_SetReservedSlot(typeObj, SLOT_ALIGN, align);</span>
<span class="lineNum">    4439 </span>            : 
<span class="lineNum">    4440 </span><span class="lineCov">         72 :   if (dataProto) {</span>
<span class="lineNum">    4441 </span>            :     // Set up the 'prototype' and 'prototype.constructor' properties.
<span class="lineNum">    4442 </span><span class="lineCov">        136 :     RootedObject prototype(cx, JS_NewObjectWithGivenProto(cx, &amp;sCDataProtoClass, dataProto));</span>
<span class="lineNum">    4443 </span><span class="lineCov">         68 :     if (!prototype)</span>
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    4445 </span>            : 
<span class="lineNum">    4446 </span><span class="lineCov">         68 :     if (!JS_DefineProperty(cx, prototype, &quot;constructor&quot;, typeObj,</span>
<span class="lineNum">    4447 </span>            :                            JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    4448 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span>            :     // Set the 'prototype' object.
<span class="lineNum">    4451 </span>            :     //if (!JS_FreezeObject(cx, prototype)) // XXX fixme - see bug 541212!
<span class="lineNum">    4452 </span>            :     //  return nullptr;
<span class="lineNum">    4453 </span><span class="lineCov">         68 :     JS_SetReservedSlot(typeObj, SLOT_PROTO, ObjectValue(*prototype));</span>
<span class="lineNum">    4454 </span>            :   }
<span class="lineNum">    4455 </span>            : 
<span class="lineNum">    4456 </span><span class="lineCov">         72 :   if (!JS_FreezeObject(cx, typeObj))</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4458 </span>            : 
<span class="lineNum">    4459 </span>            :   // Assert a sanity check on size and alignment: size % alignment should always
<span class="lineNum">    4460 </span>            :   // be zero.
<span class="lineNum">    4461 </span><span class="lineCov">         72 :   MOZ_ASSERT_IF(IsSizeDefined(typeObj),</span>
<span class="lineNum">    4462 </span>            :                 GetSize(typeObj) % GetAlignment(typeObj) == 0);
<span class="lineNum">    4463 </span>            : 
<span class="lineNum">    4464 </span><span class="lineCov">         72 :   return typeObj;</span>
<span class="lineNum">    4465 </span>            : }
<a name="4466"><span class="lineNum">    4466 </span>            : </a>
<span class="lineNum">    4467 </span>            : JSObject*
<span class="lineNum">    4468 </span><span class="lineCov">         62 : CType::DefineBuiltin(JSContext* cx,</span>
<span class="lineNum">    4469 </span>            :                      HandleObject ctypesObj,
<span class="lineNum">    4470 </span>            :                      const char* propName,
<span class="lineNum">    4471 </span>            :                      JSObject* typeProto_,
<span class="lineNum">    4472 </span>            :                      JSObject* dataProto_,
<span class="lineNum">    4473 </span>            :                      const char* name,
<span class="lineNum">    4474 </span>            :                      TypeCode type,
<span class="lineNum">    4475 </span>            :                      HandleValue size,
<span class="lineNum">    4476 </span>            :                      HandleValue align,
<span class="lineNum">    4477 </span>            :                      ffi_type* ffiType)
<span class="lineNum">    4478 </span>            : {
<span class="lineNum">    4479 </span><span class="lineCov">        124 :   RootedObject typeProto(cx, typeProto_);</span>
<span class="lineNum">    4480 </span><span class="lineCov">        124 :   RootedObject dataProto(cx, dataProto_);</span>
<span class="lineNum">    4481 </span>            : 
<span class="lineNum">    4482 </span><span class="lineCov">        124 :   RootedString nameStr(cx, JS_NewStringCopyZ(cx, name));</span>
<span class="lineNum">    4483 </span><span class="lineCov">         62 :   if (!nameStr)</span>
<span class="lineNum">    4484 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4485 </span>            : 
<span class="lineNum">    4486 </span>            :   // Create a new CType object with the common properties and slots.
<span class="lineNum">    4487 </span><span class="lineCov">        124 :   RootedObject typeObj(cx, Create(cx, typeProto, dataProto, type, nameStr, size, align, ffiType));</span>
<span class="lineNum">    4488 </span><span class="lineCov">         62 :   if (!typeObj)</span>
<span class="lineNum">    4489 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4490 </span>            : 
<span class="lineNum">    4491 </span>            :   // Define the CType as a 'propName' property on 'ctypesObj'.
<span class="lineNum">    4492 </span><span class="lineCov">         62 :   if (!JS_DefineProperty(cx, ctypesObj, propName, typeObj,</span>
<span class="lineNum">    4493 </span>            :                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    4494 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4495 </span>            : 
<span class="lineNum">    4496 </span><span class="lineCov">         62 :   return typeObj;</span>
<span class="lineNum">    4497 </span>            : }
<a name="4498"><span class="lineNum">    4498 </span>            : </a>
<span class="lineNum">    4499 </span>            : void
<span class="lineNum">    4500 </span><span class="lineNoCov">          0 : CType::Finalize(JSFreeOp* fop, JSObject* obj)</span>
<span class="lineNum">    4501 </span>            : {
<span class="lineNum">    4502 </span>            :   // Make sure our TypeCode slot is legit. If it's not, bail.
<span class="lineNum">    4503 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_TYPECODE);</span>
<span class="lineNum">    4504 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    4505 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4506 </span>            : 
<span class="lineNum">    4507 </span>            :   // The contents of our slots depends on what kind of type we are.
<span class="lineNum">    4508 </span><span class="lineNoCov">          0 :   switch (TypeCode(slot.toInt32())) {</span>
<span class="lineNum">    4509 </span>            :   case TYPE_function: {
<span class="lineNum">    4510 </span>            :     // Free the FunctionInfo.
<span class="lineNum">    4511 </span><span class="lineNoCov">          0 :     slot = JS_GetReservedSlot(obj, SLOT_FNINFO);</span>
<span class="lineNum">    4512 </span><span class="lineNoCov">          0 :     if (!slot.isUndefined())</span>
<span class="lineNum">    4513 </span><span class="lineNoCov">          0 :       FreeOp::get(fop)-&gt;delete_(static_cast&lt;FunctionInfo*&gt;(slot.toPrivate()));</span>
<span class="lineNum">    4514 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4515 </span>            :   }
<span class="lineNum">    4516 </span>            : 
<span class="lineNum">    4517 </span>            :   case TYPE_struct: {
<span class="lineNum">    4518 </span>            :     // Free the FieldInfoHash table.
<span class="lineNum">    4519 </span><span class="lineNoCov">          0 :     slot = JS_GetReservedSlot(obj, SLOT_FIELDINFO);</span>
<span class="lineNum">    4520 </span><span class="lineNoCov">          0 :     if (!slot.isUndefined()) {</span>
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :       void* info = slot.toPrivate();</span>
<span class="lineNum">    4522 </span><span class="lineNoCov">          0 :       FreeOp::get(fop)-&gt;delete_(static_cast&lt;FieldInfoHash*&gt;(info));</span>
<span class="lineNum">    4523 </span>            :     }
<span class="lineNum">    4524 </span>            :   }
<span class="lineNum">    4525 </span>            : 
<span class="lineNum">    4526 </span>            :     MOZ_FALLTHROUGH;
<span class="lineNum">    4527 </span>            : 
<span class="lineNum">    4528 </span>            :   case TYPE_array: {
<span class="lineNum">    4529 </span>            :     // Free the ffi_type info.
<span class="lineNum">    4530 </span><span class="lineNoCov">          0 :     slot = JS_GetReservedSlot(obj, SLOT_FFITYPE);</span>
<span class="lineNum">    4531 </span><span class="lineNoCov">          0 :     if (!slot.isUndefined()) {</span>
<span class="lineNum">    4532 </span><span class="lineNoCov">          0 :       ffi_type* ffiType = static_cast&lt;ffi_type*&gt;(slot.toPrivate());</span>
<span class="lineNum">    4533 </span><span class="lineNoCov">          0 :       FreeOp::get(fop)-&gt;free_(ffiType-&gt;elements);</span>
<span class="lineNum">    4534 </span><span class="lineNoCov">          0 :       FreeOp::get(fop)-&gt;delete_(ffiType);</span>
<span class="lineNum">    4535 </span>            :     }
<span class="lineNum">    4536 </span>            : 
<span class="lineNum">    4537 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4538 </span>            :   }
<span class="lineNum">    4539 </span>            :   default:
<span class="lineNum">    4540 </span>            :     // Nothing to do here.
<span class="lineNum">    4541 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4542 </span>            :   }
<span class="lineNum">    4543 </span>            : }
<a name="4544"><span class="lineNum">    4544 </span>            : </a>
<span class="lineNum">    4545 </span>            : void
<span class="lineNum">    4546 </span><span class="lineNoCov">          0 : CType::Trace(JSTracer* trc, JSObject* obj)</span>
<span class="lineNum">    4547 </span>            : {
<span class="lineNum">    4548 </span>            :   // Make sure our TypeCode slot is legit. If it's not, bail.
<span class="lineNum">    4549 </span><span class="lineNoCov">          0 :   Value slot = obj-&gt;as&lt;NativeObject&gt;().getSlot(SLOT_TYPECODE);</span>
<span class="lineNum">    4550 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    4551 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span>            :   // The contents of our slots depends on what kind of type we are.
<span class="lineNum">    4554 </span><span class="lineNoCov">          0 :   switch (TypeCode(slot.toInt32())) {</span>
<span class="lineNum">    4555 </span>            :   case TYPE_struct: {
<span class="lineNum">    4556 </span><span class="lineNoCov">          0 :     slot = obj-&gt;as&lt;NativeObject&gt;().getReservedSlot(SLOT_FIELDINFO);</span>
<span class="lineNum">    4557 </span><span class="lineNoCov">          0 :     if (slot.isUndefined())</span>
<span class="lineNum">    4558 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4559 </span>            : 
<span class="lineNum">    4560 </span><span class="lineNoCov">          0 :     FieldInfoHash* fields = static_cast&lt;FieldInfoHash*&gt;(slot.toPrivate());</span>
<span class="lineNum">    4561 </span><span class="lineNoCov">          0 :     fields-&gt;trace(trc);</span>
<span class="lineNum">    4562 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4563 </span>            :   }
<span class="lineNum">    4564 </span>            :   case TYPE_function: {
<span class="lineNum">    4565 </span>            :     // Check if we have a FunctionInfo.
<span class="lineNum">    4566 </span><span class="lineNoCov">          0 :     slot = obj-&gt;as&lt;NativeObject&gt;().getReservedSlot(SLOT_FNINFO);</span>
<span class="lineNum">    4567 </span><span class="lineNoCov">          0 :     if (slot.isUndefined())</span>
<span class="lineNum">    4568 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4569 </span>            : 
<span class="lineNum">    4570 </span><span class="lineNoCov">          0 :     FunctionInfo* fninfo = static_cast&lt;FunctionInfo*&gt;(slot.toPrivate());</span>
<span class="lineNum">    4571 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(fninfo);</span>
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span>            :     // Identify our objects to the tracer.
<span class="lineNum">    4574 </span><span class="lineNoCov">          0 :     JS::TraceEdge(trc, &amp;fninfo-&gt;mABI, &quot;abi&quot;);</span>
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 :     JS::TraceEdge(trc, &amp;fninfo-&gt;mReturnType, &quot;returnType&quot;);</span>
<span class="lineNum">    4576 </span><span class="lineNoCov">          0 :     for (auto&amp; argType : fninfo-&gt;mArgTypes)</span>
<span class="lineNum">    4577 </span><span class="lineNoCov">          0 :       JS::TraceEdge(trc, &amp;argType, &quot;argType&quot;);</span>
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4580 </span>            :   }
<span class="lineNum">    4581 </span>            :   default:
<span class="lineNum">    4582 </span>            :     // Nothing to do here.
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4584 </span>            :   }
<span class="lineNum">    4585 </span>            : }
<a name="4586"><span class="lineNum">    4586 </span>            : </a>
<span class="lineNum">    4587 </span>            : bool
<span class="lineNum">    4588 </span><span class="lineCov">        307 : CType::IsCType(JSObject* obj)</span>
<span class="lineNum">    4589 </span>            : {
<span class="lineNum">    4590 </span><span class="lineCov">        307 :   return JS_GetClass(obj) == &amp;sCTypeClass;</span>
<span class="lineNum">    4591 </span>            : }
<a name="4592"><span class="lineNum">    4592 </span>            : </a>
<span class="lineNum">    4593 </span>            : bool
<span class="lineNum">    4594 </span><span class="lineCov">         16 : CType::IsCTypeProto(JSObject* obj)</span>
<span class="lineNum">    4595 </span>            : {
<span class="lineNum">    4596 </span><span class="lineCov">         16 :   return JS_GetClass(obj) == &amp;sCTypeProtoClass;</span>
<span class="lineNum">    4597 </span>            : }
<a name="4598"><span class="lineNum">    4598 </span>            : </a>
<span class="lineNum">    4599 </span>            : TypeCode
<span class="lineNum">    4600 </span><span class="lineCov">          6 : CType::GetTypeCode(JSObject* typeObj)</span>
<span class="lineNum">    4601 </span>            : {
<span class="lineNum">    4602 </span><span class="lineCov">          6 :   MOZ_ASSERT(IsCType(typeObj));</span>
<span class="lineNum">    4603 </span>            : 
<span class="lineNum">    4604 </span><span class="lineCov">          6 :   Value result = JS_GetReservedSlot(typeObj, SLOT_TYPECODE);</span>
<span class="lineNum">    4605 </span><span class="lineCov">          6 :   return TypeCode(result.toInt32());</span>
<span class="lineNum">    4606 </span>            : }
<a name="4607"><span class="lineNum">    4607 </span>            : </a>
<span class="lineNum">    4608 </span>            : bool
<span class="lineNum">    4609 </span><span class="lineNoCov">          0 : CType::TypesEqual(JSObject* t1, JSObject* t2)</span>
<span class="lineNum">    4610 </span>            : {
<span class="lineNum">    4611 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsCType(t1) &amp;&amp; IsCType(t2));</span>
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span>            :   // Fast path: check for object equality.
<span class="lineNum">    4614 </span><span class="lineNoCov">          0 :   if (t1 == t2)</span>
<span class="lineNum">    4615 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4616 </span>            : 
<span class="lineNum">    4617 </span>            :   // First, perform shallow comparison.
<span class="lineNum">    4618 </span><span class="lineNoCov">          0 :   TypeCode c1 = GetTypeCode(t1);</span>
<span class="lineNum">    4619 </span><span class="lineNoCov">          0 :   TypeCode c2 = GetTypeCode(t2);</span>
<span class="lineNum">    4620 </span><span class="lineNoCov">          0 :   if (c1 != c2)</span>
<span class="lineNum">    4621 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4622 </span>            : 
<span class="lineNum">    4623 </span>            :   // Determine whether the types require shallow or deep comparison.
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :   switch (c1) {</span>
<span class="lineNum">    4625 </span>            :   case TYPE_pointer: {
<span class="lineNum">    4626 </span>            :     // Compare base types.
<span class="lineNum">    4627 </span><span class="lineNoCov">          0 :     JSObject* b1 = PointerType::GetBaseType(t1);</span>
<span class="lineNum">    4628 </span><span class="lineNoCov">          0 :     JSObject* b2 = PointerType::GetBaseType(t2);</span>
<span class="lineNum">    4629 </span><span class="lineNoCov">          0 :     return TypesEqual(b1, b2);</span>
<span class="lineNum">    4630 </span>            :   }
<span class="lineNum">    4631 </span>            :   case TYPE_function: {
<span class="lineNum">    4632 </span><span class="lineNoCov">          0 :     FunctionInfo* f1 = FunctionType::GetFunctionInfo(t1);</span>
<span class="lineNum">    4633 </span><span class="lineNoCov">          0 :     FunctionInfo* f2 = FunctionType::GetFunctionInfo(t2);</span>
<span class="lineNum">    4634 </span>            : 
<span class="lineNum">    4635 </span>            :     // Compare abi, return type, and argument types.
<span class="lineNum">    4636 </span><span class="lineNoCov">          0 :     if (f1-&gt;mABI != f2-&gt;mABI)</span>
<span class="lineNum">    4637 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span><span class="lineNoCov">          0 :     if (!TypesEqual(f1-&gt;mReturnType, f2-&gt;mReturnType))</span>
<span class="lineNum">    4640 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span><span class="lineNoCov">          0 :     if (f1-&gt;mArgTypes.length() != f2-&gt;mArgTypes.length())</span>
<span class="lineNum">    4643 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4644 </span>            : 
<span class="lineNum">    4645 </span><span class="lineNoCov">          0 :     if (f1-&gt;mIsVariadic != f2-&gt;mIsVariadic)</span>
<span class="lineNum">    4646 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4647 </span>            : 
<span class="lineNum">    4648 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; f1-&gt;mArgTypes.length(); ++i) {</span>
<span class="lineNum">    4649 </span><span class="lineNoCov">          0 :       if (!TypesEqual(f1-&gt;mArgTypes[i], f2-&gt;mArgTypes[i]))</span>
<span class="lineNum">    4650 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    4651 </span>            :     }
<span class="lineNum">    4652 </span>            : 
<span class="lineNum">    4653 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4654 </span>            :   }
<span class="lineNum">    4655 </span>            :   case TYPE_array: {
<span class="lineNum">    4656 </span>            :     // Compare length, then base types.
<span class="lineNum">    4657 </span>            :     // An undefined length array matches other undefined length arrays.
<span class="lineNum">    4658 </span><span class="lineNoCov">          0 :     size_t s1 = 0, s2 = 0;</span>
<span class="lineNum">    4659 </span><span class="lineNoCov">          0 :     bool d1 = ArrayType::GetSafeLength(t1, &amp;s1);</span>
<span class="lineNum">    4660 </span><span class="lineNoCov">          0 :     bool d2 = ArrayType::GetSafeLength(t2, &amp;s2);</span>
<span class="lineNum">    4661 </span><span class="lineNoCov">          0 :     if (d1 != d2 || (d1 &amp;&amp; s1 != s2))</span>
<span class="lineNum">    4662 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4663 </span>            : 
<span class="lineNum">    4664 </span><span class="lineNoCov">          0 :     JSObject* b1 = ArrayType::GetBaseType(t1);</span>
<span class="lineNum">    4665 </span><span class="lineNoCov">          0 :     JSObject* b2 = ArrayType::GetBaseType(t2);</span>
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 :     return TypesEqual(b1, b2);</span>
<span class="lineNum">    4667 </span>            :   }
<span class="lineNum">    4668 </span>            :   case TYPE_struct:
<span class="lineNum">    4669 </span>            :     // Require exact type object equality.
<span class="lineNum">    4670 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4671 </span>            :   default:
<span class="lineNum">    4672 </span>            :     // Shallow comparison is sufficient.
<span class="lineNum">    4673 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4674 </span>            :   }
<span class="lineNum">    4675 </span>            : }
<a name="4676"><span class="lineNum">    4676 </span>            : </a>
<span class="lineNum">    4677 </span>            : bool
<span class="lineNum">    4678 </span><span class="lineNoCov">          0 : CType::GetSafeSize(JSObject* obj, size_t* result)</span>
<span class="lineNum">    4679 </span>            : {
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4681 </span>            : 
<span class="lineNum">    4682 </span><span class="lineNoCov">          0 :   Value size = JS_GetReservedSlot(obj, SLOT_SIZE);</span>
<span class="lineNum">    4683 </span>            : 
<span class="lineNum">    4684 </span>            :   // The &quot;size&quot; property can be an int, a double, or JS::UndefinedValue()
<span class="lineNum">    4685 </span>            :   // (for arrays of undefined length), and must always fit in a size_t.
<span class="lineNum">    4686 </span><span class="lineNoCov">          0 :   if (size.isInt32()) {</span>
<span class="lineNum">    4687 </span><span class="lineNoCov">          0 :     *result = size.toInt32();</span>
<span class="lineNum">    4688 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4689 </span>            :   }
<span class="lineNum">    4690 </span><span class="lineNoCov">          0 :   if (size.isDouble()) {</span>
<span class="lineNum">    4691 </span><span class="lineNoCov">          0 :     *result = Convert&lt;size_t&gt;(size.toDouble());</span>
<span class="lineNum">    4692 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4693 </span>            :   }
<span class="lineNum">    4694 </span>            : 
<span class="lineNum">    4695 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(size.isUndefined());</span>
<span class="lineNum">    4696 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    4697 </span>            : }
<a name="4698"><span class="lineNum">    4698 </span>            : </a>
<span class="lineNum">    4699 </span>            : size_t
<span class="lineNum">    4700 </span><span class="lineCov">         66 : CType::GetSize(JSObject* obj)</span>
<span class="lineNum">    4701 </span>            : {
<span class="lineNum">    4702 </span><span class="lineCov">         66 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4703 </span>            : 
<span class="lineNum">    4704 </span><span class="lineCov">         66 :   Value size = JS_GetReservedSlot(obj, SLOT_SIZE);</span>
<span class="lineNum">    4705 </span>            : 
<span class="lineNum">    4706 </span><span class="lineCov">         66 :   MOZ_ASSERT(!size.isUndefined());</span>
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span>            :   // The &quot;size&quot; property can be an int, a double, or JS::UndefinedValue()
<span class="lineNum">    4709 </span>            :   // (for arrays of undefined length), and must always fit in a size_t.
<span class="lineNum">    4710 </span>            :   // For callers who know it can never be JS::UndefinedValue(), return a size_t
<span class="lineNum">    4711 </span>            :   // directly.
<span class="lineNum">    4712 </span><span class="lineCov">         66 :   if (size.isInt32())</span>
<span class="lineNum">    4713 </span><span class="lineCov">         66 :     return size.toInt32();</span>
<span class="lineNum">    4714 </span><span class="lineNoCov">          0 :   return Convert&lt;size_t&gt;(size.toDouble());</span>
<span class="lineNum">    4715 </span>            : }
<a name="4716"><span class="lineNum">    4716 </span>            : </a>
<span class="lineNum">    4717 </span>            : bool
<span class="lineNum">    4718 </span><span class="lineCov">         72 : CType::IsSizeDefined(JSObject* obj)</span>
<span class="lineNum">    4719 </span>            : {
<span class="lineNum">    4720 </span><span class="lineCov">         72 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4721 </span>            : 
<span class="lineNum">    4722 </span><span class="lineCov">         72 :   Value size = JS_GetReservedSlot(obj, SLOT_SIZE);</span>
<span class="lineNum">    4723 </span>            : 
<span class="lineNum">    4724 </span>            :   // The &quot;size&quot; property can be an int, a double, or JS::UndefinedValue()
<span class="lineNum">    4725 </span>            :   // (for arrays of undefined length), and must always fit in a size_t.
<span class="lineNum">    4726 </span><span class="lineCov">         72 :   MOZ_ASSERT(size.isInt32() || size.isDouble() || size.isUndefined());</span>
<span class="lineNum">    4727 </span><span class="lineCov">         72 :   return !size.isUndefined();</span>
<span class="lineNum">    4728 </span>            : }
<a name="4729"><span class="lineNum">    4729 </span>            : </a>
<span class="lineNum">    4730 </span>            : size_t
<span class="lineNum">    4731 </span><span class="lineCov">         66 : CType::GetAlignment(JSObject* obj)</span>
<span class="lineNum">    4732 </span>            : {
<span class="lineNum">    4733 </span><span class="lineCov">         66 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4734 </span>            : 
<span class="lineNum">    4735 </span><span class="lineCov">         66 :   Value slot = JS_GetReservedSlot(obj, SLOT_ALIGN);</span>
<span class="lineNum">    4736 </span><span class="lineCov">         66 :   return static_cast&lt;size_t&gt;(slot.toInt32());</span>
<span class="lineNum">    4737 </span>            : }
<a name="4738"><span class="lineNum">    4738 </span>            : </a>
<span class="lineNum">    4739 </span>            : ffi_type*
<span class="lineNum">    4740 </span><span class="lineNoCov">          0 : CType::GetFFIType(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    4741 </span>            : {
<span class="lineNum">    4742 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_FFITYPE);</span>
<span class="lineNum">    4745 </span>            : 
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :   if (!slot.isUndefined()) {</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :     return static_cast&lt;ffi_type*&gt;(slot.toPrivate());</span>
<span class="lineNum">    4748 </span>            :   }
<span class="lineNum">    4749 </span>            : 
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :   UniquePtrFFIType result;</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :   switch (CType::GetTypeCode(obj)) {</span>
<span class="lineNum">    4752 </span>            :   case TYPE_array:
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :     result = ArrayType::BuildFFIType(cx, obj);</span>
<span class="lineNum">    4754 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4755 </span>            : 
<span class="lineNum">    4756 </span>            :   case TYPE_struct:
<span class="lineNum">    4757 </span><span class="lineNoCov">          0 :     result = StructType::BuildFFIType(cx, obj);</span>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4759 </span>            : 
<span class="lineNum">    4760 </span>            :   default:
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;simple types must have an ffi_type&quot;);</span>
<span class="lineNum">    4762 </span>            :   }
<span class="lineNum">    4763 </span>            : 
<span class="lineNum">    4764 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    4765 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4766 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(obj, SLOT_FFITYPE, PrivateValue(result.get()));</span>
<span class="lineNum">    4767 </span><span class="lineNoCov">          0 :   return result.release();</span>
<span class="lineNum">    4768 </span>            : }
<a name="4769"><span class="lineNum">    4769 </span>            : </a>
<span class="lineNum">    4770 </span>            : JSString*
<span class="lineNum">    4771 </span><span class="lineNoCov">          0 : CType::GetName(JSContext* cx, HandleObject obj)</span>
<span class="lineNum">    4772 </span>            : {
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4774 </span>            : 
<span class="lineNum">    4775 </span><span class="lineNoCov">          0 :   Value string = JS_GetReservedSlot(obj, SLOT_NAME);</span>
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :   if (!string.isUndefined())</span>
<span class="lineNum">    4777 </span><span class="lineNoCov">          0 :     return string.toString();</span>
<span class="lineNum">    4778 </span>            : 
<span class="lineNum">    4779 </span>            :   // Build the type name lazily.
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :   JSString* name = BuildTypeName(cx, obj);</span>
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 :   if (!name)</span>
<span class="lineNum">    4782 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4783 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(obj, SLOT_NAME, StringValue(name));</span>
<span class="lineNum">    4784 </span><span class="lineNoCov">          0 :   return name;</span>
<span class="lineNum">    4785 </span>            : }
<a name="4786"><span class="lineNum">    4786 </span>            : </a>
<span class="lineNum">    4787 </span>            : JSObject*
<span class="lineNum">    4788 </span><span class="lineCov">          4 : CType::GetProtoFromCtor(JSObject* obj, CTypeProtoSlot slot)</span>
<span class="lineNum">    4789 </span>            : {
<span class="lineNum">    4790 </span>            :   // Get ctypes.{Pointer,Array,Struct}Type.prototype from a reserved slot
<span class="lineNum">    4791 </span>            :   // on the type constructor.
<span class="lineNum">    4792 </span><span class="lineCov">          4 :   Value protoslot = js::GetFunctionNativeReserved(obj, SLOT_FN_CTORPROTO);</span>
<span class="lineNum">    4793 </span><span class="lineCov">          4 :   JSObject* proto = &amp;protoslot.toObject();</span>
<span class="lineNum">    4794 </span><span class="lineCov">          4 :   MOZ_ASSERT(proto);</span>
<span class="lineNum">    4795 </span><span class="lineCov">          4 :   MOZ_ASSERT(CType::IsCTypeProto(proto));</span>
<span class="lineNum">    4796 </span>            : 
<span class="lineNum">    4797 </span>            :   // Get the desired prototype.
<span class="lineNum">    4798 </span><span class="lineCov">          4 :   Value result = JS_GetReservedSlot(proto, slot);</span>
<span class="lineNum">    4799 </span><span class="lineCov">          4 :   return &amp;result.toObject();</span>
<span class="lineNum">    4800 </span>            : }
<a name="4801"><span class="lineNum">    4801 </span>            : </a>
<span class="lineNum">    4802 </span>            : JSObject*
<span class="lineNum">    4803 </span><span class="lineCov">         12 : CType::GetProtoFromType(JSContext* cx, JSObject* objArg, CTypeProtoSlot slot)</span>
<span class="lineNum">    4804 </span>            : {
<span class="lineNum">    4805 </span><span class="lineCov">         12 :   MOZ_ASSERT(IsCType(objArg));</span>
<span class="lineNum">    4806 </span><span class="lineCov">         24 :   RootedObject obj(cx, objArg);</span>
<span class="lineNum">    4807 </span>            : 
<span class="lineNum">    4808 </span>            :   // Get the prototype of the type object.
<span class="lineNum">    4809 </span><span class="lineCov">         24 :   RootedObject proto(cx);</span>
<span class="lineNum">    4810 </span><span class="lineCov">         12 :   if (!JS_GetPrototype(cx, obj, &amp;proto))</span>
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4812 </span><span class="lineCov">         12 :   MOZ_ASSERT(proto);</span>
<span class="lineNum">    4813 </span><span class="lineCov">         12 :   MOZ_ASSERT(CType::IsCTypeProto(proto));</span>
<span class="lineNum">    4814 </span>            : 
<span class="lineNum">    4815 </span>            :   // Get the requested ctypes.{Pointer,Array,Struct,Function}Type.prototype.
<span class="lineNum">    4816 </span><span class="lineCov">         12 :   Value result = JS_GetReservedSlot(proto, slot);</span>
<span class="lineNum">    4817 </span><span class="lineCov">         12 :   MOZ_ASSERT(result.isObject());</span>
<span class="lineNum">    4818 </span><span class="lineCov">         12 :   return &amp;result.toObject();</span>
<span class="lineNum">    4819 </span>            : }
<a name="4820"><span class="lineNum">    4820 </span>            : </a>
<span class="lineNum">    4821 </span>            : bool
<span class="lineNum">    4822 </span><span class="lineNoCov">          0 : CType::IsCTypeOrProto(HandleValue v)</span>
<span class="lineNum">    4823 </span>            : {
<span class="lineNum">    4824 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    4825 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4826 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    4827 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) || CType::IsCTypeProto(obj);</span>
<span class="lineNum">    4828 </span>            : }
<a name="4829"><span class="lineNum">    4829 </span>            : </a>
<span class="lineNum">    4830 </span>            : bool
<span class="lineNum">    4831 </span><span class="lineNoCov">          0 : CType::PrototypeGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    4832 </span>            : {
<span class="lineNum">    4833 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    4834 </span><span class="lineNoCov">          0 :   unsigned slot = CType::IsCTypeProto(obj) ? (unsigned) SLOT_OURDATAPROTO</span>
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :                                            : (unsigned) SLOT_PROTO;</span>
<span class="lineNum">    4836 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, slot));</span>
<span class="lineNum">    4837 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args.rval().isObject() || args.rval().isUndefined());</span>
<span class="lineNum">    4838 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4839 </span>            : }
<a name="4840"><span class="lineNum">    4840 </span>            : </a>
<span class="lineNum">    4841 </span>            : bool
<span class="lineNum">    4842 </span><span class="lineCov">         85 : CType::IsCType(HandleValue v)</span>
<span class="lineNum">    4843 </span>            : {
<span class="lineNum">    4844 </span><span class="lineCov">         85 :   return v.isObject() &amp;&amp; CType::IsCType(&amp;v.toObject());</span>
<span class="lineNum">    4845 </span>            : }
<a name="4846"><span class="lineNum">    4846 </span>            : </a>
<span class="lineNum">    4847 </span>            : bool
<span class="lineNum">    4848 </span><span class="lineNoCov">          0 : CType::NameGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    4849 </span>            : {
<span class="lineNum">    4850 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    4851 </span><span class="lineNoCov">          0 :   JSString* name = CType::GetName(cx, obj);</span>
<span class="lineNum">    4852 </span><span class="lineNoCov">          0 :   if (!name)</span>
<span class="lineNum">    4853 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4854 </span>            : 
<span class="lineNum">    4855 </span><span class="lineNoCov">          0 :   args.rval().setString(name);</span>
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4857 </span>            : }
<a name="4858"><span class="lineNum">    4858 </span>            : </a>
<span class="lineNum">    4859 </span>            : bool
<span class="lineNum">    4860 </span><span class="lineCov">         76 : CType::SizeGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    4861 </span>            : {
<span class="lineNum">    4862 </span><span class="lineCov">        152 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    4863 </span><span class="lineCov">         76 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_SIZE));</span>
<span class="lineNum">    4864 </span><span class="lineCov">         76 :   MOZ_ASSERT(args.rval().isNumber() || args.rval().isUndefined());</span>
<span class="lineNum">    4865 </span><span class="lineCov">        152 :   return true;</span>
<span class="lineNum">    4866 </span>            : }
<a name="4867"><span class="lineNum">    4867 </span>            : </a>
<span class="lineNum">    4868 </span>            : bool
<span class="lineNum">    4869 </span><span class="lineCov">          9 : CType::PtrGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    4870 </span>            : {
<span class="lineNum">    4871 </span><span class="lineCov">         18 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    4872 </span><span class="lineCov">          9 :   JSObject* pointerType = PointerType::CreateInternal(cx, obj);</span>
<span class="lineNum">    4873 </span><span class="lineCov">          9 :   if (!pointerType)</span>
<span class="lineNum">    4874 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4875 </span>            : 
<span class="lineNum">    4876 </span><span class="lineCov">          9 :   args.rval().setObject(*pointerType);</span>
<span class="lineNum">    4877 </span><span class="lineCov">          9 :   return true;</span>
<span class="lineNum">    4878 </span>            : }
<a name="4879"><span class="lineNum">    4879 </span>            : </a>
<span class="lineNum">    4880 </span>            : bool
<span class="lineNum">    4881 </span><span class="lineNoCov">          0 : CType::CreateArray(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    4882 </span>            : {
<span class="lineNum">    4883 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    4884 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :   if (!baseType)</span>
<span class="lineNum">    4886 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4887 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(baseType)) {</span>
<span class="lineNum">    4888 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CType.prototype.array&quot;, args.thisv());</span>
<span class="lineNum">    4889 </span>            :   }
<span class="lineNum">    4890 </span>            : 
<span class="lineNum">    4891 </span>            :   // Construct and return a new ArrayType object.
<span class="lineNum">    4892 </span><span class="lineNoCov">          0 :   if (args.length() &gt; 1) {</span>
<span class="lineNum">    4893 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CType.prototype.array&quot;, &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    4894 </span>            :   }
<span class="lineNum">    4895 </span>            : 
<span class="lineNum">    4896 </span>            :   // Convert the length argument to a size_t.
<span class="lineNum">    4897 </span><span class="lineNoCov">          0 :   size_t length = 0;</span>
<span class="lineNum">    4898 </span><span class="lineNoCov">          0 :   if (args.length() == 1 &amp;&amp; !jsvalToSize(cx, args[0], false, &amp;length)) {</span>
<span class="lineNum">    4899 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;CType.prototype.array&quot;,</span>
<span class="lineNum">    4900 </span><span class="lineNoCov">          0 :                                 &quot;a nonnegative integer&quot;);</span>
<span class="lineNum">    4901 </span>            :   }
<span class="lineNum">    4902 </span>            : 
<span class="lineNum">    4903 </span><span class="lineNoCov">          0 :   JSObject* result = ArrayType::CreateInternal(cx, baseType, length, args.length() == 1);</span>
<span class="lineNum">    4904 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    4905 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4906 </span>            : 
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4909 </span>            : }
<a name="4910"><span class="lineNum">    4910 </span>            : </a>
<span class="lineNum">    4911 </span>            : bool
<span class="lineNum">    4912 </span><span class="lineNoCov">          0 : CType::ToString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    4913 </span>            : {
<span class="lineNum">    4914 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    4915 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    4916 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    4917 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4918 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj) &amp;&amp; !CType::IsCTypeProto(obj)) {</span>
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CType.prototype.toString&quot;,</span>
<span class="lineNum">    4920 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    4921 </span>            :   }
<span class="lineNum">    4922 </span>            : 
<span class="lineNum">    4923 </span>            :   // Create the appropriate string depending on whether we're sCTypeClass or
<span class="lineNum">    4924 </span>            :   // sCTypeProtoClass.
<span class="lineNum">    4925 </span>            :   JSString* result;
<span class="lineNum">    4926 </span><span class="lineNoCov">          0 :   if (CType::IsCType(obj)) {</span>
<span class="lineNum">    4927 </span><span class="lineNoCov">          0 :     AutoString type;</span>
<span class="lineNum">    4928 </span><span class="lineNoCov">          0 :     AppendString(type, &quot;type &quot;);</span>
<span class="lineNum">    4929 </span><span class="lineNoCov">          0 :     AppendString(type, GetName(cx, obj));</span>
<span class="lineNum">    4930 </span><span class="lineNoCov">          0 :     result = NewUCString(cx, type);</span>
<span class="lineNum">    4931 </span>            :   }
<span class="lineNum">    4932 </span>            :   else {
<span class="lineNum">    4933 </span><span class="lineNoCov">          0 :     result = JS_NewStringCopyZ(cx, &quot;[CType proto object]&quot;);</span>
<span class="lineNum">    4934 </span>            :   }
<span class="lineNum">    4935 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    4936 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4937 </span>            : 
<span class="lineNum">    4938 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    4939 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4940 </span>            : }
<a name="4941"><span class="lineNum">    4941 </span>            : </a>
<span class="lineNum">    4942 </span>            : bool
<span class="lineNum">    4943 </span><span class="lineNoCov">          0 : CType::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    4944 </span>            : {
<span class="lineNum">    4945 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    4946 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    4948 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj) &amp;&amp; !CType::IsCTypeProto(obj)) {</span>
<span class="lineNum">    4950 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CType.prototype.toSource&quot;,</span>
<span class="lineNum">    4951 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    4952 </span>            :   }
<span class="lineNum">    4953 </span>            : 
<span class="lineNum">    4954 </span>            :   // Create the appropriate string depending on whether we're sCTypeClass or
<span class="lineNum">    4955 </span>            :   // sCTypeProtoClass.
<span class="lineNum">    4956 </span>            :   JSString* result;
<span class="lineNum">    4957 </span><span class="lineNoCov">          0 :   if (CType::IsCType(obj)) {</span>
<span class="lineNum">    4958 </span><span class="lineNoCov">          0 :     AutoString source;</span>
<span class="lineNum">    4959 </span><span class="lineNoCov">          0 :     BuildTypeSource(cx, obj, false, source);</span>
<span class="lineNum">    4960 </span><span class="lineNoCov">          0 :     result = NewUCString(cx, source);</span>
<span class="lineNum">    4961 </span>            :   } else {
<span class="lineNum">    4962 </span><span class="lineNoCov">          0 :     result = JS_NewStringCopyZ(cx, &quot;[CType proto object]&quot;);</span>
<span class="lineNum">    4963 </span>            :   }
<span class="lineNum">    4964 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    4965 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4966 </span>            : 
<span class="lineNum">    4967 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    4968 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4969 </span>            : }
<a name="4970"><span class="lineNum">    4970 </span>            : </a>
<span class="lineNum">    4971 </span>            : bool
<span class="lineNum">    4972 </span><span class="lineNoCov">          0 : CType::HasInstance(JSContext* cx, HandleObject obj, MutableHandleValue v, bool* bp)</span>
<span class="lineNum">    4973 </span>            : {
<span class="lineNum">    4974 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    4975 </span>            : 
<span class="lineNum">    4976 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_PROTO);</span>
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :   JS::Rooted&lt;JSObject*&gt; prototype(cx, &amp;slot.toObject());</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(prototype);</span>
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CData::IsCDataProto(prototype));</span>
<span class="lineNum">    4980 </span>            : 
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :   *bp = false;</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 :   if (v.isPrimitive())</span>
<span class="lineNum">    4983 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4984 </span>            : 
<span class="lineNum">    4985 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, &amp;v.toObject());</span>
<span class="lineNum">    4986 </span>            :   for (;;) {
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 :     if (!JS_GetPrototype(cx, proto, &amp;proto))</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :     if (!proto)</span>
<span class="lineNum">    4990 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :     if (proto == prototype) {</span>
<span class="lineNum">    4992 </span><span class="lineNoCov">          0 :       *bp = true;</span>
<span class="lineNum">    4993 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4994 </span>            :     }
<span class="lineNum">    4995 </span>            :   }
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4997 </span>            : }
<a name="4998"><span class="lineNum">    4998 </span>            : </a>
<span class="lineNum">    4999 </span>            : static JSObject*
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 : CType::GetGlobalCTypes(JSContext* cx, JSObject* objArg)</span>
<span class="lineNum">    5001 </span>            : {
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(objArg));</span>
<span class="lineNum">    5003 </span>            : 
<span class="lineNum">    5004 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, objArg);</span>
<span class="lineNum">    5005 </span><span class="lineNoCov">          0 :   RootedObject objTypeProto(cx);</span>
<span class="lineNum">    5006 </span><span class="lineNoCov">          0 :   if (!JS_GetPrototype(cx, obj, &amp;objTypeProto))</span>
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(objTypeProto);</span>
<span class="lineNum">    5009 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCTypeProto(objTypeProto));</span>
<span class="lineNum">    5010 </span>            : 
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :   Value valCTypes = JS_GetReservedSlot(objTypeProto, SLOT_CTYPES);</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(valCTypes.isObject());</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :   return &amp;valCTypes.toObject();</span>
<span class="lineNum">    5014 </span>            : }
<span class="lineNum">    5015 </span>            : 
<span class="lineNum">    5016 </span>            : /*******************************************************************************
<span class="lineNum">    5017 </span>            : ** ABI implementation
<span class="lineNum">    5018 </span>            : *******************************************************************************/
<a name="5019"><span class="lineNum">    5019 </span>            : </a>
<span class="lineNum">    5020 </span>            : bool
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 : ABI::IsABI(JSObject* obj)</span>
<span class="lineNum">    5022 </span>            : {
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sCABIClass;</span>
<span class="lineNum">    5024 </span>            : }
<a name="5025"><span class="lineNum">    5025 </span>            : </a>
<span class="lineNum">    5026 </span>            : bool
<span class="lineNum">    5027 </span><span class="lineNoCov">          0 : ABI::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5028 </span>            : {
<span class="lineNum">    5029 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5030 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    5031 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;ABI.prototype.toSource&quot;, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    5032 </span>            :   }
<span class="lineNum">    5033 </span>            : 
<span class="lineNum">    5034 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    5035 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    5036 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5037 </span><span class="lineNoCov">          0 :   if (!ABI::IsABI(obj)) {</span>
<span class="lineNum">    5038 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;ABI.prototype.toSource&quot;,</span>
<span class="lineNum">    5039 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    5040 </span>            :   }
<span class="lineNum">    5041 </span>            : 
<span class="lineNum">    5042 </span>            :   JSString* result;
<span class="lineNum">    5043 </span><span class="lineNoCov">          0 :   switch (GetABICode(obj)) {</span>
<span class="lineNum">    5044 </span>            :     case ABI_DEFAULT:
<span class="lineNum">    5045 </span><span class="lineNoCov">          0 :       result = JS_NewStringCopyZ(cx, &quot;ctypes.default_abi&quot;);</span>
<span class="lineNum">    5046 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5047 </span>            :     case ABI_STDCALL:
<span class="lineNum">    5048 </span><span class="lineNoCov">          0 :       result = JS_NewStringCopyZ(cx, &quot;ctypes.stdcall_abi&quot;);</span>
<span class="lineNum">    5049 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5050 </span>            :     case ABI_THISCALL:
<span class="lineNum">    5051 </span><span class="lineNoCov">          0 :       result = JS_NewStringCopyZ(cx, &quot;ctypes.thiscall_abi&quot;);</span>
<span class="lineNum">    5052 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5053 </span>            :     case ABI_WINAPI:
<span class="lineNum">    5054 </span><span class="lineNoCov">          0 :       result = JS_NewStringCopyZ(cx, &quot;ctypes.winapi_abi&quot;);</span>
<span class="lineNum">    5055 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5056 </span>            :     default:
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 :       JS_ReportErrorASCII(cx, &quot;not a valid ABICode&quot;);</span>
<span class="lineNum">    5058 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5059 </span>            :   }
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5062 </span>            : 
<span class="lineNum">    5063 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    5064 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5065 </span>            : }
<span class="lineNum">    5066 </span>            : 
<span class="lineNum">    5067 </span>            : 
<span class="lineNum">    5068 </span>            : /*******************************************************************************
<span class="lineNum">    5069 </span>            : ** PointerType implementation
<span class="lineNum">    5070 </span>            : *******************************************************************************/
<a name="5071"><span class="lineNum">    5071 </span>            : </a>
<span class="lineNum">    5072 </span>            : bool
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 : PointerType::Create(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5074 </span>            : {
<span class="lineNum">    5075 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5076 </span>            :   // Construct and return a new PointerType object.
<span class="lineNum">    5077 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    5078 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;PointerType&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    5079 </span>            :   }
<span class="lineNum">    5080 </span>            : 
<span class="lineNum">    5081 </span><span class="lineNoCov">          0 :   Value arg = args[0];</span>
<span class="lineNum">    5082 </span><span class="lineNoCov">          0 :   RootedObject obj(cx);</span>
<span class="lineNum">    5083 </span><span class="lineNoCov">          0 :   if (arg.isPrimitive() || !CType::IsCType(obj = &amp;arg.toObject())) {</span>
<span class="lineNum">    5084 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;PointerType&quot;, &quot;a CType&quot;);</span>
<span class="lineNum">    5085 </span>            :   }
<span class="lineNum">    5086 </span>            : 
<span class="lineNum">    5087 </span><span class="lineNoCov">          0 :   JSObject* result = CreateInternal(cx, obj);</span>
<span class="lineNum">    5088 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5089 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5090 </span>            : 
<span class="lineNum">    5091 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5092 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5093 </span>            : }
<a name="5094"><span class="lineNum">    5094 </span>            : </a>
<span class="lineNum">    5095 </span>            : JSObject*
<span class="lineNum">    5096 </span><span class="lineCov">         11 : PointerType::CreateInternal(JSContext* cx, HandleObject baseType)</span>
<span class="lineNum">    5097 </span>            : {
<span class="lineNum">    5098 </span>            :   // check if we have a cached PointerType on our base CType.
<span class="lineNum">    5099 </span><span class="lineCov">         11 :   Value slot = JS_GetReservedSlot(baseType, SLOT_PTR);</span>
<span class="lineNum">    5100 </span><span class="lineCov">         11 :   if (!slot.isUndefined())</span>
<span class="lineNum">    5101 </span><span class="lineCov">          5 :     return &amp;slot.toObject();</span>
<span class="lineNum">    5102 </span>            : 
<span class="lineNum">    5103 </span>            :   // Get ctypes.PointerType.prototype and the common prototype for CData objects
<span class="lineNum">    5104 </span>            :   // of this type, or ctypes.FunctionType.prototype for function pointers.
<span class="lineNum">    5105 </span><span class="lineCov">          6 :   CTypeProtoSlot slotId = CType::GetTypeCode(baseType) == TYPE_function ?</span>
<span class="lineNum">    5106 </span><span class="lineCov">          6 :     SLOT_FUNCTIONDATAPROTO : SLOT_POINTERDATAPROTO;</span>
<span class="lineNum">    5107 </span><span class="lineCov">         12 :   RootedObject dataProto(cx, CType::GetProtoFromType(cx, baseType, slotId));</span>
<span class="lineNum">    5108 </span><span class="lineCov">          6 :   if (!dataProto)</span>
<span class="lineNum">    5109 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5110 </span><span class="lineCov">         12 :   RootedObject typeProto(cx, CType::GetProtoFromType(cx, baseType, SLOT_POINTERPROTO));</span>
<span class="lineNum">    5111 </span><span class="lineCov">          6 :   if (!typeProto)</span>
<span class="lineNum">    5112 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5113 </span>            : 
<span class="lineNum">    5114 </span>            :   // Create a new CType object with the common properties and slots.
<span class="lineNum">    5115 </span><span class="lineCov">         12 :   RootedValue sizeVal(cx, Int32Value(sizeof(void*)));</span>
<span class="lineNum">    5116 </span><span class="lineCov">         12 :   RootedValue alignVal(cx, Int32Value(ffi_type_pointer.alignment));</span>
<span class="lineNum">    5117 </span><span class="lineCov">         12 :   JSObject* typeObj = CType::Create(cx, typeProto, dataProto, TYPE_pointer,</span>
<span class="lineNum">    5118 </span>            :                                     nullptr, sizeVal, alignVal,
<span class="lineNum">    5119 </span><span class="lineCov">          6 :                                     &amp;ffi_type_pointer);</span>
<span class="lineNum">    5120 </span><span class="lineCov">          6 :   if (!typeObj)</span>
<span class="lineNum">    5121 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5122 </span>            : 
<span class="lineNum">    5123 </span>            :   // Set the target type. (This will be 'null' for an opaque pointer type.)
<span class="lineNum">    5124 </span><span class="lineCov">          6 :   JS_SetReservedSlot(typeObj, SLOT_TARGET_T, ObjectValue(*baseType));</span>
<span class="lineNum">    5125 </span>            : 
<span class="lineNum">    5126 </span>            :   // Finally, cache our newly-created PointerType on our pointed-to CType.
<span class="lineNum">    5127 </span><span class="lineCov">          6 :   JS_SetReservedSlot(baseType, SLOT_PTR, ObjectValue(*typeObj));</span>
<span class="lineNum">    5128 </span>            : 
<span class="lineNum">    5129 </span><span class="lineCov">          6 :   return typeObj;</span>
<span class="lineNum">    5130 </span>            : }
<a name="5131"><span class="lineNum">    5131 </span>            : </a>
<span class="lineNum">    5132 </span>            : bool
<span class="lineNum">    5133 </span><span class="lineNoCov">          0 : PointerType::ConstructData(JSContext* cx,</span>
<span class="lineNum">    5134 </span>            :                            HandleObject obj,
<span class="lineNum">    5135 </span>            :                            const CallArgs&amp; args)
<span class="lineNum">    5136 </span>            : {
<span class="lineNum">    5137 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_pointer) {</span>
<span class="lineNum">    5138 </span><span class="lineNoCov">          0 :     return IncompatibleCallee(cx, &quot;PointerType constructor&quot;, obj);</span>
<span class="lineNum">    5139 </span>            :   }
<span class="lineNum">    5140 </span>            : 
<span class="lineNum">    5141 </span><span class="lineNoCov">          0 :   if (args.length() &gt; 3) {</span>
<span class="lineNum">    5142 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;PointerType constructor&quot;, &quot;0, 1, 2, or 3&quot;,</span>
<span class="lineNum">    5143 </span><span class="lineNoCov">          0 :                                &quot;s&quot;);</span>
<span class="lineNum">    5144 </span>            :   }
<span class="lineNum">    5145 </span>            : 
<span class="lineNum">    5146 </span><span class="lineNoCov">          0 :   RootedObject result(cx, CData::Create(cx, obj, nullptr, nullptr, true));</span>
<span class="lineNum">    5147 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5148 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5149 </span>            : 
<span class="lineNum">    5150 </span>            :   // Set return value early, must not observe *vp after
<span class="lineNum">    5151 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5152 </span>            : 
<span class="lineNum">    5153 </span>            :   // There are 3 things that we might be creating here:
<span class="lineNum">    5154 </span>            :   // 1 - A null pointer (no arguments)
<span class="lineNum">    5155 </span>            :   // 2 - An initialized pointer (1 argument)
<span class="lineNum">    5156 </span>            :   // 3 - A closure (1-3 arguments)
<span class="lineNum">    5157 </span>            :   //
<span class="lineNum">    5158 </span>            :   // The API doesn't give us a perfect way to distinguish 2 and 3, but the
<span class="lineNum">    5159 </span>            :   // heuristics we use should be fine.
<span class="lineNum">    5160 </span>            : 
<span class="lineNum">    5161 </span>            :   //
<span class="lineNum">    5162 </span>            :   // Case 1 - Null pointer
<span class="lineNum">    5163 </span>            :   //
<span class="lineNum">    5164 </span><span class="lineNoCov">          0 :   if (args.length() == 0)</span>
<span class="lineNum">    5165 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5166 </span>            : 
<span class="lineNum">    5167 </span>            :   // Analyze the arguments a bit to decide what to do next.
<span class="lineNum">    5168 </span><span class="lineNoCov">          0 :   RootedObject baseObj(cx, PointerType::GetBaseType(obj));</span>
<span class="lineNum">    5169 </span><span class="lineNoCov">          0 :   bool looksLikeClosure = CType::GetTypeCode(baseObj) == TYPE_function &amp;&amp;</span>
<span class="lineNum">    5170 </span><span class="lineNoCov">          0 :                           args[0].isObject() &amp;&amp; JS::IsCallable(&amp;args[0].toObject());</span>
<span class="lineNum">    5171 </span>            : 
<span class="lineNum">    5172 </span>            :   //
<span class="lineNum">    5173 </span>            :   // Case 2 - Initialized pointer
<span class="lineNum">    5174 </span>            :   //
<span class="lineNum">    5175 </span><span class="lineNoCov">          0 :   if (!looksLikeClosure) {</span>
<span class="lineNum">    5176 </span><span class="lineNoCov">          0 :     if (args.length() != 1) {</span>
<span class="lineNum">    5177 </span><span class="lineNoCov">          0 :       return ArgumentLengthError(cx, &quot;FunctionType constructor&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    5178 </span>            :     }
<span class="lineNum">    5179 </span><span class="lineNoCov">          0 :     return ExplicitConvert(cx, args[0], obj, CData::GetData(result),</span>
<span class="lineNum">    5180 </span><span class="lineNoCov">          0 :                            ConversionType::Construct);</span>
<span class="lineNum">    5181 </span>            :   }
<span class="lineNum">    5182 </span>            : 
<span class="lineNum">    5183 </span>            :   //
<span class="lineNum">    5184 </span>            :   // Case 3 - Closure
<span class="lineNum">    5185 </span>            :   //
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span>            :   // The second argument is an optional 'this' parameter with which to invoke
<span class="lineNum">    5188 </span>            :   // the given js function. Callers may leave this blank, or pass null if they
<span class="lineNum">    5189 </span>            :   // wish to pass the third argument.
<span class="lineNum">    5190 </span><span class="lineNoCov">          0 :   RootedObject thisObj(cx, nullptr);</span>
<span class="lineNum">    5191 </span><span class="lineNoCov">          0 :   if (args.length() &gt;= 2) {</span>
<span class="lineNum">    5192 </span><span class="lineNoCov">          0 :     if (args[1].isNull()) {</span>
<span class="lineNum">    5193 </span><span class="lineNoCov">          0 :       thisObj = nullptr;</span>
<span class="lineNum">    5194 </span><span class="lineNoCov">          0 :     } else if (args[1].isObject()) {</span>
<span class="lineNum">    5195 </span><span class="lineNoCov">          0 :       thisObj = &amp;args[1].toObject();</span>
<span class="lineNum">    5196 </span><span class="lineNoCov">          0 :     } else if (!JS_ValueToObject(cx, args[1], &amp;thisObj)) {</span>
<span class="lineNum">    5197 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5198 </span>            :     }
<span class="lineNum">    5199 </span>            :   }
<span class="lineNum">    5200 </span>            : 
<span class="lineNum">    5201 </span>            :   // The third argument is an optional error sentinel that js-ctypes will return
<span class="lineNum">    5202 </span>            :   // if an exception is raised while executing the closure. The type must match
<span class="lineNum">    5203 </span>            :   // the return type of the callback.
<span class="lineNum">    5204 </span><span class="lineNoCov">          0 :   RootedValue errVal(cx);</span>
<span class="lineNum">    5205 </span><span class="lineNoCov">          0 :   if (args.length() == 3)</span>
<span class="lineNum">    5206 </span><span class="lineNoCov">          0 :     errVal = args[2];</span>
<span class="lineNum">    5207 </span>            : 
<span class="lineNum">    5208 </span><span class="lineNoCov">          0 :   RootedObject fnObj(cx, &amp;args[0].toObject());</span>
<span class="lineNum">    5209 </span><span class="lineNoCov">          0 :   return FunctionType::ConstructData(cx, baseObj, result, fnObj, thisObj, errVal);</span>
<span class="lineNum">    5210 </span>            : }
<a name="5211"><span class="lineNum">    5211 </span>            : </a>
<span class="lineNum">    5212 </span>            : JSObject*
<span class="lineNum">    5213 </span><span class="lineNoCov">          0 : PointerType::GetBaseType(JSObject* obj)</span>
<span class="lineNum">    5214 </span>            : {
<span class="lineNum">    5215 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_pointer);</span>
<span class="lineNum">    5216 </span>            : 
<span class="lineNum">    5217 </span><span class="lineNoCov">          0 :   Value type = JS_GetReservedSlot(obj, SLOT_TARGET_T);</span>
<span class="lineNum">    5218 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!type.isNull());</span>
<span class="lineNum">    5219 </span><span class="lineNoCov">          0 :   return &amp;type.toObject();</span>
<span class="lineNum">    5220 </span>            : }
<a name="5221"><span class="lineNum">    5221 </span>            : </a>
<span class="lineNum">    5222 </span>            : bool
<span class="lineNum">    5223 </span><span class="lineNoCov">          0 : PointerType::IsPointerType(HandleValue v)</span>
<span class="lineNum">    5224 </span>            : {
<span class="lineNum">    5225 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    5226 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5227 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    5228 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) &amp;&amp; CType::GetTypeCode(obj) == TYPE_pointer;</span>
<span class="lineNum">    5229 </span>            : }
<a name="5230"><span class="lineNum">    5230 </span>            : </a>
<span class="lineNum">    5231 </span>            : bool
<span class="lineNum">    5232 </span><span class="lineNoCov">          0 : PointerType::IsPointer(HandleValue v)</span>
<span class="lineNum">    5233 </span>            : {
<span class="lineNum">    5234 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    5235 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5236 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    5237 </span><span class="lineNoCov">          0 :   return CData::IsCData(obj) &amp;&amp; CType::GetTypeCode(CData::GetCType(obj)) == TYPE_pointer;</span>
<span class="lineNum">    5238 </span>            : }
<a name="5239"><span class="lineNum">    5239 </span>            : </a>
<span class="lineNum">    5240 </span>            : bool
<span class="lineNum">    5241 </span><span class="lineNoCov">          0 : PointerType::TargetTypeGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    5242 </span>            : {
<span class="lineNum">    5243 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    5244 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_TARGET_T));</span>
<span class="lineNum">    5245 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args.rval().isObject());</span>
<span class="lineNum">    5246 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5247 </span>            : }
<a name="5248"><span class="lineNum">    5248 </span>            : </a>
<span class="lineNum">    5249 </span>            : bool
<span class="lineNum">    5250 </span><span class="lineNoCov">          0 : PointerType::IsNull(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5251 </span>            : {
<span class="lineNum">    5252 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5253 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    5254 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    5255 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5256 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    5257 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;PointerType.prototype.isNull&quot;,</span>
<span class="lineNum">    5258 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    5259 </span>            :   }
<span class="lineNum">    5260 </span>            : 
<span class="lineNum">    5261 </span>            :   // Get pointer type and base type.
<span class="lineNum">    5262 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    5263 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_pointer) {</span>
<span class="lineNum">    5264 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;PointerType.prototype.isNull&quot;,</span>
<span class="lineNum">    5265 </span><span class="lineNoCov">          0 :                                 &quot;non-PointerType CData&quot;, args.thisv());</span>
<span class="lineNum">    5266 </span>            :   }
<span class="lineNum">    5267 </span>            : 
<span class="lineNum">    5268 </span><span class="lineNoCov">          0 :   void* data = *static_cast&lt;void**&gt;(CData::GetData(obj));</span>
<span class="lineNum">    5269 </span><span class="lineNoCov">          0 :   args.rval().setBoolean(data == nullptr);</span>
<span class="lineNum">    5270 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5271 </span>            : }
<a name="5272"><span class="lineNum">    5272 </span>            : </a>
<span class="lineNum">    5273 </span>            : bool
<span class="lineNum">    5274 </span><span class="lineNoCov">          0 : PointerType::OffsetBy(JSContext* cx, const CallArgs&amp; args, int offset)</span>
<span class="lineNum">    5275 </span>            : {
<span class="lineNum">    5276 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, args.base()));</span>
<span class="lineNum">    5277 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    5278 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5279 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    5280 </span><span class="lineNoCov">          0 :     if (offset == 1) {</span>
<span class="lineNum">    5281 </span><span class="lineNoCov">          0 :       return IncompatibleThisProto(cx, &quot;PointerType.prototype.increment&quot;,</span>
<span class="lineNum">    5282 </span><span class="lineNoCov">          0 :                                    args.thisv());</span>
<span class="lineNum">    5283 </span>            :     }
<span class="lineNum">    5284 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;PointerType.prototype.decrement&quot;,</span>
<span class="lineNum">    5285 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    5286 </span>            :   }
<span class="lineNum">    5287 </span>            : 
<span class="lineNum">    5288 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    5289 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_pointer) {</span>
<span class="lineNum">    5290 </span><span class="lineNoCov">          0 :     if (offset == 1) {</span>
<span class="lineNum">    5291 </span><span class="lineNoCov">          0 :       return IncompatibleThisType(cx, &quot;PointerType.prototype.increment&quot;,</span>
<span class="lineNum">    5292 </span><span class="lineNoCov">          0 :                                   &quot;non-PointerType CData&quot;, args.thisv());</span>
<span class="lineNum">    5293 </span>            :     }
<span class="lineNum">    5294 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;PointerType.prototype.decrement&quot;,</span>
<span class="lineNum">    5295 </span><span class="lineNoCov">          0 :                                 &quot;non-PointerType CData&quot;, args.thisv());</span>
<span class="lineNum">    5296 </span>            :   }
<span class="lineNum">    5297 </span>            : 
<span class="lineNum">    5298 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, PointerType::GetBaseType(typeObj));</span>
<span class="lineNum">    5299 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(baseType)) {</span>
<span class="lineNum">    5300 </span><span class="lineNoCov">          0 :     return UndefinedSizePointerError(cx, &quot;modify&quot;, obj);</span>
<span class="lineNum">    5301 </span>            :   }
<span class="lineNum">    5302 </span>            : 
<span class="lineNum">    5303 </span><span class="lineNoCov">          0 :   size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    5304 </span><span class="lineNoCov">          0 :   char* data = static_cast&lt;char*&gt;(*static_cast&lt;void**&gt;(CData::GetData(obj)));</span>
<span class="lineNum">    5305 </span><span class="lineNoCov">          0 :   void* address = data + offset * elementSize;</span>
<span class="lineNum">    5306 </span>            : 
<span class="lineNum">    5307 </span>            :   // Create a PointerType CData object containing the new address.
<span class="lineNum">    5308 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, typeObj, nullptr, &amp;address, true);</span>
<span class="lineNum">    5309 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5310 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5311 </span>            : 
<span class="lineNum">    5312 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5313 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5314 </span>            : }
<a name="5315"><span class="lineNum">    5315 </span>            : </a>
<span class="lineNum">    5316 </span>            : bool
<span class="lineNum">    5317 </span><span class="lineNoCov">          0 : PointerType::Increment(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5318 </span>            : {
<span class="lineNum">    5319 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5320 </span><span class="lineNoCov">          0 :   return OffsetBy(cx, args, 1);</span>
<span class="lineNum">    5321 </span>            : }
<a name="5322"><span class="lineNum">    5322 </span>            : </a>
<span class="lineNum">    5323 </span>            : bool
<span class="lineNum">    5324 </span><span class="lineNoCov">          0 : PointerType::Decrement(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5325 </span>            : {
<span class="lineNum">    5326 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5327 </span><span class="lineNoCov">          0 :   return OffsetBy(cx, args, -1);</span>
<span class="lineNum">    5328 </span>            : }
<a name="5329"><span class="lineNum">    5329 </span>            : </a>
<span class="lineNum">    5330 </span>            : bool
<span class="lineNum">    5331 </span><span class="lineNoCov">          0 : PointerType::ContentsGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    5332 </span>            : {
<span class="lineNum">    5333 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    5334 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, GetBaseType(CData::GetCType(obj)));</span>
<span class="lineNum">    5335 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(baseType)) {</span>
<span class="lineNum">    5336 </span><span class="lineNoCov">          0 :     return UndefinedSizePointerError(cx, &quot;get contents of&quot;, obj);</span>
<span class="lineNum">    5337 </span>            :   }
<span class="lineNum">    5338 </span>            : 
<span class="lineNum">    5339 </span><span class="lineNoCov">          0 :   void* data = *static_cast&lt;void**&gt;(CData::GetData(obj));</span>
<span class="lineNum">    5340 </span><span class="lineNoCov">          0 :   if (data == nullptr) {</span>
<span class="lineNum">    5341 </span><span class="lineNoCov">          0 :     return NullPointerError(cx, &quot;read contents of&quot;, obj);</span>
<span class="lineNum">    5342 </span>            :   }
<span class="lineNum">    5343 </span>            : 
<span class="lineNum">    5344 </span><span class="lineNoCov">          0 :   RootedValue result(cx);</span>
<span class="lineNum">    5345 </span><span class="lineNoCov">          0 :   if (!ConvertToJS(cx, baseType, nullptr, data, false, false, &amp;result))</span>
<span class="lineNum">    5346 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5347 </span>            : 
<span class="lineNum">    5348 </span><span class="lineNoCov">          0 :   args.rval().set(result);</span>
<span class="lineNum">    5349 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5350 </span>            : }
<a name="5351"><span class="lineNum">    5351 </span>            : </a>
<span class="lineNum">    5352 </span>            : bool
<span class="lineNum">    5353 </span><span class="lineNoCov">          0 : PointerType::ContentsSetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    5354 </span>            : {
<span class="lineNum">    5355 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    5356 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, GetBaseType(CData::GetCType(obj)));</span>
<span class="lineNum">    5357 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(baseType)) {</span>
<span class="lineNum">    5358 </span><span class="lineNoCov">          0 :     return UndefinedSizePointerError(cx, &quot;set contents of&quot;, obj);</span>
<span class="lineNum">    5359 </span>            :   }
<span class="lineNum">    5360 </span>            : 
<span class="lineNum">    5361 </span><span class="lineNoCov">          0 :   void* data = *static_cast&lt;void**&gt;(CData::GetData(obj));</span>
<span class="lineNum">    5362 </span><span class="lineNoCov">          0 :   if (data == nullptr) {</span>
<span class="lineNum">    5363 </span><span class="lineNoCov">          0 :     return NullPointerError(cx, &quot;write contents to&quot;, obj);</span>
<span class="lineNum">    5364 </span>            :   }
<span class="lineNum">    5365 </span>            : 
<span class="lineNum">    5366 </span><span class="lineNoCov">          0 :   args.rval().setUndefined();</span>
<span class="lineNum">    5367 </span><span class="lineNoCov">          0 :   return ImplicitConvert(cx, args.get(0), baseType, data,</span>
<span class="lineNum">    5368 </span><span class="lineNoCov">          0 :                          ConversionType::Setter, nullptr);</span>
<span class="lineNum">    5369 </span>            : }
<span class="lineNum">    5370 </span>            : 
<span class="lineNum">    5371 </span>            : /*******************************************************************************
<span class="lineNum">    5372 </span>            : ** ArrayType implementation
<span class="lineNum">    5373 </span>            : *******************************************************************************/
<a name="5374"><span class="lineNum">    5374 </span>            : </a>
<span class="lineNum">    5375 </span>            : bool
<span class="lineNum">    5376 </span><span class="lineNoCov">          0 : ArrayType::Create(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5377 </span>            : {
<span class="lineNum">    5378 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5379 </span>            :   // Construct and return a new ArrayType object.
<span class="lineNum">    5380 </span><span class="lineNoCov">          0 :   if (args.length() &lt; 1 || args.length() &gt; 2) {</span>
<span class="lineNum">    5381 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;ArrayType&quot;, &quot;one or two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    5382 </span>            :   }
<span class="lineNum">    5383 </span>            : 
<span class="lineNum">    5384 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !CType::IsCType(&amp;args[0].toObject())) {</span>
<span class="lineNum">    5385 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;first &quot;, &quot;ArrayType&quot;, &quot;a CType&quot;);</span>
<span class="lineNum">    5386 </span>            :   }
<span class="lineNum">    5387 </span>            : 
<span class="lineNum">    5388 </span>            :   // Convert the length argument to a size_t.
<span class="lineNum">    5389 </span><span class="lineNoCov">          0 :   size_t length = 0;</span>
<span class="lineNum">    5390 </span><span class="lineNoCov">          0 :   if (args.length() == 2 &amp;&amp; !jsvalToSize(cx, args[1], false, &amp;length)) {</span>
<span class="lineNum">    5391 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;second &quot;, &quot;ArrayType&quot;,</span>
<span class="lineNum">    5392 </span><span class="lineNoCov">          0 :                                 &quot;a nonnegative integer&quot;);</span>
<span class="lineNum">    5393 </span>            :   }
<span class="lineNum">    5394 </span>            : 
<span class="lineNum">    5395 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, &amp;args[0].toObject());</span>
<span class="lineNum">    5396 </span><span class="lineNoCov">          0 :   JSObject* result = CreateInternal(cx, baseType, length, args.length() == 2);</span>
<span class="lineNum">    5397 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5398 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5399 </span>            : 
<span class="lineNum">    5400 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5401 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5402 </span>            : }
<a name="5403"><span class="lineNum">    5403 </span>            : </a>
<span class="lineNum">    5404 </span>            : JSObject*
<span class="lineNum">    5405 </span><span class="lineNoCov">          0 : ArrayType::CreateInternal(JSContext* cx,</span>
<span class="lineNum">    5406 </span>            :                           HandleObject baseType,
<span class="lineNum">    5407 </span>            :                           size_t length,
<span class="lineNum">    5408 </span>            :                           bool lengthDefined)
<span class="lineNum">    5409 </span>            : {
<span class="lineNum">    5410 </span>            :   // Get ctypes.ArrayType.prototype and the common prototype for CData objects
<span class="lineNum">    5411 </span>            :   // of this type, from ctypes.CType.prototype.
<span class="lineNum">    5412 </span><span class="lineNoCov">          0 :   RootedObject typeProto(cx, CType::GetProtoFromType(cx, baseType, SLOT_ARRAYPROTO));</span>
<span class="lineNum">    5413 </span><span class="lineNoCov">          0 :   if (!typeProto)</span>
<span class="lineNum">    5414 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5415 </span><span class="lineNoCov">          0 :   RootedObject dataProto(cx, CType::GetProtoFromType(cx, baseType, SLOT_ARRAYDATAPROTO));</span>
<span class="lineNum">    5416 </span><span class="lineNoCov">          0 :   if (!dataProto)</span>
<span class="lineNum">    5417 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5418 </span>            : 
<span class="lineNum">    5419 </span>            :   // Determine the size of the array from the base type, if possible.
<span class="lineNum">    5420 </span>            :   // The size of the base type must be defined.
<span class="lineNum">    5421 </span>            :   // If our length is undefined, both our size and length will be undefined.
<span class="lineNum">    5422 </span>            :   size_t baseSize;
<span class="lineNum">    5423 </span><span class="lineNoCov">          0 :   if (!CType::GetSafeSize(baseType, &amp;baseSize)) {</span>
<span class="lineNum">    5424 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;base size must be defined&quot;);</span>
<span class="lineNum">    5425 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5426 </span>            :   }
<span class="lineNum">    5427 </span>            : 
<span class="lineNum">    5428 </span><span class="lineNoCov">          0 :   RootedValue sizeVal(cx);</span>
<span class="lineNum">    5429 </span><span class="lineNoCov">          0 :   RootedValue lengthVal(cx);</span>
<span class="lineNum">    5430 </span><span class="lineNoCov">          0 :   if (lengthDefined) {</span>
<span class="lineNum">    5431 </span>            :     // Check for overflow, and convert to an int or double as required.
<span class="lineNum">    5432 </span><span class="lineNoCov">          0 :     size_t size = length * baseSize;</span>
<span class="lineNum">    5433 </span><span class="lineNoCov">          0 :     if (length &gt; 0 &amp;&amp; size / length != baseSize) {</span>
<span class="lineNum">    5434 </span><span class="lineNoCov">          0 :       SizeOverflow(cx, &quot;array size&quot;, &quot;size_t&quot;);</span>
<span class="lineNum">    5435 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    5436 </span>            :     }
<span class="lineNum">    5437 </span><span class="lineNoCov">          0 :     if (!SizeTojsval(cx, size, &amp;sizeVal)) {</span>
<span class="lineNum">    5438 </span><span class="lineNoCov">          0 :       SizeOverflow(cx, &quot;array size&quot;, &quot;JavaScript number&quot;);</span>
<span class="lineNum">    5439 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    5440 </span>            :     }
<span class="lineNum">    5441 </span><span class="lineNoCov">          0 :     if (!SizeTojsval(cx, length, &amp;lengthVal)) {</span>
<span class="lineNum">    5442 </span><span class="lineNoCov">          0 :       SizeOverflow(cx, &quot;array length&quot;, &quot;JavaScript number&quot;);</span>
<span class="lineNum">    5443 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    5444 </span>            :     }
<span class="lineNum">    5445 </span>            :   }
<span class="lineNum">    5446 </span>            : 
<span class="lineNum">    5447 </span><span class="lineNoCov">          0 :   RootedValue alignVal(cx, Int32Value(CType::GetAlignment(baseType)));</span>
<span class="lineNum">    5448 </span>            : 
<span class="lineNum">    5449 </span>            :   // Create a new CType object with the common properties and slots.
<span class="lineNum">    5450 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CType::Create(cx, typeProto, dataProto, TYPE_array, nullptr,</span>
<span class="lineNum">    5451 </span><span class="lineNoCov">          0 :                                     sizeVal, alignVal, nullptr);</span>
<span class="lineNum">    5452 </span><span class="lineNoCov">          0 :   if (!typeObj)</span>
<span class="lineNum">    5453 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5454 </span>            : 
<span class="lineNum">    5455 </span>            :   // Set the element type.
<span class="lineNum">    5456 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_ELEMENT_T, ObjectValue(*baseType));</span>
<span class="lineNum">    5457 </span>            : 
<span class="lineNum">    5458 </span>            :   // Set the length.
<span class="lineNum">    5459 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_LENGTH, lengthVal);</span>
<span class="lineNum">    5460 </span>            : 
<span class="lineNum">    5461 </span><span class="lineNoCov">          0 :   return typeObj;</span>
<span class="lineNum">    5462 </span>            : }
<a name="5463"><span class="lineNum">    5463 </span>            : </a>
<span class="lineNum">    5464 </span>            : bool
<span class="lineNum">    5465 </span><span class="lineNoCov">          0 : ArrayType::ConstructData(JSContext* cx,</span>
<span class="lineNum">    5466 </span>            :                          HandleObject obj_,
<span class="lineNum">    5467 </span>            :                          const CallArgs&amp; args)
<span class="lineNum">    5468 </span>            : {
<span class="lineNum">    5469 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, obj_); // Make a mutable version</span>
<span class="lineNum">    5470 </span>            : 
<span class="lineNum">    5471 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_array) {</span>
<span class="lineNum">    5472 </span><span class="lineNoCov">          0 :     return IncompatibleCallee(cx, &quot;ArrayType constructor&quot;, obj);</span>
<span class="lineNum">    5473 </span>            :   }
<span class="lineNum">    5474 </span>            : 
<span class="lineNum">    5475 </span>            :   // Decide whether we have an object to initialize from. We'll override this
<span class="lineNum">    5476 </span>            :   // if we get a length argument instead.
<span class="lineNum">    5477 </span><span class="lineNoCov">          0 :   bool convertObject = args.length() == 1;</span>
<span class="lineNum">    5478 </span>            : 
<span class="lineNum">    5479 </span>            :   // Check if we're an array of undefined length. If we are, allow construction
<span class="lineNum">    5480 </span>            :   // with a length argument, or with an actual JS array.
<span class="lineNum">    5481 </span><span class="lineNoCov">          0 :   if (CType::IsSizeDefined(obj)) {</span>
<span class="lineNum">    5482 </span><span class="lineNoCov">          0 :     if (args.length() &gt; 1) {</span>
<span class="lineNum">    5483 </span><span class="lineNoCov">          0 :       return ArgumentLengthError(cx, &quot;size defined ArrayType constructor&quot;,</span>
<span class="lineNum">    5484 </span><span class="lineNoCov">          0 :                                  &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    5485 </span>            :     }
<span class="lineNum">    5486 </span>            : 
<span class="lineNum">    5487 </span>            :   } else {
<span class="lineNum">    5488 </span><span class="lineNoCov">          0 :     if (args.length() != 1) {</span>
<span class="lineNum">    5489 </span><span class="lineNoCov">          0 :       return ArgumentLengthError(cx, &quot;size undefined ArrayType constructor&quot;,</span>
<span class="lineNum">    5490 </span><span class="lineNoCov">          0 :                                  &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    5491 </span>            :     }
<span class="lineNum">    5492 </span>            : 
<span class="lineNum">    5493 </span><span class="lineNoCov">          0 :     RootedObject baseType(cx, GetBaseType(obj));</span>
<span class="lineNum">    5494 </span>            : 
<span class="lineNum">    5495 </span>            :     size_t length;
<span class="lineNum">    5496 </span><span class="lineNoCov">          0 :     if (jsvalToSize(cx, args[0], false, &amp;length)) {</span>
<span class="lineNum">    5497 </span>            :       // Have a length, rather than an object to initialize from.
<span class="lineNum">    5498 </span><span class="lineNoCov">          0 :       convertObject = false;</span>
<span class="lineNum">    5499 </span>            : 
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :     } else if (args[0].isObject()) {</span>
<span class="lineNum">    5501 </span>            :       // We were given an object with a .length property.
<span class="lineNum">    5502 </span>            :       // This could be a JS array, or a CData array.
<span class="lineNum">    5503 </span><span class="lineNoCov">          0 :       RootedObject arg(cx, &amp;args[0].toObject());</span>
<span class="lineNum">    5504 </span><span class="lineNoCov">          0 :       RootedValue lengthVal(cx);</span>
<span class="lineNum">    5505 </span><span class="lineNoCov">          0 :       if (!JS_GetProperty(cx, arg, &quot;length&quot;, &amp;lengthVal) ||</span>
<span class="lineNum">    5506 </span><span class="lineNoCov">          0 :           !jsvalToSize(cx, lengthVal, false, &amp;length)) {</span>
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :         return ArgumentTypeMismatch(cx, &quot;&quot;,</span>
<span class="lineNum">    5508 </span>            :                                     &quot;size undefined ArrayType constructor&quot;,
<span class="lineNum">    5509 </span><span class="lineNoCov">          0 :                                     &quot;an array object or integer&quot;);</span>
<span class="lineNum">    5510 </span>            :       }
<span class="lineNum">    5511 </span>            : 
<span class="lineNum">    5512 </span><span class="lineNoCov">          0 :     } else if (args[0].isString()) {</span>
<span class="lineNum">    5513 </span>            :       // We were given a string. Size the array to the appropriate length,
<span class="lineNum">    5514 </span>            :       // including space for the terminator.
<span class="lineNum">    5515 </span><span class="lineNoCov">          0 :       JSString* sourceString = args[0].toString();</span>
<span class="lineNum">    5516 </span><span class="lineNoCov">          0 :       size_t sourceLength = sourceString-&gt;length();</span>
<span class="lineNum">    5517 </span><span class="lineNoCov">          0 :       JSLinearString* sourceLinear = sourceString-&gt;ensureLinear(cx);</span>
<span class="lineNum">    5518 </span><span class="lineNoCov">          0 :       if (!sourceLinear)</span>
<span class="lineNum">    5519 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    5520 </span>            : 
<span class="lineNum">    5521 </span><span class="lineNoCov">          0 :       switch (CType::GetTypeCode(baseType)) {</span>
<span class="lineNum">    5522 </span>            :       case TYPE_char:
<span class="lineNum">    5523 </span>            :       case TYPE_signed_char:
<span class="lineNum">    5524 </span>            :       case TYPE_unsigned_char: {
<span class="lineNum">    5525 </span>            :         // Determine the UTF-8 length.
<span class="lineNum">    5526 </span><span class="lineNoCov">          0 :         length = GetDeflatedUTF8StringLength(cx, sourceLinear);</span>
<span class="lineNum">    5527 </span><span class="lineNoCov">          0 :         if (length == (size_t) -1)</span>
<span class="lineNum">    5528 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    5529 </span>            : 
<span class="lineNum">    5530 </span><span class="lineNoCov">          0 :         ++length;</span>
<span class="lineNum">    5531 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5532 </span>            :       }
<span class="lineNum">    5533 </span>            :       case TYPE_char16_t:
<span class="lineNum">    5534 </span><span class="lineNoCov">          0 :         length = sourceLength + 1;</span>
<span class="lineNum">    5535 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5536 </span>            :       default:
<span class="lineNum">    5537 </span><span class="lineNoCov">          0 :         return ConvError(cx, obj, args[0], ConversionType::Construct);</span>
<span class="lineNum">    5538 </span>            :       }
<span class="lineNum">    5539 </span>            : 
<span class="lineNum">    5540 </span>            :     } else {
<span class="lineNum">    5541 </span><span class="lineNoCov">          0 :       return ArgumentTypeMismatch(cx, &quot;&quot;,</span>
<span class="lineNum">    5542 </span>            :                                   &quot;size undefined ArrayType constructor&quot;,
<span class="lineNum">    5543 </span><span class="lineNoCov">          0 :                                   &quot;an array object or integer&quot;);</span>
<span class="lineNum">    5544 </span>            :     }
<span class="lineNum">    5545 </span>            : 
<span class="lineNum">    5546 </span>            :     // Construct a new ArrayType of defined length, for the new CData object.
<span class="lineNum">    5547 </span><span class="lineNoCov">          0 :     obj = CreateInternal(cx, baseType, length, true);</span>
<span class="lineNum">    5548 </span><span class="lineNoCov">          0 :     if (!obj)</span>
<span class="lineNum">    5549 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5550 </span>            :   }
<span class="lineNum">    5551 </span>            : 
<span class="lineNum">    5552 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, obj, nullptr, nullptr, true);</span>
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5555 </span>            : 
<span class="lineNum">    5556 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span><span class="lineNoCov">          0 :   if (convertObject) {</span>
<span class="lineNum">    5559 </span><span class="lineNoCov">          0 :     if (!ExplicitConvert(cx, args[0], obj, CData::GetData(result),</span>
<span class="lineNum">    5560 </span>            :                          ConversionType::Construct))
<span class="lineNum">    5561 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5562 </span>            :   }
<span class="lineNum">    5563 </span>            : 
<span class="lineNum">    5564 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5565 </span>            : }
<a name="5566"><span class="lineNum">    5566 </span>            : </a>
<span class="lineNum">    5567 </span>            : JSObject*
<span class="lineNum">    5568 </span><span class="lineNoCov">          0 : ArrayType::GetBaseType(JSObject* obj)</span>
<span class="lineNum">    5569 </span>            : {
<span class="lineNum">    5570 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    5571 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_array);</span>
<span class="lineNum">    5572 </span>            : 
<span class="lineNum">    5573 </span><span class="lineNoCov">          0 :   Value type = JS_GetReservedSlot(obj, SLOT_ELEMENT_T);</span>
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!type.isNull());</span>
<span class="lineNum">    5575 </span><span class="lineNoCov">          0 :   return &amp;type.toObject();</span>
<span class="lineNum">    5576 </span>            : }
<a name="5577"><span class="lineNum">    5577 </span>            : </a>
<span class="lineNum">    5578 </span>            : bool
<span class="lineNum">    5579 </span><span class="lineNoCov">          0 : ArrayType::GetSafeLength(JSObject* obj, size_t* result)</span>
<span class="lineNum">    5580 </span>            : {
<span class="lineNum">    5581 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    5582 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_array);</span>
<span class="lineNum">    5583 </span>            : 
<span class="lineNum">    5584 </span><span class="lineNoCov">          0 :   Value length = JS_GetReservedSlot(obj, SLOT_LENGTH);</span>
<span class="lineNum">    5585 </span>            : 
<span class="lineNum">    5586 </span>            :   // The &quot;length&quot; property can be an int, a double, or JS::UndefinedValue()
<span class="lineNum">    5587 </span>            :   // (for arrays of undefined length), and must always fit in a size_t.
<span class="lineNum">    5588 </span><span class="lineNoCov">          0 :   if (length.isInt32()) {</span>
<span class="lineNum">    5589 </span><span class="lineNoCov">          0 :     *result = length.toInt32();</span>
<span class="lineNum">    5590 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5591 </span>            :   }
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :   if (length.isDouble()) {</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :     *result = Convert&lt;size_t&gt;(length.toDouble());</span>
<span class="lineNum">    5594 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5595 </span>            :   }
<span class="lineNum">    5596 </span>            : 
<span class="lineNum">    5597 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(length.isUndefined());</span>
<span class="lineNum">    5598 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    5599 </span>            : }
<a name="5600"><span class="lineNum">    5600 </span>            : </a>
<span class="lineNum">    5601 </span>            : size_t
<span class="lineNum">    5602 </span><span class="lineNoCov">          0 : ArrayType::GetLength(JSObject* obj)</span>
<span class="lineNum">    5603 </span>            : {
<span class="lineNum">    5604 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    5605 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_array);</span>
<span class="lineNum">    5606 </span>            : 
<span class="lineNum">    5607 </span><span class="lineNoCov">          0 :   Value length = JS_GetReservedSlot(obj, SLOT_LENGTH);</span>
<span class="lineNum">    5608 </span>            : 
<span class="lineNum">    5609 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!length.isUndefined());</span>
<span class="lineNum">    5610 </span>            : 
<span class="lineNum">    5611 </span>            :   // The &quot;length&quot; property can be an int, a double, or JS::UndefinedValue()
<span class="lineNum">    5612 </span>            :   // (for arrays of undefined length), and must always fit in a size_t.
<span class="lineNum">    5613 </span>            :   // For callers who know it can never be JS::UndefinedValue(), return a size_t
<span class="lineNum">    5614 </span>            :   // directly.
<span class="lineNum">    5615 </span><span class="lineNoCov">          0 :   if (length.isInt32())</span>
<span class="lineNum">    5616 </span><span class="lineNoCov">          0 :     return length.toInt32();</span>
<span class="lineNum">    5617 </span><span class="lineNoCov">          0 :   return Convert&lt;size_t&gt;(length.toDouble());</span>
<span class="lineNum">    5618 </span>            : }
<a name="5619"><span class="lineNum">    5619 </span>            : </a>
<span class="lineNum">    5620 </span>            : UniquePtrFFIType
<span class="lineNum">    5621 </span><span class="lineNoCov">          0 : ArrayType::BuildFFIType(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    5622 </span>            : {
<span class="lineNum">    5623 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    5624 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_array);</span>
<span class="lineNum">    5625 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsSizeDefined(obj));</span>
<span class="lineNum">    5626 </span>            : 
<span class="lineNum">    5627 </span><span class="lineNoCov">          0 :   JSObject* baseType = ArrayType::GetBaseType(obj);</span>
<span class="lineNum">    5628 </span><span class="lineNoCov">          0 :   ffi_type* ffiBaseType = CType::GetFFIType(cx, baseType);</span>
<span class="lineNum">    5629 </span><span class="lineNoCov">          0 :   if (!ffiBaseType)</span>
<span class="lineNum">    5630 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5631 </span>            : 
<span class="lineNum">    5632 </span><span class="lineNoCov">          0 :   size_t length = ArrayType::GetLength(obj);</span>
<span class="lineNum">    5633 </span>            : 
<span class="lineNum">    5634 </span>            :   // Create an ffi_type to represent the array. This is necessary for the case
<span class="lineNum">    5635 </span>            :   // where the array is part of a struct. Since libffi has no intrinsic
<span class="lineNum">    5636 </span>            :   // support for array types, we approximate it by creating a struct type
<span class="lineNum">    5637 </span>            :   // with elements of type 'baseType' and with appropriate size and alignment
<span class="lineNum">    5638 </span>            :   // values. It would be nice to not do all the work of setting up 'elements',
<span class="lineNum">    5639 </span>            :   // but some libffi platforms currently require that it be meaningful. I'm
<span class="lineNum">    5640 </span>            :   // looking at you, x86_64.
<span class="lineNum">    5641 </span><span class="lineNoCov">          0 :   auto ffiType = cx-&gt;make_unique&lt;ffi_type&gt;();</span>
<span class="lineNum">    5642 </span><span class="lineNoCov">          0 :   if (!ffiType) {</span>
<span class="lineNum">    5643 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    5644 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5645 </span>            :   }
<span class="lineNum">    5646 </span>            : 
<span class="lineNum">    5647 </span><span class="lineNoCov">          0 :   ffiType-&gt;type = FFI_TYPE_STRUCT;</span>
<span class="lineNum">    5648 </span><span class="lineNoCov">          0 :   ffiType-&gt;size = CType::GetSize(obj);</span>
<span class="lineNum">    5649 </span><span class="lineNoCov">          0 :   ffiType-&gt;alignment = CType::GetAlignment(obj);</span>
<span class="lineNum">    5650 </span><span class="lineNoCov">          0 :   ffiType-&gt;elements = cx-&gt;pod_malloc&lt;ffi_type*&gt;(length + 1);</span>
<span class="lineNum">    5651 </span><span class="lineNoCov">          0 :   if (!ffiType-&gt;elements) {</span>
<span class="lineNum">    5652 </span><span class="lineNoCov">          0 :     JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    5653 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5654 </span>            :   }
<span class="lineNum">    5655 </span>            : 
<span class="lineNum">    5656 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; length; ++i)</span>
<span class="lineNum">    5657 </span><span class="lineNoCov">          0 :     ffiType-&gt;elements[i] = ffiBaseType;</span>
<span class="lineNum">    5658 </span><span class="lineNoCov">          0 :   ffiType-&gt;elements[length] = nullptr;</span>
<span class="lineNum">    5659 </span>            : 
<span class="lineNum">    5660 </span><span class="lineNoCov">          0 :   return Move(ffiType);</span>
<span class="lineNum">    5661 </span>            : }
<a name="5662"><span class="lineNum">    5662 </span>            : </a>
<span class="lineNum">    5663 </span>            : bool
<span class="lineNum">    5664 </span><span class="lineNoCov">          0 : ArrayType::IsArrayType(HandleValue v)</span>
<span class="lineNum">    5665 </span>            : {
<span class="lineNum">    5666 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    5667 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5668 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    5669 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) &amp;&amp; CType::GetTypeCode(obj) == TYPE_array;</span>
<span class="lineNum">    5670 </span>            : }
<a name="5671"><span class="lineNum">    5671 </span>            : </a>
<span class="lineNum">    5672 </span>            : bool
<span class="lineNum">    5673 </span><span class="lineNoCov">          0 : ArrayType::IsArrayOrArrayType(HandleValue v)</span>
<span class="lineNum">    5674 </span>            : {
<span class="lineNum">    5675 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    5676 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5677 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    5678 </span>            : 
<span class="lineNum">    5679 </span>            :    // Allow both CTypes and CDatas of the ArrayType persuasion by extracting the
<span class="lineNum">    5680 </span>            :    // CType if we're dealing with a CData.
<span class="lineNum">    5681 </span><span class="lineNoCov">          0 :   if (CData::IsCData(obj)) {</span>
<span class="lineNum">    5682 </span><span class="lineNoCov">          0 :     obj = CData::GetCType(obj);</span>
<span class="lineNum">    5683 </span>            :   }
<span class="lineNum">    5684 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) &amp;&amp; CType::GetTypeCode(obj) == TYPE_array;</span>
<span class="lineNum">    5685 </span>            : }
<a name="5686"><span class="lineNum">    5686 </span>            : </a>
<span class="lineNum">    5687 </span>            : bool
<span class="lineNum">    5688 </span><span class="lineNoCov">          0 : ArrayType::ElementTypeGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    5689 </span>            : {
<span class="lineNum">    5690 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    5691 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_ELEMENT_T));</span>
<span class="lineNum">    5692 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args.rval().isObject());</span>
<span class="lineNum">    5693 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5694 </span>            : }
<a name="5695"><span class="lineNum">    5695 </span>            : </a>
<span class="lineNum">    5696 </span>            : bool
<span class="lineNum">    5697 </span><span class="lineNoCov">          0 : ArrayType::LengthGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    5698 </span>            : {
<span class="lineNum">    5699 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;args.thisv().toObject();</span>
<span class="lineNum">    5700 </span>            : 
<span class="lineNum">    5701 </span>            :   // This getter exists for both CTypes and CDatas of the ArrayType persuasion.
<span class="lineNum">    5702 </span>            :   // If we're dealing with a CData, get the CType from it.
<span class="lineNum">    5703 </span><span class="lineNoCov">          0 :   if (CData::IsCData(obj))</span>
<span class="lineNum">    5704 </span><span class="lineNoCov">          0 :     obj = CData::GetCType(obj);</span>
<span class="lineNum">    5705 </span>            : 
<span class="lineNum">    5706 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_LENGTH));</span>
<span class="lineNum">    5707 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args.rval().isNumber() || args.rval().isUndefined());</span>
<span class="lineNum">    5708 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5709 </span>            : }
<a name="5710"><span class="lineNum">    5710 </span>            : </a>
<span class="lineNum">    5711 </span>            : bool
<span class="lineNum">    5712 </span><span class="lineNoCov">          0 : ArrayType::Getter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp)</span>
<span class="lineNum">    5713 </span>            : {
<span class="lineNum">    5714 </span>            :   // This should never happen, but we'll check to be safe.
<span class="lineNum">    5715 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    5716 </span><span class="lineNoCov">          0 :     RootedValue objVal(cx, ObjectValue(*obj));</span>
<span class="lineNum">    5717 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;ArrayType property getter&quot;, objVal);</span>
<span class="lineNum">    5718 </span>            :   }
<span class="lineNum">    5719 </span>            : 
<span class="lineNum">    5720 </span>            :   // Bail early if we're not an ArrayType. (This setter is present for all
<span class="lineNum">    5721 </span>            :   // CData, regardless of CType.)
<span class="lineNum">    5722 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    5723 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_array)</span>
<span class="lineNum">    5724 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5725 </span>            : 
<span class="lineNum">    5726 </span>            :   // Convert the index to a size_t and bounds-check it.
<span class="lineNum">    5727 </span>            :   size_t index;
<span class="lineNum">    5728 </span><span class="lineNoCov">          0 :   size_t length = GetLength(typeObj);</span>
<span class="lineNum">    5729 </span><span class="lineNoCov">          0 :   bool ok = jsidToSize(cx, idval, true, &amp;index);</span>
<span class="lineNum">    5730 </span>            :   int32_t dummy;
<span class="lineNum">    5731 </span><span class="lineNoCov">          0 :   if (!ok &amp;&amp; JSID_IS_SYMBOL(idval))</span>
<span class="lineNum">    5732 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5733 </span>            :   bool dummy2;
<span class="lineNum">    5734 </span><span class="lineNoCov">          0 :   if (!ok &amp;&amp; JSID_IS_STRING(idval) &amp;&amp;</span>
<span class="lineNum">    5735 </span><span class="lineNoCov">          0 :       !StringToInteger(cx, JSID_TO_STRING(idval), &amp;dummy, &amp;dummy2)) {</span>
<span class="lineNum">    5736 </span>            :     // String either isn't a number, or doesn't fit in size_t.
<span class="lineNum">    5737 </span>            :     // Chances are it's a regular property lookup, so return.
<span class="lineNum">    5738 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5739 </span>            :   }
<span class="lineNum">    5740 </span><span class="lineNoCov">          0 :   if (!ok) {</span>
<span class="lineNum">    5741 </span><span class="lineNoCov">          0 :     return InvalidIndexError(cx, idval);</span>
<span class="lineNum">    5742 </span>            :   }
<span class="lineNum">    5743 </span><span class="lineNoCov">          0 :   if (index &gt;= length) {</span>
<span class="lineNum">    5744 </span><span class="lineNoCov">          0 :     return InvalidIndexRangeError(cx, index, length);</span>
<span class="lineNum">    5745 </span>            :   }
<span class="lineNum">    5746 </span>            : 
<span class="lineNum">    5747 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, GetBaseType(typeObj));</span>
<span class="lineNum">    5748 </span><span class="lineNoCov">          0 :   size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    5749 </span><span class="lineNoCov">          0 :   char* data = static_cast&lt;char*&gt;(CData::GetData(obj)) + elementSize * index;</span>
<span class="lineNum">    5750 </span><span class="lineNoCov">          0 :   return ConvertToJS(cx, baseType, obj, data, false, false, vp);</span>
<span class="lineNum">    5751 </span>            : }
<a name="5752"><span class="lineNum">    5752 </span>            : </a>
<span class="lineNum">    5753 </span>            : bool
<span class="lineNum">    5754 </span><span class="lineNoCov">          0 : ArrayType::Setter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp,</span>
<span class="lineNum">    5755 </span>            :                   ObjectOpResult&amp; result)
<span class="lineNum">    5756 </span>            : {
<span class="lineNum">    5757 </span>            :   // This should never happen, but we'll check to be safe.
<span class="lineNum">    5758 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    5759 </span><span class="lineNoCov">          0 :     RootedValue objVal(cx, ObjectValue(*obj));</span>
<span class="lineNum">    5760 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;ArrayType property setter&quot;, objVal);</span>
<span class="lineNum">    5761 </span>            :   }
<span class="lineNum">    5762 </span>            : 
<span class="lineNum">    5763 </span>            :   // Bail early if we're not an ArrayType. (This setter is present for all
<span class="lineNum">    5764 </span>            :   // CData, regardless of CType.)
<span class="lineNum">    5765 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    5766 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_array)</span>
<span class="lineNum">    5767 </span><span class="lineNoCov">          0 :     return result.succeed();</span>
<span class="lineNum">    5768 </span>            : 
<span class="lineNum">    5769 </span>            :   // Convert the index to a size_t and bounds-check it.
<span class="lineNum">    5770 </span>            :   size_t index;
<span class="lineNum">    5771 </span><span class="lineNoCov">          0 :   size_t length = GetLength(typeObj);</span>
<span class="lineNum">    5772 </span><span class="lineNoCov">          0 :   bool ok = jsidToSize(cx, idval, true, &amp;index);</span>
<span class="lineNum">    5773 </span>            :   int32_t dummy;
<span class="lineNum">    5774 </span><span class="lineNoCov">          0 :   if (!ok &amp;&amp; JSID_IS_SYMBOL(idval))</span>
<span class="lineNum">    5775 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5776 </span>            :   bool dummy2;
<span class="lineNum">    5777 </span><span class="lineNoCov">          0 :   if (!ok &amp;&amp; JSID_IS_STRING(idval) &amp;&amp;</span>
<span class="lineNum">    5778 </span><span class="lineNoCov">          0 :       !StringToInteger(cx, JSID_TO_STRING(idval), &amp;dummy, &amp;dummy2)) {</span>
<span class="lineNum">    5779 </span>            :     // String either isn't a number, or doesn't fit in size_t.
<span class="lineNum">    5780 </span>            :     // Chances are it's a regular property lookup, so return.
<span class="lineNum">    5781 </span><span class="lineNoCov">          0 :     return result.succeed();</span>
<span class="lineNum">    5782 </span>            :   }
<span class="lineNum">    5783 </span><span class="lineNoCov">          0 :   if (!ok) {</span>
<span class="lineNum">    5784 </span><span class="lineNoCov">          0 :     return InvalidIndexError(cx, idval);</span>
<span class="lineNum">    5785 </span>            :   }
<span class="lineNum">    5786 </span><span class="lineNoCov">          0 :   if (index &gt;= length) {</span>
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :     return InvalidIndexRangeError(cx, index, length);</span>
<span class="lineNum">    5788 </span>            :   }
<span class="lineNum">    5789 </span>            : 
<span class="lineNum">    5790 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, GetBaseType(typeObj));</span>
<span class="lineNum">    5791 </span><span class="lineNoCov">          0 :   size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    5792 </span><span class="lineNoCov">          0 :   char* data = static_cast&lt;char*&gt;(CData::GetData(obj)) + elementSize * index;</span>
<span class="lineNum">    5793 </span><span class="lineNoCov">          0 :   if (!ImplicitConvert(cx, vp, baseType, data, ConversionType::Setter,</span>
<span class="lineNum">    5794 </span><span class="lineNoCov">          0 :                        nullptr, nullptr, 0, typeObj, index))</span>
<span class="lineNum">    5795 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5796 </span><span class="lineNoCov">          0 :   return result.succeed();</span>
<span class="lineNum">    5797 </span>            : }
<a name="5798"><span class="lineNum">    5798 </span>            : </a>
<span class="lineNum">    5799 </span>            : bool
<span class="lineNum">    5800 </span><span class="lineNoCov">          0 : ArrayType::AddressOfElement(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5801 </span>            : {
<span class="lineNum">    5802 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5803 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    5804 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    5805 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5806 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    5807 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;ArrayType.prototype.addressOfElement&quot;,</span>
<span class="lineNum">    5808 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    5809 </span>            :   }
<span class="lineNum">    5810 </span>            : 
<span class="lineNum">    5811 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    5812 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_array) {</span>
<span class="lineNum">    5813 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;ArrayType.prototype.addressOfElement&quot;,</span>
<span class="lineNum">    5814 </span><span class="lineNoCov">          0 :                                 &quot;non-ArrayType CData&quot;, args.thisv());</span>
<span class="lineNum">    5815 </span>            :   }
<span class="lineNum">    5816 </span>            : 
<span class="lineNum">    5817 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;ArrayType.prototype.addressOfElement&quot;,</span>
<span class="lineNum">    5819 </span><span class="lineNoCov">          0 :                                &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    5820 </span>            :   }
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, GetBaseType(typeObj));</span>
<span class="lineNum">    5823 </span><span class="lineNoCov">          0 :   RootedObject pointerType(cx, PointerType::CreateInternal(cx, baseType));</span>
<span class="lineNum">    5824 </span><span class="lineNoCov">          0 :   if (!pointerType)</span>
<span class="lineNum">    5825 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5826 </span>            : 
<span class="lineNum">    5827 </span>            :   // Create a PointerType CData object containing null.
<span class="lineNum">    5828 </span><span class="lineNoCov">          0 :   RootedObject result(cx, CData::Create(cx, pointerType, nullptr, nullptr, true));</span>
<span class="lineNum">    5829 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    5830 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5831 </span>            : 
<span class="lineNum">    5832 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5833 </span>            : 
<span class="lineNum">    5834 </span>            :   // Convert the index to a size_t and bounds-check it.
<span class="lineNum">    5835 </span>            :   size_t index;
<span class="lineNum">    5836 </span><span class="lineNoCov">          0 :   size_t length = GetLength(typeObj);</span>
<span class="lineNum">    5837 </span><span class="lineNoCov">          0 :   if (!jsvalToSize(cx, args[0], false, &amp;index)) {</span>
<span class="lineNum">    5838 </span><span class="lineNoCov">          0 :     return InvalidIndexError(cx, args[0]);</span>
<span class="lineNum">    5839 </span>            :   }
<span class="lineNum">    5840 </span><span class="lineNoCov">          0 :   if (index &gt;= length) {</span>
<span class="lineNum">    5841 </span><span class="lineNoCov">          0 :     return InvalidIndexRangeError(cx, index, length);</span>
<span class="lineNum">    5842 </span>            :   }
<span class="lineNum">    5843 </span>            : 
<span class="lineNum">    5844 </span>            :   // Manually set the pointer inside the object, so we skip the conversion step.
<span class="lineNum">    5845 </span><span class="lineNoCov">          0 :   void** data = static_cast&lt;void**&gt;(CData::GetData(result));</span>
<span class="lineNum">    5846 </span><span class="lineNoCov">          0 :   size_t elementSize = CType::GetSize(baseType);</span>
<span class="lineNum">    5847 </span><span class="lineNoCov">          0 :   *data = static_cast&lt;char*&gt;(CData::GetData(obj)) + elementSize * index;</span>
<span class="lineNum">    5848 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    5849 </span>            : }
<span class="lineNum">    5850 </span>            : 
<span class="lineNum">    5851 </span>            : /*******************************************************************************
<span class="lineNum">    5852 </span>            : ** StructType implementation
<span class="lineNum">    5853 </span>            : *******************************************************************************/
<span class="lineNum">    5854 </span>            : 
<span class="lineNum">    5855 </span>            : // For a struct field descriptor 'val' of the form { name : type }, extract
<a name="5856"><span class="lineNum">    5856 </span>            : // 'name' and 'type'.</a>
<span class="lineNum">    5857 </span>            : static JSFlatString*
<span class="lineNum">    5858 </span><span class="lineNoCov">          0 : ExtractStructField(JSContext* cx, HandleValue val, MutableHandleObject typeObj)</span>
<span class="lineNum">    5859 </span>            : {
<span class="lineNum">    5860 </span><span class="lineNoCov">          0 :   if (val.isPrimitive()) {</span>
<span class="lineNum">    5861 </span><span class="lineNoCov">          0 :     FieldDescriptorNameTypeError(cx, val);</span>
<span class="lineNum">    5862 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5863 </span>            :   }
<span class="lineNum">    5864 </span>            : 
<span class="lineNum">    5865 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;val.toObject());</span>
<span class="lineNum">    5866 </span><span class="lineNoCov">          0 :   Rooted&lt;IdVector&gt; props(cx, IdVector(cx));</span>
<span class="lineNum">    5867 </span><span class="lineNoCov">          0 :   if (!JS_Enumerate(cx, obj, &amp;props))</span>
<span class="lineNum">    5868 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5869 </span>            : 
<span class="lineNum">    5870 </span>            :   // make sure we have one, and only one, property
<span class="lineNum">    5871 </span><span class="lineNoCov">          0 :   if (props.length() != 1) {</span>
<span class="lineNum">    5872 </span><span class="lineNoCov">          0 :     FieldDescriptorCountError(cx, val, props.length());</span>
<span class="lineNum">    5873 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5874 </span>            :   }
<span class="lineNum">    5875 </span>            : 
<span class="lineNum">    5876 </span><span class="lineNoCov">          0 :   RootedId nameid(cx, props[0]);</span>
<span class="lineNum">    5877 </span><span class="lineNoCov">          0 :   if (!JSID_IS_STRING(nameid)) {</span>
<span class="lineNum">    5878 </span><span class="lineNoCov">          0 :     FieldDescriptorNameError(cx, nameid);</span>
<span class="lineNum">    5879 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5880 </span>            :   }
<span class="lineNum">    5881 </span>            : 
<span class="lineNum">    5882 </span><span class="lineNoCov">          0 :   RootedValue propVal(cx);</span>
<span class="lineNum">    5883 </span><span class="lineNoCov">          0 :   if (!JS_GetPropertyById(cx, obj, nameid, &amp;propVal))</span>
<span class="lineNum">    5884 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5885 </span>            : 
<span class="lineNum">    5886 </span><span class="lineNoCov">          0 :   if (propVal.isPrimitive() || !CType::IsCType(&amp;propVal.toObject())) {</span>
<span class="lineNum">    5887 </span><span class="lineNoCov">          0 :     FieldDescriptorTypeError(cx, propVal, nameid);</span>
<span class="lineNum">    5888 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5889 </span>            :   }
<span class="lineNum">    5890 </span>            : 
<span class="lineNum">    5891 </span>            :   // Undefined size or zero size struct members are illegal.
<span class="lineNum">    5892 </span>            :   // (Zero-size arrays are legal as struct members in C++, but libffi will
<span class="lineNum">    5893 </span>            :   // choke on a zero-size struct, so we disallow them.)
<span class="lineNum">    5894 </span><span class="lineNoCov">          0 :   typeObj.set(&amp;propVal.toObject());</span>
<span class="lineNum">    5895 </span>            :   size_t size;
<span class="lineNum">    5896 </span><span class="lineNoCov">          0 :   if (!CType::GetSafeSize(typeObj, &amp;size) || size == 0) {</span>
<span class="lineNum">    5897 </span><span class="lineNoCov">          0 :     FieldDescriptorSizeError(cx, typeObj, nameid);</span>
<span class="lineNum">    5898 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    5899 </span>            :   }
<span class="lineNum">    5900 </span>            : 
<span class="lineNum">    5901 </span><span class="lineNoCov">          0 :   return JSID_TO_FLAT_STRING(nameid);</span>
<span class="lineNum">    5902 </span>            : }
<span class="lineNum">    5903 </span>            : 
<span class="lineNum">    5904 </span>            : // For a struct field with 'name' and 'type', add an element of the form
<a name="5905"><span class="lineNum">    5905 </span>            : // { name : type }.</a>
<span class="lineNum">    5906 </span>            : static bool
<span class="lineNum">    5907 </span><span class="lineNoCov">          0 : AddFieldToArray(JSContext* cx,</span>
<span class="lineNum">    5908 </span>            :                 MutableHandleValue element,
<span class="lineNum">    5909 </span>            :                 JSFlatString* name_,
<span class="lineNum">    5910 </span>            :                 JSObject* typeObj_)
<span class="lineNum">    5911 </span>            : {
<span class="lineNum">    5912 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, typeObj_);</span>
<span class="lineNum">    5913 </span><span class="lineNoCov">          0 :   Rooted&lt;JSFlatString*&gt; name(cx, name_);</span>
<span class="lineNum">    5914 </span><span class="lineNoCov">          0 :   RootedObject fieldObj(cx, JS_NewPlainObject(cx));</span>
<span class="lineNum">    5915 </span><span class="lineNoCov">          0 :   if (!fieldObj)</span>
<span class="lineNum">    5916 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5917 </span>            : 
<span class="lineNum">    5918 </span><span class="lineNoCov">          0 :   element.setObject(*fieldObj);</span>
<span class="lineNum">    5919 </span>            : 
<span class="lineNum">    5920 </span><span class="lineNoCov">          0 :   AutoStableStringChars nameChars(cx);</span>
<span class="lineNum">    5921 </span><span class="lineNoCov">          0 :   if (!nameChars.initTwoByte(cx, name))</span>
<span class="lineNum">    5922 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5923 </span>            : 
<span class="lineNum">    5924 </span><span class="lineNoCov">          0 :   if (!JS_DefineUCProperty(cx, fieldObj,</span>
<span class="lineNum">    5925 </span><span class="lineNoCov">          0 :          nameChars.twoByteChars(), name-&gt;length(),</span>
<span class="lineNum">    5926 </span>            :          typeObj,
<span class="lineNum">    5927 </span>            :          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    5928 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5929 </span>            : 
<span class="lineNum">    5930 </span><span class="lineNoCov">          0 :   return JS_FreezeObject(cx, fieldObj);</span>
<span class="lineNum">    5931 </span>            : }
<a name="5932"><span class="lineNum">    5932 </span>            : </a>
<span class="lineNum">    5933 </span>            : bool
<span class="lineNum">    5934 </span><span class="lineCov">          4 : StructType::Create(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    5935 </span>            : {
<span class="lineNum">    5936 </span><span class="lineCov">          4 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    5937 </span>            : 
<span class="lineNum">    5938 </span>            :   // Construct and return a new StructType object.
<span class="lineNum">    5939 </span><span class="lineCov">          4 :   if (args.length() &lt; 1 || args.length() &gt; 2) {</span>
<span class="lineNum">    5940 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;StructType&quot;, &quot;one or two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    5941 </span>            :   }
<span class="lineNum">    5942 </span>            : 
<span class="lineNum">    5943 </span><span class="lineCov">          4 :   Value name = args[0];</span>
<span class="lineNum">    5944 </span><span class="lineCov">          4 :   if (!name.isString()) {</span>
<span class="lineNum">    5945 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;first &quot;, &quot;StructType&quot;, &quot;a string&quot;);</span>
<span class="lineNum">    5946 </span>            :   }
<span class="lineNum">    5947 </span>            : 
<span class="lineNum">    5948 </span>            :   // Get ctypes.StructType.prototype from the ctypes.StructType constructor.
<span class="lineNum">    5949 </span><span class="lineCov">          8 :   RootedObject typeProto(cx, CType::GetProtoFromCtor(&amp;args.callee(), SLOT_STRUCTPROTO));</span>
<span class="lineNum">    5950 </span>            : 
<span class="lineNum">    5951 </span>            :   // Create a simple StructType with no defined fields. The result will be
<span class="lineNum">    5952 </span>            :   // non-instantiable as CData, will have no 'prototype' property, and will
<span class="lineNum">    5953 </span>            :   // have undefined size and alignment and no ffi_type.
<span class="lineNum">    5954 </span><span class="lineCov">          8 :   RootedObject result(cx, CType::Create(cx, typeProto, nullptr, TYPE_struct,</span>
<span class="lineNum">    5955 </span>            :                                         name.toString(),
<span class="lineNum">    5956 </span>            :                                         JS::UndefinedHandleValue,
<span class="lineNum">    5957 </span><span class="lineCov">          8 :                                         JS::UndefinedHandleValue, nullptr));</span>
<span class="lineNum">    5958 </span><span class="lineCov">          4 :   if (!result)</span>
<span class="lineNum">    5959 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5960 </span>            : 
<span class="lineNum">    5961 </span><span class="lineCov">          4 :   if (args.length() == 2) {</span>
<span class="lineNum">    5962 </span><span class="lineNoCov">          0 :     RootedObject arr(cx, args[1].isObject() ? &amp;args[1].toObject() : nullptr);</span>
<span class="lineNum">    5963 </span>            :     bool isArray;
<span class="lineNum">    5964 </span><span class="lineNoCov">          0 :     if (!arr) {</span>
<span class="lineNum">    5965 </span><span class="lineNoCov">          0 :         isArray = false;</span>
<span class="lineNum">    5966 </span>            :     } else {
<span class="lineNum">    5967 </span><span class="lineNoCov">          0 :         if (!JS_IsArrayObject(cx, arr, &amp;isArray))</span>
<span class="lineNum">    5968 </span><span class="lineNoCov">          0 :            return false;</span>
<span class="lineNum">    5969 </span>            :     }
<span class="lineNum">    5970 </span><span class="lineNoCov">          0 :     if (!isArray)</span>
<span class="lineNum">    5971 </span><span class="lineNoCov">          0 :       return ArgumentTypeMismatch(cx, &quot;second &quot;, &quot;StructType&quot;, &quot;an array&quot;);</span>
<span class="lineNum">    5972 </span>            : 
<span class="lineNum">    5973 </span>            :     // Define the struct fields.
<span class="lineNum">    5974 </span><span class="lineNoCov">          0 :     if (!DefineInternal(cx, result, arr))</span>
<span class="lineNum">    5975 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5976 </span>            :   }
<span class="lineNum">    5977 </span>            : 
<span class="lineNum">    5978 </span><span class="lineCov">          4 :   args.rval().setObject(*result);</span>
<span class="lineNum">    5979 </span><span class="lineCov">          4 :   return true;</span>
<span class="lineNum">    5980 </span>            : }
<a name="5981"><span class="lineNum">    5981 </span>            : </a>
<span class="lineNum">    5982 </span>            : bool
<span class="lineNum">    5983 </span><span class="lineNoCov">          0 : StructType::DefineInternal(JSContext* cx, JSObject* typeObj_, JSObject* fieldsObj_)</span>
<span class="lineNum">    5984 </span>            : {
<span class="lineNum">    5985 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, typeObj_);</span>
<span class="lineNum">    5986 </span><span class="lineNoCov">          0 :   RootedObject fieldsObj(cx, fieldsObj_);</span>
<span class="lineNum">    5987 </span>            : 
<span class="lineNum">    5988 </span>            :   uint32_t len;
<span class="lineNum">    5989 </span><span class="lineNoCov">          0 :   ASSERT_OK(JS_GetArrayLength(cx, fieldsObj, &amp;len));</span>
<span class="lineNum">    5990 </span>            : 
<span class="lineNum">    5991 </span>            :   // Get the common prototype for CData objects of this type from
<span class="lineNum">    5992 </span>            :   // ctypes.CType.prototype.
<span class="lineNum">    5993 </span><span class="lineNoCov">          0 :   RootedObject dataProto(cx, CType::GetProtoFromType(cx, typeObj, SLOT_STRUCTDATAPROTO));</span>
<span class="lineNum">    5994 </span><span class="lineNoCov">          0 :   if (!dataProto)</span>
<span class="lineNum">    5995 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5996 </span>            : 
<span class="lineNum">    5997 </span>            :   // Set up the 'prototype' and 'prototype.constructor' properties.
<span class="lineNum">    5998 </span>            :   // The prototype will reflect the struct fields as properties on CData objects
<span class="lineNum">    5999 </span>            :   // created from this type.
<span class="lineNum">    6000 </span><span class="lineNoCov">          0 :   RootedObject prototype(cx, JS_NewObjectWithGivenProto(cx, &amp;sCDataProtoClass, dataProto));</span>
<span class="lineNum">    6001 </span><span class="lineNoCov">          0 :   if (!prototype)</span>
<span class="lineNum">    6002 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6003 </span>            : 
<span class="lineNum">    6004 </span><span class="lineNoCov">          0 :   if (!JS_DefineProperty(cx, prototype, &quot;constructor&quot;, typeObj,</span>
<span class="lineNum">    6005 </span>            :                          JSPROP_READONLY | JSPROP_PERMANENT))
<span class="lineNum">    6006 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6007 </span>            : 
<span class="lineNum">    6008 </span>            :   // Create a FieldInfoHash to stash on the type object.
<span class="lineNum">    6009 </span><span class="lineNoCov">          0 :   Rooted&lt;FieldInfoHash&gt; fields(cx);</span>
<span class="lineNum">    6010 </span><span class="lineNoCov">          0 :   if (!fields.init(len)) {</span>
<span class="lineNum">    6011 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6012 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6013 </span>            :   }
<span class="lineNum">    6014 </span>            : 
<span class="lineNum">    6015 </span>            :   // Process the field types.
<span class="lineNum">    6016 </span>            :   size_t structSize, structAlign;
<span class="lineNum">    6017 </span><span class="lineNoCov">          0 :   if (len != 0) {</span>
<span class="lineNum">    6018 </span><span class="lineNoCov">          0 :     structSize = 0;</span>
<span class="lineNum">    6019 </span><span class="lineNoCov">          0 :     structAlign = 0;</span>
<span class="lineNum">    6020 </span>            : 
<span class="lineNum">    6021 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">    6022 </span><span class="lineNoCov">          0 :       RootedValue item(cx);</span>
<span class="lineNum">    6023 </span><span class="lineNoCov">          0 :       if (!JS_GetElement(cx, fieldsObj, i, &amp;item))</span>
<span class="lineNum">    6024 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6025 </span>            : 
<span class="lineNum">    6026 </span><span class="lineNoCov">          0 :       RootedObject fieldType(cx, nullptr);</span>
<span class="lineNum">    6027 </span><span class="lineNoCov">          0 :       Rooted&lt;JSFlatString*&gt; name(cx, ExtractStructField(cx, item, &amp;fieldType));</span>
<span class="lineNum">    6028 </span><span class="lineNoCov">          0 :       if (!name)</span>
<span class="lineNum">    6029 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6030 </span>            : 
<span class="lineNum">    6031 </span>            :       // Make sure each field name is unique
<span class="lineNum">    6032 </span><span class="lineNoCov">          0 :       FieldInfoHash::AddPtr entryPtr = fields.lookupForAdd(name);</span>
<span class="lineNum">    6033 </span><span class="lineNoCov">          0 :       if (entryPtr) {</span>
<span class="lineNum">    6034 </span><span class="lineNoCov">          0 :         return DuplicateFieldError(cx, name);</span>
<span class="lineNum">    6035 </span>            :       }
<span class="lineNum">    6036 </span>            : 
<span class="lineNum">    6037 </span>            :       // Add the field to the StructType's 'prototype' property.
<span class="lineNum">    6038 </span><span class="lineNoCov">          0 :       AutoStableStringChars nameChars(cx);</span>
<span class="lineNum">    6039 </span><span class="lineNoCov">          0 :       if (!nameChars.initTwoByte(cx, name))</span>
<span class="lineNum">    6040 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6041 </span>            : 
<span class="lineNum">    6042 </span><span class="lineNoCov">          0 :       RootedFunction getter(cx, NewFunctionWithReserved(cx, StructType::FieldGetter, 0, 0, nullptr));</span>
<span class="lineNum">    6043 </span><span class="lineNoCov">          0 :       if (!getter)</span>
<span class="lineNum">    6044 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6045 </span><span class="lineNoCov">          0 :       SetFunctionNativeReserved(getter, StructType::SLOT_FIELDNAME,</span>
<span class="lineNum">    6046 </span><span class="lineNoCov">          0 :                                 StringValue(JS_FORGET_STRING_FLATNESS(name)));</span>
<span class="lineNum">    6047 </span><span class="lineNoCov">          0 :       RootedObject getterObj(cx, JS_GetFunctionObject(getter));</span>
<span class="lineNum">    6048 </span>            : 
<span class="lineNum">    6049 </span><span class="lineNoCov">          0 :       RootedFunction setter(cx, NewFunctionWithReserved(cx, StructType::FieldSetter, 1, 0, nullptr));</span>
<span class="lineNum">    6050 </span><span class="lineNoCov">          0 :       if (!setter)</span>
<span class="lineNum">    6051 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6052 </span><span class="lineNoCov">          0 :       SetFunctionNativeReserved(setter, StructType::SLOT_FIELDNAME,</span>
<span class="lineNum">    6053 </span><span class="lineNoCov">          0 :                                 StringValue(JS_FORGET_STRING_FLATNESS(name)));</span>
<span class="lineNum">    6054 </span><span class="lineNoCov">          0 :       RootedObject setterObj(cx, JS_GetFunctionObject(setter));</span>
<span class="lineNum">    6055 </span>            : 
<span class="lineNum">    6056 </span><span class="lineNoCov">          0 :       if (!JS_DefineUCProperty(cx, prototype,</span>
<span class="lineNum">    6057 </span><span class="lineNoCov">          0 :              nameChars.twoByteChars(), name-&gt;length(), UndefinedHandleValue,</span>
<span class="lineNum">    6058 </span>            :              JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER,
<span class="lineNum">    6059 </span><span class="lineNoCov">          0 :              JS_DATA_TO_FUNC_PTR(JSNative, getterObj.get()),</span>
<span class="lineNum">    6060 </span><span class="lineNoCov">          0 :              JS_DATA_TO_FUNC_PTR(JSNative, setterObj.get())))</span>
<span class="lineNum">    6061 </span>            :       {
<span class="lineNum">    6062 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6063 </span>            :       }
<span class="lineNum">    6064 </span>            : 
<span class="lineNum">    6065 </span><span class="lineNoCov">          0 :       size_t fieldSize = CType::GetSize(fieldType);</span>
<span class="lineNum">    6066 </span><span class="lineNoCov">          0 :       size_t fieldAlign = CType::GetAlignment(fieldType);</span>
<span class="lineNum">    6067 </span><span class="lineNoCov">          0 :       size_t fieldOffset = Align(structSize, fieldAlign);</span>
<span class="lineNum">    6068 </span>            :       // Check for overflow. Since we hold invariant that fieldSize % fieldAlign
<span class="lineNum">    6069 </span>            :       // be zero, we can safely check fieldOffset + fieldSize without first
<span class="lineNum">    6070 </span>            :       // checking fieldOffset for overflow.
<span class="lineNum">    6071 </span><span class="lineNoCov">          0 :       if (fieldOffset + fieldSize &lt; structSize) {</span>
<span class="lineNum">    6072 </span><span class="lineNoCov">          0 :         SizeOverflow(cx, &quot;struct size&quot;, &quot;size_t&quot;);</span>
<span class="lineNum">    6073 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6074 </span>            :       }
<span class="lineNum">    6075 </span>            : 
<span class="lineNum">    6076 </span>            :       // Add field name to the hash
<span class="lineNum">    6077 </span><span class="lineNoCov">          0 :       FieldInfo info;</span>
<span class="lineNum">    6078 </span><span class="lineNoCov">          0 :       info.mType = fieldType;</span>
<span class="lineNum">    6079 </span><span class="lineNoCov">          0 :       info.mIndex = i;</span>
<span class="lineNum">    6080 </span><span class="lineNoCov">          0 :       info.mOffset = fieldOffset;</span>
<span class="lineNum">    6081 </span><span class="lineNoCov">          0 :       if (!fields.add(entryPtr, name, info)) {</span>
<span class="lineNum">    6082 </span><span class="lineNoCov">          0 :         JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6083 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6084 </span>            :       }
<span class="lineNum">    6085 </span>            : 
<span class="lineNum">    6086 </span><span class="lineNoCov">          0 :       structSize = fieldOffset + fieldSize;</span>
<span class="lineNum">    6087 </span>            : 
<span class="lineNum">    6088 </span><span class="lineNoCov">          0 :       if (fieldAlign &gt; structAlign)</span>
<span class="lineNum">    6089 </span><span class="lineNoCov">          0 :         structAlign = fieldAlign;</span>
<span class="lineNum">    6090 </span>            :     }
<span class="lineNum">    6091 </span>            : 
<span class="lineNum">    6092 </span>            :     // Pad the struct tail according to struct alignment.
<span class="lineNum">    6093 </span><span class="lineNoCov">          0 :     size_t structTail = Align(structSize, structAlign);</span>
<span class="lineNum">    6094 </span><span class="lineNoCov">          0 :     if (structTail &lt; structSize) {</span>
<span class="lineNum">    6095 </span><span class="lineNoCov">          0 :       SizeOverflow(cx, &quot;struct size&quot;, &quot;size_t&quot;);</span>
<span class="lineNum">    6096 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6097 </span>            :     }
<span class="lineNum">    6098 </span><span class="lineNoCov">          0 :     structSize = structTail;</span>
<span class="lineNum">    6099 </span>            : 
<span class="lineNum">    6100 </span>            :   } else {
<span class="lineNum">    6101 </span>            :     // Empty structs are illegal in C, but are legal and have a size of
<span class="lineNum">    6102 </span>            :     // 1 byte in C++. We're going to allow them, and trick libffi into
<span class="lineNum">    6103 </span>            :     // believing this by adding a char member. The resulting struct will have
<span class="lineNum">    6104 </span>            :     // no getters or setters, and will be initialized to zero.
<span class="lineNum">    6105 </span><span class="lineNoCov">          0 :     structSize = 1;</span>
<span class="lineNum">    6106 </span><span class="lineNoCov">          0 :     structAlign = 1;</span>
<span class="lineNum">    6107 </span>            :   }
<span class="lineNum">    6108 </span>            : 
<span class="lineNum">    6109 </span><span class="lineNoCov">          0 :   RootedValue sizeVal(cx);</span>
<span class="lineNum">    6110 </span><span class="lineNoCov">          0 :   if (!SizeTojsval(cx, structSize, &amp;sizeVal)) {</span>
<span class="lineNum">    6111 </span><span class="lineNoCov">          0 :     SizeOverflow(cx, &quot;struct size&quot;, &quot;double&quot;);</span>
<span class="lineNum">    6112 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6113 </span>            :   }
<span class="lineNum">    6114 </span>            : 
<span class="lineNum">    6115 </span>            :   // Move the field hash to the heap and store it in the typeObj.
<span class="lineNum">    6116 </span><span class="lineNoCov">          0 :   FieldInfoHash *heapHash = cx-&gt;new_&lt;FieldInfoHash&gt;(mozilla::Move(fields.get()));</span>
<span class="lineNum">    6117 </span><span class="lineNoCov">          0 :   if (!heapHash) {</span>
<span class="lineNum">    6118 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6119 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6120 </span>            :   }
<span class="lineNum">    6121 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(heapHash-&gt;initialized());</span>
<span class="lineNum">    6122 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_FIELDINFO, PrivateValue(heapHash));</span>
<span class="lineNum">    6123 </span>            : 
<span class="lineNum">    6124 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_SIZE, sizeVal);</span>
<span class="lineNum">    6125 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_ALIGN, Int32Value(structAlign));</span>
<span class="lineNum">    6126 </span>            :   //if (!JS_FreezeObject(cx, prototype)0 // XXX fixme - see bug 541212!
<span class="lineNum">    6127 </span>            :   //  return false;
<span class="lineNum">    6128 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_PROTO, ObjectValue(*prototype));</span>
<span class="lineNum">    6129 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6130 </span>            : }
<a name="6131"><span class="lineNum">    6131 </span>            : </a>
<span class="lineNum">    6132 </span>            : UniquePtrFFIType
<span class="lineNum">    6133 </span><span class="lineNoCov">          0 : StructType::BuildFFIType(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    6134 </span>            : {
<span class="lineNum">    6135 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    6136 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_struct);</span>
<span class="lineNum">    6137 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsSizeDefined(obj));</span>
<span class="lineNum">    6138 </span>            : 
<span class="lineNum">    6139 </span><span class="lineNoCov">          0 :   const FieldInfoHash* fields = GetFieldInfo(obj);</span>
<span class="lineNum">    6140 </span><span class="lineNoCov">          0 :   size_t len = fields-&gt;count();</span>
<span class="lineNum">    6141 </span>            : 
<span class="lineNum">    6142 </span><span class="lineNoCov">          0 :   size_t structSize = CType::GetSize(obj);</span>
<span class="lineNum">    6143 </span><span class="lineNoCov">          0 :   size_t structAlign = CType::GetAlignment(obj);</span>
<span class="lineNum">    6144 </span>            : 
<span class="lineNum">    6145 </span><span class="lineNoCov">          0 :   auto ffiType = cx-&gt;make_unique&lt;ffi_type&gt;();</span>
<span class="lineNum">    6146 </span><span class="lineNoCov">          0 :   if (!ffiType) {</span>
<span class="lineNum">    6147 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6148 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6149 </span>            :   }
<span class="lineNum">    6150 </span><span class="lineNoCov">          0 :   ffiType-&gt;type = FFI_TYPE_STRUCT;</span>
<span class="lineNum">    6151 </span>            : 
<span class="lineNum">    6152 </span><span class="lineNoCov">          0 :   size_t count = len != 0 ? len + 1 : 2;</span>
<span class="lineNum">    6153 </span><span class="lineNoCov">          0 :   auto elements = cx-&gt;make_pod_array&lt;ffi_type*&gt;(count);</span>
<span class="lineNum">    6154 </span><span class="lineNoCov">          0 :   if (!elements) {</span>
<span class="lineNum">    6155 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6156 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6157 </span>            :   }
<span class="lineNum">    6158 </span>            : 
<span class="lineNum">    6159 </span><span class="lineNoCov">          0 :   if (len != 0) {</span>
<span class="lineNum">    6160 </span><span class="lineNoCov">          0 :     elements[len] = nullptr;</span>
<span class="lineNum">    6161 </span>            : 
<span class="lineNum">    6162 </span><span class="lineNoCov">          0 :     for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront()) {</span>
<span class="lineNum">    6163 </span><span class="lineNoCov">          0 :       const FieldInfoHash::Entry&amp; entry = r.front();</span>
<span class="lineNum">    6164 </span><span class="lineNoCov">          0 :       ffi_type* fieldType = CType::GetFFIType(cx, entry.value().mType);</span>
<span class="lineNum">    6165 </span><span class="lineNoCov">          0 :       if (!fieldType)</span>
<span class="lineNum">    6166 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">    6167 </span><span class="lineNoCov">          0 :       elements[entry.value().mIndex] = fieldType;</span>
<span class="lineNum">    6168 </span>            :     }
<span class="lineNum">    6169 </span>            :   } else {
<span class="lineNum">    6170 </span>            :     // Represent an empty struct as having a size of 1 byte, just like C++.
<span class="lineNum">    6171 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(structSize == 1);</span>
<span class="lineNum">    6172 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(structAlign == 1);</span>
<span class="lineNum">    6173 </span><span class="lineNoCov">          0 :     elements[0] = &amp;ffi_type_uint8;</span>
<span class="lineNum">    6174 </span><span class="lineNoCov">          0 :     elements[1] = nullptr;</span>
<span class="lineNum">    6175 </span>            :   }
<span class="lineNum">    6176 </span>            : 
<span class="lineNum">    6177 </span><span class="lineNoCov">          0 :   ffiType-&gt;elements = elements.release();</span>
<span class="lineNum">    6178 </span>            : 
<span class="lineNum">    6179 </span>            : #ifdef DEBUG
<span class="lineNum">    6180 </span>            :   // Perform a sanity check: the result of our struct size and alignment
<span class="lineNum">    6181 </span>            :   // calculations should match libffi's. We force it to do this calculation
<span class="lineNum">    6182 </span>            :   // by calling ffi_prep_cif.
<span class="lineNum">    6183 </span>            :   ffi_cif cif;
<span class="lineNum">    6184 </span><span class="lineNoCov">          0 :   ffiType-&gt;size = 0;</span>
<span class="lineNum">    6185 </span><span class="lineNoCov">          0 :   ffiType-&gt;alignment = 0;</span>
<span class="lineNum">    6186 </span><span class="lineNoCov">          0 :   ffi_status status = ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 0, ffiType.get(), nullptr);</span>
<span class="lineNum">    6187 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(status == FFI_OK);</span>
<span class="lineNum">    6188 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(structSize == ffiType-&gt;size);</span>
<span class="lineNum">    6189 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(structAlign == ffiType-&gt;alignment);</span>
<span class="lineNum">    6190 </span>            : #else
<span class="lineNum">    6191 </span>            :   // Fill in the ffi_type's size and align fields. This makes libffi treat the
<span class="lineNum">    6192 </span>            :   // type as initialized; it will not recompute the values. (We assume
<span class="lineNum">    6193 </span>            :   // everything agrees; if it doesn't, we really want to know about it, which
<span class="lineNum">    6194 </span>            :   // is the purpose of the above debug-only check.)
<span class="lineNum">    6195 </span>            :   ffiType-&gt;size = structSize;
<span class="lineNum">    6196 </span>            :   ffiType-&gt;alignment = structAlign;
<span class="lineNum">    6197 </span>            : #endif
<span class="lineNum">    6198 </span>            : 
<span class="lineNum">    6199 </span><span class="lineNoCov">          0 :   return Move(ffiType);</span>
<span class="lineNum">    6200 </span>            : }
<a name="6201"><span class="lineNum">    6201 </span>            : </a>
<span class="lineNum">    6202 </span>            : bool
<span class="lineNum">    6203 </span><span class="lineNoCov">          0 : StructType::Define(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    6204 </span>            : {
<span class="lineNum">    6205 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    6206 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    6207 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    6208 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6209 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj)) {</span>
<span class="lineNum">    6210 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType.prototype.define&quot;,</span>
<span class="lineNum">    6211 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    6212 </span>            :   }
<span class="lineNum">    6213 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(obj) != TYPE_struct) {</span>
<span class="lineNum">    6214 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;StructType.prototype.define&quot;,</span>
<span class="lineNum">    6215 </span><span class="lineNoCov">          0 :                                 &quot;non-StructType&quot;, args.thisv());</span>
<span class="lineNum">    6216 </span>            :   }
<span class="lineNum">    6217 </span>            : 
<span class="lineNum">    6218 </span><span class="lineNoCov">          0 :   if (CType::IsSizeDefined(obj)) {</span>
<span class="lineNum">    6219 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;StructType has already been defined&quot;);</span>
<span class="lineNum">    6220 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6221 </span>            :   }
<span class="lineNum">    6222 </span>            : 
<span class="lineNum">    6223 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    6224 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;StructType.prototype.define&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    6225 </span>            :   }
<span class="lineNum">    6226 </span>            : 
<span class="lineNum">    6227 </span><span class="lineNoCov">          0 :   HandleValue arg = args[0];</span>
<span class="lineNum">    6228 </span><span class="lineNoCov">          0 :   if (arg.isPrimitive()) {</span>
<span class="lineNum">    6229 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;StructType.prototype.define&quot;,</span>
<span class="lineNum">    6230 </span><span class="lineNoCov">          0 :                                 &quot;an array&quot;);</span>
<span class="lineNum">    6231 </span>            :   }
<span class="lineNum">    6232 </span>            : 
<span class="lineNum">    6233 </span>            :   bool isArray;
<span class="lineNum">    6234 </span><span class="lineNoCov">          0 :   if (!arg.isObject()) {</span>
<span class="lineNum">    6235 </span><span class="lineNoCov">          0 :     isArray = false;</span>
<span class="lineNum">    6236 </span>            :   } else {
<span class="lineNum">    6237 </span><span class="lineNoCov">          0 :     if (!JS_IsArrayObject(cx, arg, &amp;isArray))</span>
<span class="lineNum">    6238 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6239 </span>            :   }
<span class="lineNum">    6240 </span>            : 
<span class="lineNum">    6241 </span><span class="lineNoCov">          0 :   if (!isArray) {</span>
<span class="lineNum">    6242 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;StructType.prototype.define&quot;,</span>
<span class="lineNum">    6243 </span><span class="lineNoCov">          0 :                                 &quot;an array&quot;);</span>
<span class="lineNum">    6244 </span>            :   }
<span class="lineNum">    6245 </span>            : 
<span class="lineNum">    6246 </span><span class="lineNoCov">          0 :   RootedObject arr(cx, &amp;arg.toObject());</span>
<span class="lineNum">    6247 </span><span class="lineNoCov">          0 :   return DefineInternal(cx, obj, arr);</span>
<span class="lineNum">    6248 </span>            : }
<a name="6249"><span class="lineNum">    6249 </span>            : </a>
<span class="lineNum">    6250 </span>            : bool
<span class="lineNum">    6251 </span><span class="lineNoCov">          0 : StructType::ConstructData(JSContext* cx,</span>
<span class="lineNum">    6252 </span>            :                           HandleObject obj,
<span class="lineNum">    6253 </span>            :                           const CallArgs&amp; args)
<span class="lineNum">    6254 </span>            : {
<span class="lineNum">    6255 </span><span class="lineNoCov">          0 :   if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_struct) {</span>
<span class="lineNum">    6256 </span><span class="lineNoCov">          0 :     return IncompatibleCallee(cx, &quot;StructType constructor&quot;, obj);</span>
<span class="lineNum">    6257 </span>            :   }
<span class="lineNum">    6258 </span>            : 
<span class="lineNum">    6259 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(obj)) {</span>
<span class="lineNum">    6260 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;cannot construct an opaque StructType&quot;);</span>
<span class="lineNum">    6261 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6262 </span>            :   }
<span class="lineNum">    6263 </span>            : 
<span class="lineNum">    6264 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, obj, nullptr, nullptr, true);</span>
<span class="lineNum">    6265 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    6266 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6267 </span>            : 
<span class="lineNum">    6268 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    6269 </span>            : 
<span class="lineNum">    6270 </span><span class="lineNoCov">          0 :   if (args.length() == 0)</span>
<span class="lineNum">    6271 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6272 </span>            : 
<span class="lineNum">    6273 </span><span class="lineNoCov">          0 :   char* buffer = static_cast&lt;char*&gt;(CData::GetData(result));</span>
<span class="lineNum">    6274 </span><span class="lineNoCov">          0 :   const FieldInfoHash* fields = GetFieldInfo(obj);</span>
<span class="lineNum">    6275 </span>            : 
<span class="lineNum">    6276 </span><span class="lineNoCov">          0 :   if (args.length() == 1) {</span>
<span class="lineNum">    6277 </span>            :     // There are two possible interpretations of the argument:
<span class="lineNum">    6278 </span>            :     // 1) It may be an object '{ ... }' with properties representing the
<span class="lineNum">    6279 </span>            :     //    struct fields intended to ExplicitConvert wholesale to our StructType.
<span class="lineNum">    6280 </span>            :     // 2) If the struct contains one field, the arg may be intended to
<span class="lineNum">    6281 </span>            :     //    ImplicitConvert directly to that arg's CType.
<span class="lineNum">    6282 </span>            :     // Thankfully, the conditions for these two possibilities to succeed
<span class="lineNum">    6283 </span>            :     // are mutually exclusive, so we can pick the right one.
<span class="lineNum">    6284 </span>            : 
<span class="lineNum">    6285 </span>            :     // Try option 1) first.
<span class="lineNum">    6286 </span><span class="lineNoCov">          0 :     if (ExplicitConvert(cx, args[0], obj, buffer, ConversionType::Construct))</span>
<span class="lineNum">    6287 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    6288 </span>            : 
<span class="lineNum">    6289 </span><span class="lineNoCov">          0 :     if (fields-&gt;count() != 1)</span>
<span class="lineNum">    6290 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6291 </span>            : 
<span class="lineNum">    6292 </span>            :     // If ExplicitConvert failed, and there is no pending exception, then assume
<span class="lineNum">    6293 </span>            :     // hard failure (out of memory, or some other similarly serious condition).
<span class="lineNum">    6294 </span><span class="lineNoCov">          0 :     if (!JS_IsExceptionPending(cx))</span>
<span class="lineNum">    6295 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6296 </span>            : 
<span class="lineNum">    6297 </span>            :     // Otherwise, assume soft failure, and clear the pending exception so that we
<span class="lineNum">    6298 </span>            :     // can throw a different one as required.
<span class="lineNum">    6299 </span><span class="lineNoCov">          0 :     JS_ClearPendingException(cx);</span>
<span class="lineNum">    6300 </span>            : 
<span class="lineNum">    6301 </span>            :     // Fall through to try option 2).
<span class="lineNum">    6302 </span>            :   }
<span class="lineNum">    6303 </span>            : 
<span class="lineNum">    6304 </span>            :   // We have a type constructor of the form 'ctypes.StructType(a, b, c, ...)'.
<span class="lineNum">    6305 </span>            :   // ImplicitConvert each field.
<span class="lineNum">    6306 </span><span class="lineNoCov">          0 :   if (args.length() == fields-&gt;count()) {</span>
<span class="lineNum">    6307 </span><span class="lineNoCov">          0 :     for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront()) {</span>
<span class="lineNum">    6308 </span><span class="lineNoCov">          0 :       const FieldInfo&amp; field = r.front().value();</span>
<span class="lineNum">    6309 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(field.mIndex &lt; fields-&gt;count());  /* Quantified invariant */</span>
<span class="lineNum">    6310 </span><span class="lineNoCov">          0 :       if (!ImplicitConvert(cx, args[field.mIndex], field.mType,</span>
<span class="lineNum">    6311 </span><span class="lineNoCov">          0 :                            buffer + field.mOffset, ConversionType::Construct,</span>
<span class="lineNum">    6312 </span><span class="lineNoCov">          0 :                            nullptr, nullptr, 0, obj, field.mIndex))</span>
<span class="lineNum">    6313 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6314 </span>            :     }
<span class="lineNum">    6315 </span>            : 
<span class="lineNum">    6316 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6317 </span>            :   }
<span class="lineNum">    6318 </span>            : 
<span class="lineNum">    6319 </span><span class="lineNoCov">          0 :   size_t count = fields-&gt;count();</span>
<span class="lineNum">    6320 </span><span class="lineNoCov">          0 :   if (count &gt;= 2) {</span>
<span class="lineNum">    6321 </span>            :     char fieldLengthStr[32];
<span class="lineNum">    6322 </span><span class="lineNoCov">          0 :     SprintfLiteral(fieldLengthStr, &quot;0, 1, or %&quot; PRIuSIZE, count);</span>
<span class="lineNum">    6323 </span>            :     return ArgumentLengthError(cx, &quot;StructType constructor&quot;, fieldLengthStr,
<span class="lineNum">    6324 </span><span class="lineNoCov">          0 :                                &quot;s&quot;);</span>
<span class="lineNum">    6325 </span>            :   }
<span class="lineNum">    6326 </span><span class="lineNoCov">          0 :   return ArgumentLengthError(cx, &quot;StructType constructor&quot;, &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    6327 </span>            : }
<a name="6328"><span class="lineNum">    6328 </span>            : </a>
<span class="lineNum">    6329 </span>            : const FieldInfoHash*
<span class="lineNum">    6330 </span><span class="lineNoCov">          0 : StructType::GetFieldInfo(JSObject* obj)</span>
<span class="lineNum">    6331 </span>            : {
<span class="lineNum">    6332 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    6333 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_struct);</span>
<span class="lineNum">    6334 </span>            : 
<span class="lineNum">    6335 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_FIELDINFO);</span>
<span class="lineNum">    6336 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!slot.isUndefined() &amp;&amp; slot.toPrivate());</span>
<span class="lineNum">    6337 </span>            : 
<span class="lineNum">    6338 </span><span class="lineNoCov">          0 :   return static_cast&lt;const FieldInfoHash*&gt;(slot.toPrivate());</span>
<span class="lineNum">    6339 </span>            : }
<a name="6340"><span class="lineNum">    6340 </span>            : </a>
<span class="lineNum">    6341 </span>            : const FieldInfo*
<span class="lineNum">    6342 </span><span class="lineNoCov">          0 : StructType::LookupField(JSContext* cx, JSObject* obj, JSFlatString* name)</span>
<span class="lineNum">    6343 </span>            : {
<span class="lineNum">    6344 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    6345 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_struct);</span>
<span class="lineNum">    6346 </span>            : 
<span class="lineNum">    6347 </span><span class="lineNoCov">          0 :   FieldInfoHash::Ptr ptr = GetFieldInfo(obj)-&gt;lookup(name);</span>
<span class="lineNum">    6348 </span><span class="lineNoCov">          0 :   if (ptr)</span>
<span class="lineNum">    6349 </span><span class="lineNoCov">          0 :     return &amp;ptr-&gt;value();</span>
<span class="lineNum">    6350 </span>            : 
<span class="lineNum">    6351 </span><span class="lineNoCov">          0 :   FieldMissingError(cx, obj, name);</span>
<span class="lineNum">    6352 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">    6353 </span>            : }
<a name="6354"><span class="lineNum">    6354 </span>            : </a>
<span class="lineNum">    6355 </span>            : JSObject*
<span class="lineNum">    6356 </span><span class="lineNoCov">          0 : StructType::BuildFieldsArray(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    6357 </span>            : {
<span class="lineNum">    6358 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    6359 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_struct);</span>
<span class="lineNum">    6360 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsSizeDefined(obj));</span>
<span class="lineNum">    6361 </span>            : 
<span class="lineNum">    6362 </span><span class="lineNoCov">          0 :   const FieldInfoHash* fields = GetFieldInfo(obj);</span>
<span class="lineNum">    6363 </span><span class="lineNoCov">          0 :   size_t len = fields-&gt;count();</span>
<span class="lineNum">    6364 </span>            : 
<span class="lineNum">    6365 </span>            :   // Prepare a new array for the 'fields' property of the StructType.
<span class="lineNum">    6366 </span><span class="lineNoCov">          0 :   JS::AutoValueVector fieldsVec(cx);</span>
<span class="lineNum">    6367 </span><span class="lineNoCov">          0 :   if (!fieldsVec.resize(len))</span>
<span class="lineNum">    6368 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6369 </span>            : 
<span class="lineNum">    6370 </span><span class="lineNoCov">          0 :   for (FieldInfoHash::Range r = fields-&gt;all(); !r.empty(); r.popFront()) {</span>
<span class="lineNum">    6371 </span><span class="lineNoCov">          0 :     const FieldInfoHash::Entry&amp; entry = r.front();</span>
<span class="lineNum">    6372 </span>            :     // Add the field descriptor to the array.
<span class="lineNum">    6373 </span><span class="lineNoCov">          0 :     if (!AddFieldToArray(cx, fieldsVec[entry.value().mIndex],</span>
<span class="lineNum">    6374 </span><span class="lineNoCov">          0 :                          entry.key(), entry.value().mType))</span>
<span class="lineNum">    6375 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    6376 </span>            :   }
<span class="lineNum">    6377 </span>            : 
<span class="lineNum">    6378 </span><span class="lineNoCov">          0 :   RootedObject fieldsProp(cx, JS_NewArrayObject(cx, fieldsVec));</span>
<span class="lineNum">    6379 </span><span class="lineNoCov">          0 :   if (!fieldsProp)</span>
<span class="lineNum">    6380 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6381 </span>            : 
<span class="lineNum">    6382 </span>            :   // Seal the fields array.
<span class="lineNum">    6383 </span><span class="lineNoCov">          0 :   if (!JS_FreezeObject(cx, fieldsProp))</span>
<span class="lineNum">    6384 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6385 </span>            : 
<span class="lineNum">    6386 </span><span class="lineNoCov">          0 :   return fieldsProp;</span>
<span class="lineNum">    6387 </span>            : }
<a name="6388"><span class="lineNum">    6388 </span>            : </a>
<span class="lineNum">    6389 </span>            : /* static */ bool
<span class="lineNum">    6390 </span><span class="lineNoCov">          0 : StructType::IsStruct(HandleValue v)</span>
<span class="lineNum">    6391 </span>            : {
<span class="lineNum">    6392 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    6393 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6394 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    6395 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) &amp;&amp; CType::GetTypeCode(obj) == TYPE_struct;</span>
<span class="lineNum">    6396 </span>            : }
<a name="6397"><span class="lineNum">    6397 </span>            : </a>
<span class="lineNum">    6398 </span>            : bool
<span class="lineNum">    6399 </span><span class="lineNoCov">          0 : StructType::FieldsArrayGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    6400 </span>            : {
<span class="lineNum">    6401 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    6402 </span>            : 
<span class="lineNum">    6403 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_FIELDS));</span>
<span class="lineNum">    6404 </span>            : 
<span class="lineNum">    6405 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(obj)) {</span>
<span class="lineNum">    6406 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(args.rval().isUndefined());</span>
<span class="lineNum">    6407 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6408 </span>            :   }
<span class="lineNum">    6409 </span>            : 
<span class="lineNum">    6410 </span><span class="lineNoCov">          0 :   if (args.rval().isUndefined()) {</span>
<span class="lineNum">    6411 </span>            :     // Build the 'fields' array lazily.
<span class="lineNum">    6412 </span><span class="lineNoCov">          0 :     JSObject* fields = BuildFieldsArray(cx, obj);</span>
<span class="lineNum">    6413 </span><span class="lineNoCov">          0 :     if (!fields)</span>
<span class="lineNum">    6414 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6415 </span><span class="lineNoCov">          0 :     JS_SetReservedSlot(obj, SLOT_FIELDS, ObjectValue(*fields));</span>
<span class="lineNum">    6416 </span>            : 
<span class="lineNum">    6417 </span><span class="lineNoCov">          0 :     args.rval().setObject(*fields);</span>
<span class="lineNum">    6418 </span>            :   }
<span class="lineNum">    6419 </span>            : 
<span class="lineNum">    6420 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args.rval().isObject());</span>
<span class="lineNum">    6421 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6422 </span>            : }
<a name="6423"><span class="lineNum">    6423 </span>            : </a>
<span class="lineNum">    6424 </span>            : bool
<span class="lineNum">    6425 </span><span class="lineNoCov">          0 : StructType::FieldGetter(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    6426 </span>            : {
<span class="lineNum">    6427 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    6428 </span>            : 
<span class="lineNum">    6429 </span><span class="lineNoCov">          0 :   if (!args.thisv().isObject()) {</span>
<span class="lineNum">    6430 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType property getter&quot;, args.thisv());</span>
<span class="lineNum">    6431 </span>            :   }
<span class="lineNum">    6432 </span>            : 
<span class="lineNum">    6433 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    6434 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    6435 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType property getter&quot;, args.thisv());</span>
<span class="lineNum">    6436 </span>            :   }
<span class="lineNum">    6437 </span>            : 
<span class="lineNum">    6438 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    6439 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_struct) {</span>
<span class="lineNum">    6440 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;StructType property getter&quot;,</span>
<span class="lineNum">    6441 </span><span class="lineNoCov">          0 :                                 &quot;non-StructType CData&quot;, args.thisv());</span>
<span class="lineNum">    6442 </span>            :   }
<span class="lineNum">    6443 </span>            : 
<span class="lineNum">    6444 </span><span class="lineNoCov">          0 :   RootedValue nameVal(cx, GetFunctionNativeReserved(&amp;args.callee(), SLOT_FIELDNAME));</span>
<span class="lineNum">    6445 </span><span class="lineNoCov">          0 :   Rooted&lt;JSFlatString*&gt; name(cx, JS_FlattenString(cx, nameVal.toString()));</span>
<span class="lineNum">    6446 </span><span class="lineNoCov">          0 :   if (!name)</span>
<span class="lineNum">    6447 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6448 </span>            : 
<span class="lineNum">    6449 </span><span class="lineNoCov">          0 :   const FieldInfo* field = LookupField(cx, typeObj, name);</span>
<span class="lineNum">    6450 </span><span class="lineNoCov">          0 :   if (!field)</span>
<span class="lineNum">    6451 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6452 </span>            : 
<span class="lineNum">    6453 </span><span class="lineNoCov">          0 :   char* data = static_cast&lt;char*&gt;(CData::GetData(obj)) + field-&gt;mOffset;</span>
<span class="lineNum">    6454 </span><span class="lineNoCov">          0 :   RootedObject fieldType(cx, field-&gt;mType);</span>
<span class="lineNum">    6455 </span><span class="lineNoCov">          0 :   return ConvertToJS(cx, fieldType, obj, data, false, false, args.rval());</span>
<span class="lineNum">    6456 </span>            : }
<a name="6457"><span class="lineNum">    6457 </span>            : </a>
<span class="lineNum">    6458 </span>            : bool
<span class="lineNum">    6459 </span><span class="lineNoCov">          0 : StructType::FieldSetter(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    6460 </span>            : {
<span class="lineNum">    6461 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    6462 </span>            : 
<span class="lineNum">    6463 </span><span class="lineNoCov">          0 :   if (!args.thisv().isObject()) {</span>
<span class="lineNum">    6464 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType property setter&quot;, args.thisv());</span>
<span class="lineNum">    6465 </span>            :   }
<span class="lineNum">    6466 </span>            : 
<span class="lineNum">    6467 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    6468 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    6469 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType property setter&quot;, args.thisv());</span>
<span class="lineNum">    6470 </span>            :   }
<span class="lineNum">    6471 </span>            : 
<span class="lineNum">    6472 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    6473 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_struct) {</span>
<span class="lineNum">    6474 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;StructType property setter&quot;,</span>
<span class="lineNum">    6475 </span><span class="lineNoCov">          0 :                                 &quot;non-StructType CData&quot;, args.thisv());</span>
<span class="lineNum">    6476 </span>            :   }
<span class="lineNum">    6477 </span>            : 
<span class="lineNum">    6478 </span><span class="lineNoCov">          0 :   RootedValue nameVal(cx, GetFunctionNativeReserved(&amp;args.callee(), SLOT_FIELDNAME));</span>
<span class="lineNum">    6479 </span><span class="lineNoCov">          0 :   Rooted&lt;JSFlatString*&gt; name(cx, JS_FlattenString(cx, nameVal.toString()));</span>
<span class="lineNum">    6480 </span><span class="lineNoCov">          0 :   if (!name)</span>
<span class="lineNum">    6481 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6482 </span>            : 
<span class="lineNum">    6483 </span><span class="lineNoCov">          0 :   const FieldInfo* field = LookupField(cx, typeObj, name);</span>
<span class="lineNum">    6484 </span><span class="lineNoCov">          0 :   if (!field)</span>
<span class="lineNum">    6485 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6486 </span>            : 
<span class="lineNum">    6487 </span><span class="lineNoCov">          0 :   args.rval().setUndefined();</span>
<span class="lineNum">    6488 </span>            : 
<span class="lineNum">    6489 </span><span class="lineNoCov">          0 :   char* data = static_cast&lt;char*&gt;(CData::GetData(obj)) + field-&gt;mOffset;</span>
<span class="lineNum">    6490 </span><span class="lineNoCov">          0 :   return ImplicitConvert(cx, args.get(0), field-&gt;mType, data, ConversionType::Setter, nullptr,</span>
<span class="lineNum">    6491 </span><span class="lineNoCov">          0 :                          nullptr, 0, typeObj, field-&gt;mIndex);</span>
<span class="lineNum">    6492 </span>            : }
<a name="6493"><span class="lineNum">    6493 </span>            : </a>
<span class="lineNum">    6494 </span>            : bool
<span class="lineNum">    6495 </span><span class="lineNoCov">          0 : StructType::AddressOfField(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    6496 </span>            : {
<span class="lineNum">    6497 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    6498 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    6499 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    6500 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6501 </span><span class="lineNoCov">          0 :  if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    6502 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;StructType.prototype.addressOfField&quot;,</span>
<span class="lineNum">    6503 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    6504 </span>            :   }
<span class="lineNum">    6505 </span>            : 
<span class="lineNum">    6506 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    6507 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_struct) {</span>
<span class="lineNum">    6508 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;StructType.prototype.addressOfField&quot;,</span>
<span class="lineNum">    6509 </span><span class="lineNoCov">          0 :                                 &quot;non-StructType CData&quot;, args.thisv());</span>
<span class="lineNum">    6510 </span>            :   }
<span class="lineNum">    6511 </span>            : 
<span class="lineNum">    6512 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    6513 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;StructType.prototype.addressOfField&quot;,</span>
<span class="lineNum">    6514 </span><span class="lineNoCov">          0 :                                &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    6515 </span>            :   }
<span class="lineNum">    6516 </span>            : 
<span class="lineNum">    6517 </span><span class="lineNoCov">          0 :   if (!args[0].isString()) {</span>
<span class="lineNum">    6518 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;StructType.prototype.addressOfField&quot;,</span>
<span class="lineNum">    6519 </span><span class="lineNoCov">          0 :                                 &quot;a string&quot;);</span>
<span class="lineNum">    6520 </span>            :   }
<span class="lineNum">    6521 </span>            : 
<span class="lineNum">    6522 </span><span class="lineNoCov">          0 :   JSFlatString* str = JS_FlattenString(cx, args[0].toString());</span>
<span class="lineNum">    6523 </span><span class="lineNoCov">          0 :   if (!str)</span>
<span class="lineNum">    6524 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6525 </span>            : 
<span class="lineNum">    6526 </span><span class="lineNoCov">          0 :   const FieldInfo* field = LookupField(cx, typeObj, str);</span>
<span class="lineNum">    6527 </span><span class="lineNoCov">          0 :   if (!field)</span>
<span class="lineNum">    6528 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6529 </span>            : 
<span class="lineNum">    6530 </span><span class="lineNoCov">          0 :   RootedObject baseType(cx, field-&gt;mType);</span>
<span class="lineNum">    6531 </span><span class="lineNoCov">          0 :   RootedObject pointerType(cx, PointerType::CreateInternal(cx, baseType));</span>
<span class="lineNum">    6532 </span><span class="lineNoCov">          0 :   if (!pointerType)</span>
<span class="lineNum">    6533 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6534 </span>            : 
<span class="lineNum">    6535 </span>            :   // Create a PointerType CData object containing null.
<span class="lineNum">    6536 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, pointerType, nullptr, nullptr, true);</span>
<span class="lineNum">    6537 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    6538 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6539 </span>            : 
<span class="lineNum">    6540 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    6541 </span>            : 
<span class="lineNum">    6542 </span>            :   // Manually set the pointer inside the object, so we skip the conversion step.
<span class="lineNum">    6543 </span><span class="lineNoCov">          0 :   void** data = static_cast&lt;void**&gt;(CData::GetData(result));</span>
<span class="lineNum">    6544 </span><span class="lineNoCov">          0 :   *data = static_cast&lt;char*&gt;(CData::GetData(obj)) + field-&gt;mOffset;</span>
<span class="lineNum">    6545 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6546 </span>            : }
<span class="lineNum">    6547 </span>            : 
<span class="lineNum">    6548 </span>            : /*******************************************************************************
<span class="lineNum">    6549 </span>            : ** FunctionType implementation
<span class="lineNum">    6550 </span>            : *******************************************************************************/
<span class="lineNum">    6551 </span>            : 
<span class="lineNum">    6552 </span>            : // Helper class for handling allocation of function arguments.
<a name="6553"><span class="lineNum">    6553 </span>            : struct AutoValue</a>
<span class="lineNum">    6554 </span>            : {
<a name="6555"><span class="lineNum">    6555 </span><span class="lineNoCov">          0 :   AutoValue() : mData(nullptr) { }</span></a>
<span class="lineNum">    6556 </span>            : 
<span class="lineNum">    6557 </span><span class="lineNoCov">          0 :   ~AutoValue()</span>
<span class="lineNum">    6558 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    6559 </span><span class="lineNoCov">          0 :     js_free(mData);</span>
<a name="6560"><span class="lineNum">    6560 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    6561 </span>            : 
<span class="lineNum">    6562 </span><span class="lineNoCov">          0 :   bool SizeToType(JSContext* cx, JSObject* type)</span>
<span class="lineNum">    6563 </span>            :   {
<span class="lineNum">    6564 </span>            :     // Allocate a minimum of sizeof(ffi_arg) to handle small integers.
<span class="lineNum">    6565 </span><span class="lineNoCov">          0 :     size_t size = Align(CType::GetSize(type), sizeof(ffi_arg));</span>
<span class="lineNum">    6566 </span><span class="lineNoCov">          0 :     mData = js_malloc(size);</span>
<span class="lineNum">    6567 </span><span class="lineNoCov">          0 :     if (mData)</span>
<span class="lineNum">    6568 </span><span class="lineNoCov">          0 :       memset(mData, 0, size);</span>
<span class="lineNum">    6569 </span><span class="lineNoCov">          0 :     return mData != nullptr;</span>
<span class="lineNum">    6570 </span>            :   }
<span class="lineNum">    6571 </span>            : 
<span class="lineNum">    6572 </span>            :   void* mData;
<span class="lineNum">    6573 </span>            : };
<a name="6574"><span class="lineNum">    6574 </span>            : </a>
<span class="lineNum">    6575 </span>            : static bool
<span class="lineNum">    6576 </span><span class="lineNoCov">          0 : GetABI(JSContext* cx, HandleValue abiType, ffi_abi* result)</span>
<span class="lineNum">    6577 </span>            : {
<span class="lineNum">    6578 </span><span class="lineNoCov">          0 :   if (abiType.isPrimitive())</span>
<span class="lineNum">    6579 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6580 </span>            : 
<span class="lineNum">    6581 </span><span class="lineNoCov">          0 :   ABICode abi = GetABICode(abiType.toObjectOrNull());</span>
<span class="lineNum">    6582 </span>            : 
<span class="lineNum">    6583 </span>            :   // determine the ABI from the subset of those available on the
<span class="lineNum">    6584 </span>            :   // given platform. ABI_DEFAULT specifies the default
<span class="lineNum">    6585 </span>            :   // C calling convention (cdecl) on each platform.
<span class="lineNum">    6586 </span><span class="lineNoCov">          0 :   switch (abi) {</span>
<span class="lineNum">    6587 </span>            :   case ABI_DEFAULT:
<span class="lineNum">    6588 </span><span class="lineNoCov">          0 :     *result = FFI_DEFAULT_ABI;</span>
<span class="lineNum">    6589 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6590 </span>            :   case ABI_THISCALL:
<span class="lineNum">    6591 </span>            : #if defined(_WIN64)
<span class="lineNum">    6592 </span>            :     *result = FFI_WIN64;
<span class="lineNum">    6593 </span>            :     return true;
<span class="lineNum">    6594 </span>            : #elif defined(_WIN32)
<span class="lineNum">    6595 </span>            :     *result = FFI_THISCALL;
<span class="lineNum">    6596 </span>            :     return true;
<span class="lineNum">    6597 </span>            : #else
<span class="lineNum">    6598 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    6599 </span>            : #endif
<span class="lineNum">    6600 </span>            :   case ABI_STDCALL:
<span class="lineNum">    6601 </span>            :   case ABI_WINAPI:
<span class="lineNum">    6602 </span>            : #if (defined(_WIN32) &amp;&amp; !defined(_WIN64)) || defined(_OS2)
<span class="lineNum">    6603 </span>            :     *result = FFI_STDCALL;
<span class="lineNum">    6604 </span>            :     return true;
<span class="lineNum">    6605 </span>            : #elif (defined(_WIN64))
<span class="lineNum">    6606 </span>            :     // We'd like the same code to work across Win32 and Win64, so stdcall_api
<span class="lineNum">    6607 </span>            :     // and winapi_abi become aliases to the lone Win64 ABI.
<span class="lineNum">    6608 </span>            :     *result = FFI_WIN64;
<span class="lineNum">    6609 </span>            :     return true;
<span class="lineNum">    6610 </span>            : #endif
<span class="lineNum">    6611 </span>            :   case INVALID_ABI:
<span class="lineNum">    6612 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    6613 </span>            :   }
<span class="lineNum">    6614 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    6615 </span>            : }
<a name="6616"><span class="lineNum">    6616 </span>            : </a>
<span class="lineNum">    6617 </span>            : static JSObject*
<span class="lineNum">    6618 </span><span class="lineNoCov">          0 : PrepareType(JSContext* cx, uint32_t index, HandleValue type)</span>
<span class="lineNum">    6619 </span>            : {
<span class="lineNum">    6620 </span><span class="lineNoCov">          0 :   if (type.isPrimitive() || !CType::IsCType(type.toObjectOrNull())) {</span>
<span class="lineNum">    6621 </span><span class="lineNoCov">          0 :     FunctionArgumentTypeError(cx, index, type, &quot;is not a ctypes type&quot;);</span>
<span class="lineNum">    6622 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6623 </span>            :   }
<span class="lineNum">    6624 </span>            : 
<span class="lineNum">    6625 </span><span class="lineNoCov">          0 :   JSObject* result = type.toObjectOrNull();</span>
<span class="lineNum">    6626 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(result);</span>
<span class="lineNum">    6627 </span>            : 
<span class="lineNum">    6628 </span><span class="lineNoCov">          0 :   if (typeCode == TYPE_array) {</span>
<span class="lineNum">    6629 </span>            :     // convert array argument types to pointers, just like C.
<span class="lineNum">    6630 </span>            :     // ImplicitConvert will do the same, when passing an array as data.
<span class="lineNum">    6631 </span><span class="lineNoCov">          0 :     RootedObject baseType(cx, ArrayType::GetBaseType(result));</span>
<span class="lineNum">    6632 </span><span class="lineNoCov">          0 :     result = PointerType::CreateInternal(cx, baseType);</span>
<span class="lineNum">    6633 </span><span class="lineNoCov">          0 :     if (!result)</span>
<span class="lineNum">    6634 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    6635 </span>            : 
<span class="lineNum">    6636 </span><span class="lineNoCov">          0 :   } else if (typeCode == TYPE_void_t || typeCode == TYPE_function) {</span>
<span class="lineNum">    6637 </span>            :     // disallow void or function argument types
<span class="lineNum">    6638 </span><span class="lineNoCov">          0 :     FunctionArgumentTypeError(cx, index, type, &quot;cannot be void or function&quot;);</span>
<span class="lineNum">    6639 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6640 </span>            :   }
<span class="lineNum">    6641 </span>            : 
<span class="lineNum">    6642 </span><span class="lineNoCov">          0 :   if (!CType::IsSizeDefined(result)) {</span>
<span class="lineNum">    6643 </span><span class="lineNoCov">          0 :     FunctionArgumentTypeError(cx, index, type, &quot;must have defined size&quot;);</span>
<span class="lineNum">    6644 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6645 </span>            :   }
<span class="lineNum">    6646 </span>            : 
<span class="lineNum">    6647 </span>            :   // libffi cannot pass types of zero size by value.
<span class="lineNum">    6648 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetSize(result) != 0);</span>
<span class="lineNum">    6649 </span>            : 
<span class="lineNum">    6650 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    6651 </span>            : }
<a name="6652"><span class="lineNum">    6652 </span>            : </a>
<span class="lineNum">    6653 </span>            : static JSObject*
<span class="lineNum">    6654 </span><span class="lineNoCov">          0 : PrepareReturnType(JSContext* cx, HandleValue type)</span>
<span class="lineNum">    6655 </span>            : {
<span class="lineNum">    6656 </span><span class="lineNoCov">          0 :   if (type.isPrimitive() || !CType::IsCType(type.toObjectOrNull())) {</span>
<span class="lineNum">    6657 </span><span class="lineNoCov">          0 :     FunctionReturnTypeError(cx, type, &quot;is not a ctypes type&quot;);</span>
<span class="lineNum">    6658 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6659 </span>            :   }
<span class="lineNum">    6660 </span>            : 
<span class="lineNum">    6661 </span><span class="lineNoCov">          0 :   JSObject* result = type.toObjectOrNull();</span>
<span class="lineNum">    6662 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(result);</span>
<span class="lineNum">    6663 </span>            : 
<span class="lineNum">    6664 </span>            :   // Arrays and functions can never be return types.
<span class="lineNum">    6665 </span><span class="lineNoCov">          0 :   if (typeCode == TYPE_array || typeCode == TYPE_function) {</span>
<span class="lineNum">    6666 </span><span class="lineNoCov">          0 :     FunctionReturnTypeError(cx, type, &quot;cannot be an array or function&quot;);</span>
<span class="lineNum">    6667 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6668 </span>            :   }
<span class="lineNum">    6669 </span>            : 
<span class="lineNum">    6670 </span><span class="lineNoCov">          0 :   if (typeCode != TYPE_void_t &amp;&amp; !CType::IsSizeDefined(result)) {</span>
<span class="lineNum">    6671 </span><span class="lineNoCov">          0 :     FunctionReturnTypeError(cx, type, &quot;must have defined size&quot;);</span>
<span class="lineNum">    6672 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6673 </span>            :   }
<span class="lineNum">    6674 </span>            : 
<span class="lineNum">    6675 </span>            :   // libffi cannot pass types of zero size by value.
<span class="lineNum">    6676 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(typeCode == TYPE_void_t || CType::GetSize(result) != 0);</span>
<span class="lineNum">    6677 </span>            : 
<span class="lineNum">    6678 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    6679 </span>            : }
<a name="6680"><span class="lineNum">    6680 </span>            : </a>
<span class="lineNum">    6681 </span>            : static MOZ_ALWAYS_INLINE bool
<span class="lineNum">    6682 </span><span class="lineNoCov">          0 : IsEllipsis(JSContext* cx, HandleValue v, bool* isEllipsis)</span>
<span class="lineNum">    6683 </span>            : {
<span class="lineNum">    6684 </span><span class="lineNoCov">          0 :   *isEllipsis = false;</span>
<span class="lineNum">    6685 </span><span class="lineNoCov">          0 :   if (!v.isString())</span>
<span class="lineNum">    6686 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6687 </span><span class="lineNoCov">          0 :   JSString* str = v.toString();</span>
<span class="lineNum">    6688 </span><span class="lineNoCov">          0 :   if (str-&gt;length() != 3)</span>
<span class="lineNum">    6689 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6690 </span><span class="lineNoCov">          0 :   JSLinearString* linear = str-&gt;ensureLinear(cx);</span>
<span class="lineNum">    6691 </span><span class="lineNoCov">          0 :   if (!linear)</span>
<span class="lineNum">    6692 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6693 </span><span class="lineNoCov">          0 :   char16_t dot = '.';</span>
<span class="lineNum">    6694 </span><span class="lineNoCov">          0 :   *isEllipsis = (linear-&gt;latin1OrTwoByteChar(0) == dot &amp;&amp;</span>
<span class="lineNum">    6695 </span><span class="lineNoCov">          0 :                  linear-&gt;latin1OrTwoByteChar(1) == dot &amp;&amp;</span>
<span class="lineNum">    6696 </span><span class="lineNoCov">          0 :                  linear-&gt;latin1OrTwoByteChar(2) == dot);</span>
<span class="lineNum">    6697 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6698 </span>            : }
<a name="6699"><span class="lineNum">    6699 </span>            : </a>
<span class="lineNum">    6700 </span>            : static bool
<span class="lineNum">    6701 </span><span class="lineNoCov">          0 : PrepareCIF(JSContext* cx,</span>
<span class="lineNum">    6702 </span>            :            FunctionInfo* fninfo)
<span class="lineNum">    6703 </span>            : {
<span class="lineNum">    6704 </span>            :   ffi_abi abi;
<span class="lineNum">    6705 </span><span class="lineNoCov">          0 :   RootedValue abiType(cx, ObjectOrNullValue(fninfo-&gt;mABI));</span>
<span class="lineNum">    6706 </span><span class="lineNoCov">          0 :   if (!GetABI(cx, abiType, &amp;abi)) {</span>
<span class="lineNum">    6707 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Invalid ABI specification&quot;);</span>
<span class="lineNum">    6708 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6709 </span>            :   }
<span class="lineNum">    6710 </span>            : 
<span class="lineNum">    6711 </span><span class="lineNoCov">          0 :   ffi_type* rtype = CType::GetFFIType(cx, fninfo-&gt;mReturnType);</span>
<span class="lineNum">    6712 </span><span class="lineNoCov">          0 :   if (!rtype)</span>
<span class="lineNum">    6713 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6714 </span>            : 
<span class="lineNum">    6715 </span>            :   ffi_status status =
<span class="lineNum">    6716 </span><span class="lineNoCov">          0 :     ffi_prep_cif(&amp;fninfo-&gt;mCIF,</span>
<span class="lineNum">    6717 </span>            :                  abi,
<span class="lineNum">    6718 </span><span class="lineNoCov">          0 :                  fninfo-&gt;mFFITypes.length(),</span>
<span class="lineNum">    6719 </span>            :                  rtype,
<span class="lineNum">    6720 </span><span class="lineNoCov">          0 :                  fninfo-&gt;mFFITypes.begin());</span>
<span class="lineNum">    6721 </span>            : 
<span class="lineNum">    6722 </span><span class="lineNoCov">          0 :   switch (status) {</span>
<span class="lineNum">    6723 </span>            :   case FFI_OK:
<span class="lineNum">    6724 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6725 </span>            :   case FFI_BAD_ABI:
<span class="lineNum">    6726 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Invalid ABI specification&quot;);</span>
<span class="lineNum">    6727 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6728 </span>            :   case FFI_BAD_TYPEDEF:
<span class="lineNum">    6729 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Invalid type specification&quot;);</span>
<span class="lineNum">    6730 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6731 </span>            :   default:
<span class="lineNum">    6732 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Unknown libffi error&quot;);</span>
<span class="lineNum">    6733 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6734 </span>            :   }
<span class="lineNum">    6735 </span>            : }
<a name="6736"><span class="lineNum">    6736 </span>            : </a>
<span class="lineNum">    6737 </span>            : void
<span class="lineNum">    6738 </span><span class="lineNoCov">          0 : FunctionType::BuildSymbolName(JSString* name,</span>
<span class="lineNum">    6739 </span>            :                               JSObject* typeObj,
<span class="lineNum">    6740 </span>            :                               AutoCString&amp; result)
<span class="lineNum">    6741 </span>            : {
<span class="lineNum">    6742 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = GetFunctionInfo(typeObj);</span>
<span class="lineNum">    6743 </span>            : 
<span class="lineNum">    6744 </span><span class="lineNoCov">          0 :   switch (GetABICode(fninfo-&gt;mABI)) {</span>
<span class="lineNum">    6745 </span>            :   case ABI_DEFAULT:
<span class="lineNum">    6746 </span>            :   case ABI_THISCALL:
<span class="lineNum">    6747 </span>            :   case ABI_WINAPI:
<span class="lineNum">    6748 </span>            :     // For cdecl or WINAPI functions, no mangling is necessary.
<span class="lineNum">    6749 </span><span class="lineNoCov">          0 :     AppendString(result, name);</span>
<span class="lineNum">    6750 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    6751 </span>            : 
<span class="lineNum">    6752 </span>            :   case ABI_STDCALL: {
<span class="lineNum">    6753 </span>            : #if (defined(_WIN32) &amp;&amp; !defined(_WIN64)) || defined(_OS2)
<span class="lineNum">    6754 </span>            :     // On WIN32, stdcall functions look like:
<span class="lineNum">    6755 </span>            :     //   _foo@40
<span class="lineNum">    6756 </span>            :     // where 'foo' is the function name, and '40' is the aligned size of the
<span class="lineNum">    6757 </span>            :     // arguments.
<span class="lineNum">    6758 </span>            :     AppendString(result, &quot;_&quot;);
<span class="lineNum">    6759 </span>            :     AppendString(result, name);
<span class="lineNum">    6760 </span>            :     AppendString(result, &quot;@&quot;);
<span class="lineNum">    6761 </span>            : 
<span class="lineNum">    6762 </span>            :     // Compute the suffix by aligning each argument to sizeof(ffi_arg).
<span class="lineNum">    6763 </span>            :     size_t size = 0;
<span class="lineNum">    6764 </span>            :     for (size_t i = 0; i &lt; fninfo-&gt;mArgTypes.length(); ++i) {
<span class="lineNum">    6765 </span>            :       JSObject* argType = fninfo-&gt;mArgTypes[i];
<span class="lineNum">    6766 </span>            :       size += Align(CType::GetSize(argType), sizeof(ffi_arg));
<span class="lineNum">    6767 </span>            :     }
<span class="lineNum">    6768 </span>            : 
<span class="lineNum">    6769 </span>            :     IntegerToString(size, 10, result);
<span class="lineNum">    6770 </span>            : #elif defined(_WIN64)
<span class="lineNum">    6771 </span>            :     // On Win64, stdcall is an alias to the default ABI for compatibility, so no
<span class="lineNum">    6772 </span>            :     // mangling is done.
<span class="lineNum">    6773 </span>            :     AppendString(result, name);
<span class="lineNum">    6774 </span>            : #endif
<span class="lineNum">    6775 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    6776 </span>            :   }
<span class="lineNum">    6777 </span>            : 
<span class="lineNum">    6778 </span>            :   case INVALID_ABI:
<span class="lineNum">    6779 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;invalid abi&quot;);</span>
<span class="lineNum">    6780 </span>            :   }
<span class="lineNum">    6781 </span><span class="lineNoCov">          0 : }</span>
<a name="6782"><span class="lineNum">    6782 </span>            : </a>
<span class="lineNum">    6783 </span>            : static bool
<span class="lineNum">    6784 </span><span class="lineNoCov">          0 : CreateFunctionInfo(JSContext* cx,</span>
<span class="lineNum">    6785 </span>            :                    HandleObject typeObj,
<span class="lineNum">    6786 </span>            :                    HandleValue abiType,
<span class="lineNum">    6787 </span>            :                    HandleObject returnType,
<span class="lineNum">    6788 </span>            :                    const HandleValueArray&amp; args)
<span class="lineNum">    6789 </span>            : {
<span class="lineNum">    6790 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo(cx-&gt;new_&lt;FunctionInfo&gt;());</span>
<span class="lineNum">    6791 </span><span class="lineNoCov">          0 :   if (!fninfo) {</span>
<span class="lineNum">    6792 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6793 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6794 </span>            :   }
<span class="lineNum">    6795 </span>            : 
<span class="lineNum">    6796 </span>            :   // Stash the FunctionInfo in a reserved slot.
<span class="lineNum">    6797 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(typeObj, SLOT_FNINFO, PrivateValue(fninfo));</span>
<span class="lineNum">    6798 </span>            : 
<span class="lineNum">    6799 </span>            :   ffi_abi abi;
<span class="lineNum">    6800 </span><span class="lineNoCov">          0 :   if (!GetABI(cx, abiType, &amp;abi)) {</span>
<span class="lineNum">    6801 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Invalid ABI specification&quot;);</span>
<span class="lineNum">    6802 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6803 </span>            :   }
<span class="lineNum">    6804 </span><span class="lineNoCov">          0 :   fninfo-&gt;mABI = abiType.toObjectOrNull();</span>
<span class="lineNum">    6805 </span>            : 
<span class="lineNum">    6806 </span><span class="lineNoCov">          0 :   fninfo-&gt;mReturnType = returnType;</span>
<span class="lineNum">    6807 </span>            : 
<span class="lineNum">    6808 </span>            :   // prepare the argument types
<span class="lineNum">    6809 </span><span class="lineNoCov">          0 :   if (!fninfo-&gt;mArgTypes.reserve(args.length()) ||</span>
<span class="lineNum">    6810 </span><span class="lineNoCov">          0 :       !fninfo-&gt;mFFITypes.reserve(args.length())) {</span>
<span class="lineNum">    6811 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6812 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6813 </span>            :   }
<span class="lineNum">    6814 </span>            : 
<span class="lineNum">    6815 </span><span class="lineNoCov">          0 :   fninfo-&gt;mIsVariadic = false;</span>
<span class="lineNum">    6816 </span>            : 
<span class="lineNum">    6817 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; args.length(); ++i) {</span>
<span class="lineNum">    6818 </span>            :     bool isEllipsis;
<span class="lineNum">    6819 </span><span class="lineNoCov">          0 :     if (!IsEllipsis(cx, args[i], &amp;isEllipsis))</span>
<span class="lineNum">    6820 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6821 </span><span class="lineNoCov">          0 :     if (isEllipsis) {</span>
<span class="lineNum">    6822 </span><span class="lineNoCov">          0 :       fninfo-&gt;mIsVariadic = true;</span>
<span class="lineNum">    6823 </span><span class="lineNoCov">          0 :       if (i &lt; 1) {</span>
<span class="lineNum">    6824 </span>            :         JS_ReportErrorASCII(cx, &quot;\&quot;...\&quot; may not be the first and only parameter &quot;
<span class="lineNum">    6825 </span><span class="lineNoCov">          0 :                             &quot;type of a variadic function declaration&quot;);</span>
<span class="lineNum">    6826 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6827 </span>            :       }
<span class="lineNum">    6828 </span><span class="lineNoCov">          0 :       if (i &lt; args.length() - 1) {</span>
<span class="lineNum">    6829 </span>            :         JS_ReportErrorASCII(cx, &quot;\&quot;...\&quot; must be the last parameter type of a &quot;
<span class="lineNum">    6830 </span><span class="lineNoCov">          0 :                             &quot;variadic function declaration&quot;);</span>
<span class="lineNum">    6831 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6832 </span>            :       }
<span class="lineNum">    6833 </span><span class="lineNoCov">          0 :       if (GetABICode(fninfo-&gt;mABI) != ABI_DEFAULT) {</span>
<span class="lineNum">    6834 </span>            :         JS_ReportErrorASCII(cx, &quot;Variadic functions must use the __cdecl calling &quot;
<span class="lineNum">    6835 </span><span class="lineNoCov">          0 :                             &quot;convention&quot;);</span>
<span class="lineNum">    6836 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6837 </span>            :       }
<span class="lineNum">    6838 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6839 </span>            :     }
<span class="lineNum">    6840 </span>            : 
<span class="lineNum">    6841 </span><span class="lineNoCov">          0 :     JSObject* argType = PrepareType(cx, i, args[i]);</span>
<span class="lineNum">    6842 </span><span class="lineNoCov">          0 :     if (!argType)</span>
<span class="lineNum">    6843 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6844 </span>            : 
<span class="lineNum">    6845 </span><span class="lineNoCov">          0 :     ffi_type* ffiType = CType::GetFFIType(cx, argType);</span>
<span class="lineNum">    6846 </span><span class="lineNoCov">          0 :     if (!ffiType)</span>
<span class="lineNum">    6847 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6848 </span>            : 
<span class="lineNum">    6849 </span><span class="lineNoCov">          0 :     fninfo-&gt;mArgTypes.infallibleAppend(argType);</span>
<span class="lineNum">    6850 </span><span class="lineNoCov">          0 :     fninfo-&gt;mFFITypes.infallibleAppend(ffiType);</span>
<span class="lineNum">    6851 </span>            :   }
<span class="lineNum">    6852 </span>            : 
<span class="lineNum">    6853 </span><span class="lineNoCov">          0 :   if (fninfo-&gt;mIsVariadic) {</span>
<span class="lineNum">    6854 </span>            :     // wait to PrepareCIF until function is called
<span class="lineNum">    6855 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6856 </span>            :   }
<span class="lineNum">    6857 </span>            : 
<span class="lineNum">    6858 </span><span class="lineNoCov">          0 :   if (!PrepareCIF(cx, fninfo))</span>
<span class="lineNum">    6859 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6860 </span>            : 
<span class="lineNum">    6861 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6862 </span>            : }
<a name="6863"><span class="lineNum">    6863 </span>            : </a>
<span class="lineNum">    6864 </span>            : bool
<span class="lineNum">    6865 </span><span class="lineNoCov">          0 : FunctionType::Create(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    6866 </span>            : {
<span class="lineNum">    6867 </span>            :   // Construct and return a new FunctionType object.
<span class="lineNum">    6868 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    6869 </span><span class="lineNoCov">          0 :   if (args.length() &lt; 2 || args.length() &gt; 3) {</span>
<span class="lineNum">    6870 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;FunctionType&quot;, &quot;two or three&quot;, &quot;s&quot;);</span>
<span class="lineNum">    6871 </span>            :   }
<span class="lineNum">    6872 </span>            : 
<span class="lineNum">    6873 </span><span class="lineNoCov">          0 :   AutoValueVector argTypes(cx);</span>
<span class="lineNum">    6874 </span><span class="lineNoCov">          0 :   RootedObject arrayObj(cx, nullptr);</span>
<span class="lineNum">    6875 </span>            : 
<span class="lineNum">    6876 </span><span class="lineNoCov">          0 :   if (args.length() == 3) {</span>
<span class="lineNum">    6877 </span>            :     // Prepare an array of Values for the arguments.
<span class="lineNum">    6878 </span>            :     bool isArray;
<span class="lineNum">    6879 </span><span class="lineNoCov">          0 :     if (!args[2].isObject()) {</span>
<span class="lineNum">    6880 </span><span class="lineNoCov">          0 :       isArray = false;</span>
<span class="lineNum">    6881 </span>            :     } else {
<span class="lineNum">    6882 </span><span class="lineNoCov">          0 :       if (!JS_IsArrayObject(cx, args[2], &amp;isArray))</span>
<span class="lineNum">    6883 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    6884 </span>            :     }
<span class="lineNum">    6885 </span>            : 
<span class="lineNum">    6886 </span><span class="lineNoCov">          0 :     if (!isArray)</span>
<span class="lineNum">    6887 </span><span class="lineNoCov">          0 :       return ArgumentTypeMismatch(cx, &quot;third &quot;, &quot;FunctionType&quot;, &quot;an array&quot;);</span>
<span class="lineNum">    6888 </span>            : 
<span class="lineNum">    6889 </span><span class="lineNoCov">          0 :     arrayObj = &amp;args[2].toObject();</span>
<span class="lineNum">    6890 </span>            : 
<span class="lineNum">    6891 </span>            :     uint32_t len;
<span class="lineNum">    6892 </span><span class="lineNoCov">          0 :     ASSERT_OK(JS_GetArrayLength(cx, arrayObj, &amp;len));</span>
<span class="lineNum">    6893 </span>            : 
<span class="lineNum">    6894 </span><span class="lineNoCov">          0 :     if (!argTypes.resize(len)) {</span>
<span class="lineNum">    6895 </span><span class="lineNoCov">          0 :       JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    6896 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6897 </span>            :     }
<span class="lineNum">    6898 </span>            :   }
<span class="lineNum">    6899 </span>            : 
<span class="lineNum">    6900 </span>            :   // Pull out the argument types from the array, if any.
<span class="lineNum">    6901 </span><span class="lineNoCov">          0 :   MOZ_ASSERT_IF(argTypes.length(), arrayObj);</span>
<span class="lineNum">    6902 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; argTypes.length(); ++i) {</span>
<span class="lineNum">    6903 </span><span class="lineNoCov">          0 :     if (!JS_GetElement(cx, arrayObj, i, argTypes[i]))</span>
<span class="lineNum">    6904 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    6905 </span>            :   }
<span class="lineNum">    6906 </span>            : 
<span class="lineNum">    6907 </span><span class="lineNoCov">          0 :   JSObject* result = CreateInternal(cx, args[0], args[1], argTypes);</span>
<span class="lineNum">    6908 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    6909 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6910 </span>            : 
<span class="lineNum">    6911 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    6912 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    6913 </span>            : }
<a name="6914"><span class="lineNum">    6914 </span>            : </a>
<span class="lineNum">    6915 </span>            : JSObject*
<span class="lineNum">    6916 </span><span class="lineNoCov">          0 : FunctionType::CreateInternal(JSContext* cx,</span>
<span class="lineNum">    6917 </span>            :                              HandleValue abi,
<span class="lineNum">    6918 </span>            :                              HandleValue rtype,
<span class="lineNum">    6919 </span>            :                              const HandleValueArray&amp; args)
<span class="lineNum">    6920 </span>            : {
<span class="lineNum">    6921 </span>            :   // Prepare the result type
<span class="lineNum">    6922 </span><span class="lineNoCov">          0 :   RootedObject returnType(cx, PrepareReturnType(cx, rtype));</span>
<span class="lineNum">    6923 </span><span class="lineNoCov">          0 :   if (!returnType)</span>
<span class="lineNum">    6924 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6925 </span>            : 
<span class="lineNum">    6926 </span>            :   // Get ctypes.FunctionType.prototype and the common prototype for CData objects
<span class="lineNum">    6927 </span>            :   // of this type, from ctypes.CType.prototype.
<span class="lineNum">    6928 </span><span class="lineNoCov">          0 :   RootedObject typeProto(cx, CType::GetProtoFromType(cx, returnType, SLOT_FUNCTIONPROTO));</span>
<span class="lineNum">    6929 </span><span class="lineNoCov">          0 :   if (!typeProto)</span>
<span class="lineNum">    6930 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6931 </span><span class="lineNoCov">          0 :   RootedObject dataProto(cx, CType::GetProtoFromType(cx, returnType, SLOT_FUNCTIONDATAPROTO));</span>
<span class="lineNum">    6932 </span><span class="lineNoCov">          0 :   if (!dataProto)</span>
<span class="lineNum">    6933 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6934 </span>            : 
<span class="lineNum">    6935 </span>            :   // Create a new CType object with the common properties and slots.
<span class="lineNum">    6936 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CType::Create(cx, typeProto, dataProto, TYPE_function,</span>
<span class="lineNum">    6937 </span>            :                                          nullptr, JS::UndefinedHandleValue,
<span class="lineNum">    6938 </span><span class="lineNoCov">          0 :                                          JS::UndefinedHandleValue, nullptr));</span>
<span class="lineNum">    6939 </span><span class="lineNoCov">          0 :   if (!typeObj)</span>
<span class="lineNum">    6940 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    6941 </span>            : 
<span class="lineNum">    6942 </span>            :   // Determine and check the types, and prepare the function CIF.
<span class="lineNum">    6943 </span><span class="lineNoCov">          0 :   if (!CreateFunctionInfo(cx, typeObj, abi, returnType, args))</span>
<span class="lineNum">    6944 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    6945 </span>            : 
<span class="lineNum">    6946 </span><span class="lineNoCov">          0 :   return typeObj;</span>
<span class="lineNum">    6947 </span>            : }
<span class="lineNum">    6948 </span>            : 
<span class="lineNum">    6949 </span>            : // Construct a function pointer to a JS function (see CClosure::Create()).
<span class="lineNum">    6950 </span>            : // Regular function pointers are constructed directly in
<a name="6951"><span class="lineNum">    6951 </span>            : // PointerType::ConstructData().</a>
<span class="lineNum">    6952 </span>            : bool
<span class="lineNum">    6953 </span><span class="lineNoCov">          0 : FunctionType::ConstructData(JSContext* cx,</span>
<span class="lineNum">    6954 </span>            :                             HandleObject typeObj,
<span class="lineNum">    6955 </span>            :                             HandleObject dataObj,
<span class="lineNum">    6956 </span>            :                             HandleObject fnObj,
<span class="lineNum">    6957 </span>            :                             HandleObject thisObj,
<span class="lineNum">    6958 </span>            :                             HandleValue errVal)
<span class="lineNum">    6959 </span>            : {
<span class="lineNum">    6960 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(typeObj) == TYPE_function);</span>
<span class="lineNum">    6961 </span>            : 
<span class="lineNum">    6962 </span><span class="lineNoCov">          0 :   PRFuncPtr* data = static_cast&lt;PRFuncPtr*&gt;(CData::GetData(dataObj));</span>
<span class="lineNum">    6963 </span>            : 
<span class="lineNum">    6964 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    6965 </span><span class="lineNoCov">          0 :   if (fninfo-&gt;mIsVariadic) {</span>
<span class="lineNum">    6966 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Can't declare a variadic callback function&quot;);</span>
<span class="lineNum">    6967 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6968 </span>            :   }
<span class="lineNum">    6969 </span><span class="lineNoCov">          0 :   if (GetABICode(fninfo-&gt;mABI) == ABI_WINAPI) {</span>
<span class="lineNum">    6970 </span>            :     JS_ReportErrorASCII(cx, &quot;Can't declare a ctypes.winapi_abi callback function, &quot;
<span class="lineNum">    6971 </span><span class="lineNoCov">          0 :                         &quot;use ctypes.stdcall_abi instead&quot;);</span>
<span class="lineNum">    6972 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6973 </span>            :   }
<span class="lineNum">    6974 </span>            : 
<span class="lineNum">    6975 </span><span class="lineNoCov">          0 :   RootedObject closureObj(cx, CClosure::Create(cx, typeObj, fnObj, thisObj, errVal, data));</span>
<span class="lineNum">    6976 </span><span class="lineNoCov">          0 :   if (!closureObj)</span>
<span class="lineNum">    6977 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    6978 </span>            : 
<span class="lineNum">    6979 </span>            :   // Set the closure object as the referent of the new CData object.
<span class="lineNum">    6980 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(dataObj, SLOT_REFERENT, ObjectValue(*closureObj));</span>
<span class="lineNum">    6981 </span>            : 
<span class="lineNum">    6982 </span>            :   // Seal the CData object, to prevent modification of the function pointer.
<span class="lineNum">    6983 </span>            :   // This permanently associates this object with the closure, and avoids
<span class="lineNum">    6984 </span>            :   // having to do things like reset SLOT_REFERENT when someone tries to
<span class="lineNum">    6985 </span>            :   // change the pointer value.
<span class="lineNum">    6986 </span>            :   // XXX This will need to change when bug 541212 is fixed -- CData::ValueSetter
<span class="lineNum">    6987 </span>            :   // could be called on a frozen object.
<span class="lineNum">    6988 </span><span class="lineNoCov">          0 :   return JS_FreezeObject(cx, dataObj);</span>
<span class="lineNum">    6989 </span>            : }
<span class="lineNum">    6990 </span>            : 
<span class="lineNum">    6991 </span>            : typedef Vector&lt;AutoValue, 16, SystemAllocPolicy&gt; AutoValueAutoArray;
<a name="6992"><span class="lineNum">    6992 </span>            : </a>
<span class="lineNum">    6993 </span>            : static bool
<span class="lineNum">    6994 </span><span class="lineNoCov">          0 : ConvertArgument(JSContext* cx,</span>
<span class="lineNum">    6995 </span>            :                 HandleObject funObj,
<span class="lineNum">    6996 </span>            :                 unsigned argIndex,
<span class="lineNum">    6997 </span>            :                 HandleValue arg,
<span class="lineNum">    6998 </span>            :                 JSObject* type,
<span class="lineNum">    6999 </span>            :                 AutoValue* value,
<span class="lineNum">    7000 </span>            :                 AutoValueAutoArray* strings)
<span class="lineNum">    7001 </span>            : {
<span class="lineNum">    7002 </span><span class="lineNoCov">          0 :   if (!value-&gt;SizeToType(cx, type)) {</span>
<span class="lineNum">    7003 </span><span class="lineNoCov">          0 :     JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    7004 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7005 </span>            :   }
<span class="lineNum">    7006 </span>            : 
<span class="lineNum">    7007 </span><span class="lineNoCov">          0 :   bool freePointer = false;</span>
<span class="lineNum">    7008 </span><span class="lineNoCov">          0 :   if (!ImplicitConvert(cx, arg, type, value-&gt;mData,</span>
<span class="lineNum">    7009 </span>            :                        ConversionType::Argument, &amp;freePointer,
<span class="lineNum">    7010 </span>            :                        funObj, argIndex))
<span class="lineNum">    7011 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7012 </span>            : 
<span class="lineNum">    7013 </span><span class="lineNoCov">          0 :   if (freePointer) {</span>
<span class="lineNum">    7014 </span>            :     // ImplicitConvert converted a string for us, which we have to free.
<span class="lineNum">    7015 </span>            :     // Keep track of it.
<span class="lineNum">    7016 </span><span class="lineNoCov">          0 :     if (!strings-&gt;growBy(1)) {</span>
<span class="lineNum">    7017 </span><span class="lineNoCov">          0 :       JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7018 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7019 </span>            :     }
<span class="lineNum">    7020 </span><span class="lineNoCov">          0 :     strings-&gt;back().mData = *static_cast&lt;char**&gt;(value-&gt;mData);</span>
<span class="lineNum">    7021 </span>            :   }
<span class="lineNum">    7022 </span>            : 
<span class="lineNum">    7023 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7024 </span>            : }
<a name="7025"><span class="lineNum">    7025 </span>            : </a>
<span class="lineNum">    7026 </span>            : bool
<span class="lineNum">    7027 </span><span class="lineNoCov">          0 : FunctionType::Call(JSContext* cx,</span>
<span class="lineNum">    7028 </span>            :                    unsigned argc,
<span class="lineNum">    7029 </span>            :                    Value* vp)
<span class="lineNum">    7030 </span>            : {
<span class="lineNum">    7031 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7032 </span>            :   // get the callee object...
<span class="lineNum">    7033 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.callee());</span>
<span class="lineNum">    7034 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    7035 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;FunctionType.prototype.call&quot;,</span>
<span class="lineNum">    7036 </span><span class="lineNoCov">          0 :                                  args.calleev());</span>
<span class="lineNum">    7037 </span>            :   }
<span class="lineNum">    7038 </span>            : 
<span class="lineNum">    7039 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    7040 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_pointer) {</span>
<span class="lineNum">    7041 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;FunctionType.prototype.call&quot;,</span>
<span class="lineNum">    7042 </span><span class="lineNoCov">          0 :                                 &quot;non-PointerType CData&quot;, args.calleev());</span>
<span class="lineNum">    7043 </span>            :   }
<span class="lineNum">    7044 </span>            : 
<span class="lineNum">    7045 </span><span class="lineNoCov">          0 :   typeObj = PointerType::GetBaseType(typeObj);</span>
<span class="lineNum">    7046 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(typeObj) != TYPE_function) {</span>
<span class="lineNum">    7047 </span><span class="lineNoCov">          0 :     return IncompatibleThisType(cx, &quot;FunctionType.prototype.call&quot;,</span>
<span class="lineNum">    7048 </span><span class="lineNoCov">          0 :                                 &quot;non-FunctionType pointer&quot;, args.calleev());</span>
<span class="lineNum">    7049 </span>            :   }
<span class="lineNum">    7050 </span>            : 
<span class="lineNum">    7051 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = GetFunctionInfo(typeObj);</span>
<span class="lineNum">    7052 </span><span class="lineNoCov">          0 :   uint32_t argcFixed = fninfo-&gt;mArgTypes.length();</span>
<span class="lineNum">    7053 </span>            : 
<span class="lineNum">    7054 </span><span class="lineNoCov">          0 :   if ((!fninfo-&gt;mIsVariadic &amp;&amp; args.length() != argcFixed) ||</span>
<span class="lineNum">    7055 </span><span class="lineNoCov">          0 :       (fninfo-&gt;mIsVariadic &amp;&amp; args.length() &lt; argcFixed)) {</span>
<span class="lineNum">    7056 </span><span class="lineNoCov">          0 :     return FunctionArgumentLengthMismatch(cx, argcFixed, args.length(),</span>
<span class="lineNum">    7057 </span><span class="lineNoCov">          0 :                                           obj, typeObj, fninfo-&gt;mIsVariadic);</span>
<span class="lineNum">    7058 </span>            :   }
<span class="lineNum">    7059 </span>            : 
<span class="lineNum">    7060 </span>            :   // Check if we have a Library object. If we do, make sure it's open.
<span class="lineNum">    7061 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_REFERENT);</span>
<span class="lineNum">    7062 </span><span class="lineNoCov">          0 :   if (!slot.isUndefined() &amp;&amp; Library::IsLibrary(&amp;slot.toObject())) {</span>
<span class="lineNum">    7063 </span><span class="lineNoCov">          0 :     PRLibrary* library = Library::GetLibrary(&amp;slot.toObject());</span>
<span class="lineNum">    7064 </span><span class="lineNoCov">          0 :     if (!library) {</span>
<span class="lineNum">    7065 </span><span class="lineNoCov">          0 :       JS_ReportErrorASCII(cx, &quot;library is not open&quot;);</span>
<span class="lineNum">    7066 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7067 </span>            :     }
<span class="lineNum">    7068 </span>            :   }
<span class="lineNum">    7069 </span>            : 
<span class="lineNum">    7070 </span>            :   // prepare the values for each argument
<span class="lineNum">    7071 </span><span class="lineNoCov">          0 :   AutoValueAutoArray values;</span>
<span class="lineNum">    7072 </span><span class="lineNoCov">          0 :   AutoValueAutoArray strings;</span>
<span class="lineNum">    7073 </span><span class="lineNoCov">          0 :   if (!values.resize(args.length())) {</span>
<span class="lineNum">    7074 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7075 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7076 </span>            :   }
<span class="lineNum">    7077 </span>            : 
<span class="lineNum">    7078 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; argcFixed; ++i)</span>
<span class="lineNum">    7079 </span><span class="lineNoCov">          0 :     if (!ConvertArgument(cx, obj, i, args[i], fninfo-&gt;mArgTypes[i],</span>
<span class="lineNum">    7080 </span><span class="lineNoCov">          0 :                          &amp;values[i], &amp;strings))</span>
<span class="lineNum">    7081 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7082 </span>            : 
<span class="lineNum">    7083 </span><span class="lineNoCov">          0 :   if (fninfo-&gt;mIsVariadic) {</span>
<span class="lineNum">    7084 </span><span class="lineNoCov">          0 :     if (!fninfo-&gt;mFFITypes.resize(args.length())) {</span>
<span class="lineNum">    7085 </span><span class="lineNoCov">          0 :       JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7086 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7087 </span>            :     }
<span class="lineNum">    7088 </span>            : 
<span class="lineNum">    7089 </span><span class="lineNoCov">          0 :     RootedObject obj(cx);  // Could reuse obj instead of declaring a second</span>
<span class="lineNum">    7090 </span><span class="lineNoCov">          0 :     RootedObject type(cx); // RootedObject, but readability would suffer.</span>
<span class="lineNum">    7091 </span>            : 
<span class="lineNum">    7092 </span><span class="lineNoCov">          0 :     for (uint32_t i = argcFixed; i &lt; args.length(); ++i) {</span>
<span class="lineNum">    7093 </span><span class="lineNoCov">          0 :       if (args[i].isPrimitive() ||</span>
<span class="lineNum">    7094 </span><span class="lineNoCov">          0 :           !CData::IsCData(obj = &amp;args[i].toObject())) {</span>
<span class="lineNum">    7095 </span>            :         // Since we know nothing about the CTypes of the ... arguments,
<span class="lineNum">    7096 </span>            :         // they absolutely must be CData objects already.
<span class="lineNum">    7097 </span><span class="lineNoCov">          0 :         return VariadicArgumentTypeError(cx, i, args[i]);</span>
<span class="lineNum">    7098 </span>            :       }
<span class="lineNum">    7099 </span><span class="lineNoCov">          0 :       type = CData::GetCType(obj);</span>
<span class="lineNum">    7100 </span><span class="lineNoCov">          0 :       if (!type) {</span>
<span class="lineNum">    7101 </span>            :         // These functions report their own errors.
<span class="lineNum">    7102 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7103 </span>            :       }
<span class="lineNum">    7104 </span><span class="lineNoCov">          0 :       RootedValue typeVal(cx, ObjectValue(*type));</span>
<span class="lineNum">    7105 </span><span class="lineNoCov">          0 :       type = PrepareType(cx, i, typeVal);</span>
<span class="lineNum">    7106 </span><span class="lineNoCov">          0 :       if (!type) {</span>
<span class="lineNum">    7107 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7108 </span>            :       }
<span class="lineNum">    7109 </span>            :       // Relying on ImplicitConvert only for the limited purpose of
<span class="lineNum">    7110 </span>            :       // converting one CType to another (e.g., T[] to T*).
<span class="lineNum">    7111 </span><span class="lineNoCov">          0 :       if (!ConvertArgument(cx, obj, i, args[i], type, &amp;values[i], &amp;strings)) {</span>
<span class="lineNum">    7112 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7113 </span>            :       }
<span class="lineNum">    7114 </span><span class="lineNoCov">          0 :       fninfo-&gt;mFFITypes[i] = CType::GetFFIType(cx, type);</span>
<span class="lineNum">    7115 </span><span class="lineNoCov">          0 :       if (!fninfo-&gt;mFFITypes[i]) {</span>
<span class="lineNum">    7116 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7117 </span>            :       }
<span class="lineNum">    7118 </span>            :     }
<span class="lineNum">    7119 </span><span class="lineNoCov">          0 :     if (!PrepareCIF(cx, fninfo))</span>
<span class="lineNum">    7120 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7121 </span>            :   }
<span class="lineNum">    7122 </span>            : 
<span class="lineNum">    7123 </span>            :   // initialize a pointer to an appropriate location, for storing the result
<span class="lineNum">    7124 </span><span class="lineNoCov">          0 :   AutoValue returnValue;</span>
<span class="lineNum">    7125 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(fninfo-&gt;mReturnType);</span>
<span class="lineNum">    7126 </span><span class="lineNoCov">          0 :   if (typeCode != TYPE_void_t &amp;&amp;</span>
<span class="lineNum">    7127 </span><span class="lineNoCov">          0 :       !returnValue.SizeToType(cx, fninfo-&gt;mReturnType)) {</span>
<span class="lineNum">    7128 </span><span class="lineNoCov">          0 :     JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    7129 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7130 </span>            :   }
<span class="lineNum">    7131 </span>            : 
<span class="lineNum">    7132 </span>            :   // Let the runtime callback know that we are about to call into C.
<span class="lineNum">    7133 </span><span class="lineNoCov">          0 :   js::AutoCTypesActivityCallback autoCallback(cx, js::CTYPES_CALL_BEGIN, js::CTYPES_CALL_END);</span>
<span class="lineNum">    7134 </span>            : 
<span class="lineNum">    7135 </span><span class="lineNoCov">          0 :   uintptr_t fn = *reinterpret_cast&lt;uintptr_t*&gt;(CData::GetData(obj));</span>
<span class="lineNum">    7136 </span>            : 
<span class="lineNum">    7137 </span>            : #if defined(XP_WIN)
<span class="lineNum">    7138 </span>            :   int32_t lastErrorStatus; // The status as defined by |GetLastError|
<span class="lineNum">    7139 </span>            :   int32_t savedLastError = GetLastError();
<span class="lineNum">    7140 </span>            :   SetLastError(0);
<span class="lineNum">    7141 </span>            : #endif //defined(XP_WIN)
<span class="lineNum">    7142 </span>            :   int errnoStatus;         // The status as defined by |errno|
<span class="lineNum">    7143 </span><span class="lineNoCov">          0 :   int savedErrno = errno;</span>
<span class="lineNum">    7144 </span><span class="lineNoCov">          0 :   errno = 0;</span>
<span class="lineNum">    7145 </span>            : 
<span class="lineNum">    7146 </span><span class="lineNoCov">          0 :   ffi_call(&amp;fninfo-&gt;mCIF, FFI_FN(fn), returnValue.mData,</span>
<span class="lineNum">    7147 </span><span class="lineNoCov">          0 :            reinterpret_cast&lt;void**&gt;(values.begin()));</span>
<span class="lineNum">    7148 </span>            : 
<span class="lineNum">    7149 </span>            :   // Save error value.
<span class="lineNum">    7150 </span>            :   // We need to save it before leaving the scope of |suspend| as destructing
<span class="lineNum">    7151 </span>            :   // |suspend| has the side-effect of clearing |GetLastError|
<span class="lineNum">    7152 </span>            :   // (see bug 684017).
<span class="lineNum">    7153 </span>            : 
<span class="lineNum">    7154 </span><span class="lineNoCov">          0 :   errnoStatus = errno;</span>
<span class="lineNum">    7155 </span>            : #if defined(XP_WIN)
<span class="lineNum">    7156 </span>            :   lastErrorStatus = GetLastError();
<span class="lineNum">    7157 </span>            :   SetLastError(savedLastError);
<span class="lineNum">    7158 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    7159 </span>            : 
<span class="lineNum">    7160 </span><span class="lineNoCov">          0 :   errno = savedErrno;</span>
<span class="lineNum">    7161 </span>            : 
<span class="lineNum">    7162 </span>            :   // We're no longer calling into C.
<span class="lineNum">    7163 </span><span class="lineNoCov">          0 :   autoCallback.DoEndCallback();</span>
<span class="lineNum">    7164 </span>            : 
<span class="lineNum">    7165 </span>            :   // Store the error value for later consultation with |ctypes.getStatus|
<span class="lineNum">    7166 </span><span class="lineNoCov">          0 :   JSObject* objCTypes = CType::GetGlobalCTypes(cx, typeObj);</span>
<span class="lineNum">    7167 </span><span class="lineNoCov">          0 :   if (!objCTypes)</span>
<span class="lineNum">    7168 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7169 </span>            : 
<span class="lineNum">    7170 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(objCTypes, SLOT_ERRNO, Int32Value(errnoStatus));</span>
<span class="lineNum">    7171 </span>            : #if defined(XP_WIN)
<span class="lineNum">    7172 </span>            :   JS_SetReservedSlot(objCTypes, SLOT_LASTERROR, Int32Value(lastErrorStatus));
<span class="lineNum">    7173 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    7174 </span>            : 
<span class="lineNum">    7175 </span>            :   // Small integer types get returned as a word-sized ffi_arg. Coerce it back
<span class="lineNum">    7176 </span>            :   // into the correct size for ConvertToJS.
<span class="lineNum">    7177 </span><span class="lineNoCov">          0 :   switch (typeCode) {</span>
<span class="lineNum">    7178 </span>            : #define INTEGRAL_CASE(name, type, ffiType)                                     \
<span class="lineNum">    7179 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    7180 </span>            :     if (sizeof(type) &lt; sizeof(ffi_arg)) {                                      \
<span class="lineNum">    7181 </span>            :       ffi_arg data = *static_cast&lt;ffi_arg*&gt;(returnValue.mData);                \
<span class="lineNum">    7182 </span>            :       *static_cast&lt;type*&gt;(returnValue.mData) = static_cast&lt;type&gt;(data);        \
<span class="lineNum">    7183 </span>            :     }                                                                          \
<span class="lineNum">    7184 </span>            :     break;
<span class="lineNum">    7185 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7186 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7187 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_BOOL_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7188 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7189 </span><span class="lineNoCov">          0 :   CTYPES_FOR_EACH_CHAR16_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7190 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    7191 </span>            :   default:
<span class="lineNum">    7192 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7193 </span>            :   }
<span class="lineNum">    7194 </span>            : 
<span class="lineNum">    7195 </span>            :   // prepare a JS object from the result
<span class="lineNum">    7196 </span><span class="lineNoCov">          0 :   RootedObject returnType(cx, fninfo-&gt;mReturnType);</span>
<span class="lineNum">    7197 </span><span class="lineNoCov">          0 :   return ConvertToJS(cx, returnType, nullptr, returnValue.mData, false, true, args.rval());</span>
<span class="lineNum">    7198 </span>            : }
<a name="7199"><span class="lineNum">    7199 </span>            : </a>
<span class="lineNum">    7200 </span>            : FunctionInfo*
<span class="lineNum">    7201 </span><span class="lineNoCov">          0 : FunctionType::GetFunctionInfo(JSObject* obj)</span>
<span class="lineNum">    7202 </span>            : {
<span class="lineNum">    7203 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(obj));</span>
<span class="lineNum">    7204 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_function);</span>
<span class="lineNum">    7205 </span>            : 
<span class="lineNum">    7206 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_FNINFO);</span>
<span class="lineNum">    7207 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!slot.isUndefined() &amp;&amp; slot.toPrivate());</span>
<span class="lineNum">    7208 </span>            : 
<span class="lineNum">    7209 </span><span class="lineNoCov">          0 :   return static_cast&lt;FunctionInfo*&gt;(slot.toPrivate());</span>
<span class="lineNum">    7210 </span>            : }
<a name="7211"><span class="lineNum">    7211 </span>            : </a>
<span class="lineNum">    7212 </span>            : bool
<span class="lineNum">    7213 </span><span class="lineNoCov">          0 : FunctionType::IsFunctionType(HandleValue v)</span>
<span class="lineNum">    7214 </span>            : {
<span class="lineNum">    7215 </span><span class="lineNoCov">          0 :   if (!v.isObject())</span>
<span class="lineNum">    7216 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7217 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;v.toObject();</span>
<span class="lineNum">    7218 </span><span class="lineNoCov">          0 :   return CType::IsCType(obj) &amp;&amp; CType::GetTypeCode(obj) == TYPE_function;</span>
<span class="lineNum">    7219 </span>            : }
<a name="7220"><span class="lineNum">    7220 </span>            : </a>
<span class="lineNum">    7221 </span>            : bool
<span class="lineNum">    7222 </span><span class="lineNoCov">          0 : FunctionType::ArgTypesGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7223 </span>            : {
<span class="lineNum">    7224 </span><span class="lineNoCov">          0 :   JS::Rooted&lt;JSObject*&gt; obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    7225 </span>            : 
<span class="lineNum">    7226 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(obj, SLOT_ARGS_T));</span>
<span class="lineNum">    7227 </span><span class="lineNoCov">          0 :   if (!args.rval().isUndefined())</span>
<span class="lineNum">    7228 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    7229 </span>            : 
<span class="lineNum">    7230 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = GetFunctionInfo(obj);</span>
<span class="lineNum">    7231 </span><span class="lineNoCov">          0 :   size_t len = fninfo-&gt;mArgTypes.length();</span>
<span class="lineNum">    7232 </span>            : 
<span class="lineNum">    7233 </span>            :   // Prepare a new array.
<span class="lineNum">    7234 </span><span class="lineNoCov">          0 :   JS::Rooted&lt;JSObject*&gt; argTypes(cx);</span>
<span class="lineNum">    7235 </span>            :   {
<span class="lineNum">    7236 </span><span class="lineNoCov">          0 :       JS::AutoValueVector vec(cx);</span>
<span class="lineNum">    7237 </span><span class="lineNoCov">          0 :       if (!vec.resize(len))</span>
<span class="lineNum">    7238 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7239 </span>            : 
<span class="lineNum">    7240 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    7241 </span><span class="lineNoCov">          0 :         vec[i].setObject(*fninfo-&gt;mArgTypes[i]);</span>
<span class="lineNum">    7242 </span>            : 
<span class="lineNum">    7243 </span><span class="lineNoCov">          0 :       argTypes = JS_NewArrayObject(cx, vec);</span>
<span class="lineNum">    7244 </span><span class="lineNoCov">          0 :       if (!argTypes)</span>
<span class="lineNum">    7245 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    7246 </span>            :   }
<span class="lineNum">    7247 </span>            : 
<span class="lineNum">    7248 </span>            :   // Seal and cache it.
<span class="lineNum">    7249 </span><span class="lineNoCov">          0 :   if (!JS_FreezeObject(cx, argTypes))</span>
<span class="lineNum">    7250 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7251 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(obj, SLOT_ARGS_T, JS::ObjectValue(*argTypes));</span>
<span class="lineNum">    7252 </span>            : 
<span class="lineNum">    7253 </span><span class="lineNoCov">          0 :   args.rval().setObject(*argTypes);</span>
<span class="lineNum">    7254 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7255 </span>            : }
<a name="7256"><span class="lineNum">    7256 </span>            : </a>
<span class="lineNum">    7257 </span>            : bool
<span class="lineNum">    7258 </span><span class="lineNoCov">          0 : FunctionType::ReturnTypeGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7259 </span>            : {
<span class="lineNum">    7260 </span>            :   // Get the returnType object from the FunctionInfo.
<span class="lineNum">    7261 </span><span class="lineNoCov">          0 :   args.rval().setObject(*GetFunctionInfo(&amp;args.thisv().toObject())-&gt;mReturnType);</span>
<span class="lineNum">    7262 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7263 </span>            : }
<a name="7264"><span class="lineNum">    7264 </span>            : </a>
<span class="lineNum">    7265 </span>            : bool
<span class="lineNum">    7266 </span><span class="lineNoCov">          0 : FunctionType::ABIGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7267 </span>            : {
<span class="lineNum">    7268 </span>            :   // Get the abi object from the FunctionInfo.
<span class="lineNum">    7269 </span><span class="lineNoCov">          0 :   args.rval().setObject(*GetFunctionInfo(&amp;args.thisv().toObject())-&gt;mABI);</span>
<span class="lineNum">    7270 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7271 </span>            : }
<a name="7272"><span class="lineNum">    7272 </span>            : </a>
<span class="lineNum">    7273 </span>            : bool
<span class="lineNum">    7274 </span><span class="lineNoCov">          0 : FunctionType::IsVariadicGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7275 </span>            : {
<span class="lineNum">    7276 </span><span class="lineNoCov">          0 :   args.rval().setBoolean(GetFunctionInfo(&amp;args.thisv().toObject())-&gt;mIsVariadic);</span>
<span class="lineNum">    7277 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7278 </span>            : }
<span class="lineNum">    7279 </span>            : 
<span class="lineNum">    7280 </span>            : /*******************************************************************************
<span class="lineNum">    7281 </span>            : ** CClosure implementation
<span class="lineNum">    7282 </span>            : *******************************************************************************/
<a name="7283"><span class="lineNum">    7283 </span>            : </a>
<span class="lineNum">    7284 </span>            : JSObject*
<span class="lineNum">    7285 </span><span class="lineNoCov">          0 : CClosure::Create(JSContext* cx,</span>
<span class="lineNum">    7286 </span>            :                  HandleObject typeObj,
<span class="lineNum">    7287 </span>            :                  HandleObject fnObj,
<span class="lineNum">    7288 </span>            :                  HandleObject thisObj,
<span class="lineNum">    7289 </span>            :                  HandleValue errVal,
<span class="lineNum">    7290 </span>            :                  PRFuncPtr* fnptr)
<span class="lineNum">    7291 </span>            : {
<span class="lineNum">    7292 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(fnObj);</span>
<span class="lineNum">    7293 </span>            : 
<span class="lineNum">    7294 </span><span class="lineNoCov">          0 :   RootedObject result(cx, JS_NewObject(cx, &amp;sCClosureClass));</span>
<span class="lineNum">    7295 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    7296 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7297 </span>            : 
<span class="lineNum">    7298 </span>            :   // Get the FunctionInfo from the FunctionType.
<span class="lineNum">    7299 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    7300 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!fninfo-&gt;mIsVariadic);</span>
<span class="lineNum">    7301 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(GetABICode(fninfo-&gt;mABI) != ABI_WINAPI);</span>
<span class="lineNum">    7302 </span>            : 
<span class="lineNum">    7303 </span>            :   // Get the prototype of the FunctionType object, of class CTypeProto,
<span class="lineNum">    7304 </span>            :   // which stores our JSContext for use with the closure.
<span class="lineNum">    7305 </span><span class="lineNoCov">          0 :   RootedObject proto(cx);</span>
<span class="lineNum">    7306 </span><span class="lineNoCov">          0 :   if (!JS_GetPrototype(cx, typeObj, &amp;proto))</span>
<span class="lineNum">    7307 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7308 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(proto);</span>
<span class="lineNum">    7309 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCTypeProto(proto));</span>
<span class="lineNum">    7310 </span>            : 
<span class="lineNum">    7311 </span>            :   // Prepare the error sentinel value. It's important to do this now, because
<span class="lineNum">    7312 </span>            :   // we might be unable to convert the value to the proper type. If so, we want
<span class="lineNum">    7313 </span>            :   // the caller to know about it _now_, rather than some uncertain time in the
<span class="lineNum">    7314 </span>            :   // future when the error sentinel is actually needed.
<span class="lineNum">    7315 </span><span class="lineNoCov">          0 :   UniquePtr&lt;uint8_t[], JS::FreePolicy&gt; errResult;</span>
<span class="lineNum">    7316 </span><span class="lineNoCov">          0 :   if (!errVal.isUndefined()) {</span>
<span class="lineNum">    7317 </span>            : 
<span class="lineNum">    7318 </span>            :     // Make sure the callback returns something.
<span class="lineNum">    7319 </span><span class="lineNoCov">          0 :     if (CType::GetTypeCode(fninfo-&gt;mReturnType) == TYPE_void_t) {</span>
<span class="lineNum">    7320 </span><span class="lineNoCov">          0 :       JS_ReportErrorASCII(cx, &quot;A void callback can't pass an error sentinel&quot;);</span>
<span class="lineNum">    7321 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    7322 </span>            :     }
<span class="lineNum">    7323 </span>            : 
<span class="lineNum">    7324 </span>            :     // With the exception of void, the FunctionType constructor ensures that
<span class="lineNum">    7325 </span>            :     // the return type has a defined size.
<span class="lineNum">    7326 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(CType::IsSizeDefined(fninfo-&gt;mReturnType));</span>
<span class="lineNum">    7327 </span>            : 
<span class="lineNum">    7328 </span>            :     // Allocate a buffer for the return value.
<span class="lineNum">    7329 </span><span class="lineNoCov">          0 :     size_t rvSize = CType::GetSize(fninfo-&gt;mReturnType);</span>
<span class="lineNum">    7330 </span><span class="lineNoCov">          0 :     errResult = result-&gt;zone()-&gt;make_pod_array&lt;uint8_t&gt;(rvSize);</span>
<span class="lineNum">    7331 </span><span class="lineNoCov">          0 :     if (!errResult)</span>
<span class="lineNum">    7332 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    7333 </span>            : 
<span class="lineNum">    7334 </span>            :     // Do the value conversion. This might fail, in which case we throw.
<span class="lineNum">    7335 </span><span class="lineNoCov">          0 :     if (!ImplicitConvert(cx, errVal, fninfo-&gt;mReturnType, errResult.get(),</span>
<span class="lineNum">    7336 </span><span class="lineNoCov">          0 :                          ConversionType::Return, nullptr, typeObj))</span>
<span class="lineNum">    7337 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    7338 </span>            :   }
<span class="lineNum">    7339 </span>            : 
<span class="lineNum">    7340 </span><span class="lineNoCov">          0 :   ClosureInfo* cinfo = cx-&gt;new_&lt;ClosureInfo&gt;(cx);</span>
<span class="lineNum">    7341 </span><span class="lineNoCov">          0 :   if (!cinfo) {</span>
<span class="lineNum">    7342 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7343 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7344 </span>            :   }
<span class="lineNum">    7345 </span>            : 
<span class="lineNum">    7346 </span>            :   // Copy the important bits of context into cinfo.
<span class="lineNum">    7347 </span><span class="lineNoCov">          0 :   cinfo-&gt;errResult = errResult.release();</span>
<span class="lineNum">    7348 </span><span class="lineNoCov">          0 :   cinfo-&gt;closureObj = result;</span>
<span class="lineNum">    7349 </span><span class="lineNoCov">          0 :   cinfo-&gt;typeObj = typeObj;</span>
<span class="lineNum">    7350 </span><span class="lineNoCov">          0 :   cinfo-&gt;thisObj = thisObj;</span>
<span class="lineNum">    7351 </span><span class="lineNoCov">          0 :   cinfo-&gt;jsfnObj = fnObj;</span>
<span class="lineNum">    7352 </span>            : 
<span class="lineNum">    7353 </span>            :   // Stash the ClosureInfo struct on our new object.
<span class="lineNum">    7354 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(result, SLOT_CLOSUREINFO, PrivateValue(cinfo));</span>
<span class="lineNum">    7355 </span>            : 
<span class="lineNum">    7356 </span>            :   // Create an ffi_closure object and initialize it.
<span class="lineNum">    7357 </span>            :   void* code;
<span class="lineNum">    7358 </span><span class="lineNoCov">          0 :   cinfo-&gt;closure =</span>
<span class="lineNum">    7359 </span><span class="lineNoCov">          0 :     static_cast&lt;ffi_closure*&gt;(ffi_closure_alloc(sizeof(ffi_closure), &amp;code));</span>
<span class="lineNum">    7360 </span><span class="lineNoCov">          0 :   if (!cinfo-&gt;closure || !code) {</span>
<span class="lineNum">    7361 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;couldn't create closure - libffi error&quot;);</span>
<span class="lineNum">    7362 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7363 </span>            :   }
<span class="lineNum">    7364 </span>            : 
<span class="lineNum">    7365 </span><span class="lineNoCov">          0 :   ffi_status status = ffi_prep_closure_loc(cinfo-&gt;closure, &amp;fninfo-&gt;mCIF,</span>
<span class="lineNum">    7366 </span><span class="lineNoCov">          0 :     CClosure::ClosureStub, cinfo, code);</span>
<span class="lineNum">    7367 </span><span class="lineNoCov">          0 :   if (status != FFI_OK) {</span>
<span class="lineNum">    7368 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;couldn't create closure - libffi error&quot;);</span>
<span class="lineNum">    7369 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7370 </span>            :   }
<span class="lineNum">    7371 </span>            : 
<span class="lineNum">    7372 </span>            :   // Casting between void* and a function pointer is forbidden in C and C++.
<span class="lineNum">    7373 </span>            :   // Do it via an integral type.
<span class="lineNum">    7374 </span><span class="lineNoCov">          0 :   *fnptr = reinterpret_cast&lt;PRFuncPtr&gt;(reinterpret_cast&lt;uintptr_t&gt;(code));</span>
<span class="lineNum">    7375 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    7376 </span>            : }
<a name="7377"><span class="lineNum">    7377 </span>            : </a>
<span class="lineNum">    7378 </span>            : void
<span class="lineNum">    7379 </span><span class="lineNoCov">          0 : CClosure::Trace(JSTracer* trc, JSObject* obj)</span>
<span class="lineNum">    7380 </span>            : {
<span class="lineNum">    7381 </span>            :   // Make sure our ClosureInfo slot is legit. If it's not, bail.
<span class="lineNum">    7382 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_CLOSUREINFO);</span>
<span class="lineNum">    7383 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    7384 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7385 </span>            : 
<span class="lineNum">    7386 </span><span class="lineNoCov">          0 :   ClosureInfo* cinfo = static_cast&lt;ClosureInfo*&gt;(slot.toPrivate());</span>
<span class="lineNum">    7387 </span>            : 
<span class="lineNum">    7388 </span>            :   // Identify our objects to the tracer. (There's no need to identify
<span class="lineNum">    7389 </span>            :   // 'closureObj', since that's us.)
<span class="lineNum">    7390 </span><span class="lineNoCov">          0 :   JS::TraceEdge(trc, &amp;cinfo-&gt;typeObj, &quot;typeObj&quot;);</span>
<span class="lineNum">    7391 </span><span class="lineNoCov">          0 :   JS::TraceEdge(trc, &amp;cinfo-&gt;jsfnObj, &quot;jsfnObj&quot;);</span>
<span class="lineNum">    7392 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;thisObj)</span>
<span class="lineNum">    7393 </span><span class="lineNoCov">          0 :     JS::TraceEdge(trc, &amp;cinfo-&gt;thisObj, &quot;thisObj&quot;);</span>
<span class="lineNum">    7394 </span>            : }
<a name="7395"><span class="lineNum">    7395 </span>            : </a>
<span class="lineNum">    7396 </span>            : void
<span class="lineNum">    7397 </span><span class="lineNoCov">          0 : CClosure::Finalize(JSFreeOp* fop, JSObject* obj)</span>
<span class="lineNum">    7398 </span>            : {
<span class="lineNum">    7399 </span>            :   // Make sure our ClosureInfo slot is legit. If it's not, bail.
<span class="lineNum">    7400 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_CLOSUREINFO);</span>
<span class="lineNum">    7401 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    7402 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7403 </span>            : 
<span class="lineNum">    7404 </span><span class="lineNoCov">          0 :   ClosureInfo* cinfo = static_cast&lt;ClosureInfo*&gt;(slot.toPrivate());</span>
<span class="lineNum">    7405 </span><span class="lineNoCov">          0 :   FreeOp::get(fop)-&gt;delete_(cinfo);</span>
<span class="lineNum">    7406 </span>            : }
<a name="7407"><span class="lineNum">    7407 </span>            : </a>
<span class="lineNum">    7408 </span>            : void
<span class="lineNum">    7409 </span><span class="lineNoCov">          0 : CClosure::ClosureStub(ffi_cif* cif, void* result, void** args, void* userData)</span>
<span class="lineNum">    7410 </span>            : {
<span class="lineNum">    7411 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(cif);</span>
<span class="lineNum">    7412 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(result);</span>
<span class="lineNum">    7413 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(args);</span>
<span class="lineNum">    7414 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(userData);</span>
<span class="lineNum">    7415 </span>            : 
<span class="lineNum">    7416 </span>            :   // Retrieve the essentials from our closure object.
<span class="lineNum">    7417 </span><span class="lineNoCov">          0 :   ArgClosure argClosure(cif, result, args, static_cast&lt;ClosureInfo*&gt;(userData));</span>
<span class="lineNum">    7418 </span><span class="lineNoCov">          0 :   JSContext* cx = argClosure.cinfo-&gt;cx;</span>
<span class="lineNum">    7419 </span><span class="lineNoCov">          0 :   RootedObject fun(cx, argClosure.cinfo-&gt;jsfnObj);</span>
<span class="lineNum">    7420 </span>            : 
<span class="lineNum">    7421 </span><span class="lineNoCov">          0 :   js::PrepareScriptEnvironmentAndInvoke(cx, fun, argClosure);</span>
<a name="7422"><span class="lineNum">    7422 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    7423 </span>            : 
<span class="lineNum">    7424 </span><span class="lineNoCov">          0 : bool CClosure::ArgClosure::operator()(JSContext* cx)</span>
<span class="lineNum">    7425 </span>            : {
<span class="lineNum">    7426 </span>            :   // Let the runtime callback know that we are about to call into JS again. The end callback will
<span class="lineNum">    7427 </span>            :   // fire automatically when we exit this function.
<span class="lineNum">    7428 </span>            :   js::AutoCTypesActivityCallback autoCallback(cx, js::CTYPES_CALLBACK_BEGIN,
<span class="lineNum">    7429 </span><span class="lineNoCov">          0 :                                               js::CTYPES_CALLBACK_END);</span>
<span class="lineNum">    7430 </span>            : 
<span class="lineNum">    7431 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, cinfo-&gt;typeObj);</span>
<span class="lineNum">    7432 </span><span class="lineNoCov">          0 :   RootedObject thisObj(cx, cinfo-&gt;thisObj);</span>
<span class="lineNum">    7433 </span><span class="lineNoCov">          0 :   RootedValue jsfnVal(cx, ObjectValue(*cinfo-&gt;jsfnObj));</span>
<span class="lineNum">    7434 </span><span class="lineNoCov">          0 :   AssertSameCompartment(cx, cinfo-&gt;jsfnObj);</span>
<span class="lineNum">    7435 </span>            : 
<span class="lineNum">    7436 </span>            : 
<span class="lineNum">    7437 </span><span class="lineNoCov">          0 :   JS_AbortIfWrongThread(cx);</span>
<span class="lineNum">    7438 </span>            : 
<span class="lineNum">    7439 </span>            :   // Assert that our CIFs agree.
<span class="lineNum">    7440 </span><span class="lineNoCov">          0 :   FunctionInfo* fninfo = FunctionType::GetFunctionInfo(typeObj);</span>
<span class="lineNum">    7441 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(cif == &amp;fninfo-&gt;mCIF);</span>
<span class="lineNum">    7442 </span>            : 
<span class="lineNum">    7443 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(fninfo-&gt;mReturnType);</span>
<span class="lineNum">    7444 </span>            : 
<span class="lineNum">    7445 </span>            :   // Initialize the result to zero, in case something fails. Small integer types
<span class="lineNum">    7446 </span>            :   // are promoted to a word-sized ffi_arg, so we must be careful to zero the
<span class="lineNum">    7447 </span>            :   // whole word.
<span class="lineNum">    7448 </span><span class="lineNoCov">          0 :   size_t rvSize = 0;</span>
<span class="lineNum">    7449 </span><span class="lineNoCov">          0 :   if (cif-&gt;rtype != &amp;ffi_type_void) {</span>
<span class="lineNum">    7450 </span><span class="lineNoCov">          0 :     rvSize = cif-&gt;rtype-&gt;size;</span>
<span class="lineNum">    7451 </span><span class="lineNoCov">          0 :     switch (typeCode) {</span>
<span class="lineNum">    7452 </span>            : #define INTEGRAL_CASE(name, type, ffiType)  case TYPE_##name:
<span class="lineNum">    7453 </span>            :     CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)
<span class="lineNum">    7454 </span>            :     CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGRAL_CASE)
<span class="lineNum">    7455 </span>            :     CTYPES_FOR_EACH_BOOL_TYPE(INTEGRAL_CASE)
<span class="lineNum">    7456 </span>            :     CTYPES_FOR_EACH_CHAR_TYPE(INTEGRAL_CASE)
<span class="lineNum">    7457 </span>            :     CTYPES_FOR_EACH_CHAR16_TYPE(INTEGRAL_CASE)
<span class="lineNum">    7458 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    7459 </span><span class="lineNoCov">          0 :       rvSize = Align(rvSize, sizeof(ffi_arg));</span>
<span class="lineNum">    7460 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7461 </span>            :     default:
<span class="lineNum">    7462 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7463 </span>            :     }
<span class="lineNum">    7464 </span><span class="lineNoCov">          0 :     memset(result, 0, rvSize);</span>
<span class="lineNum">    7465 </span>            :   }
<span class="lineNum">    7466 </span>            : 
<span class="lineNum">    7467 </span>            :   // Set up an array for converted arguments.
<span class="lineNum">    7468 </span><span class="lineNoCov">          0 :   JS::AutoValueVector argv(cx);</span>
<span class="lineNum">    7469 </span><span class="lineNoCov">          0 :   if (!argv.resize(cif-&gt;nargs)) {</span>
<span class="lineNum">    7470 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7471 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7472 </span>            :   }
<span class="lineNum">    7473 </span>            : 
<span class="lineNum">    7474 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; cif-&gt;nargs; ++i) {</span>
<span class="lineNum">    7475 </span>            :     // Convert each argument, and have any CData objects created depend on
<span class="lineNum">    7476 </span>            :     // the existing buffers.
<span class="lineNum">    7477 </span><span class="lineNoCov">          0 :     RootedObject argType(cx, fninfo-&gt;mArgTypes[i]);</span>
<span class="lineNum">    7478 </span><span class="lineNoCov">          0 :     if (!ConvertToJS(cx, argType, nullptr, args[i], false, false, argv[i]))</span>
<span class="lineNum">    7479 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7480 </span>            :   }
<span class="lineNum">    7481 </span>            : 
<span class="lineNum">    7482 </span>            :   // Call the JS function. 'thisObj' may be nullptr, in which case the JS
<span class="lineNum">    7483 </span>            :   // engine will find an appropriate object to use.
<span class="lineNum">    7484 </span><span class="lineNoCov">          0 :   RootedValue rval(cx);</span>
<span class="lineNum">    7485 </span><span class="lineNoCov">          0 :   bool success = JS_CallFunctionValue(cx, thisObj, jsfnVal, argv, &amp;rval);</span>
<span class="lineNum">    7486 </span>            : 
<span class="lineNum">    7487 </span>            :   // Convert the result. Note that we pass 'ConversionType::Return', such that
<span class="lineNum">    7488 </span>            :   // ImplicitConvert will *not* autoconvert a JS string into a pointer-to-char
<span class="lineNum">    7489 </span>            :   // type, which would require an allocation that we can't track. The JS
<span class="lineNum">    7490 </span>            :   // function must perform this conversion itself and return a PointerType
<span class="lineNum">    7491 </span>            :   // CData; thusly, the burden of freeing the data is left to the user.
<span class="lineNum">    7492 </span><span class="lineNoCov">          0 :   if (success &amp;&amp; cif-&gt;rtype != &amp;ffi_type_void)</span>
<span class="lineNum">    7493 </span><span class="lineNoCov">          0 :     success = ImplicitConvert(cx, rval, fninfo-&gt;mReturnType, result,</span>
<span class="lineNum">    7494 </span><span class="lineNoCov">          0 :                               ConversionType::Return, nullptr, typeObj);</span>
<span class="lineNum">    7495 </span>            : 
<span class="lineNum">    7496 </span><span class="lineNoCov">          0 :   if (!success) {</span>
<span class="lineNum">    7497 </span>            :     // Something failed. The callee may have thrown, or it may not have
<span class="lineNum">    7498 </span>            :     // returned a value that ImplicitConvert() was happy with. Depending on how
<span class="lineNum">    7499 </span>            :     // prudent the consumer has been, we may or may not have a recovery plan.
<span class="lineNum">    7500 </span>            :     //
<span class="lineNum">    7501 </span>            :     // Note that PrepareScriptEnvironmentAndInvoke should take care of reporting
<span class="lineNum">    7502 </span>            :     // the exception.
<span class="lineNum">    7503 </span>            : 
<span class="lineNum">    7504 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;errResult) {</span>
<span class="lineNum">    7505 </span>            :       // Good case: we have a sentinel that we can return. Copy it in place of
<span class="lineNum">    7506 </span>            :       // the actual return value, and then proceed.
<span class="lineNum">    7507 </span>            : 
<span class="lineNum">    7508 </span>            :       // The buffer we're returning might be larger than the size of the return
<span class="lineNum">    7509 </span>            :       // type, due to libffi alignment issues (see above). But it should never
<span class="lineNum">    7510 </span>            :       // be smaller.
<span class="lineNum">    7511 </span><span class="lineNoCov">          0 :       size_t copySize = CType::GetSize(fninfo-&gt;mReturnType);</span>
<span class="lineNum">    7512 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(copySize &lt;= rvSize);</span>
<span class="lineNum">    7513 </span><span class="lineNoCov">          0 :       memcpy(result, cinfo-&gt;errResult, copySize);</span>
<span class="lineNum">    7514 </span>            : 
<span class="lineNum">    7515 </span>            :       // We still want to return false here, so that
<span class="lineNum">    7516 </span>            :       // PrepareScriptEnvironmentAndInvoke will report the exception.
<span class="lineNum">    7517 </span>            :     } else {
<span class="lineNum">    7518 </span>            :       // Bad case: not much we can do here. The rv is already zeroed out, so we
<span class="lineNum">    7519 </span>            :       // just return and hope for the best.
<span class="lineNum">    7520 </span>            :     }
<span class="lineNum">    7521 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7522 </span>            :   }
<span class="lineNum">    7523 </span>            : 
<span class="lineNum">    7524 </span>            :   // Small integer types must be returned as a word-sized ffi_arg. Coerce it
<span class="lineNum">    7525 </span>            :   // back into the size libffi expects.
<span class="lineNum">    7526 </span><span class="lineNoCov">          0 :   switch (typeCode) {</span>
<span class="lineNum">    7527 </span>            : #define INTEGRAL_CASE(name, type, ffiType)                                     \
<span class="lineNum">    7528 </span>            :   case TYPE_##name:                                                            \
<span class="lineNum">    7529 </span>            :     if (sizeof(type) &lt; sizeof(ffi_arg)) {                                      \
<span class="lineNum">    7530 </span>            :       ffi_arg data = *static_cast&lt;type*&gt;(result);                              \
<span class="lineNum">    7531 </span>            :       *static_cast&lt;ffi_arg*&gt;(result) = data;                                   \
<span class="lineNum">    7532 </span>            :     }                                                                          \
<span class="lineNum">    7533 </span>            :     break;
<span class="lineNum">    7534 </span><span class="lineNoCov">          0 :     CTYPES_FOR_EACH_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7535 </span><span class="lineNoCov">          0 :     CTYPES_FOR_EACH_WRAPPED_INT_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7536 </span><span class="lineNoCov">          0 :     CTYPES_FOR_EACH_BOOL_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7537 </span><span class="lineNoCov">          0 :     CTYPES_FOR_EACH_CHAR_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7538 </span><span class="lineNoCov">          0 :     CTYPES_FOR_EACH_CHAR16_TYPE(INTEGRAL_CASE)</span>
<span class="lineNum">    7539 </span>            : #undef INTEGRAL_CASE
<span class="lineNum">    7540 </span>            :   default:
<span class="lineNum">    7541 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7542 </span>            :   }
<span class="lineNum">    7543 </span>            : 
<span class="lineNum">    7544 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7545 </span>            : }
<span class="lineNum">    7546 </span>            : 
<span class="lineNum">    7547 </span>            : /*******************************************************************************
<span class="lineNum">    7548 </span>            : ** CData implementation
<span class="lineNum">    7549 </span>            : *******************************************************************************/
<span class="lineNum">    7550 </span>            : 
<span class="lineNum">    7551 </span>            : // Create a new CData object of type 'typeObj' containing binary data supplied
<span class="lineNum">    7552 </span>            : // in 'source', optionally with a referent object 'refObj'.
<span class="lineNum">    7553 </span>            : //
<span class="lineNum">    7554 </span>            : // * 'typeObj' must be a CType of defined (but possibly zero) size.
<span class="lineNum">    7555 </span>            : //
<span class="lineNum">    7556 </span>            : // * If an object 'refObj' is supplied, the new CData object stores the
<span class="lineNum">    7557 </span>            : //   referent object in a reserved slot for GC safety, such that 'refObj' will
<span class="lineNum">    7558 </span>            : //   be held alive by the resulting CData object. 'refObj' may or may not be
<span class="lineNum">    7559 </span>            : //   a CData object; merely an object we want to keep alive.
<span class="lineNum">    7560 </span>            : //   * If 'refObj' is a CData object, 'ownResult' must be false.
<span class="lineNum">    7561 </span>            : //   * Otherwise, 'refObj' is a Library or CClosure object, and 'ownResult'
<span class="lineNum">    7562 </span>            : //     may be true or false.
<span class="lineNum">    7563 </span>            : // * Otherwise 'refObj' is nullptr. In this case, 'ownResult' may be true or
<span class="lineNum">    7564 </span>            : //   false.
<span class="lineNum">    7565 </span>            : //
<span class="lineNum">    7566 </span>            : // * If 'ownResult' is true, the CData object will allocate an appropriately
<span class="lineNum">    7567 </span>            : //   sized buffer, and free it upon finalization. If 'source' data is
<span class="lineNum">    7568 </span>            : //   supplied, the data will be copied from 'source' into the buffer;
<span class="lineNum">    7569 </span>            : //   otherwise, the entirety of the new buffer will be initialized to zero.
<span class="lineNum">    7570 </span>            : // * If 'ownResult' is false, the new CData's buffer refers to a slice of
<span class="lineNum">    7571 </span>            : //   another buffer kept alive by 'refObj'. 'source' data must be provided,
<a name="7572"><span class="lineNum">    7572 </span>            : //   and the new CData's buffer will refer to 'source'.</a>
<span class="lineNum">    7573 </span>            : JSObject*
<span class="lineNum">    7574 </span><span class="lineNoCov">          0 : CData::Create(JSContext* cx,</span>
<span class="lineNum">    7575 </span>            :               HandleObject typeObj,
<span class="lineNum">    7576 </span>            :               HandleObject refObj,
<span class="lineNum">    7577 </span>            :               void* source,
<span class="lineNum">    7578 </span>            :               bool ownResult)
<span class="lineNum">    7579 </span>            : {
<span class="lineNum">    7580 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(typeObj);</span>
<span class="lineNum">    7581 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(typeObj));</span>
<span class="lineNum">    7582 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsSizeDefined(typeObj));</span>
<span class="lineNum">    7583 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(ownResult || source);</span>
<span class="lineNum">    7584 </span><span class="lineNoCov">          0 :   MOZ_ASSERT_IF(refObj &amp;&amp; CData::IsCData(refObj), !ownResult);</span>
<span class="lineNum">    7585 </span>            : 
<span class="lineNum">    7586 </span>            :   // Get the 'prototype' property from the type.
<span class="lineNum">    7587 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(typeObj, SLOT_PROTO);</span>
<span class="lineNum">    7588 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(slot.isObject());</span>
<span class="lineNum">    7589 </span>            : 
<span class="lineNum">    7590 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, &amp;slot.toObject());</span>
<span class="lineNum">    7591 </span>            : 
<span class="lineNum">    7592 </span><span class="lineNoCov">          0 :   RootedObject dataObj(cx, JS_NewObjectWithGivenProto(cx, &amp;sCDataClass, proto));</span>
<span class="lineNum">    7593 </span><span class="lineNoCov">          0 :   if (!dataObj)</span>
<span class="lineNum">    7594 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7595 </span>            : 
<span class="lineNum">    7596 </span>            :   // set the CData's associated type
<span class="lineNum">    7597 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(dataObj, SLOT_CTYPE, ObjectValue(*typeObj));</span>
<span class="lineNum">    7598 </span>            : 
<span class="lineNum">    7599 </span>            :   // Stash the referent object, if any, for GC safety.
<span class="lineNum">    7600 </span><span class="lineNoCov">          0 :   if (refObj)</span>
<span class="lineNum">    7601 </span><span class="lineNoCov">          0 :     JS_SetReservedSlot(dataObj, SLOT_REFERENT, ObjectValue(*refObj));</span>
<span class="lineNum">    7602 </span>            : 
<span class="lineNum">    7603 </span>            :   // Set our ownership flag.
<span class="lineNum">    7604 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(dataObj, SLOT_OWNS, BooleanValue(ownResult));</span>
<span class="lineNum">    7605 </span>            : 
<span class="lineNum">    7606 </span>            :   // attach the buffer. since it might not be 2-byte aligned, we need to
<span class="lineNum">    7607 </span>            :   // allocate an aligned space for it and store it there. :(
<span class="lineNum">    7608 </span><span class="lineNoCov">          0 :   char** buffer = cx-&gt;new_&lt;char*&gt;();</span>
<span class="lineNum">    7609 </span><span class="lineNoCov">          0 :   if (!buffer) {</span>
<span class="lineNum">    7610 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    7611 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7612 </span>            :   }
<span class="lineNum">    7613 </span>            : 
<span class="lineNum">    7614 </span>            :   char* data;
<span class="lineNum">    7615 </span><span class="lineNoCov">          0 :   if (!ownResult) {</span>
<span class="lineNum">    7616 </span><span class="lineNoCov">          0 :     data = static_cast&lt;char*&gt;(source);</span>
<span class="lineNum">    7617 </span>            :   } else {
<span class="lineNum">    7618 </span>            :     // Initialize our own buffer.
<span class="lineNum">    7619 </span><span class="lineNoCov">          0 :     size_t size = CType::GetSize(typeObj);</span>
<span class="lineNum">    7620 </span><span class="lineNoCov">          0 :     data = dataObj-&gt;zone()-&gt;pod_malloc&lt;char&gt;(size);</span>
<span class="lineNum">    7621 </span><span class="lineNoCov">          0 :     if (!data) {</span>
<span class="lineNum">    7622 </span>            :       // Report a catchable allocation error.
<span class="lineNum">    7623 </span><span class="lineNoCov">          0 :       JS_ReportAllocationOverflow(cx);</span>
<span class="lineNum">    7624 </span><span class="lineNoCov">          0 :       js_free(buffer);</span>
<span class="lineNum">    7625 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    7626 </span>            :     }
<span class="lineNum">    7627 </span>            : 
<span class="lineNum">    7628 </span><span class="lineNoCov">          0 :     if (!source)</span>
<span class="lineNum">    7629 </span><span class="lineNoCov">          0 :       memset(data, 0, size);</span>
<span class="lineNum">    7630 </span>            :     else
<span class="lineNum">    7631 </span><span class="lineNoCov">          0 :       memcpy(data, source, size);</span>
<span class="lineNum">    7632 </span>            :   }
<span class="lineNum">    7633 </span>            : 
<span class="lineNum">    7634 </span><span class="lineNoCov">          0 :   *buffer = data;</span>
<span class="lineNum">    7635 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(dataObj, SLOT_DATA, PrivateValue(buffer));</span>
<span class="lineNum">    7636 </span>            : 
<span class="lineNum">    7637 </span><span class="lineNoCov">          0 :   return dataObj;</span>
<span class="lineNum">    7638 </span>            : }
<a name="7639"><span class="lineNum">    7639 </span>            : </a>
<span class="lineNum">    7640 </span>            : void
<span class="lineNum">    7641 </span><span class="lineNoCov">          0 : CData::Finalize(JSFreeOp* fop, JSObject* obj)</span>
<span class="lineNum">    7642 </span>            : {
<span class="lineNum">    7643 </span>            :   // Delete our buffer, and the data it contains if we own it.
<span class="lineNum">    7644 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_OWNS);</span>
<span class="lineNum">    7645 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    7646 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7647 </span>            : 
<span class="lineNum">    7648 </span><span class="lineNoCov">          0 :   bool owns = slot.toBoolean();</span>
<span class="lineNum">    7649 </span>            : 
<span class="lineNum">    7650 </span><span class="lineNoCov">          0 :   slot = JS_GetReservedSlot(obj, SLOT_DATA);</span>
<span class="lineNum">    7651 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    7652 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    7653 </span><span class="lineNoCov">          0 :   char** buffer = static_cast&lt;char**&gt;(slot.toPrivate());</span>
<span class="lineNum">    7654 </span>            : 
<span class="lineNum">    7655 </span><span class="lineNoCov">          0 :   if (owns)</span>
<span class="lineNum">    7656 </span><span class="lineNoCov">          0 :     FreeOp::get(fop)-&gt;free_(*buffer);</span>
<span class="lineNum">    7657 </span><span class="lineNoCov">          0 :   FreeOp::get(fop)-&gt;delete_(buffer);</span>
<span class="lineNum">    7658 </span>            : }
<a name="7659"><span class="lineNum">    7659 </span>            : </a>
<span class="lineNum">    7660 </span>            : JSObject*
<span class="lineNum">    7661 </span><span class="lineNoCov">          0 : CData::GetCType(JSObject* dataObj)</span>
<span class="lineNum">    7662 </span>            : {
<span class="lineNum">    7663 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CData::IsCData(dataObj));</span>
<span class="lineNum">    7664 </span>            : 
<span class="lineNum">    7665 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(dataObj, SLOT_CTYPE);</span>
<span class="lineNum">    7666 </span><span class="lineNoCov">          0 :   JSObject* typeObj = slot.toObjectOrNull();</span>
<span class="lineNum">    7667 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::IsCType(typeObj));</span>
<span class="lineNum">    7668 </span><span class="lineNoCov">          0 :   return typeObj;</span>
<span class="lineNum">    7669 </span>            : }
<a name="7670"><span class="lineNum">    7670 </span>            : </a>
<span class="lineNum">    7671 </span>            : void*
<span class="lineNum">    7672 </span><span class="lineNoCov">          0 : CData::GetData(JSObject* dataObj)</span>
<span class="lineNum">    7673 </span>            : {
<span class="lineNum">    7674 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CData::IsCData(dataObj));</span>
<span class="lineNum">    7675 </span>            : 
<span class="lineNum">    7676 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(dataObj, SLOT_DATA);</span>
<span class="lineNum">    7677 </span>            : 
<span class="lineNum">    7678 </span><span class="lineNoCov">          0 :   void** buffer = static_cast&lt;void**&gt;(slot.toPrivate());</span>
<span class="lineNum">    7679 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(buffer);</span>
<span class="lineNum">    7680 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(*buffer);</span>
<span class="lineNum">    7681 </span><span class="lineNoCov">          0 :   return *buffer;</span>
<span class="lineNum">    7682 </span>            : }
<a name="7683"><span class="lineNum">    7683 </span>            : </a>
<span class="lineNum">    7684 </span>            : bool
<span class="lineNum">    7685 </span><span class="lineNoCov">          0 : CData::IsCData(JSObject* obj)</span>
<span class="lineNum">    7686 </span>            : {
<span class="lineNum">    7687 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sCDataClass;</span>
<span class="lineNum">    7688 </span>            : }
<a name="7689"><span class="lineNum">    7689 </span>            : </a>
<span class="lineNum">    7690 </span>            : bool
<span class="lineNum">    7691 </span><span class="lineNoCov">          0 : CData::IsCData(HandleValue v)</span>
<span class="lineNum">    7692 </span>            : {
<span class="lineNum">    7693 </span><span class="lineNoCov">          0 :   return v.isObject() &amp;&amp; CData::IsCData(&amp;v.toObject());</span>
<span class="lineNum">    7694 </span>            : }
<a name="7695"><span class="lineNum">    7695 </span>            : </a>
<span class="lineNum">    7696 </span>            : bool
<span class="lineNum">    7697 </span><span class="lineNoCov">          0 : CData::IsCDataProto(JSObject* obj)</span>
<span class="lineNum">    7698 </span>            : {
<span class="lineNum">    7699 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sCDataProtoClass;</span>
<span class="lineNum">    7700 </span>            : }
<a name="7701"><span class="lineNum">    7701 </span>            : </a>
<span class="lineNum">    7702 </span>            : bool
<span class="lineNum">    7703 </span><span class="lineNoCov">          0 : CData::ValueGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7704 </span>            : {
<span class="lineNum">    7705 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    7706 </span>            : 
<span class="lineNum">    7707 </span>            :   // Convert the value to a primitive; do not create a new CData object.
<span class="lineNum">    7708 </span><span class="lineNoCov">          0 :   RootedObject ctype(cx, GetCType(obj));</span>
<span class="lineNum">    7709 </span><span class="lineNoCov">          0 :   return ConvertToJS(cx, ctype, nullptr, GetData(obj), true, false, args.rval());</span>
<span class="lineNum">    7710 </span>            : }
<a name="7711"><span class="lineNum">    7711 </span>            : </a>
<span class="lineNum">    7712 </span>            : bool
<span class="lineNum">    7713 </span><span class="lineNoCov">          0 : CData::ValueSetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    7714 </span>            : {
<span class="lineNum">    7715 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, &amp;args.thisv().toObject());</span>
<span class="lineNum">    7716 </span><span class="lineNoCov">          0 :   args.rval().setUndefined();</span>
<span class="lineNum">    7717 </span><span class="lineNoCov">          0 :   return ImplicitConvert(cx, args.get(0), GetCType(obj), GetData(obj),</span>
<span class="lineNum">    7718 </span><span class="lineNoCov">          0 :                          ConversionType::Setter, nullptr);</span>
<span class="lineNum">    7719 </span>            : }
<a name="7720"><span class="lineNum">    7720 </span>            : </a>
<span class="lineNum">    7721 </span>            : bool
<span class="lineNum">    7722 </span><span class="lineNoCov">          0 : CData::Address(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7723 </span>            : {
<span class="lineNum">    7724 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7725 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    7726 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CData.prototype.address&quot;, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    7727 </span>            :   }
<span class="lineNum">    7728 </span>            : 
<span class="lineNum">    7729 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    7730 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    7731 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7732 </span><span class="lineNoCov">          0 :   if (!IsCData(obj)) {</span>
<span class="lineNum">    7733 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CData.prototype.address&quot;, args.thisv());</span>
<span class="lineNum">    7734 </span>            :   }
<span class="lineNum">    7735 </span>            : 
<span class="lineNum">    7736 </span><span class="lineNoCov">          0 :   RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    7737 </span><span class="lineNoCov">          0 :   RootedObject pointerType(cx, PointerType::CreateInternal(cx, typeObj));</span>
<span class="lineNum">    7738 </span><span class="lineNoCov">          0 :   if (!pointerType)</span>
<span class="lineNum">    7739 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7740 </span>            : 
<span class="lineNum">    7741 </span>            :   // Create a PointerType CData object containing null.
<span class="lineNum">    7742 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, pointerType, nullptr, nullptr, true);</span>
<span class="lineNum">    7743 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    7744 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7745 </span>            : 
<span class="lineNum">    7746 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    7747 </span>            : 
<span class="lineNum">    7748 </span>            :   // Manually set the pointer inside the object, so we skip the conversion step.
<span class="lineNum">    7749 </span><span class="lineNoCov">          0 :   void** data = static_cast&lt;void**&gt;(GetData(result));</span>
<span class="lineNum">    7750 </span><span class="lineNoCov">          0 :   *data = GetData(obj);</span>
<span class="lineNum">    7751 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7752 </span>            : }
<a name="7753"><span class="lineNum">    7753 </span>            : </a>
<span class="lineNum">    7754 </span>            : bool
<span class="lineNum">    7755 </span><span class="lineNoCov">          0 : CData::Cast(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7756 </span>            : {
<span class="lineNum">    7757 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7758 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    7759 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;ctypes.cast&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    7760 </span>            :   }
<span class="lineNum">    7761 </span>            : 
<span class="lineNum">    7762 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !CData::IsCData(&amp;args[0].toObject())) {</span>
<span class="lineNum">    7763 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;first &quot;, &quot;ctypes.cast&quot;, &quot;a CData&quot;);</span>
<span class="lineNum">    7764 </span>            :   }
<span class="lineNum">    7765 </span><span class="lineNoCov">          0 :   RootedObject sourceData(cx, &amp;args[0].toObject());</span>
<span class="lineNum">    7766 </span><span class="lineNoCov">          0 :   RootedObject sourceType(cx, CData::GetCType(sourceData));</span>
<span class="lineNum">    7767 </span>            : 
<span class="lineNum">    7768 </span><span class="lineNoCov">          0 :   if (args[1].isPrimitive() || !CType::IsCType(&amp;args[1].toObject())) {</span>
<span class="lineNum">    7769 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;second &quot;, &quot;ctypes.cast&quot;, &quot;a CType&quot;);</span>
<span class="lineNum">    7770 </span>            :   }
<span class="lineNum">    7771 </span>            : 
<span class="lineNum">    7772 </span><span class="lineNoCov">          0 :   RootedObject targetType(cx, &amp;args[1].toObject());</span>
<span class="lineNum">    7773 </span>            :   size_t targetSize;
<span class="lineNum">    7774 </span><span class="lineNoCov">          0 :   if (!CType::GetSafeSize(targetType, &amp;targetSize)) {</span>
<span class="lineNum">    7775 </span><span class="lineNoCov">          0 :     return UndefinedSizeCastError(cx, targetType);</span>
<span class="lineNum">    7776 </span>            :   }
<span class="lineNum">    7777 </span><span class="lineNoCov">          0 :   if (targetSize &gt; CType::GetSize(sourceType)) {</span>
<span class="lineNum">    7778 </span><span class="lineNoCov">          0 :     return SizeMismatchCastError(cx, sourceType, targetType,</span>
<span class="lineNum">    7779 </span><span class="lineNoCov">          0 :                                  CType::GetSize(sourceType), targetSize);</span>
<span class="lineNum">    7780 </span>            :   }
<span class="lineNum">    7781 </span>            : 
<span class="lineNum">    7782 </span>            :   // Construct a new CData object with a type of 'targetType' and a referent
<span class="lineNum">    7783 </span>            :   // of 'sourceData'.
<span class="lineNum">    7784 </span><span class="lineNoCov">          0 :   void* data = CData::GetData(sourceData);</span>
<span class="lineNum">    7785 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, targetType, sourceData, data, false);</span>
<span class="lineNum">    7786 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    7787 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7788 </span>            : 
<span class="lineNum">    7789 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    7790 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7791 </span>            : }
<a name="7792"><span class="lineNum">    7792 </span>            : </a>
<span class="lineNum">    7793 </span>            : bool
<span class="lineNum">    7794 </span><span class="lineNoCov">          0 : CData::GetRuntime(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7795 </span>            : {
<span class="lineNum">    7796 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7797 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    7798 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;ctypes.getRuntime&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    7799 </span>            :   }
<span class="lineNum">    7800 </span>            : 
<span class="lineNum">    7801 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !CType::IsCType(&amp;args[0].toObject())) {</span>
<span class="lineNum">    7802 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;ctypes.getRuntime&quot;, &quot;a CType&quot;);</span>
<span class="lineNum">    7803 </span>            :   }
<span class="lineNum">    7804 </span>            : 
<span class="lineNum">    7805 </span><span class="lineNoCov">          0 :   RootedObject targetType(cx, &amp;args[0].toObject());</span>
<span class="lineNum">    7806 </span>            :   size_t targetSize;
<span class="lineNum">    7807 </span><span class="lineNoCov">          0 :   if (!CType::GetSafeSize(targetType, &amp;targetSize) ||</span>
<span class="lineNum">    7808 </span><span class="lineNoCov">          0 :       targetSize != sizeof(void*)) {</span>
<span class="lineNum">    7809 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;target CType has non-pointer size&quot;);</span>
<span class="lineNum">    7810 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7811 </span>            :   }
<span class="lineNum">    7812 </span>            : 
<span class="lineNum">    7813 </span><span class="lineNoCov">          0 :   void* data = static_cast&lt;void*&gt;(cx-&gt;runtime());</span>
<span class="lineNum">    7814 </span><span class="lineNoCov">          0 :   JSObject* result = CData::Create(cx, targetType, nullptr, &amp;data, true);</span>
<span class="lineNum">    7815 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    7816 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7817 </span>            : 
<span class="lineNum">    7818 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    7819 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7820 </span>            : }
<span class="lineNum">    7821 </span>            : 
<span class="lineNum">    7822 </span>            : typedef JS::TwoByteCharsZ (*InflateUTF8Method)(JSContext*, const JS::UTF8Chars, size_t*);
<a name="7823"><span class="lineNum">    7823 </span>            : </a>
<span class="lineNum">    7824 </span>            : static bool
<span class="lineNum">    7825 </span><span class="lineNoCov">          0 : ReadStringCommon(JSContext* cx, InflateUTF8Method inflateUTF8, unsigned argc,</span>
<span class="lineNum">    7826 </span>            :                  Value* vp, const char* funName)
<span class="lineNum">    7827 </span>            : {
<span class="lineNum">    7828 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7829 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    7830 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, funName, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    7831 </span>            :   }
<span class="lineNum">    7832 </span>            : 
<span class="lineNum">    7833 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    7834 </span><span class="lineNoCov">          0 :   if (!obj) {</span>
<span class="lineNum">    7835 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, funName, args.thisv());</span>
<span class="lineNum">    7836 </span>            :   }
<span class="lineNum">    7837 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    7838 </span><span class="lineNoCov">          0 :       if (!CDataFinalizer::IsCDataFinalizer(obj)) {</span>
<span class="lineNum">    7839 </span><span class="lineNoCov">          0 :           return IncompatibleThisProto(cx, funName, args.thisv());</span>
<span class="lineNum">    7840 </span>            :       }
<span class="lineNum">    7841 </span>            : 
<span class="lineNum">    7842 </span>            :       CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    7843 </span><span class="lineNoCov">          0 :                                    JS_GetPrivate(obj);</span>
<span class="lineNum">    7844 </span><span class="lineNoCov">          0 :       if (!p) {</span>
<span class="lineNum">    7845 </span><span class="lineNoCov">          0 :           return EmptyFinalizerCallError(cx, funName);</span>
<span class="lineNum">    7846 </span>            :       }
<span class="lineNum">    7847 </span>            : 
<span class="lineNum">    7848 </span><span class="lineNoCov">          0 :       RootedValue dataVal(cx);</span>
<span class="lineNum">    7849 </span><span class="lineNoCov">          0 :       if (!CDataFinalizer::GetValue(cx, obj, &amp;dataVal)) {</span>
<span class="lineNum">    7850 </span><span class="lineNoCov">          0 :           return IncompatibleThisProto(cx, funName, args.thisv());</span>
<span class="lineNum">    7851 </span>            :       }
<span class="lineNum">    7852 </span>            : 
<span class="lineNum">    7853 </span><span class="lineNoCov">          0 :       if (dataVal.isPrimitive()) {</span>
<span class="lineNum">    7854 </span><span class="lineNoCov">          0 :           return IncompatibleThisProto(cx, funName, args.thisv());</span>
<span class="lineNum">    7855 </span>            :       }
<span class="lineNum">    7856 </span>            : 
<span class="lineNum">    7857 </span><span class="lineNoCov">          0 :       obj = dataVal.toObjectOrNull();</span>
<span class="lineNum">    7858 </span><span class="lineNoCov">          0 :       if (!obj || !CData::IsCData(obj)) {</span>
<span class="lineNum">    7859 </span><span class="lineNoCov">          0 :           return IncompatibleThisProto(cx, funName, args.thisv());</span>
<span class="lineNum">    7860 </span>            :       }
<span class="lineNum">    7861 </span>            :   }
<span class="lineNum">    7862 </span>            : 
<span class="lineNum">    7863 </span>            :   // Make sure we are a pointer to, or an array of, an 8-bit or 16-bit
<span class="lineNum">    7864 </span>            :   // character or integer type.
<span class="lineNum">    7865 </span>            :   JSObject* baseType;
<span class="lineNum">    7866 </span><span class="lineNoCov">          0 :   JSObject* typeObj = CData::GetCType(obj);</span>
<span class="lineNum">    7867 </span><span class="lineNoCov">          0 :   TypeCode typeCode = CType::GetTypeCode(typeObj);</span>
<span class="lineNum">    7868 </span>            :   void* data;
<span class="lineNum">    7869 </span><span class="lineNoCov">          0 :   size_t maxLength = -1;</span>
<span class="lineNum">    7870 </span><span class="lineNoCov">          0 :   switch (typeCode) {</span>
<span class="lineNum">    7871 </span>            :   case TYPE_pointer:
<span class="lineNum">    7872 </span><span class="lineNoCov">          0 :     baseType = PointerType::GetBaseType(typeObj);</span>
<span class="lineNum">    7873 </span><span class="lineNoCov">          0 :     data = *static_cast&lt;void**&gt;(CData::GetData(obj));</span>
<span class="lineNum">    7874 </span><span class="lineNoCov">          0 :     if (data == nullptr) {</span>
<span class="lineNum">    7875 </span><span class="lineNoCov">          0 :       return NullPointerError(cx, &quot;read contents of&quot;, obj);</span>
<span class="lineNum">    7876 </span>            :     }
<span class="lineNum">    7877 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7878 </span>            :   case TYPE_array:
<span class="lineNum">    7879 </span><span class="lineNoCov">          0 :     baseType = ArrayType::GetBaseType(typeObj);</span>
<span class="lineNum">    7880 </span><span class="lineNoCov">          0 :     data = CData::GetData(obj);</span>
<span class="lineNum">    7881 </span><span class="lineNoCov">          0 :     maxLength = ArrayType::GetLength(typeObj);</span>
<span class="lineNum">    7882 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7883 </span>            :   default:
<span class="lineNum">    7884 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;PointerType or ArrayType&quot;, args.thisv());</span>
<span class="lineNum">    7885 </span>            :   }
<span class="lineNum">    7886 </span>            : 
<span class="lineNum">    7887 </span>            :   // Convert the string buffer, taking care to determine the correct string
<span class="lineNum">    7888 </span>            :   // length in the case of arrays (which may contain embedded nulls).
<span class="lineNum">    7889 </span>            :   JSString* result;
<span class="lineNum">    7890 </span><span class="lineNoCov">          0 :   switch (CType::GetTypeCode(baseType)) {</span>
<span class="lineNum">    7891 </span>            :   case TYPE_int8_t:
<span class="lineNum">    7892 </span>            :   case TYPE_uint8_t:
<span class="lineNum">    7893 </span>            :   case TYPE_char:
<span class="lineNum">    7894 </span>            :   case TYPE_signed_char:
<span class="lineNum">    7895 </span>            :   case TYPE_unsigned_char: {
<span class="lineNum">    7896 </span><span class="lineNoCov">          0 :     char* bytes = static_cast&lt;char*&gt;(data);</span>
<span class="lineNum">    7897 </span><span class="lineNoCov">          0 :     size_t length = strnlen(bytes, maxLength);</span>
<span class="lineNum">    7898 </span>            : 
<span class="lineNum">    7899 </span>            :     // Determine the length.
<span class="lineNum">    7900 </span><span class="lineNoCov">          0 :     char16_t* dst = inflateUTF8(cx, JS::UTF8Chars(bytes, length), &amp;length).get();</span>
<span class="lineNum">    7901 </span><span class="lineNoCov">          0 :     if (!dst)</span>
<span class="lineNum">    7902 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7903 </span>            : 
<span class="lineNum">    7904 </span><span class="lineNoCov">          0 :     result = JS_NewUCString(cx, dst, length);</span>
<span class="lineNum">    7905 </span><span class="lineNoCov">          0 :     if (!result) {</span>
<span class="lineNum">    7906 </span><span class="lineNoCov">          0 :       js_free(dst);</span>
<span class="lineNum">    7907 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7908 </span>            :     }
<span class="lineNum">    7909 </span>            : 
<span class="lineNum">    7910 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7911 </span>            :   }
<span class="lineNum">    7912 </span>            :   case TYPE_int16_t:
<span class="lineNum">    7913 </span>            :   case TYPE_uint16_t:
<span class="lineNum">    7914 </span>            :   case TYPE_short:
<span class="lineNum">    7915 </span>            :   case TYPE_unsigned_short:
<span class="lineNum">    7916 </span>            :   case TYPE_char16_t: {
<span class="lineNum">    7917 </span><span class="lineNoCov">          0 :     char16_t* chars = static_cast&lt;char16_t*&gt;(data);</span>
<span class="lineNum">    7918 </span><span class="lineNoCov">          0 :     size_t length = strnlen(chars, maxLength);</span>
<span class="lineNum">    7919 </span><span class="lineNoCov">          0 :     result = JS_NewUCStringCopyN(cx, chars, length);</span>
<span class="lineNum">    7920 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    7921 </span>            :   }
<span class="lineNum">    7922 </span>            :   default:
<span class="lineNum">    7923 </span><span class="lineNoCov">          0 :     return NonStringBaseError(cx, args.thisv());</span>
<span class="lineNum">    7924 </span>            :   }
<span class="lineNum">    7925 </span>            : 
<span class="lineNum">    7926 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    7927 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7928 </span>            : 
<span class="lineNum">    7929 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    7930 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    7931 </span>            : }
<a name="7932"><span class="lineNum">    7932 </span>            : </a>
<span class="lineNum">    7933 </span>            : bool
<span class="lineNum">    7934 </span><span class="lineNoCov">          0 : CData::ReadString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7935 </span>            : {
<span class="lineNum">    7936 </span>            :   return ReadStringCommon(cx, JS::UTF8CharsToNewTwoByteCharsZ, argc, vp,
<span class="lineNum">    7937 </span><span class="lineNoCov">          0 :                           &quot;CData.prototype.readString&quot;);</span>
<span class="lineNum">    7938 </span>            : }
<a name="7939"><span class="lineNum">    7939 </span>            : </a>
<span class="lineNum">    7940 </span>            : bool
<span class="lineNum">    7941 </span><span class="lineNoCov">          0 : CDataFinalizer::Methods::ReadString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7942 </span>            : {
<span class="lineNum">    7943 </span>            :   return ReadStringCommon(cx, JS::UTF8CharsToNewTwoByteCharsZ, argc, vp,
<span class="lineNum">    7944 </span><span class="lineNoCov">          0 :                           &quot;CDataFinalizer.prototype.readString&quot;);</span>
<span class="lineNum">    7945 </span>            : }
<a name="7946"><span class="lineNum">    7946 </span>            : </a>
<span class="lineNum">    7947 </span>            : bool
<span class="lineNum">    7948 </span><span class="lineNoCov">          0 : CData::ReadStringReplaceMalformed(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7949 </span>            : {
<span class="lineNum">    7950 </span>            :   return ReadStringCommon(cx, JS::LossyUTF8CharsToNewTwoByteCharsZ, argc, vp,
<span class="lineNum">    7951 </span><span class="lineNoCov">          0 :                           &quot;CData.prototype.readStringReplaceMalformed&quot;);</span>
<span class="lineNum">    7952 </span>            : }
<a name="7953"><span class="lineNum">    7953 </span>            : </a>
<span class="lineNum">    7954 </span>            : JSString*
<span class="lineNum">    7955 </span><span class="lineNoCov">          0 : CData::GetSourceString(JSContext* cx, HandleObject typeObj, void* data)</span>
<span class="lineNum">    7956 </span>            : {
<span class="lineNum">    7957 </span>            :   // Walk the types, building up the toSource() string.
<span class="lineNum">    7958 </span>            :   // First, we build up the type expression:
<span class="lineNum">    7959 </span>            :   // 't.ptr' for pointers;
<span class="lineNum">    7960 </span>            :   // 't.array([n])' for arrays;
<span class="lineNum">    7961 </span>            :   // 'n' for structs, where n = t.name, the struct's name. (We assume this is
<span class="lineNum">    7962 </span>            :   // bound to a variable in the current scope.)
<span class="lineNum">    7963 </span><span class="lineNoCov">          0 :   AutoString source;</span>
<span class="lineNum">    7964 </span><span class="lineNoCov">          0 :   BuildTypeSource(cx, typeObj, true, source);</span>
<span class="lineNum">    7965 </span><span class="lineNoCov">          0 :   AppendString(source, &quot;(&quot;);</span>
<span class="lineNum">    7966 </span><span class="lineNoCov">          0 :   if (!BuildDataSource(cx, typeObj, data, false, source))</span>
<span class="lineNum">    7967 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    7968 </span>            : 
<span class="lineNum">    7969 </span><span class="lineNoCov">          0 :   AppendString(source, &quot;)&quot;);</span>
<span class="lineNum">    7970 </span>            : 
<span class="lineNum">    7971 </span><span class="lineNoCov">          0 :   return NewUCString(cx, source);</span>
<span class="lineNum">    7972 </span>            : }
<a name="7973"><span class="lineNum">    7973 </span>            : </a>
<span class="lineNum">    7974 </span>            : bool
<span class="lineNum">    7975 </span><span class="lineNoCov">          0 : CData::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    7976 </span>            : {
<span class="lineNum">    7977 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    7978 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    7979 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CData.prototype.toSource&quot;, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    7980 </span>            :   }
<span class="lineNum">    7981 </span>            : 
<span class="lineNum">    7982 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    7983 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    7984 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    7985 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(obj) &amp;&amp; !CData::IsCDataProto(obj)) {</span>
<span class="lineNum">    7986 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CData.prototype.toSource&quot;,</span>
<span class="lineNum">    7987 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    7988 </span>            :   }
<span class="lineNum">    7989 </span>            : 
<span class="lineNum">    7990 </span>            :   JSString* result;
<span class="lineNum">    7991 </span><span class="lineNoCov">          0 :   if (CData::IsCData(obj)) {</span>
<span class="lineNum">    7992 </span><span class="lineNoCov">          0 :     RootedObject typeObj(cx, CData::GetCType(obj));</span>
<span class="lineNum">    7993 </span><span class="lineNoCov">          0 :     void* data = CData::GetData(obj);</span>
<span class="lineNum">    7994 </span>            : 
<span class="lineNum">    7995 </span><span class="lineNoCov">          0 :     result = CData::GetSourceString(cx, typeObj, data);</span>
<span class="lineNum">    7996 </span>            :   } else {
<span class="lineNum">    7997 </span><span class="lineNoCov">          0 :     result = JS_NewStringCopyZ(cx, &quot;[CData proto object]&quot;);</span>
<span class="lineNum">    7998 </span>            :   }
<span class="lineNum">    7999 </span>            : 
<span class="lineNum">    8000 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8001 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8002 </span>            : 
<span class="lineNum">    8003 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    8004 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8005 </span>            : }
<a name="8006"><span class="lineNum">    8006 </span>            : </a>
<span class="lineNum">    8007 </span>            : bool
<span class="lineNum">    8008 </span><span class="lineNoCov">          0 : CData::ErrnoGetter(JSContext* cx, const JS::CallArgs&amp; args)</span>
<span class="lineNum">    8009 </span>            : {
<span class="lineNum">    8010 </span><span class="lineNoCov">          0 :   args.rval().set(JS_GetReservedSlot(&amp;args.thisv().toObject(), SLOT_ERRNO));</span>
<span class="lineNum">    8011 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8012 </span>            : }
<span class="lineNum">    8013 </span>            : 
<span class="lineNum">    8014 </span>            : #if defined(XP_WIN)
<span class="lineNum">    8015 </span>            : bool
<span class="lineNum">    8016 </span>            : CData::LastErrorGetter(JSContext* cx, const JS::CallArgs&amp; args)
<span class="lineNum">    8017 </span>            : {
<span class="lineNum">    8018 </span>            :   args.rval().set(JS_GetReservedSlot(&amp;args.thisv().toObject(), SLOT_LASTERROR));
<span class="lineNum">    8019 </span>            :   return true;
<span class="lineNum">    8020 </span>            : }
<span class="lineNum">    8021 </span>            : #endif // defined(XP_WIN)
<a name="8022"><span class="lineNum">    8022 </span>            : </a>
<span class="lineNum">    8023 </span>            : bool
<span class="lineNum">    8024 </span><span class="lineNoCov">          0 : CDataFinalizer::Methods::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8025 </span>            : {
<span class="lineNum">    8026 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8027 </span><span class="lineNoCov">          0 :   RootedObject objThis(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    8028 </span><span class="lineNoCov">          0 :   if (!objThis)</span>
<span class="lineNum">    8029 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8030 </span><span class="lineNoCov">          0 :   if (!CDataFinalizer::IsCDataFinalizer(objThis)) {</span>
<span class="lineNum">    8031 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CDataFinalizer.prototype.toSource&quot;,</span>
<span class="lineNum">    8032 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8033 </span>            :   }
<span class="lineNum">    8034 </span>            : 
<span class="lineNum">    8035 </span>            :   CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    8036 </span><span class="lineNoCov">          0 :     JS_GetPrivate(objThis);</span>
<span class="lineNum">    8037 </span>            : 
<span class="lineNum">    8038 </span>            :   JSString* strMessage;
<span class="lineNum">    8039 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8040 </span><span class="lineNoCov">          0 :     strMessage = JS_NewStringCopyZ(cx, &quot;ctypes.CDataFinalizer()&quot;);</span>
<span class="lineNum">    8041 </span>            :   } else {
<span class="lineNum">    8042 </span><span class="lineNoCov">          0 :     RootedObject objType(cx, CDataFinalizer::GetCType(cx, objThis));</span>
<span class="lineNum">    8043 </span><span class="lineNoCov">          0 :     if (!objType) {</span>
<span class="lineNum">    8044 </span><span class="lineNoCov">          0 :       JS_ReportErrorASCII(cx, &quot;CDataFinalizer has no type&quot;);</span>
<span class="lineNum">    8045 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8046 </span>            :     }
<span class="lineNum">    8047 </span>            : 
<span class="lineNum">    8048 </span><span class="lineNoCov">          0 :     AutoString source;</span>
<span class="lineNum">    8049 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;ctypes.CDataFinalizer(&quot;);</span>
<span class="lineNum">    8050 </span><span class="lineNoCov">          0 :     JSString* srcValue = CData::GetSourceString(cx, objType, p-&gt;cargs);</span>
<span class="lineNum">    8051 </span><span class="lineNoCov">          0 :     if (!srcValue) {</span>
<span class="lineNum">    8052 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8053 </span>            :     }
<span class="lineNum">    8054 </span><span class="lineNoCov">          0 :     AppendString(source, srcValue);</span>
<span class="lineNum">    8055 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;, &quot;);</span>
<span class="lineNum">    8056 </span>            :     Value valCodePtrType = JS_GetReservedSlot(objThis,
<span class="lineNum">    8057 </span><span class="lineNoCov">          0 :                                               SLOT_DATAFINALIZER_CODETYPE);</span>
<span class="lineNum">    8058 </span><span class="lineNoCov">          0 :     if (valCodePtrType.isPrimitive()) {</span>
<span class="lineNum">    8059 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8060 </span>            :     }
<span class="lineNum">    8061 </span>            : 
<span class="lineNum">    8062 </span><span class="lineNoCov">          0 :     RootedObject typeObj(cx, valCodePtrType.toObjectOrNull());</span>
<span class="lineNum">    8063 </span><span class="lineNoCov">          0 :     JSString* srcDispose = CData::GetSourceString(cx, typeObj, &amp;(p-&gt;code));</span>
<span class="lineNum">    8064 </span><span class="lineNoCov">          0 :     if (!srcDispose) {</span>
<span class="lineNum">    8065 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8066 </span>            :     }
<span class="lineNum">    8067 </span>            : 
<span class="lineNum">    8068 </span><span class="lineNoCov">          0 :     AppendString(source, srcDispose);</span>
<span class="lineNum">    8069 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;)&quot;);</span>
<span class="lineNum">    8070 </span><span class="lineNoCov">          0 :     strMessage = NewUCString(cx, source);</span>
<span class="lineNum">    8071 </span>            :   }
<span class="lineNum">    8072 </span>            : 
<span class="lineNum">    8073 </span><span class="lineNoCov">          0 :   if (!strMessage) {</span>
<span class="lineNum">    8074 </span>            :     // This is a memory issue, no error message
<span class="lineNum">    8075 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8076 </span>            :   }
<span class="lineNum">    8077 </span>            : 
<span class="lineNum">    8078 </span><span class="lineNoCov">          0 :   args.rval().setString(strMessage);</span>
<span class="lineNum">    8079 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8080 </span>            : }
<a name="8081"><span class="lineNum">    8081 </span>            : </a>
<span class="lineNum">    8082 </span>            : bool
<span class="lineNum">    8083 </span><span class="lineNoCov">          0 : CDataFinalizer::Methods::ToString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8084 </span>            : {
<span class="lineNum">    8085 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8086 </span><span class="lineNoCov">          0 :   JSObject* objThis = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    8087 </span><span class="lineNoCov">          0 :   if (!objThis)</span>
<span class="lineNum">    8088 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8089 </span><span class="lineNoCov">          0 :   if (!CDataFinalizer::IsCDataFinalizer(objThis)) {</span>
<span class="lineNum">    8090 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CDataFinalizer.prototype.toString&quot;,</span>
<span class="lineNum">    8091 </span><span class="lineNoCov">          0 :                                  InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8092 </span>            :   }
<span class="lineNum">    8093 </span>            : 
<span class="lineNum">    8094 </span>            :   JSString* strMessage;
<span class="lineNum">    8095 </span><span class="lineNoCov">          0 :   RootedValue value(cx);</span>
<span class="lineNum">    8096 </span><span class="lineNoCov">          0 :   if (!JS_GetPrivate(objThis)) {</span>
<span class="lineNum">    8097 </span>            :     // Pre-check whether CDataFinalizer::GetValue can fail
<span class="lineNum">    8098 </span>            :     // to avoid reporting an error when not appropriate.
<span class="lineNum">    8099 </span><span class="lineNoCov">          0 :     strMessage = JS_NewStringCopyZ(cx, &quot;[CDataFinalizer - empty]&quot;);</span>
<span class="lineNum">    8100 </span><span class="lineNoCov">          0 :     if (!strMessage) {</span>
<span class="lineNum">    8101 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8102 </span>            :     }
<span class="lineNum">    8103 </span><span class="lineNoCov">          0 :   } else if (!CDataFinalizer::GetValue(cx, objThis, &amp;value)) {</span>
<span class="lineNum">    8104 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Could not convert an empty CDataFinalizer&quot;);</span>
<span class="lineNum">    8105 </span>            :   } else {
<span class="lineNum">    8106 </span><span class="lineNoCov">          0 :     strMessage = ToString(cx, value);</span>
<span class="lineNum">    8107 </span><span class="lineNoCov">          0 :     if (!strMessage) {</span>
<span class="lineNum">    8108 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    8109 </span>            :     }
<span class="lineNum">    8110 </span>            :   }
<span class="lineNum">    8111 </span><span class="lineNoCov">          0 :   args.rval().setString(strMessage);</span>
<span class="lineNum">    8112 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8113 </span>            : }
<a name="8114"><span class="lineNum">    8114 </span>            : </a>
<span class="lineNum">    8115 </span>            : bool
<span class="lineNum">    8116 </span><span class="lineNoCov">          0 : CDataFinalizer::IsCDataFinalizer(JSObject* obj)</span>
<span class="lineNum">    8117 </span>            : {
<span class="lineNum">    8118 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sCDataFinalizerClass;</span>
<span class="lineNum">    8119 </span>            : }
<span class="lineNum">    8120 </span>            : 
<a name="8121"><span class="lineNum">    8121 </span>            : </a>
<span class="lineNum">    8122 </span>            : JSObject*
<span class="lineNum">    8123 </span><span class="lineNoCov">          0 : CDataFinalizer::GetCType(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    8124 </span>            : {
<span class="lineNum">    8125 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsCDataFinalizer(obj));</span>
<span class="lineNum">    8126 </span>            : 
<span class="lineNum">    8127 </span>            :   Value valData = JS_GetReservedSlot(obj,
<span class="lineNum">    8128 </span><span class="lineNoCov">          0 :                                      SLOT_DATAFINALIZER_VALTYPE);</span>
<span class="lineNum">    8129 </span><span class="lineNoCov">          0 :   if (valData.isUndefined()) {</span>
<span class="lineNum">    8130 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    8131 </span>            :   }
<span class="lineNum">    8132 </span>            : 
<span class="lineNum">    8133 </span><span class="lineNoCov">          0 :   return valData.toObjectOrNull();</span>
<span class="lineNum">    8134 </span>            : }
<a name="8135"><span class="lineNum">    8135 </span>            : </a>
<span class="lineNum">    8136 </span>            : bool
<span class="lineNum">    8137 </span><span class="lineNoCov">          0 : CDataFinalizer::GetValue(JSContext* cx, JSObject* obj,</span>
<span class="lineNum">    8138 </span>            :                          MutableHandleValue aResult)
<span class="lineNum">    8139 </span>            : {
<span class="lineNum">    8140 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsCDataFinalizer(obj));</span>
<span class="lineNum">    8141 </span>            : 
<span class="lineNum">    8142 </span>            :   CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    8143 </span><span class="lineNoCov">          0 :     JS_GetPrivate(obj);</span>
<span class="lineNum">    8144 </span>            : 
<span class="lineNum">    8145 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8146 </span>            :     // We have called |dispose| or |forget| already.
<span class="lineNum">    8147 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Attempting to get the value of an empty CDataFinalizer&quot;);</span>
<span class="lineNum">    8148 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8149 </span>            :   }
<span class="lineNum">    8150 </span>            : 
<span class="lineNum">    8151 </span><span class="lineNoCov">          0 :   RootedObject ctype(cx, GetCType(cx, obj));</span>
<span class="lineNum">    8152 </span><span class="lineNoCov">          0 :   return ConvertToJS(cx, ctype, /*parent*/nullptr, p-&gt;cargs, false, true, aResult);</span>
<span class="lineNum">    8153 </span>            : }
<span class="lineNum">    8154 </span>            : 
<span class="lineNum">    8155 </span>            : /*
<span class="lineNum">    8156 </span>            :  * Attach a C function as a finalizer to a JS object.
<span class="lineNum">    8157 </span>            :  *
<span class="lineNum">    8158 </span>            :  * Pseudo-JS signature:
<span class="lineNum">    8159 </span>            :  * function(CData&lt;T&gt;, CData&lt;T -&gt; U&gt;): CDataFinalizer&lt;T&gt;
<span class="lineNum">    8160 </span>            :  *          value,    finalizer
<span class="lineNum">    8161 </span>            :  *
<span class="lineNum">    8162 </span>            :  * This function attaches strong references to the following values:
<span class="lineNum">    8163 </span>            :  * - the CType of |value|
<span class="lineNum">    8164 </span>            :  *
<span class="lineNum">    8165 </span>            :  * Note: This function takes advantage of the fact that non-variadic
<span class="lineNum">    8166 </span>            :  * CData functions are initialized during creation.
<a name="8167"><span class="lineNum">    8167 </span>            :  */</a>
<span class="lineNum">    8168 </span>            : bool
<span class="lineNum">    8169 </span><span class="lineNoCov">          0 : CDataFinalizer::Construct(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8170 </span>            : {
<span class="lineNum">    8171 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8172 </span><span class="lineNoCov">          0 :   RootedObject objSelf(cx, &amp;args.callee());</span>
<span class="lineNum">    8173 </span><span class="lineNoCov">          0 :   RootedObject objProto(cx);</span>
<span class="lineNum">    8174 </span><span class="lineNoCov">          0 :   if (!GetObjectProperty(cx, objSelf, &quot;prototype&quot;, &amp;objProto)) {</span>
<span class="lineNum">    8175 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;CDataFinalizer.prototype does not exist&quot;);</span>
<span class="lineNum">    8176 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8177 </span>            :   }
<span class="lineNum">    8178 </span>            : 
<span class="lineNum">    8179 </span>            :   // Get arguments
<span class="lineNum">    8180 </span><span class="lineNoCov">          0 :   if (args.length() == 0) { // Special case: the empty (already finalized) object</span>
<span class="lineNum">    8181 </span><span class="lineNoCov">          0 :     JSObject* objResult = JS_NewObjectWithGivenProto(cx, &amp;sCDataFinalizerClass, objProto);</span>
<span class="lineNum">    8182 </span><span class="lineNoCov">          0 :     args.rval().setObject(*objResult);</span>
<span class="lineNum">    8183 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    8184 </span>            :   }
<span class="lineNum">    8185 </span>            : 
<span class="lineNum">    8186 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    8187 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CDataFinalizer constructor&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8188 </span>            :   }
<span class="lineNum">    8189 </span>            : 
<span class="lineNum">    8190 </span><span class="lineNoCov">          0 :   JS::HandleValue valCodePtr = args[1];</span>
<span class="lineNum">    8191 </span><span class="lineNoCov">          0 :   if (!valCodePtr.isObject()) {</span>
<span class="lineNum">    8192 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;_a CData object_ of a function pointer type&quot;,</span>
<span class="lineNum">    8193 </span><span class="lineNoCov">          0 :                      valCodePtr);</span>
<span class="lineNum">    8194 </span>            :   }
<span class="lineNum">    8195 </span><span class="lineNoCov">          0 :   JSObject* objCodePtr = &amp;valCodePtr.toObject();</span>
<span class="lineNum">    8196 </span>            : 
<span class="lineNum">    8197 </span>            :   //Note: Using a custom argument formatter here would be awkward (requires
<span class="lineNum">    8198 </span>            :   //a destructor just to uninstall the formatter).
<span class="lineNum">    8199 </span>            : 
<span class="lineNum">    8200 </span>            :   // 2. Extract argument type of |objCodePtr|
<span class="lineNum">    8201 </span><span class="lineNoCov">          0 :   if (!CData::IsCData(objCodePtr)) {</span>
<span class="lineNum">    8202 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a _CData_ object of a function pointer type&quot;,</span>
<span class="lineNum">    8203 </span><span class="lineNoCov">          0 :                      valCodePtr);</span>
<span class="lineNum">    8204 </span>            :   }
<span class="lineNum">    8205 </span><span class="lineNoCov">          0 :   RootedObject objCodePtrType(cx, CData::GetCType(objCodePtr));</span>
<span class="lineNum">    8206 </span><span class="lineNoCov">          0 :   RootedValue valCodePtrType(cx, ObjectValue(*objCodePtrType));</span>
<span class="lineNum">    8207 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(objCodePtrType);</span>
<span class="lineNum">    8208 </span>            : 
<span class="lineNum">    8209 </span><span class="lineNoCov">          0 :   TypeCode typCodePtr = CType::GetTypeCode(objCodePtrType);</span>
<span class="lineNum">    8210 </span><span class="lineNoCov">          0 :   if (typCodePtr != TYPE_pointer) {</span>
<span class="lineNum">    8211 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a CData object of a function _pointer_ type&quot;,</span>
<span class="lineNum">    8212 </span><span class="lineNoCov">          0 :                      valCodePtr);</span>
<span class="lineNum">    8213 </span>            :   }
<span class="lineNum">    8214 </span>            : 
<span class="lineNum">    8215 </span><span class="lineNoCov">          0 :   JSObject* objCodeType = PointerType::GetBaseType(objCodePtrType);</span>
<span class="lineNum">    8216 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(objCodeType);</span>
<span class="lineNum">    8217 </span>            : 
<span class="lineNum">    8218 </span><span class="lineNoCov">          0 :   TypeCode typCode = CType::GetTypeCode(objCodeType);</span>
<span class="lineNum">    8219 </span><span class="lineNoCov">          0 :   if (typCode != TYPE_function) {</span>
<span class="lineNum">    8220 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a CData object of a _function_ pointer type&quot;,</span>
<span class="lineNum">    8221 </span><span class="lineNoCov">          0 :                      valCodePtr);</span>
<span class="lineNum">    8222 </span>            :   }
<span class="lineNum">    8223 </span><span class="lineNoCov">          0 :   uintptr_t code = *reinterpret_cast&lt;uintptr_t*&gt;(CData::GetData(objCodePtr));</span>
<span class="lineNum">    8224 </span><span class="lineNoCov">          0 :   if (!code) {</span>
<span class="lineNum">    8225 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a CData object of a _non-NULL_ function pointer type&quot;,</span>
<span class="lineNum">    8226 </span><span class="lineNoCov">          0 :                      valCodePtr);</span>
<span class="lineNum">    8227 </span>            :   }
<span class="lineNum">    8228 </span>            : 
<span class="lineNum">    8229 </span>            :   FunctionInfo* funInfoFinalizer =
<span class="lineNum">    8230 </span><span class="lineNoCov">          0 :     FunctionType::GetFunctionInfo(objCodeType);</span>
<span class="lineNum">    8231 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(funInfoFinalizer);</span>
<span class="lineNum">    8232 </span>            : 
<span class="lineNum">    8233 </span><span class="lineNoCov">          0 :   if ((funInfoFinalizer-&gt;mArgTypes.length() != 1)</span>
<span class="lineNum">    8234 </span><span class="lineNoCov">          0 :       || (funInfoFinalizer-&gt;mIsVariadic)) {</span>
<span class="lineNum">    8235 </span><span class="lineNoCov">          0 :     RootedValue valCodeType(cx, ObjectValue(*objCodeType));</span>
<span class="lineNum">    8236 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a function accepting exactly one argument&quot;,</span>
<span class="lineNum">    8237 </span><span class="lineNoCov">          0 :                      valCodeType);</span>
<span class="lineNum">    8238 </span>            :   }
<span class="lineNum">    8239 </span><span class="lineNoCov">          0 :   RootedObject objArgType(cx, funInfoFinalizer-&gt;mArgTypes[0]);</span>
<span class="lineNum">    8240 </span><span class="lineNoCov">          0 :   RootedObject returnType(cx, funInfoFinalizer-&gt;mReturnType);</span>
<span class="lineNum">    8241 </span>            : 
<span class="lineNum">    8242 </span>            :   // Invariant: At this stage, we know that funInfoFinalizer-&gt;mIsVariadic
<span class="lineNum">    8243 </span>            :   // is |false|. Therefore, funInfoFinalizer-&gt;mCIF has already been initialized.
<span class="lineNum">    8244 </span>            : 
<span class="lineNum">    8245 </span><span class="lineNoCov">          0 :   bool freePointer = false;</span>
<span class="lineNum">    8246 </span>            : 
<span class="lineNum">    8247 </span>            :   // 3. Perform dynamic cast of |args[0]| into |objType|, store it in |cargs|
<span class="lineNum">    8248 </span>            : 
<span class="lineNum">    8249 </span>            :   size_t sizeArg;
<span class="lineNum">    8250 </span><span class="lineNoCov">          0 :   RootedValue valData(cx, args[0]);</span>
<span class="lineNum">    8251 </span><span class="lineNoCov">          0 :   if (!CType::GetSafeSize(objArgType, &amp;sizeArg)) {</span>
<span class="lineNum">    8252 </span><span class="lineNoCov">          0 :     RootedValue valCodeType(cx, ObjectValue(*objCodeType));</span>
<span class="lineNum">    8253 </span><span class="lineNoCov">          0 :     return TypeError(cx, &quot;a function with one known size argument&quot;,</span>
<span class="lineNum">    8254 </span><span class="lineNoCov">          0 :                      valCodeType);</span>
<span class="lineNum">    8255 </span>            :   }
<span class="lineNum">    8256 </span>            : 
<span class="lineNum">    8257 </span><span class="lineNoCov">          0 :   ScopedJSFreePtr&lt;void&gt; cargs(malloc(sizeArg));</span>
<span class="lineNum">    8258 </span>            : 
<span class="lineNum">    8259 </span><span class="lineNoCov">          0 :   if (!ImplicitConvert(cx, valData, objArgType, cargs.get(),</span>
<span class="lineNum">    8260 </span>            :                        ConversionType::Finalizer, &amp;freePointer,
<span class="lineNum">    8261 </span><span class="lineNoCov">          0 :                        objCodePtrType, 0)) {</span>
<span class="lineNum">    8262 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8263 </span>            :   }
<span class="lineNum">    8264 </span><span class="lineNoCov">          0 :   if (freePointer) {</span>
<span class="lineNum">    8265 </span>            :     // Note: We could handle that case, if necessary.
<span class="lineNum">    8266 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;Internal Error during CDataFinalizer. Object cannot be represented&quot;);</span>
<span class="lineNum">    8267 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8268 </span>            :   }
<span class="lineNum">    8269 </span>            : 
<span class="lineNum">    8270 </span>            :   // 4. Prepare buffer for holding return value
<span class="lineNum">    8271 </span>            : 
<span class="lineNum">    8272 </span><span class="lineNoCov">          0 :   ScopedJSFreePtr&lt;void&gt; rvalue;</span>
<span class="lineNum">    8273 </span><span class="lineNoCov">          0 :   if (CType::GetTypeCode(returnType) != TYPE_void_t) {</span>
<span class="lineNum">    8274 </span><span class="lineNoCov">          0 :     rvalue = malloc(Align(CType::GetSize(returnType),</span>
<span class="lineNum">    8275 </span><span class="lineNoCov">          0 :                           sizeof(ffi_arg)));</span>
<span class="lineNum">    8276 </span>            :   } //Otherwise, simply do not allocate
<span class="lineNum">    8277 </span>            : 
<span class="lineNum">    8278 </span>            :   // 5. Create |objResult|
<span class="lineNum">    8279 </span>            : 
<span class="lineNum">    8280 </span><span class="lineNoCov">          0 :   JSObject* objResult = JS_NewObjectWithGivenProto(cx, &amp;sCDataFinalizerClass, objProto);</span>
<span class="lineNum">    8281 </span><span class="lineNoCov">          0 :   if (!objResult) {</span>
<span class="lineNum">    8282 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8283 </span>            :   }
<span class="lineNum">    8284 </span>            : 
<span class="lineNum">    8285 </span>            :   // If our argument is a CData, it holds a type.
<span class="lineNum">    8286 </span>            :   // This is the type that we should capture, not that
<span class="lineNum">    8287 </span>            :   // of the function, which may be less precise.
<span class="lineNum">    8288 </span><span class="lineNoCov">          0 :   JSObject* objBestArgType = objArgType;</span>
<span class="lineNum">    8289 </span><span class="lineNoCov">          0 :   if (valData.isObject()) {</span>
<span class="lineNum">    8290 </span><span class="lineNoCov">          0 :     JSObject* objData = &amp;valData.toObject();</span>
<span class="lineNum">    8291 </span><span class="lineNoCov">          0 :     if (CData::IsCData(objData)) {</span>
<span class="lineNum">    8292 </span><span class="lineNoCov">          0 :       objBestArgType = CData::GetCType(objData);</span>
<span class="lineNum">    8293 </span>            :       size_t sizeBestArg;
<span class="lineNum">    8294 </span><span class="lineNoCov">          0 :       if (!CType::GetSafeSize(objBestArgType, &amp;sizeBestArg)) {</span>
<span class="lineNum">    8295 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;object with unknown size&quot;);</span>
<span class="lineNum">    8296 </span>            :       }
<span class="lineNum">    8297 </span><span class="lineNoCov">          0 :       if (sizeBestArg != sizeArg) {</span>
<span class="lineNum">    8298 </span><span class="lineNoCov">          0 :         return FinalizerSizeError(cx, objCodePtrType, valData);</span>
<span class="lineNum">    8299 </span>            :       }
<span class="lineNum">    8300 </span>            :     }
<span class="lineNum">    8301 </span>            :   }
<span class="lineNum">    8302 </span>            : 
<span class="lineNum">    8303 </span>            :   // Used by GetCType
<span class="lineNum">    8304 </span>            :   JS_SetReservedSlot(objResult,
<span class="lineNum">    8305 </span>            :                      SLOT_DATAFINALIZER_VALTYPE,
<span class="lineNum">    8306 </span><span class="lineNoCov">          0 :                      ObjectOrNullValue(objBestArgType));</span>
<span class="lineNum">    8307 </span>            : 
<span class="lineNum">    8308 </span>            :   // Used by ToSource
<span class="lineNum">    8309 </span>            :   JS_SetReservedSlot(objResult,
<span class="lineNum">    8310 </span>            :                      SLOT_DATAFINALIZER_CODETYPE,
<span class="lineNum">    8311 </span><span class="lineNoCov">          0 :                      ObjectValue(*objCodePtrType));</span>
<span class="lineNum">    8312 </span>            : 
<span class="lineNum">    8313 </span><span class="lineNoCov">          0 :   RootedValue abiType(cx, ObjectOrNullValue(funInfoFinalizer-&gt;mABI));</span>
<span class="lineNum">    8314 </span>            :   ffi_abi abi;
<span class="lineNum">    8315 </span><span class="lineNoCov">          0 :   if (!GetABI(cx, abiType, &amp;abi)) {</span>
<span class="lineNum">    8316 </span>            :     JS_ReportErrorASCII(cx, &quot;Internal Error: &quot;
<span class="lineNum">    8317 </span><span class="lineNoCov">          0 :                         &quot;Invalid ABI specification in CDataFinalizer&quot;);</span>
<span class="lineNum">    8318 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8319 </span>            :   }
<span class="lineNum">    8320 </span>            : 
<span class="lineNum">    8321 </span><span class="lineNoCov">          0 :   ffi_type* rtype = CType::GetFFIType(cx, funInfoFinalizer-&gt;mReturnType);</span>
<span class="lineNum">    8322 </span><span class="lineNoCov">          0 :   if (!rtype) {</span>
<span class="lineNum">    8323 </span>            :     JS_ReportErrorASCII(cx, &quot;Internal Error: &quot;
<span class="lineNum">    8324 </span><span class="lineNoCov">          0 :                         &quot;Could not access ffi type of CDataFinalizer&quot;);</span>
<span class="lineNum">    8325 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8326 </span>            :   }
<span class="lineNum">    8327 </span>            : 
<span class="lineNum">    8328 </span>            :   // 7. Store C information as private
<span class="lineNum">    8329 </span>            :   ScopedJSFreePtr&lt;CDataFinalizer::Private&gt;
<span class="lineNum">    8330 </span><span class="lineNoCov">          0 :     p((CDataFinalizer::Private*)malloc(sizeof(CDataFinalizer::Private)));</span>
<span class="lineNum">    8331 </span>            : 
<span class="lineNum">    8332 </span><span class="lineNoCov">          0 :   memmove(&amp;p-&gt;CIF, &amp;funInfoFinalizer-&gt;mCIF, sizeof(ffi_cif));</span>
<span class="lineNum">    8333 </span>            : 
<span class="lineNum">    8334 </span><span class="lineNoCov">          0 :   p-&gt;cargs = cargs.forget();</span>
<span class="lineNum">    8335 </span><span class="lineNoCov">          0 :   p-&gt;rvalue = rvalue.forget();</span>
<span class="lineNum">    8336 </span><span class="lineNoCov">          0 :   p-&gt;cargs_size = sizeArg;</span>
<span class="lineNum">    8337 </span><span class="lineNoCov">          0 :   p-&gt;code = code;</span>
<span class="lineNum">    8338 </span>            : 
<span class="lineNum">    8339 </span>            : 
<span class="lineNum">    8340 </span><span class="lineNoCov">          0 :   JS_SetPrivate(objResult, p.forget());</span>
<span class="lineNum">    8341 </span><span class="lineNoCov">          0 :   args.rval().setObject(*objResult);</span>
<span class="lineNum">    8342 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8343 </span>            : }
<span class="lineNum">    8344 </span>            : 
<span class="lineNum">    8345 </span>            : 
<span class="lineNum">    8346 </span>            : /*
<span class="lineNum">    8347 </span>            :  * Actually call the finalizer. Does not perform any cleanup on the object.
<span class="lineNum">    8348 </span>            :  *
<span class="lineNum">    8349 </span>            :  * Preconditions: |this| must be a |CDataFinalizer|, |p| must be non-null.
<span class="lineNum">    8350 </span>            :  * The function fails if |this| has gone through |Forget|/|Dispose|
<span class="lineNum">    8351 </span>            :  * or |Finalize|.
<span class="lineNum">    8352 </span>            :  *
<span class="lineNum">    8353 </span>            :  * This function does not alter the value of |errno|/|GetLastError|.
<span class="lineNum">    8354 </span>            :  *
<span class="lineNum">    8355 </span>            :  * If argument |errnoStatus| is non-nullptr, it receives the value of |errno|
<span class="lineNum">    8356 </span>            :  * immediately after the call. Under Windows, if argument |lastErrorStatus|
<span class="lineNum">    8357 </span>            :  * is non-nullptr, it receives the value of |GetLastError| immediately after
<span class="lineNum">    8358 </span>            :  * the call. On other platforms, |lastErrorStatus| is ignored.
<a name="8359"><span class="lineNum">    8359 </span>            :  */</a>
<span class="lineNum">    8360 </span>            : void
<span class="lineNum">    8361 </span><span class="lineNoCov">          0 : CDataFinalizer::CallFinalizer(CDataFinalizer::Private* p,</span>
<span class="lineNum">    8362 </span>            :                               int* errnoStatus,
<span class="lineNum">    8363 </span>            :                               int32_t* lastErrorStatus)
<span class="lineNum">    8364 </span>            : {
<span class="lineNum">    8365 </span><span class="lineNoCov">          0 :   int savedErrno = errno;</span>
<span class="lineNum">    8366 </span><span class="lineNoCov">          0 :   errno = 0;</span>
<span class="lineNum">    8367 </span>            : #if defined(XP_WIN)
<span class="lineNum">    8368 </span>            :   int32_t savedLastError = GetLastError();
<span class="lineNum">    8369 </span>            :   SetLastError(0);
<span class="lineNum">    8370 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    8371 </span>            : 
<span class="lineNum">    8372 </span><span class="lineNoCov">          0 :   void* args[1] = {p-&gt;cargs};</span>
<span class="lineNum">    8373 </span><span class="lineNoCov">          0 :   ffi_call(&amp;p-&gt;CIF, FFI_FN(p-&gt;code), p-&gt;rvalue, args);</span>
<span class="lineNum">    8374 </span>            : 
<span class="lineNum">    8375 </span><span class="lineNoCov">          0 :   if (errnoStatus) {</span>
<span class="lineNum">    8376 </span><span class="lineNoCov">          0 :     *errnoStatus = errno;</span>
<span class="lineNum">    8377 </span>            :   }
<span class="lineNum">    8378 </span><span class="lineNoCov">          0 :   errno = savedErrno;</span>
<span class="lineNum">    8379 </span>            : #if defined(XP_WIN)
<span class="lineNum">    8380 </span>            :   if (lastErrorStatus) {
<span class="lineNum">    8381 </span>            :     *lastErrorStatus = GetLastError();
<span class="lineNum">    8382 </span>            :   }
<span class="lineNum">    8383 </span>            :   SetLastError(savedLastError);
<span class="lineNum">    8384 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    8385 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    8386 </span>            : 
<span class="lineNum">    8387 </span>            : /*
<span class="lineNum">    8388 </span>            :  * Forget the value.
<span class="lineNum">    8389 </span>            :  *
<span class="lineNum">    8390 </span>            :  * Preconditions: |this| must be a |CDataFinalizer|.
<span class="lineNum">    8391 </span>            :  * The function fails if |this| has gone through |Forget|/|Dispose|
<span class="lineNum">    8392 </span>            :  * or |Finalize|.
<span class="lineNum">    8393 </span>            :  *
<span class="lineNum">    8394 </span>            :  * Does not call the finalizer. Cleans up the Private memory and releases all
<span class="lineNum">    8395 </span>            :  * strong references.
<a name="8396"><span class="lineNum">    8396 </span>            :  */</a>
<span class="lineNum">    8397 </span>            : bool
<span class="lineNum">    8398 </span><span class="lineNoCov">          0 : CDataFinalizer::Methods::Forget(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8399 </span>            : {
<span class="lineNum">    8400 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8401 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    8402 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CDataFinalizer.prototype.forget&quot;, &quot;no&quot;,</span>
<span class="lineNum">    8403 </span><span class="lineNoCov">          0 :                                &quot;s&quot;);</span>
<span class="lineNum">    8404 </span>            :   }
<span class="lineNum">    8405 </span>            : 
<span class="lineNum">    8406 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    8407 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8408 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8409 </span><span class="lineNoCov">          0 :   if (!CDataFinalizer::IsCDataFinalizer(obj)) {</span>
<span class="lineNum">    8410 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CDataFinalizer.prototype.forget&quot;,</span>
<span class="lineNum">    8411 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    8412 </span>            :   }
<span class="lineNum">    8413 </span>            : 
<span class="lineNum">    8414 </span>            :   CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    8415 </span><span class="lineNoCov">          0 :     JS_GetPrivate(obj);</span>
<span class="lineNum">    8416 </span>            : 
<span class="lineNum">    8417 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8418 </span><span class="lineNoCov">          0 :     return EmptyFinalizerCallError(cx, &quot;CDataFinalizer.prototype.forget&quot;);</span>
<span class="lineNum">    8419 </span>            :   }
<span class="lineNum">    8420 </span>            : 
<span class="lineNum">    8421 </span><span class="lineNoCov">          0 :   RootedValue valJSData(cx);</span>
<span class="lineNum">    8422 </span><span class="lineNoCov">          0 :   RootedObject ctype(cx, GetCType(cx, obj));</span>
<span class="lineNum">    8423 </span><span class="lineNoCov">          0 :   if (!ConvertToJS(cx, ctype, nullptr, p-&gt;cargs, false, true, &amp;valJSData)) {</span>
<span class="lineNum">    8424 </span><span class="lineNoCov">          0 :     JS_ReportErrorASCII(cx, &quot;CDataFinalizer value cannot be represented&quot;);</span>
<span class="lineNum">    8425 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8426 </span>            :   }
<span class="lineNum">    8427 </span>            : 
<span class="lineNum">    8428 </span><span class="lineNoCov">          0 :   CDataFinalizer::Cleanup(p, obj);</span>
<span class="lineNum">    8429 </span>            : 
<span class="lineNum">    8430 </span><span class="lineNoCov">          0 :   args.rval().set(valJSData);</span>
<span class="lineNum">    8431 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8432 </span>            : }
<span class="lineNum">    8433 </span>            : 
<span class="lineNum">    8434 </span>            : /*
<span class="lineNum">    8435 </span>            :  * Clean up the value.
<span class="lineNum">    8436 </span>            :  *
<span class="lineNum">    8437 </span>            :  * Preconditions: |this| must be a |CDataFinalizer|.
<span class="lineNum">    8438 </span>            :  * The function fails if |this| has gone through |Forget|/|Dispose|
<span class="lineNum">    8439 </span>            :  * or |Finalize|.
<span class="lineNum">    8440 </span>            :  *
<span class="lineNum">    8441 </span>            :  * Calls the finalizer, cleans up the Private memory and releases all
<span class="lineNum">    8442 </span>            :  * strong references.
<a name="8443"><span class="lineNum">    8443 </span>            :  */</a>
<span class="lineNum">    8444 </span>            : bool
<span class="lineNum">    8445 </span><span class="lineNoCov">          0 : CDataFinalizer::Methods::Dispose(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8446 </span>            : {
<span class="lineNum">    8447 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8448 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    8449 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;CDataFinalizer.prototype.dispose&quot;, &quot;no&quot;,</span>
<span class="lineNum">    8450 </span><span class="lineNoCov">          0 :                                &quot;s&quot;);</span>
<span class="lineNum">    8451 </span>            :   }
<span class="lineNum">    8452 </span>            : 
<span class="lineNum">    8453 </span><span class="lineNoCov">          0 :   RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));</span>
<span class="lineNum">    8454 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8455 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8456 </span><span class="lineNoCov">          0 :   if (!CDataFinalizer::IsCDataFinalizer(obj)) {</span>
<span class="lineNum">    8457 </span><span class="lineNoCov">          0 :     return IncompatibleThisProto(cx, &quot;CDataFinalizer.prototype.dispose&quot;,</span>
<span class="lineNum">    8458 </span><span class="lineNoCov">          0 :                                  args.thisv());</span>
<span class="lineNum">    8459 </span>            :   }
<span class="lineNum">    8460 </span>            : 
<span class="lineNum">    8461 </span>            :   CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    8462 </span><span class="lineNoCov">          0 :     JS_GetPrivate(obj);</span>
<span class="lineNum">    8463 </span>            : 
<span class="lineNum">    8464 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8465 </span><span class="lineNoCov">          0 :     return EmptyFinalizerCallError(cx, &quot;CDataFinalizer.prototype.dispose&quot;);</span>
<span class="lineNum">    8466 </span>            :   }
<span class="lineNum">    8467 </span>            : 
<span class="lineNum">    8468 </span><span class="lineNoCov">          0 :   Value valType = JS_GetReservedSlot(obj, SLOT_DATAFINALIZER_VALTYPE);</span>
<span class="lineNum">    8469 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(valType.isObject());</span>
<span class="lineNum">    8470 </span>            : 
<span class="lineNum">    8471 </span><span class="lineNoCov">          0 :   RootedObject objCTypes(cx, CType::GetGlobalCTypes(cx, &amp;valType.toObject()));</span>
<span class="lineNum">    8472 </span><span class="lineNoCov">          0 :   if (!objCTypes)</span>
<span class="lineNum">    8473 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8474 </span>            : 
<span class="lineNum">    8475 </span><span class="lineNoCov">          0 :   Value valCodePtrType = JS_GetReservedSlot(obj, SLOT_DATAFINALIZER_CODETYPE);</span>
<span class="lineNum">    8476 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(valCodePtrType.isObject());</span>
<span class="lineNum">    8477 </span><span class="lineNoCov">          0 :   JSObject* objCodePtrType = &amp;valCodePtrType.toObject();</span>
<span class="lineNum">    8478 </span>            : 
<span class="lineNum">    8479 </span><span class="lineNoCov">          0 :   JSObject* objCodeType = PointerType::GetBaseType(objCodePtrType);</span>
<span class="lineNum">    8480 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(objCodeType);</span>
<span class="lineNum">    8481 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CType::GetTypeCode(objCodeType) == TYPE_function);</span>
<span class="lineNum">    8482 </span>            : 
<span class="lineNum">    8483 </span><span class="lineNoCov">          0 :   RootedObject resultType(cx, FunctionType::GetFunctionInfo(objCodeType)-&gt;mReturnType);</span>
<span class="lineNum">    8484 </span><span class="lineNoCov">          0 :   RootedValue result(cx);</span>
<span class="lineNum">    8485 </span>            : 
<span class="lineNum">    8486 </span>            :   int errnoStatus;
<span class="lineNum">    8487 </span>            : #if defined(XP_WIN)
<span class="lineNum">    8488 </span>            :   int32_t lastErrorStatus;
<span class="lineNum">    8489 </span>            :   CDataFinalizer::CallFinalizer(p, &amp;errnoStatus, &amp;lastErrorStatus);
<span class="lineNum">    8490 </span>            : #else
<span class="lineNum">    8491 </span><span class="lineNoCov">          0 :   CDataFinalizer::CallFinalizer(p, &amp;errnoStatus, nullptr);</span>
<span class="lineNum">    8492 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    8493 </span>            : 
<span class="lineNum">    8494 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(objCTypes, SLOT_ERRNO, Int32Value(errnoStatus));</span>
<span class="lineNum">    8495 </span>            : #if defined(XP_WIN)
<span class="lineNum">    8496 </span>            :   JS_SetReservedSlot(objCTypes, SLOT_LASTERROR, Int32Value(lastErrorStatus));
<span class="lineNum">    8497 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    8498 </span>            : 
<span class="lineNum">    8499 </span><span class="lineNoCov">          0 :   if (ConvertToJS(cx, resultType, nullptr, p-&gt;rvalue, false, true, &amp;result)) {</span>
<span class="lineNum">    8500 </span><span class="lineNoCov">          0 :     CDataFinalizer::Cleanup(p, obj);</span>
<span class="lineNum">    8501 </span><span class="lineNoCov">          0 :     args.rval().set(result);</span>
<span class="lineNum">    8502 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    8503 </span>            :   }
<span class="lineNum">    8504 </span><span class="lineNoCov">          0 :   CDataFinalizer::Cleanup(p, obj);</span>
<span class="lineNum">    8505 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    8506 </span>            : }
<span class="lineNum">    8507 </span>            : 
<span class="lineNum">    8508 </span>            : /*
<span class="lineNum">    8509 </span>            :  * Perform finalization.
<span class="lineNum">    8510 </span>            :  *
<span class="lineNum">    8511 </span>            :  * Preconditions: |this| must be the result of |CDataFinalizer|.
<span class="lineNum">    8512 </span>            :  * It may have gone through |Forget|/|Dispose|.
<span class="lineNum">    8513 </span>            :  *
<span class="lineNum">    8514 </span>            :  * If |this| has not gone through |Forget|/|Dispose|, calls the
<span class="lineNum">    8515 </span>            :  * finalizer, cleans up the Private memory and releases all
<span class="lineNum">    8516 </span>            :  * strong references.
<a name="8517"><span class="lineNum">    8517 </span>            :  */</a>
<span class="lineNum">    8518 </span>            : void
<span class="lineNum">    8519 </span><span class="lineNoCov">          0 : CDataFinalizer::Finalize(JSFreeOp* fop, JSObject* obj)</span>
<span class="lineNum">    8520 </span>            : {
<span class="lineNum">    8521 </span>            :   CDataFinalizer::Private* p = (CDataFinalizer::Private*)
<span class="lineNum">    8522 </span><span class="lineNoCov">          0 :     JS_GetPrivate(obj);</span>
<span class="lineNum">    8523 </span>            : 
<span class="lineNum">    8524 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8525 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    8526 </span>            :   }
<span class="lineNum">    8527 </span>            : 
<span class="lineNum">    8528 </span><span class="lineNoCov">          0 :   CDataFinalizer::CallFinalizer(p, nullptr, nullptr);</span>
<span class="lineNum">    8529 </span><span class="lineNoCov">          0 :   CDataFinalizer::Cleanup(p, nullptr);</span>
<span class="lineNum">    8530 </span>            : }
<span class="lineNum">    8531 </span>            : 
<span class="lineNum">    8532 </span>            : /*
<span class="lineNum">    8533 </span>            :  * Perform cleanup of a CDataFinalizer
<span class="lineNum">    8534 </span>            :  *
<span class="lineNum">    8535 </span>            :  * Release strong references, cleanup |Private|.
<span class="lineNum">    8536 </span>            :  *
<span class="lineNum">    8537 </span>            :  * Argument |p| contains the private information of the CDataFinalizer. If
<span class="lineNum">    8538 </span>            :  * nullptr, this function does nothing.
<span class="lineNum">    8539 </span>            :  * Argument |obj| should contain |nullptr| during finalization (or in any
<span class="lineNum">    8540 </span>            :  * context in which the object itself should not be cleaned up), or a
<span class="lineNum">    8541 </span>            :  * CDataFinalizer object otherwise.
<a name="8542"><span class="lineNum">    8542 </span>            :  */</a>
<span class="lineNum">    8543 </span>            : void
<span class="lineNum">    8544 </span><span class="lineNoCov">          0 : CDataFinalizer::Cleanup(CDataFinalizer::Private* p, JSObject* obj)</span>
<span class="lineNum">    8545 </span>            : {
<span class="lineNum">    8546 </span><span class="lineNoCov">          0 :   if (!p) {</span>
<span class="lineNum">    8547 </span><span class="lineNoCov">          0 :     return;  // We have already cleaned up</span>
<span class="lineNum">    8548 </span>            :   }
<span class="lineNum">    8549 </span>            : 
<span class="lineNum">    8550 </span><span class="lineNoCov">          0 :   free(p-&gt;cargs);</span>
<span class="lineNum">    8551 </span><span class="lineNoCov">          0 :   free(p-&gt;rvalue);</span>
<span class="lineNum">    8552 </span><span class="lineNoCov">          0 :   free(p);</span>
<span class="lineNum">    8553 </span>            : 
<span class="lineNum">    8554 </span><span class="lineNoCov">          0 :   if (!obj) {</span>
<span class="lineNum">    8555 </span><span class="lineNoCov">          0 :     return;  // No slots to clean up</span>
<span class="lineNum">    8556 </span>            :   }
<span class="lineNum">    8557 </span>            : 
<span class="lineNum">    8558 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CDataFinalizer::IsCDataFinalizer(obj));</span>
<span class="lineNum">    8559 </span>            : 
<span class="lineNum">    8560 </span><span class="lineNoCov">          0 :   JS_SetPrivate(obj, nullptr);</span>
<span class="lineNum">    8561 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; CDATAFINALIZER_SLOTS; ++i) {</span>
<span class="lineNum">    8562 </span><span class="lineNoCov">          0 :     JS_SetReservedSlot(obj, i, JS::NullValue());</span>
<span class="lineNum">    8563 </span>            :   }
<span class="lineNum">    8564 </span>            : }
<span class="lineNum">    8565 </span>            : 
<span class="lineNum">    8566 </span>            : 
<span class="lineNum">    8567 </span>            : /*******************************************************************************
<span class="lineNum">    8568 </span>            : ** Int64 and UInt64 implementation
<span class="lineNum">    8569 </span>            : *******************************************************************************/
<a name="8570"><span class="lineNum">    8570 </span>            : </a>
<span class="lineNum">    8571 </span>            : JSObject*
<span class="lineNum">    8572 </span><span class="lineNoCov">          0 : Int64Base::Construct(JSContext* cx,</span>
<span class="lineNum">    8573 </span>            :                      HandleObject proto,
<span class="lineNum">    8574 </span>            :                      uint64_t data,
<span class="lineNum">    8575 </span>            :                      bool isUnsigned)
<span class="lineNum">    8576 </span>            : {
<span class="lineNum">    8577 </span><span class="lineNoCov">          0 :   const JSClass* clasp = isUnsigned ? &amp;sUInt64Class : &amp;sInt64Class;</span>
<span class="lineNum">    8578 </span><span class="lineNoCov">          0 :   RootedObject result(cx, JS_NewObjectWithGivenProto(cx, clasp, proto));</span>
<span class="lineNum">    8579 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8580 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    8581 </span>            : 
<span class="lineNum">    8582 </span>            :   // attach the Int64's data
<span class="lineNum">    8583 </span><span class="lineNoCov">          0 :   uint64_t* buffer = cx-&gt;new_&lt;uint64_t&gt;(data);</span>
<span class="lineNum">    8584 </span><span class="lineNoCov">          0 :   if (!buffer) {</span>
<span class="lineNum">    8585 </span><span class="lineNoCov">          0 :     JS_ReportOutOfMemory(cx);</span>
<span class="lineNum">    8586 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    8587 </span>            :   }
<span class="lineNum">    8588 </span>            : 
<span class="lineNum">    8589 </span><span class="lineNoCov">          0 :   JS_SetReservedSlot(result, SLOT_INT64, PrivateValue(buffer));</span>
<span class="lineNum">    8590 </span>            : 
<span class="lineNum">    8591 </span><span class="lineNoCov">          0 :   if (!JS_FreezeObject(cx, result))</span>
<span class="lineNum">    8592 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    8593 </span>            : 
<span class="lineNum">    8594 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    8595 </span>            : }
<a name="8596"><span class="lineNum">    8596 </span>            : </a>
<span class="lineNum">    8597 </span>            : void
<span class="lineNum">    8598 </span><span class="lineNoCov">          0 : Int64Base::Finalize(JSFreeOp* fop, JSObject* obj)</span>
<span class="lineNum">    8599 </span>            : {
<span class="lineNum">    8600 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_INT64);</span>
<span class="lineNum">    8601 </span><span class="lineNoCov">          0 :   if (slot.isUndefined())</span>
<span class="lineNum">    8602 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    8603 </span>            : 
<span class="lineNum">    8604 </span><span class="lineNoCov">          0 :   FreeOp::get(fop)-&gt;delete_(static_cast&lt;uint64_t*&gt;(slot.toPrivate()));</span>
<span class="lineNum">    8605 </span>            : }
<a name="8606"><span class="lineNum">    8606 </span>            : </a>
<span class="lineNum">    8607 </span>            : uint64_t
<span class="lineNum">    8608 </span><span class="lineNoCov">          0 : Int64Base::GetInt(JSObject* obj) {</span>
<span class="lineNum">    8609 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(Int64::IsInt64(obj) || UInt64::IsUInt64(obj));</span>
<span class="lineNum">    8610 </span>            : 
<span class="lineNum">    8611 </span><span class="lineNoCov">          0 :   Value slot = JS_GetReservedSlot(obj, SLOT_INT64);</span>
<span class="lineNum">    8612 </span><span class="lineNoCov">          0 :   return *static_cast&lt;uint64_t*&gt;(slot.toPrivate());</span>
<span class="lineNum">    8613 </span>            : }
<a name="8614"><span class="lineNum">    8614 </span>            : </a>
<span class="lineNum">    8615 </span>            : bool
<span class="lineNum">    8616 </span><span class="lineNoCov">          0 : Int64Base::ToString(JSContext* cx,</span>
<span class="lineNum">    8617 </span>            :                     JSObject* obj,
<span class="lineNum">    8618 </span>            :                     const CallArgs&amp; args,
<span class="lineNum">    8619 </span>            :                     bool isUnsigned)
<span class="lineNum">    8620 </span>            : {
<span class="lineNum">    8621 </span><span class="lineNoCov">          0 :   if (args.length() &gt; 1) {</span>
<span class="lineNum">    8622 </span><span class="lineNoCov">          0 :     if (isUnsigned) {</span>
<span class="lineNum">    8623 </span>            :       return ArgumentLengthError(cx, &quot;UInt64.prototype.toString&quot;,
<span class="lineNum">    8624 </span><span class="lineNoCov">          0 :                                  &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8625 </span>            :     }
<span class="lineNum">    8626 </span>            :     return ArgumentLengthError(cx, &quot;Int64.prototype.toString&quot;,
<span class="lineNum">    8627 </span><span class="lineNoCov">          0 :                                &quot;at most one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8628 </span>            :   }
<span class="lineNum">    8629 </span>            : 
<span class="lineNum">    8630 </span><span class="lineNoCov">          0 :   int radix = 10;</span>
<span class="lineNum">    8631 </span><span class="lineNoCov">          0 :   if (args.length() == 1) {</span>
<span class="lineNum">    8632 </span><span class="lineNoCov">          0 :     Value arg = args[0];</span>
<span class="lineNum">    8633 </span><span class="lineNoCov">          0 :     if (arg.isInt32())</span>
<span class="lineNum">    8634 </span><span class="lineNoCov">          0 :       radix = arg.toInt32();</span>
<span class="lineNum">    8635 </span><span class="lineNoCov">          0 :     if (!arg.isInt32() || radix &lt; 2 || radix &gt; 36) {</span>
<span class="lineNum">    8636 </span><span class="lineNoCov">          0 :       if (isUnsigned) {</span>
<span class="lineNum">    8637 </span><span class="lineNoCov">          0 :         return ArgumentRangeMismatch(cx, &quot;UInt64.prototype.toString&quot;, &quot;an integer at least 2 and no greater than 36&quot;);</span>
<span class="lineNum">    8638 </span>            :       }
<span class="lineNum">    8639 </span><span class="lineNoCov">          0 :       return ArgumentRangeMismatch(cx, &quot;Int64.prototype.toString&quot;, &quot;an integer at least 2 and no greater than 36&quot;);</span>
<span class="lineNum">    8640 </span>            :     }
<span class="lineNum">    8641 </span>            :   }
<span class="lineNum">    8642 </span>            : 
<span class="lineNum">    8643 </span><span class="lineNoCov">          0 :   AutoString intString;</span>
<span class="lineNum">    8644 </span><span class="lineNoCov">          0 :   if (isUnsigned) {</span>
<span class="lineNum">    8645 </span><span class="lineNoCov">          0 :     IntegerToString(GetInt(obj), radix, intString);</span>
<span class="lineNum">    8646 </span>            :   } else {
<span class="lineNum">    8647 </span><span class="lineNoCov">          0 :     IntegerToString(static_cast&lt;int64_t&gt;(GetInt(obj)), radix, intString);</span>
<span class="lineNum">    8648 </span>            :   }
<span class="lineNum">    8649 </span>            : 
<span class="lineNum">    8650 </span><span class="lineNoCov">          0 :   JSString* result = NewUCString(cx, intString);</span>
<span class="lineNum">    8651 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8652 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8653 </span>            : 
<span class="lineNum">    8654 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    8655 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8656 </span>            : }
<a name="8657"><span class="lineNum">    8657 </span>            : </a>
<span class="lineNum">    8658 </span>            : bool
<span class="lineNum">    8659 </span><span class="lineNoCov">          0 : Int64Base::ToSource(JSContext* cx,</span>
<span class="lineNum">    8660 </span>            :                     JSObject* obj,
<span class="lineNum">    8661 </span>            :                     const CallArgs&amp; args,
<span class="lineNum">    8662 </span>            :                     bool isUnsigned)
<span class="lineNum">    8663 </span>            : {
<span class="lineNum">    8664 </span><span class="lineNoCov">          0 :   if (args.length() != 0) {</span>
<span class="lineNum">    8665 </span><span class="lineNoCov">          0 :     if (isUnsigned) {</span>
<span class="lineNum">    8666 </span><span class="lineNoCov">          0 :       return ArgumentLengthError(cx, &quot;UInt64.prototype.toSource&quot;, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8667 </span>            :     }
<span class="lineNum">    8668 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64.prototype.toSource&quot;, &quot;no&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8669 </span>            :   }
<span class="lineNum">    8670 </span>            : 
<span class="lineNum">    8671 </span>            :   // Return a decimal string suitable for constructing the number.
<span class="lineNum">    8672 </span><span class="lineNoCov">          0 :   AutoString source;</span>
<span class="lineNum">    8673 </span><span class="lineNoCov">          0 :   if (isUnsigned) {</span>
<span class="lineNum">    8674 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;ctypes.UInt64(\&quot;&quot;);</span>
<span class="lineNum">    8675 </span><span class="lineNoCov">          0 :     IntegerToString(GetInt(obj), 10, source);</span>
<span class="lineNum">    8676 </span>            :   } else {
<span class="lineNum">    8677 </span><span class="lineNoCov">          0 :     AppendString(source, &quot;ctypes.Int64(\&quot;&quot;);</span>
<span class="lineNum">    8678 </span><span class="lineNoCov">          0 :     IntegerToString(static_cast&lt;int64_t&gt;(GetInt(obj)), 10, source);</span>
<span class="lineNum">    8679 </span>            :   }
<span class="lineNum">    8680 </span><span class="lineNoCov">          0 :   AppendString(source, &quot;\&quot;)&quot;);</span>
<span class="lineNum">    8681 </span>            : 
<span class="lineNum">    8682 </span><span class="lineNoCov">          0 :   JSString* result = NewUCString(cx, source);</span>
<span class="lineNum">    8683 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8684 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8685 </span>            : 
<span class="lineNum">    8686 </span><span class="lineNoCov">          0 :   args.rval().setString(result);</span>
<span class="lineNum">    8687 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8688 </span>            : }
<a name="8689"><span class="lineNum">    8689 </span>            : </a>
<span class="lineNum">    8690 </span>            : bool
<span class="lineNum">    8691 </span><span class="lineNoCov">          0 : Int64::Construct(JSContext* cx,</span>
<span class="lineNum">    8692 </span>            :                  unsigned argc,
<span class="lineNum">    8693 </span>            :                  Value* vp)
<span class="lineNum">    8694 </span>            : {
<span class="lineNum">    8695 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8696 </span>            : 
<span class="lineNum">    8697 </span>            :   // Construct and return a new Int64 object.
<span class="lineNum">    8698 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    8699 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64 constructor&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8700 </span>            :   }
<span class="lineNum">    8701 </span>            : 
<span class="lineNum">    8702 </span><span class="lineNoCov">          0 :   int64_t i = 0;</span>
<span class="lineNum">    8703 </span><span class="lineNoCov">          0 :   bool overflow = false;</span>
<span class="lineNum">    8704 </span><span class="lineNoCov">          0 :   if (!jsvalToBigInteger(cx, args[0], true, &amp;i, &amp;overflow)) {</span>
<span class="lineNum">    8705 </span><span class="lineNoCov">          0 :     if (overflow) {</span>
<span class="lineNum">    8706 </span><span class="lineNoCov">          0 :       return TypeOverflow(cx, &quot;int64&quot;, args[0]);</span>
<span class="lineNum">    8707 </span>            :     }
<span class="lineNum">    8708 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[0], &quot;Int64&quot;, 0);</span>
<span class="lineNum">    8709 </span>            :   }
<span class="lineNum">    8710 </span>            : 
<span class="lineNum">    8711 </span>            :   // Get ctypes.Int64.prototype from the 'prototype' property of the ctor.
<span class="lineNum">    8712 </span><span class="lineNoCov">          0 :   RootedValue slot(cx);</span>
<span class="lineNum">    8713 </span><span class="lineNoCov">          0 :   RootedObject callee(cx, &amp;args.callee());</span>
<span class="lineNum">    8714 </span><span class="lineNoCov">          0 :   ASSERT_OK(JS_GetProperty(cx, callee, &quot;prototype&quot;, &amp;slot));</span>
<span class="lineNum">    8715 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, slot.toObjectOrNull());</span>
<span class="lineNum">    8716 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(JS_GetClass(proto) == &amp;sInt64ProtoClass);</span>
<span class="lineNum">    8717 </span>            : 
<span class="lineNum">    8718 </span><span class="lineNoCov">          0 :   JSObject* result = Int64Base::Construct(cx, proto, i, false);</span>
<span class="lineNum">    8719 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8720 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8721 </span>            : 
<span class="lineNum">    8722 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    8723 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8724 </span>            : }
<a name="8725"><span class="lineNum">    8725 </span>            : </a>
<span class="lineNum">    8726 </span>            : bool
<span class="lineNum">    8727 </span><span class="lineNoCov">          0 : Int64::IsInt64(JSObject* obj)</span>
<span class="lineNum">    8728 </span>            : {
<span class="lineNum">    8729 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sInt64Class;</span>
<span class="lineNum">    8730 </span>            : }
<a name="8731"><span class="lineNum">    8731 </span>            : </a>
<span class="lineNum">    8732 </span>            : bool
<span class="lineNum">    8733 </span><span class="lineNoCov">          0 : Int64::ToString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8734 </span>            : {
<span class="lineNum">    8735 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8736 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    8737 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8738 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8739 </span><span class="lineNoCov">          0 :   if (!Int64::IsInt64(obj)) {</span>
<span class="lineNum">    8740 </span><span class="lineNoCov">          0 :     if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    8741 </span><span class="lineNoCov">          0 :       return IncompatibleThisProto(cx, &quot;Int64.prototype.toString&quot;,</span>
<span class="lineNum">    8742 </span><span class="lineNoCov">          0 :                                    InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8743 </span>            :     }
<span class="lineNum">    8744 </span>            :     return IncompatibleThisType(cx, &quot;Int64.prototype.toString&quot;,
<span class="lineNum">    8745 </span><span class="lineNoCov">          0 :                                 &quot;non-Int64 CData&quot;);</span>
<span class="lineNum">    8746 </span>            :   }
<span class="lineNum">    8747 </span>            : 
<span class="lineNum">    8748 </span><span class="lineNoCov">          0 :   return Int64Base::ToString(cx, obj, args, false);</span>
<span class="lineNum">    8749 </span>            : }
<a name="8750"><span class="lineNum">    8750 </span>            : </a>
<span class="lineNum">    8751 </span>            : bool
<span class="lineNum">    8752 </span><span class="lineNoCov">          0 : Int64::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8753 </span>            : {
<span class="lineNum">    8754 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8755 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    8756 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8757 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8758 </span><span class="lineNoCov">          0 :   if (!Int64::IsInt64(obj)) {</span>
<span class="lineNum">    8759 </span><span class="lineNoCov">          0 :     if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    8760 </span><span class="lineNoCov">          0 :       return IncompatibleThisProto(cx, &quot;Int64.prototype.toSource&quot;,</span>
<span class="lineNum">    8761 </span><span class="lineNoCov">          0 :                                    InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8762 </span>            :     }
<span class="lineNum">    8763 </span>            :     return IncompatibleThisType(cx, &quot;Int64.prototype.toSource&quot;,
<span class="lineNum">    8764 </span><span class="lineNoCov">          0 :                                 &quot;non-Int64 CData&quot;);</span>
<span class="lineNum">    8765 </span>            :   }
<span class="lineNum">    8766 </span>            : 
<span class="lineNum">    8767 </span><span class="lineNoCov">          0 :   return Int64Base::ToSource(cx, obj, args, false);</span>
<span class="lineNum">    8768 </span>            : }
<a name="8769"><span class="lineNum">    8769 </span>            : </a>
<span class="lineNum">    8770 </span>            : bool
<span class="lineNum">    8771 </span><span class="lineNoCov">          0 : Int64::Compare(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8772 </span>            : {
<span class="lineNum">    8773 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8774 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    8775 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64.compare&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8776 </span>            :   }
<span class="lineNum">    8777 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !Int64::IsInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    8778 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;first &quot;, &quot;Int64.compare&quot;, &quot;a Int64&quot;);</span>
<span class="lineNum">    8779 </span>            :   }
<span class="lineNum">    8780 </span><span class="lineNoCov">          0 :   if (args[1].isPrimitive() ||!Int64::IsInt64(&amp;args[1].toObject())) {</span>
<span class="lineNum">    8781 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;second &quot;, &quot;Int64.compare&quot;, &quot;a Int64&quot;);</span>
<span class="lineNum">    8782 </span>            :   }
<span class="lineNum">    8783 </span>            : 
<span class="lineNum">    8784 </span><span class="lineNoCov">          0 :   JSObject* obj1 = &amp;args[0].toObject();</span>
<span class="lineNum">    8785 </span><span class="lineNoCov">          0 :   JSObject* obj2 = &amp;args[1].toObject();</span>
<span class="lineNum">    8786 </span>            : 
<span class="lineNum">    8787 </span><span class="lineNoCov">          0 :   int64_t i1 = Int64Base::GetInt(obj1);</span>
<span class="lineNum">    8788 </span><span class="lineNoCov">          0 :   int64_t i2 = Int64Base::GetInt(obj2);</span>
<span class="lineNum">    8789 </span>            : 
<span class="lineNum">    8790 </span><span class="lineNoCov">          0 :   if (i1 == i2)</span>
<span class="lineNum">    8791 </span><span class="lineNoCov">          0 :     args.rval().setInt32(0);</span>
<span class="lineNum">    8792 </span><span class="lineNoCov">          0 :   else if (i1 &lt; i2)</span>
<span class="lineNum">    8793 </span><span class="lineNoCov">          0 :     args.rval().setInt32(-1);</span>
<span class="lineNum">    8794 </span>            :   else
<span class="lineNum">    8795 </span><span class="lineNoCov">          0 :     args.rval().setInt32(1);</span>
<span class="lineNum">    8796 </span>            : 
<span class="lineNum">    8797 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8798 </span>            : }
<span class="lineNum">    8799 </span>            : 
<span class="lineNum">    8800 </span>            : #define LO_MASK ((uint64_t(1) &lt;&lt; 32) - 1)
<span class="lineNum">    8801 </span>            : #define INT64_LO(i) ((i) &amp; LO_MASK)
<span class="lineNum">    8802 </span>            : #define INT64_HI(i) ((i) &gt;&gt; 32)
<a name="8803"><span class="lineNum">    8803 </span>            : </a>
<span class="lineNum">    8804 </span>            : bool
<span class="lineNum">    8805 </span><span class="lineNoCov">          0 : Int64::Lo(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8806 </span>            : {
<span class="lineNum">    8807 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8808 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    8809 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64.lo&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8810 </span>            :   }
<span class="lineNum">    8811 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !Int64::IsInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    8812 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;Int64.lo&quot;, &quot;a Int64&quot;);</span>
<span class="lineNum">    8813 </span>            :   }
<span class="lineNum">    8814 </span>            : 
<span class="lineNum">    8815 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;args[0].toObject();</span>
<span class="lineNum">    8816 </span><span class="lineNoCov">          0 :   int64_t u = Int64Base::GetInt(obj);</span>
<span class="lineNum">    8817 </span><span class="lineNoCov">          0 :   double d = uint32_t(INT64_LO(u));</span>
<span class="lineNum">    8818 </span>            : 
<span class="lineNum">    8819 </span><span class="lineNoCov">          0 :   args.rval().setNumber(d);</span>
<span class="lineNum">    8820 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8821 </span>            : }
<a name="8822"><span class="lineNum">    8822 </span>            : </a>
<span class="lineNum">    8823 </span>            : bool
<span class="lineNum">    8824 </span><span class="lineNoCov">          0 : Int64::Hi(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8825 </span>            : {
<span class="lineNum">    8826 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8827 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    8828 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64.hi&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8829 </span>            :   }
<span class="lineNum">    8830 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !Int64::IsInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    8831 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;Int64.hi&quot;, &quot;a Int64&quot;);</span>
<span class="lineNum">    8832 </span>            :   }
<span class="lineNum">    8833 </span>            : 
<span class="lineNum">    8834 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;args[0].toObject();</span>
<span class="lineNum">    8835 </span><span class="lineNoCov">          0 :   int64_t u = Int64Base::GetInt(obj);</span>
<span class="lineNum">    8836 </span><span class="lineNoCov">          0 :   double d = int32_t(INT64_HI(u));</span>
<span class="lineNum">    8837 </span>            : 
<span class="lineNum">    8838 </span><span class="lineNoCov">          0 :   args.rval().setDouble(d);</span>
<span class="lineNum">    8839 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8840 </span>            : }
<a name="8841"><span class="lineNum">    8841 </span>            : </a>
<span class="lineNum">    8842 </span>            : bool
<span class="lineNum">    8843 </span><span class="lineNoCov">          0 : Int64::Join(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8844 </span>            : {
<span class="lineNum">    8845 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8846 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    8847 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;Int64.join&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8848 </span>            :   }
<span class="lineNum">    8849 </span>            : 
<span class="lineNum">    8850 </span>            :   int32_t hi;
<span class="lineNum">    8851 </span>            :   uint32_t lo;
<span class="lineNum">    8852 </span><span class="lineNoCov">          0 :   if (!jsvalToInteger(cx, args[0], &amp;hi))</span>
<span class="lineNum">    8853 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[0], &quot;Int64.join&quot;, 0);</span>
<span class="lineNum">    8854 </span><span class="lineNoCov">          0 :   if (!jsvalToInteger(cx, args[1], &amp;lo))</span>
<span class="lineNum">    8855 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[1], &quot;Int64.join&quot;, 1);</span>
<span class="lineNum">    8856 </span>            : 
<span class="lineNum">    8857 </span><span class="lineNoCov">          0 :   int64_t i = (int64_t(hi) &lt;&lt; 32) + int64_t(lo);</span>
<span class="lineNum">    8858 </span>            : 
<span class="lineNum">    8859 </span>            :   // Get Int64.prototype from the function's reserved slot.
<span class="lineNum">    8860 </span><span class="lineNoCov">          0 :   JSObject* callee = &amp;args.callee();</span>
<span class="lineNum">    8861 </span>            : 
<span class="lineNum">    8862 </span><span class="lineNoCov">          0 :   Value slot = js::GetFunctionNativeReserved(callee, SLOT_FN_INT64PROTO);</span>
<span class="lineNum">    8863 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, &amp;slot.toObject());</span>
<span class="lineNum">    8864 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(JS_GetClass(proto) == &amp;sInt64ProtoClass);</span>
<span class="lineNum">    8865 </span>            : 
<span class="lineNum">    8866 </span><span class="lineNoCov">          0 :   JSObject* result = Int64Base::Construct(cx, proto, i, false);</span>
<span class="lineNum">    8867 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8868 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8869 </span>            : 
<span class="lineNum">    8870 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    8871 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8872 </span>            : }
<a name="8873"><span class="lineNum">    8873 </span>            : </a>
<span class="lineNum">    8874 </span>            : bool
<span class="lineNum">    8875 </span><span class="lineNoCov">          0 : UInt64::Construct(JSContext* cx,</span>
<span class="lineNum">    8876 </span>            :                   unsigned argc,
<span class="lineNum">    8877 </span>            :                   Value* vp)
<span class="lineNum">    8878 </span>            : {
<span class="lineNum">    8879 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8880 </span>            : 
<span class="lineNum">    8881 </span>            :   // Construct and return a new UInt64 object.
<span class="lineNum">    8882 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    8883 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;UInt64 constructor&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8884 </span>            :   }
<span class="lineNum">    8885 </span>            : 
<span class="lineNum">    8886 </span><span class="lineNoCov">          0 :   uint64_t u = 0;</span>
<span class="lineNum">    8887 </span><span class="lineNoCov">          0 :   bool overflow = false;</span>
<span class="lineNum">    8888 </span><span class="lineNoCov">          0 :   if (!jsvalToBigInteger(cx, args[0], true, &amp;u, &amp;overflow)) {</span>
<span class="lineNum">    8889 </span><span class="lineNoCov">          0 :     if (overflow) {</span>
<span class="lineNum">    8890 </span><span class="lineNoCov">          0 :       return TypeOverflow(cx, &quot;uint64&quot;, args[0]);</span>
<span class="lineNum">    8891 </span>            :     }
<span class="lineNum">    8892 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[0], &quot;UInt64&quot;, 0);</span>
<span class="lineNum">    8893 </span>            :   }
<span class="lineNum">    8894 </span>            : 
<span class="lineNum">    8895 </span>            :   // Get ctypes.UInt64.prototype from the 'prototype' property of the ctor.
<span class="lineNum">    8896 </span><span class="lineNoCov">          0 :   RootedValue slot(cx);</span>
<span class="lineNum">    8897 </span><span class="lineNoCov">          0 :   RootedObject callee(cx, &amp;args.callee());</span>
<span class="lineNum">    8898 </span><span class="lineNoCov">          0 :   ASSERT_OK(JS_GetProperty(cx, callee, &quot;prototype&quot;, &amp;slot));</span>
<span class="lineNum">    8899 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, &amp;slot.toObject());</span>
<span class="lineNum">    8900 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(JS_GetClass(proto) == &amp;sUInt64ProtoClass);</span>
<span class="lineNum">    8901 </span>            : 
<span class="lineNum">    8902 </span><span class="lineNoCov">          0 :   JSObject* result = Int64Base::Construct(cx, proto, u, true);</span>
<span class="lineNum">    8903 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    8904 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8905 </span>            : 
<span class="lineNum">    8906 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    8907 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8908 </span>            : }
<a name="8909"><span class="lineNum">    8909 </span>            : </a>
<span class="lineNum">    8910 </span>            : bool
<span class="lineNum">    8911 </span><span class="lineNoCov">          0 : UInt64::IsUInt64(JSObject* obj)</span>
<span class="lineNum">    8912 </span>            : {
<span class="lineNum">    8913 </span><span class="lineNoCov">          0 :   return JS_GetClass(obj) == &amp;sUInt64Class;</span>
<span class="lineNum">    8914 </span>            : }
<a name="8915"><span class="lineNum">    8915 </span>            : </a>
<span class="lineNum">    8916 </span>            : bool
<span class="lineNum">    8917 </span><span class="lineNoCov">          0 : UInt64::ToString(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8918 </span>            : {
<span class="lineNum">    8919 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8920 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    8921 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8922 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8923 </span><span class="lineNoCov">          0 :   if (!UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    8924 </span><span class="lineNoCov">          0 :     if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    8925 </span><span class="lineNoCov">          0 :       return IncompatibleThisProto(cx, &quot;UInt64.prototype.toString&quot;,</span>
<span class="lineNum">    8926 </span><span class="lineNoCov">          0 :                                    InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8927 </span>            :     }
<span class="lineNum">    8928 </span>            :     return IncompatibleThisType(cx, &quot;UInt64.prototype.toString&quot;,
<span class="lineNum">    8929 </span><span class="lineNoCov">          0 :                                 &quot;non-UInt64 CData&quot;);</span>
<span class="lineNum">    8930 </span>            :   }
<span class="lineNum">    8931 </span>            : 
<span class="lineNum">    8932 </span><span class="lineNoCov">          0 :   return Int64Base::ToString(cx, obj, args, true);</span>
<span class="lineNum">    8933 </span>            : }
<a name="8934"><span class="lineNum">    8934 </span>            : </a>
<span class="lineNum">    8935 </span>            : bool
<span class="lineNum">    8936 </span><span class="lineNoCov">          0 : UInt64::ToSource(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8937 </span>            : {
<span class="lineNum">    8938 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8939 </span><span class="lineNoCov">          0 :   JSObject* obj = JS_THIS_OBJECT(cx, vp);</span>
<span class="lineNum">    8940 </span><span class="lineNoCov">          0 :   if (!obj)</span>
<span class="lineNum">    8941 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    8942 </span><span class="lineNoCov">          0 :   if (!UInt64::IsUInt64(obj)) {</span>
<span class="lineNum">    8943 </span><span class="lineNoCov">          0 :     if (!CData::IsCData(obj)) {</span>
<span class="lineNum">    8944 </span><span class="lineNoCov">          0 :       return IncompatibleThisProto(cx, &quot;UInt64.prototype.toSource&quot;,</span>
<span class="lineNum">    8945 </span><span class="lineNoCov">          0 :                                    InformalValueTypeName(args.thisv()));</span>
<span class="lineNum">    8946 </span>            :     }
<span class="lineNum">    8947 </span>            :     return IncompatibleThisType(cx, &quot;UInt64.prototype.toSource&quot;,
<span class="lineNum">    8948 </span><span class="lineNoCov">          0 :                                 &quot;non-UInt64 CData&quot;);</span>
<span class="lineNum">    8949 </span>            :   }
<span class="lineNum">    8950 </span>            : 
<span class="lineNum">    8951 </span><span class="lineNoCov">          0 :   return Int64Base::ToSource(cx, obj, args, true);</span>
<span class="lineNum">    8952 </span>            : }
<a name="8953"><span class="lineNum">    8953 </span>            : </a>
<span class="lineNum">    8954 </span>            : bool
<span class="lineNum">    8955 </span><span class="lineNoCov">          0 : UInt64::Compare(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8956 </span>            : {
<span class="lineNum">    8957 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8958 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    8959 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;UInt64.compare&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    8960 </span>            :   }
<span class="lineNum">    8961 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !UInt64::IsUInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    8962 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;first &quot;, &quot;UInt64.compare&quot;, &quot;a UInt64&quot;);</span>
<span class="lineNum">    8963 </span>            :   }
<span class="lineNum">    8964 </span><span class="lineNoCov">          0 :   if (args[1].isPrimitive() || !UInt64::IsUInt64(&amp;args[1].toObject())) {</span>
<span class="lineNum">    8965 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;second &quot;, &quot;UInt64.compare&quot;, &quot;a UInt64&quot;);</span>
<span class="lineNum">    8966 </span>            :   }
<span class="lineNum">    8967 </span>            : 
<span class="lineNum">    8968 </span><span class="lineNoCov">          0 :   JSObject* obj1 = &amp;args[0].toObject();</span>
<span class="lineNum">    8969 </span><span class="lineNoCov">          0 :   JSObject* obj2 = &amp;args[1].toObject();</span>
<span class="lineNum">    8970 </span>            : 
<span class="lineNum">    8971 </span><span class="lineNoCov">          0 :   uint64_t u1 = Int64Base::GetInt(obj1);</span>
<span class="lineNum">    8972 </span><span class="lineNoCov">          0 :   uint64_t u2 = Int64Base::GetInt(obj2);</span>
<span class="lineNum">    8973 </span>            : 
<span class="lineNum">    8974 </span><span class="lineNoCov">          0 :   if (u1 == u2)</span>
<span class="lineNum">    8975 </span><span class="lineNoCov">          0 :     args.rval().setInt32(0);</span>
<span class="lineNum">    8976 </span><span class="lineNoCov">          0 :   else if (u1 &lt; u2)</span>
<span class="lineNum">    8977 </span><span class="lineNoCov">          0 :     args.rval().setInt32(-1);</span>
<span class="lineNum">    8978 </span>            :   else
<span class="lineNum">    8979 </span><span class="lineNoCov">          0 :     args.rval().setInt32(1);</span>
<span class="lineNum">    8980 </span>            : 
<span class="lineNum">    8981 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    8982 </span>            : }
<a name="8983"><span class="lineNum">    8983 </span>            : </a>
<span class="lineNum">    8984 </span>            : bool
<span class="lineNum">    8985 </span><span class="lineNoCov">          0 : UInt64::Lo(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    8986 </span>            : {
<span class="lineNum">    8987 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    8988 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    8989 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;UInt64.lo&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    8990 </span>            :   }
<span class="lineNum">    8991 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !UInt64::IsUInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    8992 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;UInt64.lo&quot;, &quot;a UInt64&quot;);</span>
<span class="lineNum">    8993 </span>            :   }
<span class="lineNum">    8994 </span>            : 
<span class="lineNum">    8995 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;args[0].toObject();</span>
<span class="lineNum">    8996 </span><span class="lineNoCov">          0 :   uint64_t u = Int64Base::GetInt(obj);</span>
<span class="lineNum">    8997 </span><span class="lineNoCov">          0 :   double d = uint32_t(INT64_LO(u));</span>
<span class="lineNum">    8998 </span>            : 
<span class="lineNum">    8999 </span><span class="lineNoCov">          0 :   args.rval().setDouble(d);</span>
<span class="lineNum">    9000 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    9001 </span>            : }
<a name="9002"><span class="lineNum">    9002 </span>            : </a>
<span class="lineNum">    9003 </span>            : bool
<span class="lineNum">    9004 </span><span class="lineNoCov">          0 : UInt64::Hi(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    9005 </span>            : {
<span class="lineNum">    9006 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    9007 </span><span class="lineNoCov">          0 :   if (args.length() != 1) {</span>
<span class="lineNum">    9008 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;UInt64.hi&quot;, &quot;one&quot;, &quot;&quot;);</span>
<span class="lineNum">    9009 </span>            :   }
<span class="lineNum">    9010 </span><span class="lineNoCov">          0 :   if (args[0].isPrimitive() || !UInt64::IsUInt64(&amp;args[0].toObject())) {</span>
<span class="lineNum">    9011 </span><span class="lineNoCov">          0 :     return ArgumentTypeMismatch(cx, &quot;&quot;, &quot;UInt64.hi&quot;, &quot;a UInt64&quot;);</span>
<span class="lineNum">    9012 </span>            :   }
<span class="lineNum">    9013 </span>            : 
<span class="lineNum">    9014 </span><span class="lineNoCov">          0 :   JSObject* obj = &amp;args[0].toObject();</span>
<span class="lineNum">    9015 </span><span class="lineNoCov">          0 :   uint64_t u = Int64Base::GetInt(obj);</span>
<span class="lineNum">    9016 </span><span class="lineNoCov">          0 :   double d = uint32_t(INT64_HI(u));</span>
<span class="lineNum">    9017 </span>            : 
<span class="lineNum">    9018 </span><span class="lineNoCov">          0 :   args.rval().setDouble(d);</span>
<span class="lineNum">    9019 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    9020 </span>            : }
<a name="9021"><span class="lineNum">    9021 </span>            : </a>
<span class="lineNum">    9022 </span>            : bool
<span class="lineNum">    9023 </span><span class="lineNoCov">          0 : UInt64::Join(JSContext* cx, unsigned argc, Value* vp)</span>
<span class="lineNum">    9024 </span>            : {
<span class="lineNum">    9025 </span><span class="lineNoCov">          0 :   CallArgs args = CallArgsFromVp(argc, vp);</span>
<span class="lineNum">    9026 </span><span class="lineNoCov">          0 :   if (args.length() != 2) {</span>
<span class="lineNum">    9027 </span><span class="lineNoCov">          0 :     return ArgumentLengthError(cx, &quot;UInt64.join&quot;, &quot;two&quot;, &quot;s&quot;);</span>
<span class="lineNum">    9028 </span>            :   }
<span class="lineNum">    9029 </span>            : 
<span class="lineNum">    9030 </span>            :   uint32_t hi;
<span class="lineNum">    9031 </span>            :   uint32_t lo;
<span class="lineNum">    9032 </span><span class="lineNoCov">          0 :   if (!jsvalToInteger(cx, args[0], &amp;hi))</span>
<span class="lineNum">    9033 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[0], &quot;UInt64.join&quot;, 0);</span>
<span class="lineNum">    9034 </span><span class="lineNoCov">          0 :   if (!jsvalToInteger(cx, args[1], &amp;lo))</span>
<span class="lineNum">    9035 </span><span class="lineNoCov">          0 :     return ArgumentConvError(cx, args[1], &quot;UInt64.join&quot;, 1);</span>
<span class="lineNum">    9036 </span>            : 
<span class="lineNum">    9037 </span><span class="lineNoCov">          0 :   uint64_t u = (uint64_t(hi) &lt;&lt; 32) + uint64_t(lo);</span>
<span class="lineNum">    9038 </span>            : 
<span class="lineNum">    9039 </span>            :   // Get UInt64.prototype from the function's reserved slot.
<span class="lineNum">    9040 </span><span class="lineNoCov">          0 :   JSObject* callee = &amp;args.callee();</span>
<span class="lineNum">    9041 </span>            : 
<span class="lineNum">    9042 </span><span class="lineNoCov">          0 :   Value slot = js::GetFunctionNativeReserved(callee, SLOT_FN_INT64PROTO);</span>
<span class="lineNum">    9043 </span><span class="lineNoCov">          0 :   RootedObject proto(cx, &amp;slot.toObject());</span>
<span class="lineNum">    9044 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(JS_GetClass(proto) == &amp;sUInt64ProtoClass);</span>
<span class="lineNum">    9045 </span>            : 
<span class="lineNum">    9046 </span><span class="lineNoCov">          0 :   JSObject* result = Int64Base::Construct(cx, proto, u, true);</span>
<span class="lineNum">    9047 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    9048 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    9049 </span>            : 
<span class="lineNum">    9050 </span><span class="lineNoCov">          0 :   args.rval().setObject(*result);</span>
<span class="lineNum">    9051 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    9052 </span>            : }
<span class="lineNum">    9053 </span>            : 
<span class="lineNum">    9054 </span>            : } // namespace ctypes
<span class="lineNum">    9055 </span>            : } // namespace js
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

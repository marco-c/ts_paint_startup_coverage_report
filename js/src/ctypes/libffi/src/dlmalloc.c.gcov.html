<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/ctypes/libffi/src/dlmalloc.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">js/src/ctypes/libffi/src</a> - dlmalloc.c<span style="font-size: 80%;"> (source / <a href="dlmalloc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">908</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :   This is a version (aka dlmalloc) of malloc/free/realloc written by
<span class="lineNum">       3 </span>            :   Doug Lea and released to the public domain, as explained at
<span class="lineNum">       4 </span>            :   http://creativecommons.org/licenses/publicdomain.  Send questions,
<span class="lineNum">       5 </span>            :   comments, complaints, performance data, etc to dl@cs.oswego.edu
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : * Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    Note: There may be an updated version of this malloc obtainable at
<span class="lineNum">      10 </span>            :            ftp://gee.cs.oswego.edu/pub/misc/malloc.c
<span class="lineNum">      11 </span>            :          Check before installing!
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : * Quickstart
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            :   This library is all in one file to simplify the most common usage:
<span class="lineNum">      16 </span>            :   ftp it, compile it (-O3), and link it into another program. All of
<span class="lineNum">      17 </span>            :   the compile-time options default to reasonable values for use on
<span class="lineNum">      18 </span>            :   most platforms.  You might later want to step through various
<span class="lineNum">      19 </span>            :   compile-time and dynamic tuning options.
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            :   For convenience, an include file for code using this malloc is at:
<span class="lineNum">      22 </span>            :      ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h
<span class="lineNum">      23 </span>            :   You don't really need this .h file unless you call functions not
<span class="lineNum">      24 </span>            :   defined in your system include files.  The .h file contains only the
<span class="lineNum">      25 </span>            :   excerpts from this file needed for using this malloc on ANSI C/C++
<span class="lineNum">      26 </span>            :   systems, so long as you haven't changed compile-time options about
<span class="lineNum">      27 </span>            :   naming and tuning parameters.  If you do, then you can create your
<span class="lineNum">      28 </span>            :   own malloc.h that does include all settings by cutting at the point
<span class="lineNum">      29 </span>            :   indicated below. Note that you may already by default be using a C
<span class="lineNum">      30 </span>            :   library containing a malloc that is based on some version of this
<span class="lineNum">      31 </span>            :   malloc (for example in linux). You might still want to use the one
<span class="lineNum">      32 </span>            :   in this file to customize settings or to avoid overheads associated
<span class="lineNum">      33 </span>            :   with library versions.
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : * Vital statistics:
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :   Supported pointer/size_t representation:       4 or 8 bytes
<span class="lineNum">      38 </span>            :        size_t MUST be an unsigned type of the same width as
<span class="lineNum">      39 </span>            :        pointers. (If you are using an ancient system that declares
<span class="lineNum">      40 </span>            :        size_t as a signed type, or need it to be a different width
<span class="lineNum">      41 </span>            :        than pointers, you can use a previous release of this malloc
<span class="lineNum">      42 </span>            :        (e.g. 2.7.2) supporting these.)
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :   Alignment:                                     8 bytes (default)
<span class="lineNum">      45 </span>            :        This suffices for nearly all current machines and C compilers.
<span class="lineNum">      46 </span>            :        However, you can define MALLOC_ALIGNMENT to be wider than this
<span class="lineNum">      47 </span>            :        if necessary (up to 128bytes), at the expense of using more space.
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
<span class="lineNum">      50 </span>            :                                           8 or 16 bytes (if 8byte sizes)
<span class="lineNum">      51 </span>            :        Each malloced chunk has a hidden word of overhead holding size
<span class="lineNum">      52 </span>            :        and status information, and additional cross-check word
<span class="lineNum">      53 </span>            :        if FOOTERS is defined.
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :   Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
<span class="lineNum">      56 </span>            :                           8-byte ptrs:  32 bytes    (including overhead)
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :        Even a request for zero bytes (i.e., malloc(0)) returns a
<span class="lineNum">      59 </span>            :        pointer to something of the minimum allocatable size.
<span class="lineNum">      60 </span>            :        The maximum overhead wastage (i.e., number of extra bytes
<span class="lineNum">      61 </span>            :        allocated than were requested in malloc) is less than or equal
<span class="lineNum">      62 </span>            :        to the minimum size, except for requests &gt;= mmap_threshold that
<span class="lineNum">      63 </span>            :        are serviced via mmap(), where the worst case wastage is about
<span class="lineNum">      64 </span>            :        32 bytes plus the remainder from a system page (the minimal
<span class="lineNum">      65 </span>            :        mmap unit); typically 4096 or 8192 bytes.
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :   Security: static-safe; optionally more or less
<span class="lineNum">      68 </span>            :        The &quot;security&quot; of malloc refers to the ability of malicious
<span class="lineNum">      69 </span>            :        code to accentuate the effects of errors (for example, freeing
<span class="lineNum">      70 </span>            :        space that is not currently malloc'ed or overwriting past the
<span class="lineNum">      71 </span>            :        ends of chunks) in code that calls malloc.  This malloc
<span class="lineNum">      72 </span>            :        guarantees not to modify any memory locations below the base of
<span class="lineNum">      73 </span>            :        heap, i.e., static variables, even in the presence of usage
<span class="lineNum">      74 </span>            :        errors.  The routines additionally detect most improper frees
<span class="lineNum">      75 </span>            :        and reallocs.  All this holds as long as the static bookkeeping
<span class="lineNum">      76 </span>            :        for malloc itself is not corrupted by some other means.  This
<span class="lineNum">      77 </span>            :        is only one aspect of security -- these checks do not, and
<span class="lineNum">      78 </span>            :        cannot, detect all possible programming errors.
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :        If FOOTERS is defined nonzero, then each allocated chunk
<span class="lineNum">      81 </span>            :        carries an additional check word to verify that it was malloced
<span class="lineNum">      82 </span>            :        from its space.  These check words are the same within each
<span class="lineNum">      83 </span>            :        execution of a program using malloc, but differ across
<span class="lineNum">      84 </span>            :        executions, so externally crafted fake chunks cannot be
<span class="lineNum">      85 </span>            :        freed. This improves security by rejecting frees/reallocs that
<span class="lineNum">      86 </span>            :        could corrupt heap memory, in addition to the checks preventing
<span class="lineNum">      87 </span>            :        writes to statics that are always on.  This may further improve
<span class="lineNum">      88 </span>            :        security at the expense of time and space overhead.  (Note that
<span class="lineNum">      89 </span>            :        FOOTERS may also be worth using with MSPACES.)
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :        By default detected errors cause the program to abort (calling
<span class="lineNum">      92 </span>            :        &quot;abort()&quot;). You can override this to instead proceed past
<span class="lineNum">      93 </span>            :        errors by defining PROCEED_ON_ERROR.  In this case, a bad free
<span class="lineNum">      94 </span>            :        has no effect, and a malloc that encounters a bad address
<span class="lineNum">      95 </span>            :        caused by user overwrites will ignore the bad address by
<span class="lineNum">      96 </span>            :        dropping pointers and indices to all known memory. This may
<span class="lineNum">      97 </span>            :        be appropriate for programs that should continue if at all
<span class="lineNum">      98 </span>            :        possible in the face of programming errors, although they may
<span class="lineNum">      99 </span>            :        run out of memory because dropped memory is never reclaimed.
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :        If you don't like either of these options, you can define
<span class="lineNum">     102 </span>            :        CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
<span class="lineNum">     103 </span>            :        else. And if if you are sure that your program using malloc has
<span class="lineNum">     104 </span>            :        no errors or vulnerabilities, you can define INSECURE to 1,
<span class="lineNum">     105 </span>            :        which might (or might not) provide a small performance improvement.
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   Thread-safety: NOT thread-safe unless USE_LOCKS defined
<span class="lineNum">     108 </span>            :        When USE_LOCKS is defined, each public call to malloc, free,
<span class="lineNum">     109 </span>            :        etc is surrounded with either a pthread mutex or a win32
<span class="lineNum">     110 </span>            :        spinlock (depending on WIN32). This is not especially fast, and
<span class="lineNum">     111 </span>            :        can be a major bottleneck.  It is designed only to provide
<span class="lineNum">     112 </span>            :        minimal protection in concurrent environments, and to provide a
<span class="lineNum">     113 </span>            :        basis for extensions.  If you are using malloc in a concurrent
<span class="lineNum">     114 </span>            :        program, consider instead using ptmalloc, which is derived from
<span class="lineNum">     115 </span>            :        a version of this malloc. (See http://www.malloc.de).
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
<span class="lineNum">     118 </span>            :        This malloc can use unix sbrk or any emulation (invoked using
<span class="lineNum">     119 </span>            :        the CALL_MORECORE macro) and/or mmap/munmap or any emulation
<span class="lineNum">     120 </span>            :        (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
<span class="lineNum">     121 </span>            :        memory.  On most unix systems, it tends to work best if both
<span class="lineNum">     122 </span>            :        MORECORE and MMAP are enabled.  On Win32, it uses emulations
<span class="lineNum">     123 </span>            :        based on VirtualAlloc. It also uses common C library functions
<span class="lineNum">     124 </span>            :        like memset.
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   Compliance: I believe it is compliant with the Single Unix Specification
<span class="lineNum">     127 </span>            :        (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
<span class="lineNum">     128 </span>            :        others as well.
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : * Overview of algorithms
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :   This is not the fastest, most space-conserving, most portable, or
<span class="lineNum">     133 </span>            :   most tunable malloc ever written. However it is among the fastest
<span class="lineNum">     134 </span>            :   while also being among the most space-conserving, portable and
<span class="lineNum">     135 </span>            :   tunable.  Consistent balance across these factors results in a good
<span class="lineNum">     136 </span>            :   general-purpose allocator for malloc-intensive programs.
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   In most ways, this malloc is a best-fit allocator. Generally, it
<span class="lineNum">     139 </span>            :   chooses the best-fitting existing chunk for a request, with ties
<span class="lineNum">     140 </span>            :   broken in approximately least-recently-used order. (This strategy
<span class="lineNum">     141 </span>            :   normally maintains low fragmentation.) However, for requests less
<span class="lineNum">     142 </span>            :   than 256bytes, it deviates from best-fit when there is not an
<span class="lineNum">     143 </span>            :   exactly fitting available chunk by preferring to use space adjacent
<span class="lineNum">     144 </span>            :   to that used for the previous small request, as well as by breaking
<span class="lineNum">     145 </span>            :   ties in approximately most-recently-used order. (These enhance
<span class="lineNum">     146 </span>            :   locality of series of small allocations.)  And for very large requests
<span class="lineNum">     147 </span>            :   (&gt;= 256Kb by default), it relies on system memory mapping
<span class="lineNum">     148 </span>            :   facilities, if supported.  (This helps avoid carrying around and
<span class="lineNum">     149 </span>            :   possibly fragmenting memory used only for large chunks.)
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :   All operations (except malloc_stats and mallinfo) have execution
<span class="lineNum">     152 </span>            :   times that are bounded by a constant factor of the number of bits in
<span class="lineNum">     153 </span>            :   a size_t, not counting any clearing in calloc or copying in realloc,
<span class="lineNum">     154 </span>            :   or actions surrounding MORECORE and MMAP that have times
<span class="lineNum">     155 </span>            :   proportional to the number of non-contiguous regions returned by
<span class="lineNum">     156 </span>            :   system allocation routines, which is often just 1.
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :   The implementation is not very modular and seriously overuses
<span class="lineNum">     159 </span>            :   macros. Perhaps someday all C compilers will do as good a job
<span class="lineNum">     160 </span>            :   inlining modular code as can now be done by brute-force expansion,
<span class="lineNum">     161 </span>            :   but now, enough of them seem not to.
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   Some compilers issue a lot of warnings about code that is
<span class="lineNum">     164 </span>            :   dead/unreachable only on some platforms, and also about intentional
<span class="lineNum">     165 </span>            :   uses of negation on unsigned types. All known cases of each can be
<span class="lineNum">     166 </span>            :   ignored.
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :   For a longer but out of date high-level description, see
<span class="lineNum">     169 </span>            :      http://gee.cs.oswego.edu/dl/html/malloc.html
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : * MSPACES
<span class="lineNum">     172 </span>            :   If MSPACES is defined, then in addition to malloc, free, etc.,
<span class="lineNum">     173 </span>            :   this file also defines mspace_malloc, mspace_free, etc. These
<span class="lineNum">     174 </span>            :   are versions of malloc routines that take an &quot;mspace&quot; argument
<span class="lineNum">     175 </span>            :   obtained using create_mspace, to control all internal bookkeeping.
<span class="lineNum">     176 </span>            :   If ONLY_MSPACES is defined, only these versions are compiled.
<span class="lineNum">     177 </span>            :   So if you would like to use this allocator for only some allocations,
<span class="lineNum">     178 </span>            :   and your system malloc for others, you can compile with
<span class="lineNum">     179 </span>            :   ONLY_MSPACES and then do something like...
<span class="lineNum">     180 </span>            :     static mspace mymspace = create_mspace(0,0); // for example
<span class="lineNum">     181 </span>            :     #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :   (Note: If you only need one instance of an mspace, you can instead
<span class="lineNum">     184 </span>            :   use &quot;USE_DL_PREFIX&quot; to relabel the global malloc.)
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :   You can similarly create thread-local allocators by storing
<span class="lineNum">     187 </span>            :   mspaces as thread-locals. For example:
<span class="lineNum">     188 </span>            :     static __thread mspace tlms = 0;
<span class="lineNum">     189 </span>            :     void*  tlmalloc(size_t bytes) {
<span class="lineNum">     190 </span>            :       if (tlms == 0) tlms = create_mspace(0, 0);
<span class="lineNum">     191 </span>            :       return mspace_malloc(tlms, bytes);
<span class="lineNum">     192 </span>            :     }
<span class="lineNum">     193 </span>            :     void  tlfree(void* mem) { mspace_free(tlms, mem); }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   Unless FOOTERS is defined, each mspace is completely independent.
<span class="lineNum">     196 </span>            :   You cannot allocate from one and free to another (although
<span class="lineNum">     197 </span>            :   conformance is only weakly checked, so usage errors are not always
<span class="lineNum">     198 </span>            :   caught). If FOOTERS is defined, then each chunk carries around a tag
<span class="lineNum">     199 </span>            :   indicating its originating mspace, and frees are directed to their
<span class="lineNum">     200 </span>            :   originating spaces.
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :  -------------------------  Compile-time options ---------------------------
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : Be careful in setting #define values for numerical constants of type
<span class="lineNum">     205 </span>            : size_t. On some systems, literal values are not automatically extended
<span class="lineNum">     206 </span>            : to size_t precision unless they are explicitly casted.
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : WIN32                    default: defined if _WIN32 defined
<span class="lineNum">     209 </span>            :   Defining WIN32 sets up defaults for MS environment and compilers.
<span class="lineNum">     210 </span>            :   Otherwise defaults are for unix.
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : MALLOC_ALIGNMENT         default: (size_t)8
<span class="lineNum">     213 </span>            :   Controls the minimum alignment for malloc'ed chunks.  It must be a
<span class="lineNum">     214 </span>            :   power of two and at least 8, even on machines for which smaller
<span class="lineNum">     215 </span>            :   alignments would suffice. It may be defined as larger than this
<span class="lineNum">     216 </span>            :   though. Note however that code and data structures are optimized for
<span class="lineNum">     217 </span>            :   the case of 8-byte alignment.
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : MSPACES                  default: 0 (false)
<span class="lineNum">     220 </span>            :   If true, compile in support for independent allocation spaces.
<span class="lineNum">     221 </span>            :   This is only supported if HAVE_MMAP is true.
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : ONLY_MSPACES             default: 0 (false)
<span class="lineNum">     224 </span>            :   If true, only compile in mspace versions, not regular versions.
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : USE_LOCKS                default: 0 (false)
<span class="lineNum">     227 </span>            :   Causes each call to each public routine to be surrounded with
<span class="lineNum">     228 </span>            :   pthread or WIN32 mutex lock/unlock. (If set true, this can be
<span class="lineNum">     229 </span>            :   overridden on a per-mspace basis for mspace versions.)
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : FOOTERS                  default: 0
<span class="lineNum">     232 </span>            :   If true, provide extra checking and dispatching by placing
<span class="lineNum">     233 </span>            :   information in the footers of allocated chunks. This adds
<span class="lineNum">     234 </span>            :   space and time overhead.
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : INSECURE                 default: 0
<span class="lineNum">     237 </span>            :   If true, omit checks for usage errors and heap space overwrites.
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : USE_DL_PREFIX            default: NOT defined
<span class="lineNum">     240 </span>            :   Causes compiler to prefix all public routines with the string 'dl'.
<span class="lineNum">     241 </span>            :   This can be useful when you only want to use this malloc in one part
<span class="lineNum">     242 </span>            :   of a program, using your regular system malloc elsewhere.
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : ABORT                    default: defined as abort()
<span class="lineNum">     245 </span>            :   Defines how to abort on failed checks.  On most systems, a failed
<span class="lineNum">     246 </span>            :   check cannot die with an &quot;assert&quot; or even print an informative
<span class="lineNum">     247 </span>            :   message, because the underlying print routines in turn call malloc,
<span class="lineNum">     248 </span>            :   which will fail again.  Generally, the best policy is to simply call
<span class="lineNum">     249 </span>            :   abort(). It's not very useful to do more than this because many
<span class="lineNum">     250 </span>            :   errors due to overwriting will show up as address faults (null, odd
<span class="lineNum">     251 </span>            :   addresses etc) rather than malloc-triggered checks, so will also
<span class="lineNum">     252 </span>            :   abort.  Also, most compilers know that abort() does not return, so
<span class="lineNum">     253 </span>            :   can better optimize code conditionally calling it.
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : PROCEED_ON_ERROR           default: defined as 0 (false)
<span class="lineNum">     256 </span>            :   Controls whether detected bad addresses cause them to bypassed
<span class="lineNum">     257 </span>            :   rather than aborting. If set, detected bad arguments to free and
<span class="lineNum">     258 </span>            :   realloc are ignored. And all bookkeeping information is zeroed out
<span class="lineNum">     259 </span>            :   upon a detected overwrite of freed heap space, thus losing the
<span class="lineNum">     260 </span>            :   ability to ever return it from malloc again, but enabling the
<span class="lineNum">     261 </span>            :   application to proceed. If PROCEED_ON_ERROR is defined, the
<span class="lineNum">     262 </span>            :   static variable malloc_corruption_error_count is compiled in
<span class="lineNum">     263 </span>            :   and can be examined to see if errors have occurred. This option
<span class="lineNum">     264 </span>            :   generates slower code than the default abort policy.
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : DEBUG                    default: NOT defined
<span class="lineNum">     267 </span>            :   The DEBUG setting is mainly intended for people trying to modify
<span class="lineNum">     268 </span>            :   this code or diagnose problems when porting to new platforms.
<span class="lineNum">     269 </span>            :   However, it may also be able to better isolate user errors than just
<span class="lineNum">     270 </span>            :   using runtime checks.  The assertions in the check routines spell
<span class="lineNum">     271 </span>            :   out in more detail the assumptions and invariants underlying the
<span class="lineNum">     272 </span>            :   algorithms.  The checking is fairly extensive, and will slow down
<span class="lineNum">     273 </span>            :   execution noticeably. Calling malloc_stats or mallinfo with DEBUG
<span class="lineNum">     274 </span>            :   set will attempt to check every non-mmapped allocated and free chunk
<span class="lineNum">     275 </span>            :   in the course of computing the summaries.
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
<span class="lineNum">     278 </span>            :   Debugging assertion failures can be nearly impossible if your
<span class="lineNum">     279 </span>            :   version of the assert macro causes malloc to be called, which will
<span class="lineNum">     280 </span>            :   lead to a cascade of further failures, blowing the runtime stack.
<span class="lineNum">     281 </span>            :   ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
<span class="lineNum">     282 </span>            :   which will usually make debugging easier.
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
<span class="lineNum">     285 </span>            :   The action to take before &quot;return 0&quot; when malloc fails to be able to
<span class="lineNum">     286 </span>            :   return memory because there is none available.
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
<span class="lineNum">     289 </span>            :   True if this system supports sbrk or an emulation of it.
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : MORECORE                  default: sbrk
<span class="lineNum">     292 </span>            :   The name of the sbrk-style system routine to call to obtain more
<span class="lineNum">     293 </span>            :   memory.  See below for guidance on writing custom MORECORE
<span class="lineNum">     294 </span>            :   functions. The type of the argument to sbrk/MORECORE varies across
<span class="lineNum">     295 </span>            :   systems.  It cannot be size_t, because it supports negative
<span class="lineNum">     296 </span>            :   arguments, so it is normally the signed type of the same width as
<span class="lineNum">     297 </span>            :   size_t (sometimes declared as &quot;intptr_t&quot;).  It doesn't much matter
<span class="lineNum">     298 </span>            :   though. Internally, we only call it with arguments less than half
<span class="lineNum">     299 </span>            :   the max value of a size_t, which should work across all reasonable
<span class="lineNum">     300 </span>            :   possibilities, although sometimes generating compiler warnings.  See
<span class="lineNum">     301 </span>            :   near the end of this file for guidelines for creating a custom
<span class="lineNum">     302 </span>            :   version of MORECORE.
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : MORECORE_CONTIGUOUS       default: 1 (true)
<span class="lineNum">     305 </span>            :   If true, take advantage of fact that consecutive calls to MORECORE
<span class="lineNum">     306 </span>            :   with positive arguments always return contiguous increasing
<span class="lineNum">     307 </span>            :   addresses.  This is true of unix sbrk. It does not hurt too much to
<span class="lineNum">     308 </span>            :   set it true anyway, since malloc copes with non-contiguities.
<span class="lineNum">     309 </span>            :   Setting it false when definitely non-contiguous saves time
<span class="lineNum">     310 </span>            :   and possibly wasted space it would take to discover this though.
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : MORECORE_CANNOT_TRIM      default: NOT defined
<span class="lineNum">     313 </span>            :   True if MORECORE cannot release space back to the system when given
<span class="lineNum">     314 </span>            :   negative arguments. This is generally necessary only if you are
<span class="lineNum">     315 </span>            :   using a hand-crafted MORECORE function that cannot handle negative
<span class="lineNum">     316 </span>            :   arguments.
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : HAVE_MMAP                 default: 1 (true)
<span class="lineNum">     319 </span>            :   True if this system supports mmap or an emulation of it.  If so, and
<span class="lineNum">     320 </span>            :   HAVE_MORECORE is not true, MMAP is used for all system
<span class="lineNum">     321 </span>            :   allocation. If set and HAVE_MORECORE is true as well, MMAP is
<span class="lineNum">     322 </span>            :   primarily used to directly allocate very large blocks. It is also
<span class="lineNum">     323 </span>            :   used as a backup strategy in cases where MORECORE fails to provide
<span class="lineNum">     324 </span>            :   space from system. Note: A single call to MUNMAP is assumed to be
<span class="lineNum">     325 </span>            :   able to unmap memory that may have be allocated using multiple calls
<span class="lineNum">     326 </span>            :   to MMAP, so long as they are adjacent.
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : HAVE_MREMAP               default: 1 on linux, else 0
<span class="lineNum">     329 </span>            :   If true realloc() uses mremap() to re-allocate large blocks and
<span class="lineNum">     330 </span>            :   extend or shrink allocation spaces.
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : MMAP_CLEARS               default: 1 on unix
<span class="lineNum">     333 </span>            :   True if mmap clears memory so calloc doesn't need to. This is true
<span class="lineNum">     334 </span>            :   for standard unix mmap using /dev/zero.
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : USE_BUILTIN_FFS            default: 0 (i.e., not used)
<span class="lineNum">     337 </span>            :   Causes malloc to use the builtin ffs() function to compute indices.
<span class="lineNum">     338 </span>            :   Some compilers may recognize and intrinsify ffs to be faster than the
<span class="lineNum">     339 </span>            :   supplied C version. Also, the case of x86 using gcc is special-cased
<span class="lineNum">     340 </span>            :   to an asm instruction, so is already as fast as it can be, and so
<span class="lineNum">     341 </span>            :   this setting has no effect. (On most x86s, the asm version is only
<span class="lineNum">     342 </span>            :   slightly faster than the C version.)
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : malloc_getpagesize         default: derive from system includes, or 4096.
<span class="lineNum">     345 </span>            :   The system page size. To the extent possible, this malloc manages
<span class="lineNum">     346 </span>            :   memory from the system in page-size units.  This may be (and
<span class="lineNum">     347 </span>            :   usually is) a function rather than a constant. This is ignored
<span class="lineNum">     348 </span>            :   if WIN32, where page size is determined using getSystemInfo during
<span class="lineNum">     349 </span>            :   initialization.
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : USE_DEV_RANDOM             default: 0 (i.e., not used)
<span class="lineNum">     352 </span>            :   Causes malloc to use /dev/random to initialize secure magic seed for
<span class="lineNum">     353 </span>            :   stamping footers. Otherwise, the current time is used.
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : NO_MALLINFO                default: 0
<span class="lineNum">     356 </span>            :   If defined, don't compile &quot;mallinfo&quot;. This can be a simple way
<span class="lineNum">     357 </span>            :   of dealing with mismatches between system declarations and
<span class="lineNum">     358 </span>            :   those in this file.
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : MALLINFO_FIELD_TYPE        default: size_t
<span class="lineNum">     361 </span>            :   The type of the fields in the mallinfo struct. This was originally
<span class="lineNum">     362 </span>            :   defined as &quot;int&quot; in SVID etc, but is more usefully defined as
<span class="lineNum">     363 </span>            :   size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : REALLOC_ZERO_BYTES_FREES    default: not defined
<span class="lineNum">     366 </span>            :   This should be set if a call to realloc with zero bytes should 
<span class="lineNum">     367 </span>            :   be the same as a call to free. Some people think it should. Otherwise, 
<span class="lineNum">     368 </span>            :   since this malloc returns a unique pointer for malloc(0), so does 
<span class="lineNum">     369 </span>            :   realloc(p, 0).
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
<span class="lineNum">     372 </span>            : LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
<span class="lineNum">     373 </span>            : LACKS_STDLIB_H                default: NOT defined unless on WIN32
<span class="lineNum">     374 </span>            :   Define these if your system does not have these header files.
<span class="lineNum">     375 </span>            :   You might need to manually insert some of the declarations they provide.
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
<span class="lineNum">     378 </span>            :                                 system_info.dwAllocationGranularity in WIN32,
<span class="lineNum">     379 </span>            :                                 otherwise 64K.
<span class="lineNum">     380 </span>            :       Also settable using mallopt(M_GRANULARITY, x)
<span class="lineNum">     381 </span>            :   The unit for allocating and deallocating memory from the system.  On
<span class="lineNum">     382 </span>            :   most systems with contiguous MORECORE, there is no reason to
<span class="lineNum">     383 </span>            :   make this more than a page. However, systems with MMAP tend to
<span class="lineNum">     384 </span>            :   either require or encourage larger granularities.  You can increase
<span class="lineNum">     385 </span>            :   this value to prevent system allocation functions to be called so
<span class="lineNum">     386 </span>            :   often, especially if they are slow.  The value must be at least one
<span class="lineNum">     387 </span>            :   page and must be a power of two.  Setting to 0 causes initialization
<span class="lineNum">     388 </span>            :   to either page size or win32 region size.  (Note: In previous
<span class="lineNum">     389 </span>            :   versions of malloc, the equivalent of this option was called
<span class="lineNum">     390 </span>            :   &quot;TOP_PAD&quot;)
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : DEFAULT_TRIM_THRESHOLD    default: 2MB
<span class="lineNum">     393 </span>            :       Also settable using mallopt(M_TRIM_THRESHOLD, x)
<span class="lineNum">     394 </span>            :   The maximum amount of unused top-most memory to keep before
<span class="lineNum">     395 </span>            :   releasing via malloc_trim in free().  Automatic trimming is mainly
<span class="lineNum">     396 </span>            :   useful in long-lived programs using contiguous MORECORE.  Because
<span class="lineNum">     397 </span>            :   trimming via sbrk can be slow on some systems, and can sometimes be
<span class="lineNum">     398 </span>            :   wasteful (in cases where programs immediately afterward allocate
<span class="lineNum">     399 </span>            :   more large chunks) the value should be high enough so that your
<span class="lineNum">     400 </span>            :   overall system performance would improve by releasing this much
<span class="lineNum">     401 </span>            :   memory.  As a rough guide, you might set to a value close to the
<span class="lineNum">     402 </span>            :   average size of a process (program) running on your system.
<span class="lineNum">     403 </span>            :   Releasing this much memory would allow such a process to run in
<span class="lineNum">     404 </span>            :   memory.  Generally, it is worth tuning trim thresholds when a
<span class="lineNum">     405 </span>            :   program undergoes phases where several large chunks are allocated
<span class="lineNum">     406 </span>            :   and released in ways that can reuse each other's storage, perhaps
<span class="lineNum">     407 </span>            :   mixed with phases where there are no such chunks at all. The trim
<span class="lineNum">     408 </span>            :   value must be greater than page size to have any useful effect.  To
<span class="lineNum">     409 </span>            :   disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
<span class="lineNum">     410 </span>            :   some people use of mallocing a huge space and then freeing it at
<span class="lineNum">     411 </span>            :   program startup, in an attempt to reserve system memory, doesn't
<span class="lineNum">     412 </span>            :   have the intended effect under automatic trimming, since that memory
<span class="lineNum">     413 </span>            :   will immediately be returned to the system.
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : DEFAULT_MMAP_THRESHOLD       default: 256K
<span class="lineNum">     416 </span>            :       Also settable using mallopt(M_MMAP_THRESHOLD, x)
<span class="lineNum">     417 </span>            :   The request size threshold for using MMAP to directly service a
<span class="lineNum">     418 </span>            :   request. Requests of at least this size that cannot be allocated
<span class="lineNum">     419 </span>            :   using already-existing space will be serviced via mmap.  (If enough
<span class="lineNum">     420 </span>            :   normal freed space already exists it is used instead.)  Using mmap
<span class="lineNum">     421 </span>            :   segregates relatively large chunks of memory so that they can be
<span class="lineNum">     422 </span>            :   individually obtained and released from the host system. A request
<span class="lineNum">     423 </span>            :   serviced through mmap is never reused by any other request (at least
<span class="lineNum">     424 </span>            :   not directly; the system may just so happen to remap successive
<span class="lineNum">     425 </span>            :   requests to the same locations).  Segregating space in this way has
<span class="lineNum">     426 </span>            :   the benefits that: Mmapped space can always be individually released
<span class="lineNum">     427 </span>            :   back to the system, which helps keep the system level memory demands
<span class="lineNum">     428 </span>            :   of a long-lived program low.  Also, mapped memory doesn't become
<span class="lineNum">     429 </span>            :   `locked' between other chunks, as can happen with normally allocated
<span class="lineNum">     430 </span>            :   chunks, which means that even trimming via malloc_trim would not
<span class="lineNum">     431 </span>            :   release them.  However, it has the disadvantage that the space
<span class="lineNum">     432 </span>            :   cannot be reclaimed, consolidated, and then used to service later
<span class="lineNum">     433 </span>            :   requests, as happens with normal chunks.  The advantages of mmap
<span class="lineNum">     434 </span>            :   nearly always outweigh disadvantages for &quot;large&quot; chunks, but the
<span class="lineNum">     435 </span>            :   value of &quot;large&quot; may vary across systems.  The default is an
<span class="lineNum">     436 </span>            :   empirically derived value that works well in most systems. You can
<span class="lineNum">     437 </span>            :   disable mmap by setting to MAX_SIZE_T.
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : */
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : #ifndef WIN32
<span class="lineNum">     442 </span>            : #ifdef _WIN32
<span class="lineNum">     443 </span>            : #define WIN32 1
<span class="lineNum">     444 </span>            : #endif  /* _WIN32 */
<span class="lineNum">     445 </span>            : #endif  /* WIN32 */
<span class="lineNum">     446 </span>            : #ifdef WIN32
<span class="lineNum">     447 </span>            : #define WIN32_LEAN_AND_MEAN
<span class="lineNum">     448 </span>            : #include &lt;windows.h&gt;
<span class="lineNum">     449 </span>            : #define HAVE_MMAP 1
<span class="lineNum">     450 </span>            : #define HAVE_MORECORE 0
<span class="lineNum">     451 </span>            : #define LACKS_UNISTD_H
<span class="lineNum">     452 </span>            : #define LACKS_SYS_PARAM_H
<span class="lineNum">     453 </span>            : #define LACKS_SYS_MMAN_H
<span class="lineNum">     454 </span>            : #define LACKS_STRING_H
<span class="lineNum">     455 </span>            : #define LACKS_STRINGS_H
<span class="lineNum">     456 </span>            : #define LACKS_SYS_TYPES_H
<span class="lineNum">     457 </span>            : #define LACKS_ERRNO_H
<span class="lineNum">     458 </span>            : #define MALLOC_FAILURE_ACTION
<span class="lineNum">     459 </span>            : #define MMAP_CLEARS 0 /* WINCE and some others apparently don't clear */
<span class="lineNum">     460 </span>            : #endif  /* WIN32 */
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : #ifdef __OS2__
<span class="lineNum">     463 </span>            : #define INCL_DOS
<span class="lineNum">     464 </span>            : #include &lt;os2.h&gt;
<span class="lineNum">     465 </span>            : #define HAVE_MMAP 1
<span class="lineNum">     466 </span>            : #define HAVE_MORECORE 0
<span class="lineNum">     467 </span>            : #define LACKS_SYS_MMAN_H
<span class="lineNum">     468 </span>            : #endif  /* __OS2__ */
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : #if defined(DARWIN) || defined(_DARWIN)
<span class="lineNum">     471 </span>            : /* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
<span class="lineNum">     472 </span>            : #ifndef HAVE_MORECORE
<span class="lineNum">     473 </span>            : #define HAVE_MORECORE 0
<span class="lineNum">     474 </span>            : #define HAVE_MMAP 1
<span class="lineNum">     475 </span>            : #endif  /* HAVE_MORECORE */
<span class="lineNum">     476 </span>            : #endif  /* DARWIN */
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : #ifndef LACKS_SYS_TYPES_H
<span class="lineNum">     479 </span>            : #include &lt;sys/types.h&gt;  /* For size_t */
<span class="lineNum">     480 </span>            : #endif  /* LACKS_SYS_TYPES_H */
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : /* The maximum possible size_t value has all bits set */
<span class="lineNum">     483 </span>            : #define MAX_SIZE_T           (~(size_t)0)
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : #ifndef ONLY_MSPACES
<span class="lineNum">     486 </span>            : #define ONLY_MSPACES 0
<span class="lineNum">     487 </span>            : #endif  /* ONLY_MSPACES */
<span class="lineNum">     488 </span>            : #ifndef MSPACES
<span class="lineNum">     489 </span>            : #if ONLY_MSPACES
<span class="lineNum">     490 </span>            : #define MSPACES 1
<span class="lineNum">     491 </span>            : #else   /* ONLY_MSPACES */
<span class="lineNum">     492 </span>            : #define MSPACES 0
<span class="lineNum">     493 </span>            : #endif  /* ONLY_MSPACES */
<span class="lineNum">     494 </span>            : #endif  /* MSPACES */
<span class="lineNum">     495 </span>            : #ifndef MALLOC_ALIGNMENT
<span class="lineNum">     496 </span>            : #define MALLOC_ALIGNMENT ((size_t)8U)
<span class="lineNum">     497 </span>            : #endif  /* MALLOC_ALIGNMENT */
<span class="lineNum">     498 </span>            : #ifndef FOOTERS
<span class="lineNum">     499 </span>            : #define FOOTERS 0
<span class="lineNum">     500 </span>            : #endif  /* FOOTERS */
<span class="lineNum">     501 </span>            : #ifndef ABORT
<span class="lineNum">     502 </span>            : #define ABORT  abort()
<span class="lineNum">     503 </span>            : #endif  /* ABORT */
<span class="lineNum">     504 </span>            : #ifndef ABORT_ON_ASSERT_FAILURE
<span class="lineNum">     505 </span>            : #define ABORT_ON_ASSERT_FAILURE 1
<span class="lineNum">     506 </span>            : #endif  /* ABORT_ON_ASSERT_FAILURE */
<span class="lineNum">     507 </span>            : #ifndef PROCEED_ON_ERROR
<span class="lineNum">     508 </span>            : #define PROCEED_ON_ERROR 0
<span class="lineNum">     509 </span>            : #endif  /* PROCEED_ON_ERROR */
<span class="lineNum">     510 </span>            : #ifndef USE_LOCKS
<span class="lineNum">     511 </span>            : #define USE_LOCKS 0
<span class="lineNum">     512 </span>            : #endif  /* USE_LOCKS */
<span class="lineNum">     513 </span>            : #ifndef INSECURE
<span class="lineNum">     514 </span>            : #define INSECURE 0
<span class="lineNum">     515 </span>            : #endif  /* INSECURE */
<span class="lineNum">     516 </span>            : #ifndef HAVE_MMAP
<span class="lineNum">     517 </span>            : #define HAVE_MMAP 1
<span class="lineNum">     518 </span>            : #endif  /* HAVE_MMAP */
<span class="lineNum">     519 </span>            : #ifndef MMAP_CLEARS
<span class="lineNum">     520 </span>            : #define MMAP_CLEARS 1
<span class="lineNum">     521 </span>            : #endif  /* MMAP_CLEARS */
<span class="lineNum">     522 </span>            : #ifndef HAVE_MREMAP
<span class="lineNum">     523 </span>            : #ifdef linux
<span class="lineNum">     524 </span>            : #define HAVE_MREMAP 1
<span class="lineNum">     525 </span>            : #else   /* linux */
<span class="lineNum">     526 </span>            : #define HAVE_MREMAP 0
<span class="lineNum">     527 </span>            : #endif  /* linux */
<span class="lineNum">     528 </span>            : #endif  /* HAVE_MREMAP */
<span class="lineNum">     529 </span>            : #ifndef MALLOC_FAILURE_ACTION
<span class="lineNum">     530 </span>            : #define MALLOC_FAILURE_ACTION  errno = ENOMEM;
<span class="lineNum">     531 </span>            : #endif  /* MALLOC_FAILURE_ACTION */
<span class="lineNum">     532 </span>            : #ifndef HAVE_MORECORE
<span class="lineNum">     533 </span>            : #if ONLY_MSPACES
<span class="lineNum">     534 </span>            : #define HAVE_MORECORE 0
<span class="lineNum">     535 </span>            : #else   /* ONLY_MSPACES */
<span class="lineNum">     536 </span>            : #define HAVE_MORECORE 1
<span class="lineNum">     537 </span>            : #endif  /* ONLY_MSPACES */
<span class="lineNum">     538 </span>            : #endif  /* HAVE_MORECORE */
<span class="lineNum">     539 </span>            : #if !HAVE_MORECORE
<span class="lineNum">     540 </span>            : #define MORECORE_CONTIGUOUS 0
<span class="lineNum">     541 </span>            : #else   /* !HAVE_MORECORE */
<span class="lineNum">     542 </span>            : #ifndef MORECORE
<span class="lineNum">     543 </span>            : #define MORECORE sbrk
<span class="lineNum">     544 </span>            : #endif  /* MORECORE */
<span class="lineNum">     545 </span>            : #ifndef MORECORE_CONTIGUOUS
<span class="lineNum">     546 </span>            : #define MORECORE_CONTIGUOUS 1
<span class="lineNum">     547 </span>            : #endif  /* MORECORE_CONTIGUOUS */
<span class="lineNum">     548 </span>            : #endif  /* HAVE_MORECORE */
<span class="lineNum">     549 </span>            : #ifndef DEFAULT_GRANULARITY
<span class="lineNum">     550 </span>            : #if MORECORE_CONTIGUOUS
<span class="lineNum">     551 </span>            : #define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
<span class="lineNum">     552 </span>            : #else   /* MORECORE_CONTIGUOUS */
<span class="lineNum">     553 </span>            : #define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
<span class="lineNum">     554 </span>            : #endif  /* MORECORE_CONTIGUOUS */
<span class="lineNum">     555 </span>            : #endif  /* DEFAULT_GRANULARITY */
<span class="lineNum">     556 </span>            : #ifndef DEFAULT_TRIM_THRESHOLD
<span class="lineNum">     557 </span>            : #ifndef MORECORE_CANNOT_TRIM
<span class="lineNum">     558 </span>            : #define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
<span class="lineNum">     559 </span>            : #else   /* MORECORE_CANNOT_TRIM */
<span class="lineNum">     560 </span>            : #define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
<span class="lineNum">     561 </span>            : #endif  /* MORECORE_CANNOT_TRIM */
<span class="lineNum">     562 </span>            : #endif  /* DEFAULT_TRIM_THRESHOLD */
<span class="lineNum">     563 </span>            : #ifndef DEFAULT_MMAP_THRESHOLD
<span class="lineNum">     564 </span>            : #if HAVE_MMAP
<span class="lineNum">     565 </span>            : #define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
<span class="lineNum">     566 </span>            : #else   /* HAVE_MMAP */
<span class="lineNum">     567 </span>            : #define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
<span class="lineNum">     568 </span>            : #endif  /* HAVE_MMAP */
<span class="lineNum">     569 </span>            : #endif  /* DEFAULT_MMAP_THRESHOLD */
<span class="lineNum">     570 </span>            : #ifndef USE_BUILTIN_FFS
<span class="lineNum">     571 </span>            : #define USE_BUILTIN_FFS 0
<span class="lineNum">     572 </span>            : #endif  /* USE_BUILTIN_FFS */
<span class="lineNum">     573 </span>            : #ifndef USE_DEV_RANDOM
<span class="lineNum">     574 </span>            : #define USE_DEV_RANDOM 0
<span class="lineNum">     575 </span>            : #endif  /* USE_DEV_RANDOM */
<span class="lineNum">     576 </span>            : #ifndef NO_MALLINFO
<span class="lineNum">     577 </span>            : #define NO_MALLINFO 0
<span class="lineNum">     578 </span>            : #endif  /* NO_MALLINFO */
<span class="lineNum">     579 </span>            : #ifndef MALLINFO_FIELD_TYPE
<span class="lineNum">     580 </span>            : #define MALLINFO_FIELD_TYPE size_t
<span class="lineNum">     581 </span>            : #endif  /* MALLINFO_FIELD_TYPE */
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : /*
<span class="lineNum">     584 </span>            :   mallopt tuning options.  SVID/XPG defines four standard parameter
<span class="lineNum">     585 </span>            :   numbers for mallopt, normally defined in malloc.h.  None of these
<span class="lineNum">     586 </span>            :   are used in this malloc, so setting them has no effect. But this
<span class="lineNum">     587 </span>            :   malloc does support the following options.
<span class="lineNum">     588 </span>            : */
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : #define M_TRIM_THRESHOLD     (-1)
<span class="lineNum">     591 </span>            : #define M_GRANULARITY        (-2)
<span class="lineNum">     592 </span>            : #define M_MMAP_THRESHOLD     (-3)
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            : /* ------------------------ Mallinfo declarations ------------------------ */
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            : #if !NO_MALLINFO
<span class="lineNum">     597 </span>            : /*
<span class="lineNum">     598 </span>            :   This version of malloc supports the standard SVID/XPG mallinfo
<span class="lineNum">     599 </span>            :   routine that returns a struct containing usage properties and
<span class="lineNum">     600 </span>            :   statistics. It should work on any system that has a
<span class="lineNum">     601 </span>            :   /usr/include/malloc.h defining struct mallinfo.  The main
<span class="lineNum">     602 </span>            :   declaration needed is the mallinfo struct that is returned (by-copy)
<span class="lineNum">     603 </span>            :   by mallinfo().  The malloinfo struct contains a bunch of fields that
<span class="lineNum">     604 </span>            :   are not even meaningful in this version of malloc.  These fields are
<span class="lineNum">     605 </span>            :   are instead filled by mallinfo() with other numbers that might be of
<span class="lineNum">     606 </span>            :   interest.
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :   HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
<span class="lineNum">     609 </span>            :   /usr/include/malloc.h file that includes a declaration of struct
<span class="lineNum">     610 </span>            :   mallinfo.  If so, it is included; else a compliant version is
<span class="lineNum">     611 </span>            :   declared below.  These must be precisely the same for mallinfo() to
<span class="lineNum">     612 </span>            :   work.  The original SVID version of this struct, defined on most
<span class="lineNum">     613 </span>            :   systems with mallinfo, declares all fields as ints. But some others
<span class="lineNum">     614 </span>            :   define as unsigned long. If your system defines the fields using a
<span class="lineNum">     615 </span>            :   type of different width than listed here, you MUST #include your
<span class="lineNum">     616 </span>            :   system version and #define HAVE_USR_INCLUDE_MALLOC_H.
<span class="lineNum">     617 </span>            : */
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : /* #define HAVE_USR_INCLUDE_MALLOC_H */
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : #ifdef HAVE_USR_INCLUDE_MALLOC_H
<span class="lineNum">     622 </span>            : #include &quot;/usr/include/malloc.h&quot;
<span class="lineNum">     623 </span>            : #else /* HAVE_USR_INCLUDE_MALLOC_H */
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : /* HP-UX's stdlib.h redefines mallinfo unless _STRUCT_MALLINFO is defined */
<span class="lineNum">     626 </span>            : #define _STRUCT_MALLINFO
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            : struct mallinfo {
<span class="lineNum">     629 </span>            :   MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
<span class="lineNum">     630 </span>            :   MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
<span class="lineNum">     631 </span>            :   MALLINFO_FIELD_TYPE smblks;   /* always 0 */
<span class="lineNum">     632 </span>            :   MALLINFO_FIELD_TYPE hblks;    /* always 0 */
<span class="lineNum">     633 </span>            :   MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
<span class="lineNum">     634 </span>            :   MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
<span class="lineNum">     635 </span>            :   MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
<span class="lineNum">     636 </span>            :   MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
<span class="lineNum">     637 </span>            :   MALLINFO_FIELD_TYPE fordblks; /* total free space */
<span class="lineNum">     638 </span>            :   MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
<span class="lineNum">     639 </span>            : };
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : #endif /* HAVE_USR_INCLUDE_MALLOC_H */
<span class="lineNum">     642 </span>            : #endif /* NO_MALLINFO */
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : #ifdef __cplusplus
<span class="lineNum">     645 </span>            : extern &quot;C&quot; {
<span class="lineNum">     646 </span>            : #endif /* __cplusplus */
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : #if !ONLY_MSPACES
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : /* ------------------- Declarations of public routines ------------------- */
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : #ifndef USE_DL_PREFIX
<span class="lineNum">     653 </span>            : #define dlcalloc               calloc
<span class="lineNum">     654 </span>            : #define dlfree                 free
<span class="lineNum">     655 </span>            : #define dlmalloc               malloc
<span class="lineNum">     656 </span>            : #define dlmemalign             memalign
<span class="lineNum">     657 </span>            : #define dlrealloc              realloc
<span class="lineNum">     658 </span>            : #define dlvalloc               valloc
<span class="lineNum">     659 </span>            : #define dlpvalloc              pvalloc
<span class="lineNum">     660 </span>            : #define dlmallinfo             mallinfo
<span class="lineNum">     661 </span>            : #define dlmallopt              mallopt
<span class="lineNum">     662 </span>            : #define dlmalloc_trim          malloc_trim
<span class="lineNum">     663 </span>            : #define dlmalloc_stats         malloc_stats
<span class="lineNum">     664 </span>            : #define dlmalloc_usable_size   malloc_usable_size
<span class="lineNum">     665 </span>            : #define dlmalloc_footprint     malloc_footprint
<span class="lineNum">     666 </span>            : #define dlmalloc_max_footprint malloc_max_footprint
<span class="lineNum">     667 </span>            : #define dlindependent_calloc   independent_calloc
<span class="lineNum">     668 </span>            : #define dlindependent_comalloc independent_comalloc
<span class="lineNum">     669 </span>            : #endif /* USE_DL_PREFIX */
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : /*
<span class="lineNum">     673 </span>            :   malloc(size_t n)
<span class="lineNum">     674 </span>            :   Returns a pointer to a newly allocated chunk of at least n bytes, or
<span class="lineNum">     675 </span>            :   null if no space is available, in which case errno is set to ENOMEM
<span class="lineNum">     676 </span>            :   on ANSI C systems.
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   If n is zero, malloc returns a minimum-sized chunk. (The minimum
<span class="lineNum">     679 </span>            :   size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
<span class="lineNum">     680 </span>            :   systems.)  Note that size_t is an unsigned type, so calls with
<span class="lineNum">     681 </span>            :   arguments that would be negative if signed are interpreted as
<span class="lineNum">     682 </span>            :   requests for huge amounts of space, which will often fail. The
<span class="lineNum">     683 </span>            :   maximum supported value of n differs across systems, but is in all
<span class="lineNum">     684 </span>            :   cases less than the maximum representable value of a size_t.
<span class="lineNum">     685 </span>            : */
<span class="lineNum">     686 </span>            : void* dlmalloc(size_t);
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            : /*
<span class="lineNum">     689 </span>            :   free(void* p)
<span class="lineNum">     690 </span>            :   Releases the chunk of memory pointed to by p, that had been previously
<span class="lineNum">     691 </span>            :   allocated using malloc or a related routine such as realloc.
<span class="lineNum">     692 </span>            :   It has no effect if p is null. If p was not malloced or already
<span class="lineNum">     693 </span>            :   freed, free(p) will by default cause the current program to abort.
<span class="lineNum">     694 </span>            : */
<span class="lineNum">     695 </span>            : void  dlfree(void*);
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            : /*
<span class="lineNum">     698 </span>            :   calloc(size_t n_elements, size_t element_size);
<span class="lineNum">     699 </span>            :   Returns a pointer to n_elements * element_size bytes, with all locations
<span class="lineNum">     700 </span>            :   set to zero.
<span class="lineNum">     701 </span>            : */
<span class="lineNum">     702 </span>            : void* dlcalloc(size_t, size_t);
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : /*
<span class="lineNum">     705 </span>            :   realloc(void* p, size_t n)
<span class="lineNum">     706 </span>            :   Returns a pointer to a chunk of size n that contains the same data
<span class="lineNum">     707 </span>            :   as does chunk p up to the minimum of (n, p's size) bytes, or null
<span class="lineNum">     708 </span>            :   if no space is available.
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :   The returned pointer may or may not be the same as p. The algorithm
<span class="lineNum">     711 </span>            :   prefers extending p in most cases when possible, otherwise it
<span class="lineNum">     712 </span>            :   employs the equivalent of a malloc-copy-free sequence.
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   If p is null, realloc is equivalent to malloc.
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   If space is not available, realloc returns null, errno is set (if on
<span class="lineNum">     717 </span>            :   ANSI) and p is NOT freed.
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   if n is for fewer bytes than already held by p, the newly unused
<span class="lineNum">     720 </span>            :   space is lopped off and freed if possible.  realloc with a size
<span class="lineNum">     721 </span>            :   argument of zero (re)allocates a minimum-sized chunk.
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   The old unix realloc convention of allowing the last-free'd chunk
<span class="lineNum">     724 </span>            :   to be used as an argument to realloc is not supported.
<span class="lineNum">     725 </span>            : */
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : void* dlrealloc(void*, size_t);
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : /*
<span class="lineNum">     730 </span>            :   memalign(size_t alignment, size_t n);
<span class="lineNum">     731 </span>            :   Returns a pointer to a newly allocated chunk of n bytes, aligned
<span class="lineNum">     732 </span>            :   in accord with the alignment argument.
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :   The alignment argument should be a power of two. If the argument is
<span class="lineNum">     735 </span>            :   not a power of two, the nearest greater power is used.
<span class="lineNum">     736 </span>            :   8-byte alignment is guaranteed by normal malloc calls, so don't
<span class="lineNum">     737 </span>            :   bother calling memalign with an argument of 8 or less.
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   Overreliance on memalign is a sure way to fragment space.
<span class="lineNum">     740 </span>            : */
<span class="lineNum">     741 </span>            : void* dlmemalign(size_t, size_t);
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : /*
<span class="lineNum">     744 </span>            :   valloc(size_t n);
<span class="lineNum">     745 </span>            :   Equivalent to memalign(pagesize, n), where pagesize is the page
<span class="lineNum">     746 </span>            :   size of the system. If the pagesize is unknown, 4096 is used.
<span class="lineNum">     747 </span>            : */
<span class="lineNum">     748 </span>            : void* dlvalloc(size_t);
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : /*
<span class="lineNum">     751 </span>            :   mallopt(int parameter_number, int parameter_value)
<span class="lineNum">     752 </span>            :   Sets tunable parameters The format is to provide a
<span class="lineNum">     753 </span>            :   (parameter-number, parameter-value) pair.  mallopt then sets the
<span class="lineNum">     754 </span>            :   corresponding parameter to the argument value if it can (i.e., so
<span class="lineNum">     755 </span>            :   long as the value is meaningful), and returns 1 if successful else
<span class="lineNum">     756 </span>            :   0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,
<span class="lineNum">     757 </span>            :   normally defined in malloc.h.  None of these are use in this malloc,
<span class="lineNum">     758 </span>            :   so setting them has no effect. But this malloc also supports other
<span class="lineNum">     759 </span>            :   options in mallopt. See below for details.  Briefly, supported
<span class="lineNum">     760 </span>            :   parameters are as follows (listed defaults are for &quot;typical&quot;
<span class="lineNum">     761 </span>            :   configurations).
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   Symbol            param #  default    allowed param values
<span class="lineNum">     764 </span>            :   M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)
<span class="lineNum">     765 </span>            :   M_GRANULARITY        -2     page size   any power of 2 &gt;= page size
<span class="lineNum">     766 </span>            :   M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
<span class="lineNum">     767 </span>            : */
<span class="lineNum">     768 </span>            : int dlmallopt(int, int);
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : /*
<span class="lineNum">     771 </span>            :   malloc_footprint();
<span class="lineNum">     772 </span>            :   Returns the number of bytes obtained from the system.  The total
<span class="lineNum">     773 </span>            :   number of bytes allocated by malloc, realloc etc., is less than this
<span class="lineNum">     774 </span>            :   value. Unlike mallinfo, this function returns only a precomputed
<span class="lineNum">     775 </span>            :   result, so can be called frequently to monitor memory consumption.
<span class="lineNum">     776 </span>            :   Even if locks are otherwise defined, this function does not use them,
<span class="lineNum">     777 </span>            :   so results might not be up to date.
<span class="lineNum">     778 </span>            : */
<span class="lineNum">     779 </span>            : size_t dlmalloc_footprint(void);
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : /*
<span class="lineNum">     782 </span>            :   malloc_max_footprint();
<span class="lineNum">     783 </span>            :   Returns the maximum number of bytes obtained from the system. This
<span class="lineNum">     784 </span>            :   value will be greater than current footprint if deallocated space
<span class="lineNum">     785 </span>            :   has been reclaimed by the system. The peak number of bytes allocated
<span class="lineNum">     786 </span>            :   by malloc, realloc etc., is less than this value. Unlike mallinfo,
<span class="lineNum">     787 </span>            :   this function returns only a precomputed result, so can be called
<span class="lineNum">     788 </span>            :   frequently to monitor memory consumption.  Even if locks are
<span class="lineNum">     789 </span>            :   otherwise defined, this function does not use them, so results might
<span class="lineNum">     790 </span>            :   not be up to date.
<span class="lineNum">     791 </span>            : */
<span class="lineNum">     792 </span>            : size_t dlmalloc_max_footprint(void);
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            : #if !NO_MALLINFO
<span class="lineNum">     795 </span>            : /*
<span class="lineNum">     796 </span>            :   mallinfo()
<span class="lineNum">     797 </span>            :   Returns (by copy) a struct containing various summary statistics:
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :   arena:     current total non-mmapped bytes allocated from system
<span class="lineNum">     800 </span>            :   ordblks:   the number of free chunks
<span class="lineNum">     801 </span>            :   smblks:    always zero.
<span class="lineNum">     802 </span>            :   hblks:     current number of mmapped regions
<span class="lineNum">     803 </span>            :   hblkhd:    total bytes held in mmapped regions
<span class="lineNum">     804 </span>            :   usmblks:   the maximum total allocated space. This will be greater
<span class="lineNum">     805 </span>            :                 than current total if trimming has occurred.
<span class="lineNum">     806 </span>            :   fsmblks:   always zero
<span class="lineNum">     807 </span>            :   uordblks:  current total allocated space (normal or mmapped)
<span class="lineNum">     808 </span>            :   fordblks:  total free space
<span class="lineNum">     809 </span>            :   keepcost:  the maximum number of bytes that could ideally be released
<span class="lineNum">     810 </span>            :                back to system via malloc_trim. (&quot;ideally&quot; means that
<span class="lineNum">     811 </span>            :                it ignores page restrictions etc.)
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   Because these fields are ints, but internal bookkeeping may
<span class="lineNum">     814 </span>            :   be kept as longs, the reported values may wrap around zero and
<span class="lineNum">     815 </span>            :   thus be inaccurate.
<span class="lineNum">     816 </span>            : */
<span class="lineNum">     817 </span>            : struct mallinfo dlmallinfo(void);
<span class="lineNum">     818 </span>            : #endif /* NO_MALLINFO */
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : /*
<span class="lineNum">     821 </span>            :   independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :   independent_calloc is similar to calloc, but instead of returning a
<span class="lineNum">     824 </span>            :   single cleared space, it returns an array of pointers to n_elements
<span class="lineNum">     825 </span>            :   independent elements that can hold contents of size elem_size, each
<span class="lineNum">     826 </span>            :   of which starts out cleared, and can be independently freed,
<span class="lineNum">     827 </span>            :   realloc'ed etc. The elements are guaranteed to be adjacently
<span class="lineNum">     828 </span>            :   allocated (this is not guaranteed to occur with multiple callocs or
<span class="lineNum">     829 </span>            :   mallocs), which may also improve cache locality in some
<span class="lineNum">     830 </span>            :   applications.
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :   The &quot;chunks&quot; argument is optional (i.e., may be null, which is
<span class="lineNum">     833 </span>            :   probably the most typical usage). If it is null, the returned array
<span class="lineNum">     834 </span>            :   is itself dynamically allocated and should also be freed when it is
<span class="lineNum">     835 </span>            :   no longer needed. Otherwise, the chunks array must be of at least
<span class="lineNum">     836 </span>            :   n_elements in length. It is filled in with the pointers to the
<span class="lineNum">     837 </span>            :   chunks.
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   In either case, independent_calloc returns this pointer array, or
<span class="lineNum">     840 </span>            :   null if the allocation failed.  If n_elements is zero and &quot;chunks&quot;
<span class="lineNum">     841 </span>            :   is null, it returns a chunk representing an array with zero elements
<span class="lineNum">     842 </span>            :   (which should be freed if not wanted).
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   Each element must be individually freed when it is no longer
<span class="lineNum">     845 </span>            :   needed. If you'd like to instead be able to free all at once, you
<span class="lineNum">     846 </span>            :   should instead use regular calloc and assign pointers into this
<span class="lineNum">     847 </span>            :   space to represent elements.  (In this case though, you cannot
<span class="lineNum">     848 </span>            :   independently free elements.)
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :   independent_calloc simplifies and speeds up implementations of many
<span class="lineNum">     851 </span>            :   kinds of pools.  It may also be useful when constructing large data
<span class="lineNum">     852 </span>            :   structures that initially have a fixed number of fixed-sized nodes,
<span class="lineNum">     853 </span>            :   but the number is not known at compile time, and some of the nodes
<span class="lineNum">     854 </span>            :   may later need to be freed. For example:
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :   struct Node { int item; struct Node* next; };
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            :   struct Node* build_list() {
<span class="lineNum">     859 </span>            :     struct Node** pool;
<span class="lineNum">     860 </span>            :     int n = read_number_of_nodes_needed();
<span class="lineNum">     861 </span>            :     if (n &lt;= 0) return 0;
<span class="lineNum">     862 </span>            :     pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
<span class="lineNum">     863 </span>            :     if (pool == 0) die();
<span class="lineNum">     864 </span>            :     // organize into a linked list...
<span class="lineNum">     865 </span>            :     struct Node* first = pool[0];
<span class="lineNum">     866 </span>            :     for (i = 0; i &lt; n-1; ++i)
<span class="lineNum">     867 </span>            :       pool[i]-&gt;next = pool[i+1];
<span class="lineNum">     868 </span>            :     free(pool);     // Can now free the array (or not, if it is needed later)
<span class="lineNum">     869 </span>            :     return first;
<span class="lineNum">     870 </span>            :   }
<span class="lineNum">     871 </span>            : */
<span class="lineNum">     872 </span>            : void** dlindependent_calloc(size_t, size_t, void**);
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /*
<span class="lineNum">     875 </span>            :   independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :   independent_comalloc allocates, all at once, a set of n_elements
<span class="lineNum">     878 </span>            :   chunks with sizes indicated in the &quot;sizes&quot; array.    It returns
<span class="lineNum">     879 </span>            :   an array of pointers to these elements, each of which can be
<span class="lineNum">     880 </span>            :   independently freed, realloc'ed etc. The elements are guaranteed to
<span class="lineNum">     881 </span>            :   be adjacently allocated (this is not guaranteed to occur with
<span class="lineNum">     882 </span>            :   multiple callocs or mallocs), which may also improve cache locality
<span class="lineNum">     883 </span>            :   in some applications.
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   The &quot;chunks&quot; argument is optional (i.e., may be null). If it is null
<span class="lineNum">     886 </span>            :   the returned array is itself dynamically allocated and should also
<span class="lineNum">     887 </span>            :   be freed when it is no longer needed. Otherwise, the chunks array
<span class="lineNum">     888 </span>            :   must be of at least n_elements in length. It is filled in with the
<span class="lineNum">     889 </span>            :   pointers to the chunks.
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :   In either case, independent_comalloc returns this pointer array, or
<span class="lineNum">     892 </span>            :   null if the allocation failed.  If n_elements is zero and chunks is
<span class="lineNum">     893 </span>            :   null, it returns a chunk representing an array with zero elements
<span class="lineNum">     894 </span>            :   (which should be freed if not wanted).
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :   Each element must be individually freed when it is no longer
<span class="lineNum">     897 </span>            :   needed. If you'd like to instead be able to free all at once, you
<span class="lineNum">     898 </span>            :   should instead use a single regular malloc, and assign pointers at
<span class="lineNum">     899 </span>            :   particular offsets in the aggregate space. (In this case though, you
<span class="lineNum">     900 </span>            :   cannot independently free elements.)
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            :   independent_comallac differs from independent_calloc in that each
<span class="lineNum">     903 </span>            :   element may have a different size, and also that it does not
<span class="lineNum">     904 </span>            :   automatically clear elements.
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :   independent_comalloc can be used to speed up allocation in cases
<span class="lineNum">     907 </span>            :   where several structs or objects must always be allocated at the
<span class="lineNum">     908 </span>            :   same time.  For example:
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :   struct Head { ... }
<span class="lineNum">     911 </span>            :   struct Foot { ... }
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :   void send_message(char* msg) {
<span class="lineNum">     914 </span>            :     int msglen = strlen(msg);
<span class="lineNum">     915 </span>            :     size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
<span class="lineNum">     916 </span>            :     void* chunks[3];
<span class="lineNum">     917 </span>            :     if (independent_comalloc(3, sizes, chunks) == 0)
<span class="lineNum">     918 </span>            :       die();
<span class="lineNum">     919 </span>            :     struct Head* head = (struct Head*)(chunks[0]);
<span class="lineNum">     920 </span>            :     char*        body = (char*)(chunks[1]);
<span class="lineNum">     921 </span>            :     struct Foot* foot = (struct Foot*)(chunks[2]);
<span class="lineNum">     922 </span>            :     // ...
<span class="lineNum">     923 </span>            :   }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :   In general though, independent_comalloc is worth using only for
<span class="lineNum">     926 </span>            :   larger values of n_elements. For small values, you probably won't
<span class="lineNum">     927 </span>            :   detect enough difference from series of malloc calls to bother.
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            :   Overuse of independent_comalloc can increase overall memory usage,
<span class="lineNum">     930 </span>            :   since it cannot reuse existing noncontiguous small chunks that
<span class="lineNum">     931 </span>            :   might be available for some of the elements.
<span class="lineNum">     932 </span>            : */
<span class="lineNum">     933 </span>            : void** dlindependent_comalloc(size_t, size_t*, void**);
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : /*
<span class="lineNum">     937 </span>            :   pvalloc(size_t n);
<span class="lineNum">     938 </span>            :   Equivalent to valloc(minimum-page-that-holds(n)), that is,
<span class="lineNum">     939 </span>            :   round up n to nearest pagesize.
<span class="lineNum">     940 </span>            :  */
<span class="lineNum">     941 </span>            : void*  dlpvalloc(size_t);
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            : /*
<span class="lineNum">     944 </span>            :   malloc_trim(size_t pad);
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :   If possible, gives memory back to the system (via negative arguments
<span class="lineNum">     947 </span>            :   to sbrk) if there is unused memory at the `high' end of the malloc
<span class="lineNum">     948 </span>            :   pool or in unused MMAP segments. You can call this after freeing
<span class="lineNum">     949 </span>            :   large blocks of memory to potentially reduce the system-level memory
<span class="lineNum">     950 </span>            :   requirements of a program. However, it cannot guarantee to reduce
<span class="lineNum">     951 </span>            :   memory. Under some allocation patterns, some large free blocks of
<span class="lineNum">     952 </span>            :   memory will be locked between two used chunks, so they cannot be
<span class="lineNum">     953 </span>            :   given back to the system.
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :   The `pad' argument to malloc_trim represents the amount of free
<span class="lineNum">     956 </span>            :   trailing space to leave untrimmed. If this argument is zero, only
<span class="lineNum">     957 </span>            :   the minimum amount of memory to maintain internal data structures
<span class="lineNum">     958 </span>            :   will be left. Non-zero arguments can be supplied to maintain enough
<span class="lineNum">     959 </span>            :   trailing space to service future expected allocations without having
<span class="lineNum">     960 </span>            :   to re-obtain memory from the system.
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   Malloc_trim returns 1 if it actually released any memory, else 0.
<span class="lineNum">     963 </span>            : */
<span class="lineNum">     964 </span>            : int  dlmalloc_trim(size_t);
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            : /*
<span class="lineNum">     967 </span>            :   malloc_usable_size(void* p);
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   Returns the number of bytes you can actually use in
<span class="lineNum">     970 </span>            :   an allocated chunk, which may be more than you requested (although
<span class="lineNum">     971 </span>            :   often not) due to alignment and minimum size constraints.
<span class="lineNum">     972 </span>            :   You can use this many bytes without worrying about
<span class="lineNum">     973 </span>            :   overwriting other allocated objects. This is not a particularly great
<span class="lineNum">     974 </span>            :   programming practice. malloc_usable_size can be more useful in
<span class="lineNum">     975 </span>            :   debugging and assertions, for example:
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   p = malloc(n);
<span class="lineNum">     978 </span>            :   assert(malloc_usable_size(p) &gt;= 256);
<span class="lineNum">     979 </span>            : */
<span class="lineNum">     980 </span>            : size_t dlmalloc_usable_size(void*);
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : /*
<span class="lineNum">     983 </span>            :   malloc_stats();
<span class="lineNum">     984 </span>            :   Prints on stderr the amount of space obtained from the system (both
<span class="lineNum">     985 </span>            :   via sbrk and mmap), the maximum amount (which may be more than
<span class="lineNum">     986 </span>            :   current if malloc_trim and/or munmap got called), and the current
<span class="lineNum">     987 </span>            :   number of bytes allocated via malloc (or realloc, etc) but not yet
<span class="lineNum">     988 </span>            :   freed. Note that this is the number of bytes allocated, not the
<span class="lineNum">     989 </span>            :   number requested. It will be larger than the number requested
<span class="lineNum">     990 </span>            :   because of alignment and bookkeeping overhead. Because it includes
<span class="lineNum">     991 </span>            :   alignment wastage as being in use, this figure may be greater than
<span class="lineNum">     992 </span>            :   zero even when no user-level chunks are allocated.
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :   The reported current and maximum system memory can be inaccurate if
<span class="lineNum">     995 </span>            :   a program makes other calls to system memory allocation functions
<span class="lineNum">     996 </span>            :   (normally sbrk) outside of malloc.
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :   malloc_stats prints only the most commonly interesting statistics.
<span class="lineNum">     999 </span>            :   More information can be obtained by calling mallinfo.
<span class="lineNum">    1000 </span>            : */
<span class="lineNum">    1001 </span>            : void  dlmalloc_stats(void);
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            : #endif /* ONLY_MSPACES */
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : #if MSPACES
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : /*
<span class="lineNum">    1008 </span>            :   mspace is an opaque type representing an independent
<span class="lineNum">    1009 </span>            :   region of space that supports mspace_malloc, etc.
<span class="lineNum">    1010 </span>            : */
<span class="lineNum">    1011 </span>            : typedef void* mspace;
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : /*
<span class="lineNum">    1014 </span>            :   create_mspace creates and returns a new independent space with the
<span class="lineNum">    1015 </span>            :   given initial capacity, or, if 0, the default granularity size.  It
<span class="lineNum">    1016 </span>            :   returns null if there is no system memory available to create the
<span class="lineNum">    1017 </span>            :   space.  If argument locked is non-zero, the space uses a separate
<span class="lineNum">    1018 </span>            :   lock to control access. The capacity of the space will grow
<span class="lineNum">    1019 </span>            :   dynamically as needed to service mspace_malloc requests.  You can
<span class="lineNum">    1020 </span>            :   control the sizes of incremental increases of this space by
<span class="lineNum">    1021 </span>            :   compiling with a different DEFAULT_GRANULARITY or dynamically
<span class="lineNum">    1022 </span>            :   setting with mallopt(M_GRANULARITY, value).
<span class="lineNum">    1023 </span>            : */
<span class="lineNum">    1024 </span>            : mspace create_mspace(size_t capacity, int locked);
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /*
<span class="lineNum">    1027 </span>            :   destroy_mspace destroys the given space, and attempts to return all
<span class="lineNum">    1028 </span>            :   of its memory back to the system, returning the total number of
<span class="lineNum">    1029 </span>            :   bytes freed. After destruction, the results of access to all memory
<span class="lineNum">    1030 </span>            :   used by the space become undefined.
<span class="lineNum">    1031 </span>            : */
<span class="lineNum">    1032 </span>            : size_t destroy_mspace(mspace msp);
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : /*
<span class="lineNum">    1035 </span>            :   create_mspace_with_base uses the memory supplied as the initial base
<span class="lineNum">    1036 </span>            :   of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
<span class="lineNum">    1037 </span>            :   space is used for bookkeeping, so the capacity must be at least this
<span class="lineNum">    1038 </span>            :   large. (Otherwise 0 is returned.) When this initial space is
<span class="lineNum">    1039 </span>            :   exhausted, additional memory will be obtained from the system.
<span class="lineNum">    1040 </span>            :   Destroying this space will deallocate all additionally allocated
<span class="lineNum">    1041 </span>            :   space (if possible) but not the initial base.
<span class="lineNum">    1042 </span>            : */
<span class="lineNum">    1043 </span>            : mspace create_mspace_with_base(void* base, size_t capacity, int locked);
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            : /*
<span class="lineNum">    1046 </span>            :   mspace_malloc behaves as malloc, but operates within
<span class="lineNum">    1047 </span>            :   the given space.
<span class="lineNum">    1048 </span>            : */
<span class="lineNum">    1049 </span>            : void* mspace_malloc(mspace msp, size_t bytes);
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            : /*
<span class="lineNum">    1052 </span>            :   mspace_free behaves as free, but operates within
<span class="lineNum">    1053 </span>            :   the given space.
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :   If compiled with FOOTERS==1, mspace_free is not actually needed.
<span class="lineNum">    1056 </span>            :   free may be called instead of mspace_free because freed chunks from
<span class="lineNum">    1057 </span>            :   any space are handled by their originating spaces.
<span class="lineNum">    1058 </span>            : */
<span class="lineNum">    1059 </span>            : void mspace_free(mspace msp, void* mem);
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            : /*
<span class="lineNum">    1062 </span>            :   mspace_realloc behaves as realloc, but operates within
<span class="lineNum">    1063 </span>            :   the given space.
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :   If compiled with FOOTERS==1, mspace_realloc is not actually
<span class="lineNum">    1066 </span>            :   needed.  realloc may be called instead of mspace_realloc because
<span class="lineNum">    1067 </span>            :   realloced chunks from any space are handled by their originating
<span class="lineNum">    1068 </span>            :   spaces.
<span class="lineNum">    1069 </span>            : */
<span class="lineNum">    1070 </span>            : void* mspace_realloc(mspace msp, void* mem, size_t newsize);
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            : /*
<span class="lineNum">    1073 </span>            :   mspace_calloc behaves as calloc, but operates within
<span class="lineNum">    1074 </span>            :   the given space.
<span class="lineNum">    1075 </span>            : */
<span class="lineNum">    1076 </span>            : void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : /*
<span class="lineNum">    1079 </span>            :   mspace_memalign behaves as memalign, but operates within
<span class="lineNum">    1080 </span>            :   the given space.
<span class="lineNum">    1081 </span>            : */
<span class="lineNum">    1082 </span>            : void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : /*
<span class="lineNum">    1085 </span>            :   mspace_independent_calloc behaves as independent_calloc, but
<span class="lineNum">    1086 </span>            :   operates within the given space.
<span class="lineNum">    1087 </span>            : */
<span class="lineNum">    1088 </span>            : void** mspace_independent_calloc(mspace msp, size_t n_elements,
<span class="lineNum">    1089 </span>            :                                  size_t elem_size, void* chunks[]);
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            : /*
<span class="lineNum">    1092 </span>            :   mspace_independent_comalloc behaves as independent_comalloc, but
<span class="lineNum">    1093 </span>            :   operates within the given space.
<span class="lineNum">    1094 </span>            : */
<span class="lineNum">    1095 </span>            : void** mspace_independent_comalloc(mspace msp, size_t n_elements,
<span class="lineNum">    1096 </span>            :                                    size_t sizes[], void* chunks[]);
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : /*
<span class="lineNum">    1099 </span>            :   mspace_footprint() returns the number of bytes obtained from the
<span class="lineNum">    1100 </span>            :   system for this space.
<span class="lineNum">    1101 </span>            : */
<span class="lineNum">    1102 </span>            : size_t mspace_footprint(mspace msp);
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            : /*
<span class="lineNum">    1105 </span>            :   mspace_max_footprint() returns the peak number of bytes obtained from the
<span class="lineNum">    1106 </span>            :   system for this space.
<span class="lineNum">    1107 </span>            : */
<span class="lineNum">    1108 </span>            : size_t mspace_max_footprint(mspace msp);
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : #if !NO_MALLINFO
<span class="lineNum">    1112 </span>            : /*
<span class="lineNum">    1113 </span>            :   mspace_mallinfo behaves as mallinfo, but reports properties of
<span class="lineNum">    1114 </span>            :   the given space.
<span class="lineNum">    1115 </span>            : */
<span class="lineNum">    1116 </span>            : struct mallinfo mspace_mallinfo(mspace msp);
<span class="lineNum">    1117 </span>            : #endif /* NO_MALLINFO */
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            : /*
<span class="lineNum">    1120 </span>            :   mspace_malloc_stats behaves as malloc_stats, but reports
<span class="lineNum">    1121 </span>            :   properties of the given space.
<span class="lineNum">    1122 </span>            : */
<span class="lineNum">    1123 </span>            : void mspace_malloc_stats(mspace msp);
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : /*
<span class="lineNum">    1126 </span>            :   mspace_trim behaves as malloc_trim, but
<span class="lineNum">    1127 </span>            :   operates within the given space.
<span class="lineNum">    1128 </span>            : */
<span class="lineNum">    1129 </span>            : int mspace_trim(mspace msp, size_t pad);
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span>            : /*
<span class="lineNum">    1132 </span>            :   An alias for mallopt.
<span class="lineNum">    1133 </span>            : */
<span class="lineNum">    1134 </span>            : int mspace_mallopt(int, int);
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            : #endif /* MSPACES */
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : #ifdef __cplusplus
<span class="lineNum">    1139 </span>            : };  /* end of extern &quot;C&quot; */
<span class="lineNum">    1140 </span>            : #endif /* __cplusplus */
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : /*
<span class="lineNum">    1143 </span>            :   ========================================================================
<span class="lineNum">    1144 </span>            :   To make a fully customizable malloc.h header file, cut everything
<span class="lineNum">    1145 </span>            :   above this line, put into file malloc.h, edit to suit, and #include it
<span class="lineNum">    1146 </span>            :   on the next line, as well as in programs that use this malloc.
<span class="lineNum">    1147 </span>            :   ========================================================================
<span class="lineNum">    1148 </span>            : */
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            : /* #include &quot;malloc.h&quot; */
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            : /*------------------------------ internal #includes ---------------------- */
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : #ifdef _MSC_VER
<span class="lineNum">    1155 </span>            : #pragma warning( disable : 4146 ) /* no &quot;unsigned&quot; warnings */
<span class="lineNum">    1156 </span>            : #endif /* _MSC_VER */
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : #include &lt;stdio.h&gt;       /* for printing in malloc_stats */
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : #ifndef LACKS_ERRNO_H
<span class="lineNum">    1161 </span>            : #include &lt;errno.h&gt;       /* for MALLOC_FAILURE_ACTION */
<span class="lineNum">    1162 </span>            : #endif /* LACKS_ERRNO_H */
<span class="lineNum">    1163 </span>            : #if FOOTERS
<span class="lineNum">    1164 </span>            : #include &lt;time.h&gt;        /* for magic initialization */
<span class="lineNum">    1165 </span>            : #endif /* FOOTERS */
<span class="lineNum">    1166 </span>            : #ifndef LACKS_STDLIB_H
<span class="lineNum">    1167 </span>            : #include &lt;stdlib.h&gt;      /* for abort() */
<span class="lineNum">    1168 </span>            : #endif /* LACKS_STDLIB_H */
<span class="lineNum">    1169 </span>            : #ifdef DEBUG
<span class="lineNum">    1170 </span>            : #if ABORT_ON_ASSERT_FAILURE
<span class="lineNum">    1171 </span>            : #define assert(x) if(!(x)) ABORT
<span class="lineNum">    1172 </span>            : #else /* ABORT_ON_ASSERT_FAILURE */
<span class="lineNum">    1173 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">    1174 </span>            : #endif /* ABORT_ON_ASSERT_FAILURE */
<span class="lineNum">    1175 </span>            : #else  /* DEBUG */
<span class="lineNum">    1176 </span>            : #define assert(x)
<span class="lineNum">    1177 </span>            : #endif /* DEBUG */
<span class="lineNum">    1178 </span>            : #ifndef LACKS_STRING_H
<span class="lineNum">    1179 </span>            : #include &lt;string.h&gt;      /* for memset etc */
<span class="lineNum">    1180 </span>            : #endif  /* LACKS_STRING_H */
<span class="lineNum">    1181 </span>            : #if USE_BUILTIN_FFS
<span class="lineNum">    1182 </span>            : #ifndef LACKS_STRINGS_H
<span class="lineNum">    1183 </span>            : #include &lt;strings.h&gt;     /* for ffs */
<span class="lineNum">    1184 </span>            : #endif /* LACKS_STRINGS_H */
<span class="lineNum">    1185 </span>            : #endif /* USE_BUILTIN_FFS */
<span class="lineNum">    1186 </span>            : #if HAVE_MMAP
<span class="lineNum">    1187 </span>            : #ifndef LACKS_SYS_MMAN_H
<span class="lineNum">    1188 </span>            : #include &lt;sys/mman.h&gt;    /* for mmap */
<span class="lineNum">    1189 </span>            : #endif /* LACKS_SYS_MMAN_H */
<span class="lineNum">    1190 </span>            : #ifndef LACKS_FCNTL_H
<span class="lineNum">    1191 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">    1192 </span>            : #endif /* LACKS_FCNTL_H */
<span class="lineNum">    1193 </span>            : #endif /* HAVE_MMAP */
<span class="lineNum">    1194 </span>            : #if HAVE_MORECORE
<span class="lineNum">    1195 </span>            : #ifndef LACKS_UNISTD_H
<span class="lineNum">    1196 </span>            : #include &lt;unistd.h&gt;     /* for sbrk */
<span class="lineNum">    1197 </span>            : #else /* LACKS_UNISTD_H */
<span class="lineNum">    1198 </span>            : #if !defined(__FreeBSD__) &amp;&amp; !defined(__OpenBSD__) &amp;&amp; !defined(__NetBSD__)
<span class="lineNum">    1199 </span>            : extern void*     sbrk(ptrdiff_t);
<span class="lineNum">    1200 </span>            : #endif /* FreeBSD etc */
<span class="lineNum">    1201 </span>            : #endif /* LACKS_UNISTD_H */
<span class="lineNum">    1202 </span>            : #endif /* HAVE_MMAP */
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            : #ifndef WIN32
<span class="lineNum">    1205 </span>            : #ifndef malloc_getpagesize
<span class="lineNum">    1206 </span>            : #  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
<span class="lineNum">    1207 </span>            : #    ifndef _SC_PAGE_SIZE
<span class="lineNum">    1208 </span>            : #      define _SC_PAGE_SIZE _SC_PAGESIZE
<span class="lineNum">    1209 </span>            : #    endif
<span class="lineNum">    1210 </span>            : #  endif
<span class="lineNum">    1211 </span>            : #  ifdef _SC_PAGE_SIZE
<span class="lineNum">    1212 </span>            : #    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
<span class="lineNum">    1213 </span>            : #  else
<span class="lineNum">    1214 </span>            : #    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
<span class="lineNum">    1215 </span>            :        extern size_t getpagesize();
<span class="lineNum">    1216 </span>            : #      define malloc_getpagesize getpagesize()
<span class="lineNum">    1217 </span>            : #    else
<span class="lineNum">    1218 </span>            : #      ifdef WIN32 /* use supplied emulation of getpagesize */
<span class="lineNum">    1219 </span>            : #        define malloc_getpagesize getpagesize()
<span class="lineNum">    1220 </span>            : #      else
<span class="lineNum">    1221 </span>            : #        ifndef LACKS_SYS_PARAM_H
<span class="lineNum">    1222 </span>            : #          include &lt;sys/param.h&gt;
<span class="lineNum">    1223 </span>            : #        endif
<span class="lineNum">    1224 </span>            : #        ifdef EXEC_PAGESIZE
<span class="lineNum">    1225 </span>            : #          define malloc_getpagesize EXEC_PAGESIZE
<span class="lineNum">    1226 </span>            : #        else
<span class="lineNum">    1227 </span>            : #          ifdef NBPG
<span class="lineNum">    1228 </span>            : #            ifndef CLSIZE
<span class="lineNum">    1229 </span>            : #              define malloc_getpagesize NBPG
<span class="lineNum">    1230 </span>            : #            else
<span class="lineNum">    1231 </span>            : #              define malloc_getpagesize (NBPG * CLSIZE)
<span class="lineNum">    1232 </span>            : #            endif
<span class="lineNum">    1233 </span>            : #          else
<span class="lineNum">    1234 </span>            : #            ifdef NBPC
<span class="lineNum">    1235 </span>            : #              define malloc_getpagesize NBPC
<span class="lineNum">    1236 </span>            : #            else
<span class="lineNum">    1237 </span>            : #              ifdef PAGESIZE
<span class="lineNum">    1238 </span>            : #                define malloc_getpagesize PAGESIZE
<span class="lineNum">    1239 </span>            : #              else /* just guess */
<span class="lineNum">    1240 </span>            : #                define malloc_getpagesize ((size_t)4096U)
<span class="lineNum">    1241 </span>            : #              endif
<span class="lineNum">    1242 </span>            : #            endif
<span class="lineNum">    1243 </span>            : #          endif
<span class="lineNum">    1244 </span>            : #        endif
<span class="lineNum">    1245 </span>            : #      endif
<span class="lineNum">    1246 </span>            : #    endif
<span class="lineNum">    1247 </span>            : #  endif
<span class="lineNum">    1248 </span>            : #endif
<span class="lineNum">    1249 </span>            : #endif
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            : /* ------------------- size_t and alignment properties -------------------- */
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span>            : /* The byte and bit size of a size_t */
<span class="lineNum">    1254 </span>            : #define SIZE_T_SIZE         (sizeof(size_t))
<span class="lineNum">    1255 </span>            : #define SIZE_T_BITSIZE      (sizeof(size_t) &lt;&lt; 3)
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            : /* Some constants coerced to size_t */
<span class="lineNum">    1258 </span>            : /* Annoying but necessary to avoid errors on some platforms */
<span class="lineNum">    1259 </span>            : #define SIZE_T_ZERO         ((size_t)0)
<span class="lineNum">    1260 </span>            : #define SIZE_T_ONE          ((size_t)1)
<span class="lineNum">    1261 </span>            : #define SIZE_T_TWO          ((size_t)2)
<span class="lineNum">    1262 </span>            : #define TWO_SIZE_T_SIZES    (SIZE_T_SIZE&lt;&lt;1)
<span class="lineNum">    1263 </span>            : #define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE&lt;&lt;2)
<span class="lineNum">    1264 </span>            : #define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
<span class="lineNum">    1265 </span>            : #define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            : /* The bit mask value corresponding to MALLOC_ALIGNMENT */
<span class="lineNum">    1268 </span>            : #define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            : /* True if address a has acceptable alignment */
<span class="lineNum">    1271 </span>            : #define is_aligned(A)       (((size_t)((A)) &amp; (CHUNK_ALIGN_MASK)) == 0)
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : /* the number of bytes to offset an address to align it */
<span class="lineNum">    1274 </span>            : #define align_offset(A)\
<span class="lineNum">    1275 </span>            :  ((((size_t)(A) &amp; CHUNK_ALIGN_MASK) == 0)? 0 :\
<span class="lineNum">    1276 </span>            :   ((MALLOC_ALIGNMENT - ((size_t)(A) &amp; CHUNK_ALIGN_MASK)) &amp; CHUNK_ALIGN_MASK))
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : /* -------------------------- MMAP preliminaries ------------------------- */
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            : /*
<span class="lineNum">    1281 </span>            :    If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
<span class="lineNum">    1282 </span>            :    checks to fail so compiler optimizer can delete code rather than
<span class="lineNum">    1283 </span>            :    using so many &quot;#if&quot;s.
<span class="lineNum">    1284 </span>            : */
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            : /* MORECORE and MMAP must return MFAIL on failure */
<span class="lineNum">    1288 </span>            : #define MFAIL                ((void*)(MAX_SIZE_T))
<span class="lineNum">    1289 </span>            : #define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            : #if !HAVE_MMAP
<span class="lineNum">    1292 </span>            : #define IS_MMAPPED_BIT       (SIZE_T_ZERO)
<span class="lineNum">    1293 </span>            : #define USE_MMAP_BIT         (SIZE_T_ZERO)
<span class="lineNum">    1294 </span>            : #define CALL_MMAP(s)         MFAIL
<span class="lineNum">    1295 </span>            : #define CALL_MUNMAP(a, s)    (-1)
<span class="lineNum">    1296 </span>            : #define DIRECT_MMAP(s)       MFAIL
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : #else /* HAVE_MMAP */
<span class="lineNum">    1299 </span>            : #define IS_MMAPPED_BIT       (SIZE_T_ONE)
<span class="lineNum">    1300 </span>            : #define USE_MMAP_BIT         (SIZE_T_ONE)
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            : #if !defined(WIN32) &amp;&amp; !defined (__OS2__)
<span class="lineNum">    1303 </span>            : #define CALL_MUNMAP(a, s)    munmap((a), (s))
<span class="lineNum">    1304 </span>            : #define MMAP_PROT            (PROT_READ|PROT_WRITE)
<span class="lineNum">    1305 </span>            : #if !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)
<span class="lineNum">    1306 </span>            : #define MAP_ANONYMOUS        MAP_ANON
<span class="lineNum">    1307 </span>            : #endif /* MAP_ANON */
<span class="lineNum">    1308 </span>            : #ifdef MAP_ANONYMOUS
<span class="lineNum">    1309 </span>            : #define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
<span class="lineNum">    1310 </span>            : #define CALL_MMAP(s)         mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
<span class="lineNum">    1311 </span>            : #else /* MAP_ANONYMOUS */
<span class="lineNum">    1312 </span>            : /*
<span class="lineNum">    1313 </span>            :    Nearly all versions of mmap support MAP_ANONYMOUS, so the following
<span class="lineNum">    1314 </span>            :    is unlikely to be needed, but is supplied just in case.
<span class="lineNum">    1315 </span>            : */
<span class="lineNum">    1316 </span>            : #define MMAP_FLAGS           (MAP_PRIVATE)
<span class="lineNum">    1317 </span>            : static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
<span class="lineNum">    1318 </span>            : #define CALL_MMAP(s) ((dev_zero_fd &lt; 0) ? \
<span class="lineNum">    1319 </span>            :            (dev_zero_fd = open(&quot;/dev/zero&quot;, O_RDWR), \
<span class="lineNum">    1320 </span>            :             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
<span class="lineNum">    1321 </span>            :             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
<span class="lineNum">    1322 </span>            : #endif /* MAP_ANONYMOUS */
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : #define DIRECT_MMAP(s)       CALL_MMAP(s)
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            : #elif defined(__OS2__)
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : /* OS/2 MMAP via DosAllocMem */
<span class="lineNum">    1329 </span>            : static void* os2mmap(size_t size) {
<span class="lineNum">    1330 </span>            :   void* ptr;
<span class="lineNum">    1331 </span>            :   if (DosAllocMem(&amp;ptr, size, OBJ_ANY|PAG_COMMIT|PAG_READ|PAG_WRITE) &amp;&amp;
<span class="lineNum">    1332 </span>            :       DosAllocMem(&amp;ptr, size, PAG_COMMIT|PAG_READ|PAG_WRITE))
<span class="lineNum">    1333 </span>            :     return MFAIL;
<span class="lineNum">    1334 </span>            :   return ptr;
<span class="lineNum">    1335 </span>            : }
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : #define os2direct_mmap(n)     os2mmap(n)
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : /* This function supports releasing coalesed segments */
<span class="lineNum">    1340 </span>            : static int os2munmap(void* ptr, size_t size) {
<span class="lineNum">    1341 </span>            :   while (size) {
<span class="lineNum">    1342 </span>            :     ULONG ulSize = size;
<span class="lineNum">    1343 </span>            :     ULONG ulFlags = 0;
<span class="lineNum">    1344 </span>            :     if (DosQueryMem(ptr, &amp;ulSize, &amp;ulFlags) != 0)
<span class="lineNum">    1345 </span>            :       return -1;
<span class="lineNum">    1346 </span>            :     if ((ulFlags &amp; PAG_BASE) == 0 ||(ulFlags &amp; PAG_COMMIT) == 0 ||
<span class="lineNum">    1347 </span>            :         ulSize &gt; size)
<span class="lineNum">    1348 </span>            :       return -1;
<span class="lineNum">    1349 </span>            :     if (DosFreeMem(ptr) != 0)
<span class="lineNum">    1350 </span>            :       return -1;
<span class="lineNum">    1351 </span>            :     ptr = ( void * ) ( ( char * ) ptr + ulSize );
<span class="lineNum">    1352 </span>            :     size -= ulSize;
<span class="lineNum">    1353 </span>            :   }
<span class="lineNum">    1354 </span>            :   return 0;
<span class="lineNum">    1355 </span>            : }
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : #define CALL_MMAP(s)         os2mmap(s)
<span class="lineNum">    1358 </span>            : #define CALL_MUNMAP(a, s)    os2munmap((a), (s))
<span class="lineNum">    1359 </span>            : #define DIRECT_MMAP(s)       os2direct_mmap(s)
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            : #else /* WIN32 */
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            : /* Win32 MMAP via VirtualAlloc */
<span class="lineNum">    1364 </span>            : static void* win32mmap(size_t size) {
<span class="lineNum">    1365 </span>            :   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
<span class="lineNum">    1366 </span>            :   return (ptr != 0)? ptr: MFAIL;
<span class="lineNum">    1367 </span>            : }
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            : /* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
<span class="lineNum">    1370 </span>            : static void* win32direct_mmap(size_t size) {
<span class="lineNum">    1371 </span>            :   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
<span class="lineNum">    1372 </span>            :                            PAGE_EXECUTE_READWRITE);
<span class="lineNum">    1373 </span>            :   return (ptr != 0)? ptr: MFAIL;
<span class="lineNum">    1374 </span>            : }
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : /* This function supports releasing coalesed segments */
<span class="lineNum">    1377 </span>            : static int win32munmap(void* ptr, size_t size) {
<span class="lineNum">    1378 </span>            :   MEMORY_BASIC_INFORMATION minfo;
<span class="lineNum">    1379 </span>            :   char* cptr = ptr;
<span class="lineNum">    1380 </span>            :   while (size) {
<span class="lineNum">    1381 </span>            :     if (VirtualQuery(cptr, &amp;minfo, sizeof(minfo)) == 0)
<span class="lineNum">    1382 </span>            :       return -1;
<span class="lineNum">    1383 </span>            :     if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
<span class="lineNum">    1384 </span>            :         minfo.State != MEM_COMMIT || minfo.RegionSize &gt; size)
<span class="lineNum">    1385 </span>            :       return -1;
<span class="lineNum">    1386 </span>            :     if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
<span class="lineNum">    1387 </span>            :       return -1;
<span class="lineNum">    1388 </span>            :     cptr += minfo.RegionSize;
<span class="lineNum">    1389 </span>            :     size -= minfo.RegionSize;
<span class="lineNum">    1390 </span>            :   }
<span class="lineNum">    1391 </span>            :   return 0;
<span class="lineNum">    1392 </span>            : }
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            : #define CALL_MMAP(s)         win32mmap(s)
<span class="lineNum">    1395 </span>            : #define CALL_MUNMAP(a, s)    win32munmap((a), (s))
<span class="lineNum">    1396 </span>            : #define DIRECT_MMAP(s)       win32direct_mmap(s)
<span class="lineNum">    1397 </span>            : #endif /* WIN32 */
<span class="lineNum">    1398 </span>            : #endif /* HAVE_MMAP */
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            : #if HAVE_MMAP &amp;&amp; HAVE_MREMAP
<span class="lineNum">    1401 </span>            : #define CALL_MREMAP(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
<span class="lineNum">    1402 </span>            : #else  /* HAVE_MMAP &amp;&amp; HAVE_MREMAP */
<span class="lineNum">    1403 </span>            : #define CALL_MREMAP(addr, osz, nsz, mv) MFAIL
<span class="lineNum">    1404 </span>            : #endif /* HAVE_MMAP &amp;&amp; HAVE_MREMAP */
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            : #if HAVE_MORECORE
<span class="lineNum">    1407 </span>            : #define CALL_MORECORE(S)     MORECORE(S)
<span class="lineNum">    1408 </span>            : #else  /* HAVE_MORECORE */
<span class="lineNum">    1409 </span>            : #define CALL_MORECORE(S)     MFAIL
<span class="lineNum">    1410 </span>            : #endif /* HAVE_MORECORE */
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            : /* mstate bit set if contiguous morecore disabled or failed */
<span class="lineNum">    1413 </span>            : #define USE_NONCONTIGUOUS_BIT (4U)
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            : /* segment bit set in create_mspace_with_base */
<span class="lineNum">    1416 </span>            : #define EXTERN_BIT            (8U)
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            : /* --------------------------- Lock preliminaries ------------------------ */
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span>            : #if USE_LOCKS
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            : /*
<span class="lineNum">    1424 </span>            :   When locks are defined, there are up to two global locks:
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :   * If HAVE_MORECORE, morecore_mutex protects sequences of calls to
<span class="lineNum">    1427 </span>            :     MORECORE.  In many cases sys_alloc requires two calls, that should
<span class="lineNum">    1428 </span>            :     not be interleaved with calls by other threads.  This does not
<span class="lineNum">    1429 </span>            :     protect against direct calls to MORECORE by other threads not
<span class="lineNum">    1430 </span>            :     using this lock, so there is still code to cope the best we can on
<span class="lineNum">    1431 </span>            :     interference.
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :   * magic_init_mutex ensures that mparams.magic and other
<span class="lineNum">    1434 </span>            :     unique mparams values are initialized only once.
<span class="lineNum">    1435 </span>            : */
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : #if !defined(WIN32) &amp;&amp; !defined(__OS2__)
<span class="lineNum">    1438 </span>            : /* By default use posix locks */
<span class="lineNum">    1439 </span>            : #include &lt;pthread.h&gt;
<span class="lineNum">    1440 </span>            : #define MLOCK_T pthread_mutex_t
<span class="lineNum">    1441 </span>            : #define INITIAL_LOCK(l)      pthread_mutex_init(l, NULL)
<span class="lineNum">    1442 </span>            : #define ACQUIRE_LOCK(l)      pthread_mutex_lock(l)
<span class="lineNum">    1443 </span>            : #define RELEASE_LOCK(l)      pthread_mutex_unlock(l)
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            : #if HAVE_MORECORE
<span class="lineNum">    1446 </span>            : static MLOCK_T morecore_mutex = PTHREAD_MUTEX_INITIALIZER;
<span class="lineNum">    1447 </span>            : #endif /* HAVE_MORECORE */
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            : static MLOCK_T magic_init_mutex = PTHREAD_MUTEX_INITIALIZER;
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            : #elif defined(__OS2__)
<span class="lineNum">    1452 </span>            : #define MLOCK_T HMTX
<span class="lineNum">    1453 </span>            : #define INITIAL_LOCK(l)      DosCreateMutexSem(0, l, 0, FALSE)
<span class="lineNum">    1454 </span>            : #define ACQUIRE_LOCK(l)      DosRequestMutexSem(*l, SEM_INDEFINITE_WAIT)
<span class="lineNum">    1455 </span>            : #define RELEASE_LOCK(l)      DosReleaseMutexSem(*l)
<span class="lineNum">    1456 </span>            : #if HAVE_MORECORE
<span class="lineNum">    1457 </span>            : static MLOCK_T morecore_mutex;
<span class="lineNum">    1458 </span>            : #endif /* HAVE_MORECORE */
<span class="lineNum">    1459 </span>            : static MLOCK_T magic_init_mutex;
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span>            : #else /* WIN32 */
<span class="lineNum">    1462 </span>            : /*
<span class="lineNum">    1463 </span>            :    Because lock-protected regions have bounded times, and there
<span class="lineNum">    1464 </span>            :    are no recursive lock calls, we can use simple spinlocks.
<span class="lineNum">    1465 </span>            : */
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            : #define MLOCK_T long
<span class="lineNum">    1468 </span>            : static int win32_acquire_lock (MLOCK_T *sl) {
<span class="lineNum">    1469 </span>            :   for (;;) {
<span class="lineNum">    1470 </span>            : #ifdef InterlockedCompareExchangePointer
<span class="lineNum">    1471 </span>            :     if (!InterlockedCompareExchange(sl, 1, 0))
<span class="lineNum">    1472 </span>            :       return 0;
<span class="lineNum">    1473 </span>            : #else  /* Use older void* version */
<span class="lineNum">    1474 </span>            :     if (!InterlockedCompareExchange((void**)sl, (void*)1, (void*)0))
<span class="lineNum">    1475 </span>            :       return 0;
<span class="lineNum">    1476 </span>            : #endif /* InterlockedCompareExchangePointer */
<span class="lineNum">    1477 </span>            :     Sleep (0);
<span class="lineNum">    1478 </span>            :   }
<span class="lineNum">    1479 </span>            : }
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : static void win32_release_lock (MLOCK_T *sl) {
<span class="lineNum">    1482 </span>            :   InterlockedExchange (sl, 0);
<span class="lineNum">    1483 </span>            : }
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            : #define INITIAL_LOCK(l)      *(l)=0
<span class="lineNum">    1486 </span>            : #define ACQUIRE_LOCK(l)      win32_acquire_lock(l)
<span class="lineNum">    1487 </span>            : #define RELEASE_LOCK(l)      win32_release_lock(l)
<span class="lineNum">    1488 </span>            : #if HAVE_MORECORE
<span class="lineNum">    1489 </span>            : static MLOCK_T morecore_mutex;
<span class="lineNum">    1490 </span>            : #endif /* HAVE_MORECORE */
<span class="lineNum">    1491 </span>            : static MLOCK_T magic_init_mutex;
<span class="lineNum">    1492 </span>            : #endif /* WIN32 */
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            : #define USE_LOCK_BIT               (2U)
<span class="lineNum">    1495 </span>            : #else  /* USE_LOCKS */
<span class="lineNum">    1496 </span>            : #define USE_LOCK_BIT               (0U)
<span class="lineNum">    1497 </span>            : #define INITIAL_LOCK(l)
<span class="lineNum">    1498 </span>            : #endif /* USE_LOCKS */
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            : #if USE_LOCKS &amp;&amp; HAVE_MORECORE
<span class="lineNum">    1501 </span>            : #define ACQUIRE_MORECORE_LOCK()    ACQUIRE_LOCK(&amp;morecore_mutex);
<span class="lineNum">    1502 </span>            : #define RELEASE_MORECORE_LOCK()    RELEASE_LOCK(&amp;morecore_mutex);
<span class="lineNum">    1503 </span>            : #else /* USE_LOCKS &amp;&amp; HAVE_MORECORE */
<span class="lineNum">    1504 </span>            : #define ACQUIRE_MORECORE_LOCK()
<span class="lineNum">    1505 </span>            : #define RELEASE_MORECORE_LOCK()
<span class="lineNum">    1506 </span>            : #endif /* USE_LOCKS &amp;&amp; HAVE_MORECORE */
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            : #if USE_LOCKS
<span class="lineNum">    1509 </span>            : #define ACQUIRE_MAGIC_INIT_LOCK()  ACQUIRE_LOCK(&amp;magic_init_mutex);
<span class="lineNum">    1510 </span>            : #define RELEASE_MAGIC_INIT_LOCK()  RELEASE_LOCK(&amp;magic_init_mutex);
<span class="lineNum">    1511 </span>            : #else  /* USE_LOCKS */
<span class="lineNum">    1512 </span>            : #define ACQUIRE_MAGIC_INIT_LOCK()
<span class="lineNum">    1513 </span>            : #define RELEASE_MAGIC_INIT_LOCK()
<span class="lineNum">    1514 </span>            : #endif /* USE_LOCKS */
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            : /* -----------------------  Chunk representations ------------------------ */
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : /*
<span class="lineNum">    1520 </span>            :   (The following includes lightly edited explanations by Colin Plumb.)
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span>            :   The malloc_chunk declaration below is misleading (but accurate and
<span class="lineNum">    1523 </span>            :   necessary).  It declares a &quot;view&quot; into memory allowing access to
<span class="lineNum">    1524 </span>            :   necessary fields at known offsets from a given base.
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :   Chunks of memory are maintained using a `boundary tag' method as
<span class="lineNum">    1527 </span>            :   originally described by Knuth.  (See the paper by Paul Wilson
<span class="lineNum">    1528 </span>            :   ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
<span class="lineNum">    1529 </span>            :   techniques.)  Sizes of free chunks are stored both in the front of
<span class="lineNum">    1530 </span>            :   each chunk and at the end.  This makes consolidating fragmented
<span class="lineNum">    1531 </span>            :   chunks into bigger chunks fast.  The head fields also hold bits
<span class="lineNum">    1532 </span>            :   representing whether chunks are free or in use.
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            :   Here are some pictures to make it clearer.  They are &quot;exploded&quot; to
<span class="lineNum">    1535 </span>            :   show that the state of a chunk can be thought of as extending from
<span class="lineNum">    1536 </span>            :   the high 31 bits of the head field of its header through the
<span class="lineNum">    1537 </span>            :   prev_foot and PINUSE_BIT bit of the following chunk header.
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :   A chunk that's in use looks like:
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            :    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1542 </span>            :            | Size of previous chunk (if P = 1)                             |
<span class="lineNum">    1543 </span>            :            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1544 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
<span class="lineNum">    1545 </span>            :          | Size of this chunk                                         1| +-+
<span class="lineNum">    1546 </span>            :    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1547 </span>            :          |                                                               |
<span class="lineNum">    1548 </span>            :          +-                                                             -+
<span class="lineNum">    1549 </span>            :          |                                                               |
<span class="lineNum">    1550 </span>            :          +-                                                             -+
<span class="lineNum">    1551 </span>            :          |                                                               :
<span class="lineNum">    1552 </span>            :          +-      size - sizeof(size_t) available payload bytes          -+
<span class="lineNum">    1553 </span>            :          :                                                               |
<span class="lineNum">    1554 </span>            :  chunk-&gt; +-                                                             -+
<span class="lineNum">    1555 </span>            :          |                                                               |
<span class="lineNum">    1556 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1557 </span>            :        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
<span class="lineNum">    1558 </span>            :        | Size of next chunk (may or may not be in use)               | +-+
<span class="lineNum">    1559 </span>            :  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            :     And if it's free, it looks like this:
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :    chunk-&gt; +-                                                             -+
<span class="lineNum">    1564 </span>            :            | User payload (must be in use, or we would have merged!)       |
<span class="lineNum">    1565 </span>            :            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1566 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
<span class="lineNum">    1567 </span>            :          | Size of this chunk                                         0| +-+
<span class="lineNum">    1568 </span>            :    mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1569 </span>            :          | Next pointer                                                  |
<span class="lineNum">    1570 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1571 </span>            :          | Prev pointer                                                  |
<span class="lineNum">    1572 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1573 </span>            :          |                                                               :
<span class="lineNum">    1574 </span>            :          +-      size - sizeof(struct chunk) unused bytes               -+
<span class="lineNum">    1575 </span>            :          :                                                               |
<span class="lineNum">    1576 </span>            :  chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1577 </span>            :          | Size of this chunk                                            |
<span class="lineNum">    1578 </span>            :          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1579 </span>            :        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
<span class="lineNum">    1580 </span>            :        | Size of next chunk (must be in use, or we would have merged)| +-+
<span class="lineNum">    1581 </span>            :  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1582 </span>            :        |                                                               :
<span class="lineNum">    1583 </span>            :        +- User payload                                                -+
<span class="lineNum">    1584 </span>            :        :                                                               |
<span class="lineNum">    1585 </span>            :        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1586 </span>            :                                                                      |0|
<span class="lineNum">    1587 </span>            :                                                                      +-+
<span class="lineNum">    1588 </span>            :   Note that since we always merge adjacent free chunks, the chunks
<span class="lineNum">    1589 </span>            :   adjacent to a free chunk must be in use.
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            :   Given a pointer to a chunk (which can be derived trivially from the
<span class="lineNum">    1592 </span>            :   payload pointer) we can, in O(1) time, find out whether the adjacent
<span class="lineNum">    1593 </span>            :   chunks are free, and if so, unlink them from the lists that they
<span class="lineNum">    1594 </span>            :   are on and merge them with the current chunk.
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span>            :   Chunks always begin on even word boundaries, so the mem portion
<span class="lineNum">    1597 </span>            :   (which is returned to the user) is also on an even word boundary, and
<span class="lineNum">    1598 </span>            :   thus at least double-word aligned.
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :   The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
<span class="lineNum">    1601 </span>            :   chunk size (which is always a multiple of two words), is an in-use
<span class="lineNum">    1602 </span>            :   bit for the *previous* chunk.  If that bit is *clear*, then the
<span class="lineNum">    1603 </span>            :   word before the current chunk size contains the previous chunk
<span class="lineNum">    1604 </span>            :   size, and can be used to find the front of the previous chunk.
<span class="lineNum">    1605 </span>            :   The very first chunk allocated always has this bit set, preventing
<span class="lineNum">    1606 </span>            :   access to non-existent (or non-owned) memory. If pinuse is set for
<span class="lineNum">    1607 </span>            :   any given chunk, then you CANNOT determine the size of the
<span class="lineNum">    1608 </span>            :   previous chunk, and might even get a memory addressing fault when
<span class="lineNum">    1609 </span>            :   trying to do so.
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :   The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
<span class="lineNum">    1612 </span>            :   the chunk size redundantly records whether the current chunk is
<span class="lineNum">    1613 </span>            :   inuse. This redundancy enables usage checks within free and realloc,
<span class="lineNum">    1614 </span>            :   and reduces indirection when freeing and consolidating chunks.
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span>            :   Each freshly allocated chunk must have both cinuse and pinuse set.
<span class="lineNum">    1617 </span>            :   That is, each allocated chunk borders either a previously allocated
<span class="lineNum">    1618 </span>            :   and still in-use chunk, or the base of its memory arena. This is
<span class="lineNum">    1619 </span>            :   ensured by making all allocations from the the `lowest' part of any
<span class="lineNum">    1620 </span>            :   found chunk.  Further, no free chunk physically borders another one,
<span class="lineNum">    1621 </span>            :   so each free chunk is known to be preceded and followed by either
<span class="lineNum">    1622 </span>            :   inuse chunks or the ends of memory.
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :   Note that the `foot' of the current chunk is actually represented
<span class="lineNum">    1625 </span>            :   as the prev_foot of the NEXT chunk. This makes it easier to
<span class="lineNum">    1626 </span>            :   deal with alignments etc but can be very confusing when trying
<span class="lineNum">    1627 </span>            :   to extend or adapt this code.
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            :   The exceptions to all this are
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            :      1. The special chunk `top' is the top-most available chunk (i.e.,
<span class="lineNum">    1632 </span>            :         the one bordering the end of available memory). It is treated
<span class="lineNum">    1633 </span>            :         specially.  Top is never included in any bin, is used only if
<span class="lineNum">    1634 </span>            :         no other chunk is available, and is released back to the
<span class="lineNum">    1635 </span>            :         system if it is very large (see M_TRIM_THRESHOLD).  In effect,
<span class="lineNum">    1636 </span>            :         the top chunk is treated as larger (and thus less well
<span class="lineNum">    1637 </span>            :         fitting) than any other available chunk.  The top chunk
<span class="lineNum">    1638 </span>            :         doesn't update its trailing size field since there is no next
<span class="lineNum">    1639 </span>            :         contiguous chunk that would have to index off it. However,
<span class="lineNum">    1640 </span>            :         space is still allocated for it (TOP_FOOT_SIZE) to enable
<span class="lineNum">    1641 </span>            :         separation or merging when space is extended.
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :      3. Chunks allocated via mmap, which have the lowest-order bit
<span class="lineNum">    1644 </span>            :         (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set
<span class="lineNum">    1645 </span>            :         PINUSE_BIT in their head fields.  Because they are allocated
<span class="lineNum">    1646 </span>            :         one-by-one, each must carry its own prev_foot field, which is
<span class="lineNum">    1647 </span>            :         also used to hold the offset this chunk has within its mmapped
<span class="lineNum">    1648 </span>            :         region, which is needed to preserve alignment. Each mmapped
<span class="lineNum">    1649 </span>            :         chunk is trailed by the first two fields of a fake next-chunk
<span class="lineNum">    1650 </span>            :         for sake of usage checks.
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span>            : */
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span>            : struct malloc_chunk {
<span class="lineNum">    1655 </span>            :   size_t               prev_foot;  /* Size of previous chunk (if free).  */
<span class="lineNum">    1656 </span>            :   size_t               head;       /* Size and inuse bits. */
<span class="lineNum">    1657 </span>            :   struct malloc_chunk* fd;         /* double links -- used only if free. */
<span class="lineNum">    1658 </span>            :   struct malloc_chunk* bk;
<span class="lineNum">    1659 </span>            : };
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : typedef struct malloc_chunk  mchunk;
<span class="lineNum">    1662 </span>            : typedef struct malloc_chunk* mchunkptr;
<span class="lineNum">    1663 </span>            : typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
<span class="lineNum">    1664 </span>            : typedef size_t bindex_t;               /* Described below */
<span class="lineNum">    1665 </span>            : typedef unsigned int binmap_t;         /* Described below */
<span class="lineNum">    1666 </span>            : typedef unsigned int flag_t;           /* The type of various bit flag sets */
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            : /* ------------------- Chunks sizes and alignments ----------------------- */
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            : #define MCHUNK_SIZE         (sizeof(mchunk))
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            : #if FOOTERS
<span class="lineNum">    1673 </span>            : #define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
<span class="lineNum">    1674 </span>            : #else /* FOOTERS */
<span class="lineNum">    1675 </span>            : #define CHUNK_OVERHEAD      (SIZE_T_SIZE)
<span class="lineNum">    1676 </span>            : #endif /* FOOTERS */
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span>            : /* MMapped chunks need a second word of overhead ... */
<span class="lineNum">    1679 </span>            : #define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
<span class="lineNum">    1680 </span>            : /* ... and additional padding for fake next-chunk at foot */
<span class="lineNum">    1681 </span>            : #define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            : /* The smallest size we can malloc is an aligned minimal chunk */
<span class="lineNum">    1684 </span>            : #define MIN_CHUNK_SIZE\
<span class="lineNum">    1685 </span>            :   ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span>            : /* conversion from malloc headers to user pointers, and back */
<span class="lineNum">    1688 </span>            : #define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
<span class="lineNum">    1689 </span>            : #define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
<span class="lineNum">    1690 </span>            : /* chunk associated with aligned address A */
<span class="lineNum">    1691 </span>            : #define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            : /* Bounds on request (not chunk) sizes. */
<span class="lineNum">    1694 </span>            : #define MAX_REQUEST         ((-MIN_CHUNK_SIZE) &lt;&lt; 2)
<span class="lineNum">    1695 </span>            : #define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            : /* pad request bytes into a usable size */
<span class="lineNum">    1698 </span>            : #define pad_request(req) \
<span class="lineNum">    1699 </span>            :    (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) &amp; ~CHUNK_ALIGN_MASK)
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            : /* pad request, checking for minimum (but not maximum) */
<span class="lineNum">    1702 </span>            : #define request2size(req) \
<span class="lineNum">    1703 </span>            :   (((req) &lt; MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            : /* ------------------ Operations on head and foot fields ----------------- */
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            : /*
<span class="lineNum">    1709 </span>            :   The head field of a chunk is or'ed with PINUSE_BIT when previous
<span class="lineNum">    1710 </span>            :   adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
<span class="lineNum">    1711 </span>            :   use. If the chunk was obtained with mmap, the prev_foot field has
<span class="lineNum">    1712 </span>            :   IS_MMAPPED_BIT set, otherwise holding the offset of the base of the
<span class="lineNum">    1713 </span>            :   mmapped region to the base of the chunk.
<span class="lineNum">    1714 </span>            : */
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span>            : #define PINUSE_BIT          (SIZE_T_ONE)
<span class="lineNum">    1717 </span>            : #define CINUSE_BIT          (SIZE_T_TWO)
<span class="lineNum">    1718 </span>            : #define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            : /* Head value for fenceposts */
<span class="lineNum">    1721 </span>            : #define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            : /* extraction of fields from head words */
<span class="lineNum">    1724 </span>            : #define cinuse(p)           ((p)-&gt;head &amp; CINUSE_BIT)
<span class="lineNum">    1725 </span>            : #define pinuse(p)           ((p)-&gt;head &amp; PINUSE_BIT)
<span class="lineNum">    1726 </span>            : #define chunksize(p)        ((p)-&gt;head &amp; ~(INUSE_BITS))
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span>            : #define clear_pinuse(p)     ((p)-&gt;head &amp;= ~PINUSE_BIT)
<span class="lineNum">    1729 </span>            : #define clear_cinuse(p)     ((p)-&gt;head &amp;= ~CINUSE_BIT)
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            : /* Treat space at ptr +/- offset as a chunk */
<span class="lineNum">    1732 </span>            : #define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
<span class="lineNum">    1733 </span>            : #define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            : /* Ptr to next or previous physical malloc_chunk. */
<span class="lineNum">    1736 </span>            : #define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;head &amp; ~INUSE_BITS)))
<span class="lineNum">    1737 </span>            : #define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_foot) ))
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span>            : /* extract next chunk's pinuse bit */
<span class="lineNum">    1740 </span>            : #define next_pinuse(p)  ((next_chunk(p)-&gt;head) &amp; PINUSE_BIT)
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            : /* Get/set size at footer */
<span class="lineNum">    1743 </span>            : #define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot)
<span class="lineNum">    1744 </span>            : #define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot = (s))
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            : /* Set size, pinuse bit, and foot */
<span class="lineNum">    1747 </span>            : #define set_size_and_pinuse_of_free_chunk(p, s)\
<span class="lineNum">    1748 </span>            :   ((p)-&gt;head = (s|PINUSE_BIT), set_foot(p, s))
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            : /* Set size, pinuse bit, foot, and clear next pinuse */
<span class="lineNum">    1751 </span>            : #define set_free_with_pinuse(p, s, n)\
<span class="lineNum">    1752 </span>            :   (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            : #define is_mmapped(p)\
<span class="lineNum">    1755 </span>            :   (!((p)-&gt;head &amp; PINUSE_BIT) &amp;&amp; ((p)-&gt;prev_foot &amp; IS_MMAPPED_BIT))
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            : /* Get the internal overhead associated with chunk p */
<span class="lineNum">    1758 </span>            : #define overhead_for(p)\
<span class="lineNum">    1759 </span>            :  (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            : /* Return true if malloced space is not necessarily cleared */
<span class="lineNum">    1762 </span>            : #if MMAP_CLEARS
<span class="lineNum">    1763 </span>            : #define calloc_must_clear(p) (!is_mmapped(p))
<span class="lineNum">    1764 </span>            : #else /* MMAP_CLEARS */
<span class="lineNum">    1765 </span>            : #define calloc_must_clear(p) (1)
<span class="lineNum">    1766 </span>            : #endif /* MMAP_CLEARS */
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            : /* ---------------------- Overlaid data structures ----------------------- */
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span>            : /*
<span class="lineNum">    1771 </span>            :   When chunks are not in use, they are treated as nodes of either
<span class="lineNum">    1772 </span>            :   lists or trees.
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :   &quot;Small&quot;  chunks are stored in circular doubly-linked lists, and look
<span class="lineNum">    1775 </span>            :   like this:
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span>            :     chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1778 </span>            :             |             Size of previous chunk                            |
<span class="lineNum">    1779 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1780 </span>            :     `head:' |             Size of chunk, in bytes                         |P|
<span class="lineNum">    1781 </span>            :       mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1782 </span>            :             |             Forward pointer to next chunk in list             |
<span class="lineNum">    1783 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1784 </span>            :             |             Back pointer to previous chunk in list            |
<span class="lineNum">    1785 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1786 </span>            :             |             Unused space (may be 0 bytes long)                .
<span class="lineNum">    1787 </span>            :             .                                                               .
<span class="lineNum">    1788 </span>            :             .                                                               |
<span class="lineNum">    1789 </span>            : nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1790 </span>            :     `foot:' |             Size of chunk, in bytes                           |
<span class="lineNum">    1791 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :   Larger chunks are kept in a form of bitwise digital trees (aka
<span class="lineNum">    1794 </span>            :   tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
<span class="lineNum">    1795 </span>            :   free chunks greater than 256 bytes, their size doesn't impose any
<span class="lineNum">    1796 </span>            :   constraints on user chunk sizes.  Each node looks like:
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            :     chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1799 </span>            :             |             Size of previous chunk                            |
<span class="lineNum">    1800 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1801 </span>            :     `head:' |             Size of chunk, in bytes                         |P|
<span class="lineNum">    1802 </span>            :       mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1803 </span>            :             |             Forward pointer to next chunk of same size        |
<span class="lineNum">    1804 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1805 </span>            :             |             Back pointer to previous chunk of same size       |
<span class="lineNum">    1806 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1807 </span>            :             |             Pointer to left child (child[0])                  |
<span class="lineNum">    1808 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1809 </span>            :             |             Pointer to right child (child[1])                 |
<span class="lineNum">    1810 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1811 </span>            :             |             Pointer to parent                                 |
<span class="lineNum">    1812 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1813 </span>            :             |             bin index of this chunk                           |
<span class="lineNum">    1814 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1815 </span>            :             |             Unused space                                      .
<span class="lineNum">    1816 </span>            :             .                                                               |
<span class="lineNum">    1817 </span>            : nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1818 </span>            :     `foot:' |             Size of chunk, in bytes                           |
<span class="lineNum">    1819 </span>            :             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            :   Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
<span class="lineNum">    1822 </span>            :   of the same size are arranged in a circularly-linked list, with only
<span class="lineNum">    1823 </span>            :   the oldest chunk (the next to be used, in our FIFO ordering)
<span class="lineNum">    1824 </span>            :   actually in the tree.  (Tree members are distinguished by a non-null
<span class="lineNum">    1825 </span>            :   parent pointer.)  If a chunk with the same size an an existing node
<span class="lineNum">    1826 </span>            :   is inserted, it is linked off the existing node using pointers that
<span class="lineNum">    1827 </span>            :   work in the same way as fd/bk pointers of small chunks.
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            :   Each tree contains a power of 2 sized range of chunk sizes (the
<span class="lineNum">    1830 </span>            :   smallest is 0x100 &lt;= x &lt; 0x180), which is is divided in half at each
<span class="lineNum">    1831 </span>            :   tree level, with the chunks in the smaller half of the range (0x100
<span class="lineNum">    1832 </span>            :   &lt;= x &lt; 0x140 for the top nose) in the left subtree and the larger
<span class="lineNum">    1833 </span>            :   half (0x140 &lt;= x &lt; 0x180) in the right subtree.  This is, of course,
<span class="lineNum">    1834 </span>            :   done by inspecting individual bits.
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :   Using these rules, each node's left subtree contains all smaller
<span class="lineNum">    1837 </span>            :   sizes than its right subtree.  However, the node at the root of each
<span class="lineNum">    1838 </span>            :   subtree has no particular ordering relationship to either.  (The
<span class="lineNum">    1839 </span>            :   dividing line between the subtree sizes is based on trie relation.)
<span class="lineNum">    1840 </span>            :   If we remove the last chunk of a given size from the interior of the
<span class="lineNum">    1841 </span>            :   tree, we need to replace it with a leaf node.  The tree ordering
<span class="lineNum">    1842 </span>            :   rules permit a node to be replaced by any leaf below it.
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            :   The smallest chunk in a tree (a common operation in a best-fit
<span class="lineNum">    1845 </span>            :   allocator) can be found by walking a path to the leftmost leaf in
<span class="lineNum">    1846 </span>            :   the tree.  Unlike a usual binary tree, where we follow left child
<span class="lineNum">    1847 </span>            :   pointers until we reach a null, here we follow the right child
<span class="lineNum">    1848 </span>            :   pointer any time the left one is null, until we reach a leaf with
<span class="lineNum">    1849 </span>            :   both child pointers null. The smallest chunk in the tree will be
<span class="lineNum">    1850 </span>            :   somewhere along that path.
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            :   The worst case number of steps to add, find, or remove a node is
<span class="lineNum">    1853 </span>            :   bounded by the number of bits differentiating chunks within
<span class="lineNum">    1854 </span>            :   bins. Under current bin calculations, this ranges from 6 up to 21
<span class="lineNum">    1855 </span>            :   (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
<span class="lineNum">    1856 </span>            :   is of course much better.
<span class="lineNum">    1857 </span>            : */
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            : struct malloc_tree_chunk {
<span class="lineNum">    1860 </span>            :   /* The first four fields must be compatible with malloc_chunk */
<span class="lineNum">    1861 </span>            :   size_t                    prev_foot;
<span class="lineNum">    1862 </span>            :   size_t                    head;
<span class="lineNum">    1863 </span>            :   struct malloc_tree_chunk* fd;
<span class="lineNum">    1864 </span>            :   struct malloc_tree_chunk* bk;
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            :   struct malloc_tree_chunk* child[2];
<span class="lineNum">    1867 </span>            :   struct malloc_tree_chunk* parent;
<span class="lineNum">    1868 </span>            :   bindex_t                  index;
<span class="lineNum">    1869 </span>            : };
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            : typedef struct malloc_tree_chunk  tchunk;
<span class="lineNum">    1872 </span>            : typedef struct malloc_tree_chunk* tchunkptr;
<span class="lineNum">    1873 </span>            : typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            : /* A little helper macro for trees */
<span class="lineNum">    1876 </span>            : #define leftmost_child(t) ((t)-&gt;child[0] != 0? (t)-&gt;child[0] : (t)-&gt;child[1])
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span>            : /* ----------------------------- Segments -------------------------------- */
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            : /*
<span class="lineNum">    1881 </span>            :   Each malloc space may include non-contiguous segments, held in a
<span class="lineNum">    1882 </span>            :   list headed by an embedded malloc_segment record representing the
<span class="lineNum">    1883 </span>            :   top-most space. Segments also include flags holding properties of
<span class="lineNum">    1884 </span>            :   the space. Large chunks that are directly allocated by mmap are not
<span class="lineNum">    1885 </span>            :   included in this list. They are instead independently created and
<span class="lineNum">    1886 </span>            :   destroyed without otherwise keeping track of them.
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            :   Segment management mainly comes into play for spaces allocated by
<span class="lineNum">    1889 </span>            :   MMAP.  Any call to MMAP might or might not return memory that is
<span class="lineNum">    1890 </span>            :   adjacent to an existing segment.  MORECORE normally contiguously
<span class="lineNum">    1891 </span>            :   extends the current space, so this space is almost always adjacent,
<span class="lineNum">    1892 </span>            :   which is simpler and faster to deal with. (This is why MORECORE is
<span class="lineNum">    1893 </span>            :   used preferentially to MMAP when both are available -- see
<span class="lineNum">    1894 </span>            :   sys_alloc.)  When allocating using MMAP, we don't use any of the
<span class="lineNum">    1895 </span>            :   hinting mechanisms (inconsistently) supported in various
<span class="lineNum">    1896 </span>            :   implementations of unix mmap, or distinguish reserving from
<span class="lineNum">    1897 </span>            :   committing memory. Instead, we just ask for space, and exploit
<span class="lineNum">    1898 </span>            :   contiguity when we get it.  It is probably possible to do
<span class="lineNum">    1899 </span>            :   better than this on some systems, but no general scheme seems
<span class="lineNum">    1900 </span>            :   to be significantly better.
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :   Management entails a simpler variant of the consolidation scheme
<span class="lineNum">    1903 </span>            :   used for chunks to reduce fragmentation -- new adjacent memory is
<span class="lineNum">    1904 </span>            :   normally prepended or appended to an existing segment. However,
<span class="lineNum">    1905 </span>            :   there are limitations compared to chunk consolidation that mostly
<span class="lineNum">    1906 </span>            :   reflect the fact that segment processing is relatively infrequent
<span class="lineNum">    1907 </span>            :   (occurring only when getting memory from system) and that we
<span class="lineNum">    1908 </span>            :   don't expect to have huge numbers of segments:
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span>            :   * Segments are not indexed, so traversal requires linear scans.  (It
<span class="lineNum">    1911 </span>            :     would be possible to index these, but is not worth the extra
<span class="lineNum">    1912 </span>            :     overhead and complexity for most programs on most platforms.)
<span class="lineNum">    1913 </span>            :   * New segments are only appended to old ones when holding top-most
<span class="lineNum">    1914 </span>            :     memory; if they cannot be prepended to others, they are held in
<span class="lineNum">    1915 </span>            :     different segments.
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :   Except for the top-most segment of an mstate, each segment record
<span class="lineNum">    1918 </span>            :   is kept at the tail of its segment. Segments are added by pushing
<span class="lineNum">    1919 </span>            :   segment records onto the list headed by &amp;mstate.seg for the
<span class="lineNum">    1920 </span>            :   containing mstate.
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            :   Segment flags control allocation/merge/deallocation policies:
<span class="lineNum">    1923 </span>            :   * If EXTERN_BIT set, then we did not allocate this segment,
<span class="lineNum">    1924 </span>            :     and so should not try to deallocate or merge with others.
<span class="lineNum">    1925 </span>            :     (This currently holds only for the initial segment passed
<span class="lineNum">    1926 </span>            :     into create_mspace_with_base.)
<span class="lineNum">    1927 </span>            :   * If IS_MMAPPED_BIT set, the segment may be merged with
<span class="lineNum">    1928 </span>            :     other surrounding mmapped segments and trimmed/de-allocated
<span class="lineNum">    1929 </span>            :     using munmap.
<span class="lineNum">    1930 </span>            :   * If neither bit is set, then the segment was obtained using
<span class="lineNum">    1931 </span>            :     MORECORE so can be merged with surrounding MORECORE'd segments
<span class="lineNum">    1932 </span>            :     and deallocated/trimmed using MORECORE with negative arguments.
<span class="lineNum">    1933 </span>            : */
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            : struct malloc_segment {
<span class="lineNum">    1936 </span>            :   char*        base;             /* base address */
<span class="lineNum">    1937 </span>            :   size_t       size;             /* allocated size */
<span class="lineNum">    1938 </span>            :   struct malloc_segment* next;   /* ptr to next segment */
<span class="lineNum">    1939 </span>            : #if FFI_MMAP_EXEC_WRIT
<span class="lineNum">    1940 </span>            :   /* The mmap magic is supposed to store the address of the executable
<span class="lineNum">    1941 </span>            :      segment at the very end of the requested block.  */
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            : # define mmap_exec_offset(b,s) (*(ptrdiff_t*)((b)+(s)-sizeof(ptrdiff_t)))
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span>            :   /* We can only merge segments if their corresponding executable
<span class="lineNum">    1946 </span>            :      segments are at identical offsets.  */
<span class="lineNum">    1947 </span>            : # define check_segment_merge(S,b,s) \
<span class="lineNum">    1948 </span>            :   (mmap_exec_offset((b),(s)) == (S)-&gt;exec_offset)
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            : # define add_segment_exec_offset(p,S) ((char*)(p) + (S)-&gt;exec_offset)
<span class="lineNum">    1951 </span>            : # define sub_segment_exec_offset(p,S) ((char*)(p) - (S)-&gt;exec_offset)
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span>            :   /* The removal of sflags only works with HAVE_MORECORE == 0.  */
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            : # define get_segment_flags(S)   (IS_MMAPPED_BIT)
<span class="lineNum">    1956 </span>            : # define set_segment_flags(S,v) \
<span class="lineNum">    1957 </span>            :   (((v) != IS_MMAPPED_BIT) ? (ABORT, (v)) :                             \
<span class="lineNum">    1958 </span>            :    (((S)-&gt;exec_offset =                                                      \
<span class="lineNum">    1959 </span>            :      mmap_exec_offset((S)-&gt;base, (S)-&gt;size)),                             \
<span class="lineNum">    1960 </span>            :     (mmap_exec_offset((S)-&gt;base + (S)-&gt;exec_offset, (S)-&gt;size) !=      \
<span class="lineNum">    1961 </span>            :      (S)-&gt;exec_offset) ? (ABORT, (v)) :                                      \
<span class="lineNum">    1962 </span>            :    (mmap_exec_offset((S)-&gt;base, (S)-&gt;size) = 0), (v)))
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            :   /* We use an offset here, instead of a pointer, because then, when
<span class="lineNum">    1965 </span>            :      base changes, we don't have to modify this.  On architectures
<span class="lineNum">    1966 </span>            :      with segmented addresses, this might not work.  */
<span class="lineNum">    1967 </span>            :   ptrdiff_t    exec_offset;
<span class="lineNum">    1968 </span>            : #else
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            : # define get_segment_flags(S)   ((S)-&gt;sflags)
<span class="lineNum">    1971 </span>            : # define set_segment_flags(S,v) ((S)-&gt;sflags = (v))
<span class="lineNum">    1972 </span>            : # define check_segment_merge(S,b,s) (1)
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            :   flag_t       sflags;           /* mmap and extern flag */
<span class="lineNum">    1975 </span>            : #endif
<span class="lineNum">    1976 </span>            : };
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span>            : #define is_mmapped_segment(S)  (get_segment_flags(S) &amp; IS_MMAPPED_BIT)
<span class="lineNum">    1979 </span>            : #define is_extern_segment(S)   (get_segment_flags(S) &amp; EXTERN_BIT)
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span>            : typedef struct malloc_segment  msegment;
<span class="lineNum">    1982 </span>            : typedef struct malloc_segment* msegmentptr;
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span>            : /* ---------------------------- malloc_state ----------------------------- */
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span>            : /*
<span class="lineNum">    1987 </span>            :    A malloc_state holds all of the bookkeeping for a space.
<span class="lineNum">    1988 </span>            :    The main fields are:
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            :   Top
<span class="lineNum">    1991 </span>            :     The topmost chunk of the currently active segment. Its size is
<span class="lineNum">    1992 </span>            :     cached in topsize.  The actual size of topmost space is
<span class="lineNum">    1993 </span>            :     topsize+TOP_FOOT_SIZE, which includes space reserved for adding
<span class="lineNum">    1994 </span>            :     fenceposts and segment records if necessary when getting more
<span class="lineNum">    1995 </span>            :     space from the system.  The size at which to autotrim top is
<span class="lineNum">    1996 </span>            :     cached from mparams in trim_check, except that it is disabled if
<span class="lineNum">    1997 </span>            :     an autotrim fails.
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span>            :   Designated victim (dv)
<span class="lineNum">    2000 </span>            :     This is the preferred chunk for servicing small requests that
<span class="lineNum">    2001 </span>            :     don't have exact fits.  It is normally the chunk split off most
<span class="lineNum">    2002 </span>            :     recently to service another small request.  Its size is cached in
<span class="lineNum">    2003 </span>            :     dvsize. The link fields of this chunk are not maintained since it
<span class="lineNum">    2004 </span>            :     is not kept in a bin.
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span>            :   SmallBins
<span class="lineNum">    2007 </span>            :     An array of bin headers for free chunks.  These bins hold chunks
<span class="lineNum">    2008 </span>            :     with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
<span class="lineNum">    2009 </span>            :     chunks of all the same size, spaced 8 bytes apart.  To simplify
<span class="lineNum">    2010 </span>            :     use in double-linked lists, each bin header acts as a malloc_chunk
<span class="lineNum">    2011 </span>            :     pointing to the real first node, if it exists (else pointing to
<span class="lineNum">    2012 </span>            :     itself).  This avoids special-casing for headers.  But to avoid
<span class="lineNum">    2013 </span>            :     waste, we allocate only the fd/bk pointers of bins, and then use
<span class="lineNum">    2014 </span>            :     repositioning tricks to treat these as the fields of a chunk.
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :   TreeBins
<span class="lineNum">    2017 </span>            :     Treebins are pointers to the roots of trees holding a range of
<span class="lineNum">    2018 </span>            :     sizes. There are 2 equally spaced treebins for each power of two
<span class="lineNum">    2019 </span>            :     from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
<span class="lineNum">    2020 </span>            :     larger.
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :   Bin maps
<span class="lineNum">    2023 </span>            :     There is one bit map for small bins (&quot;smallmap&quot;) and one for
<span class="lineNum">    2024 </span>            :     treebins (&quot;treemap).  Each bin sets its bit when non-empty, and
<span class="lineNum">    2025 </span>            :     clears the bit when empty.  Bit operations are then used to avoid
<span class="lineNum">    2026 </span>            :     bin-by-bin searching -- nearly all &quot;search&quot; is done without ever
<span class="lineNum">    2027 </span>            :     looking at bins that won't be selected.  The bit maps
<span class="lineNum">    2028 </span>            :     conservatively use 32 bits per map word, even if on 64bit system.
<span class="lineNum">    2029 </span>            :     For a good description of some of the bit-based techniques used
<span class="lineNum">    2030 </span>            :     here, see Henry S. Warren Jr's book &quot;Hacker's Delight&quot; (and
<span class="lineNum">    2031 </span>            :     supplement at http://hackersdelight.org/). Many of these are
<span class="lineNum">    2032 </span>            :     intended to reduce the branchiness of paths through malloc etc, as
<span class="lineNum">    2033 </span>            :     well as to reduce the number of memory locations read or written.
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span>            :   Segments
<span class="lineNum">    2036 </span>            :     A list of segments headed by an embedded malloc_segment record
<span class="lineNum">    2037 </span>            :     representing the initial space.
<span class="lineNum">    2038 </span>            : 
<span class="lineNum">    2039 </span>            :   Address check support
<span class="lineNum">    2040 </span>            :     The least_addr field is the least address ever obtained from
<span class="lineNum">    2041 </span>            :     MORECORE or MMAP. Attempted frees and reallocs of any address less
<span class="lineNum">    2042 </span>            :     than this are trapped (unless INSECURE is defined).
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            :   Magic tag
<span class="lineNum">    2045 </span>            :     A cross-check field that should always hold same value as mparams.magic.
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span>            :   Flags
<span class="lineNum">    2048 </span>            :     Bits recording whether to use MMAP, locks, or contiguous MORECORE
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span>            :   Statistics
<span class="lineNum">    2051 </span>            :     Each space keeps track of current and maximum system memory
<span class="lineNum">    2052 </span>            :     obtained via MORECORE or MMAP.
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            :   Locking
<span class="lineNum">    2055 </span>            :     If USE_LOCKS is defined, the &quot;mutex&quot; lock is acquired and released
<span class="lineNum">    2056 </span>            :     around every public call using this mspace.
<span class="lineNum">    2057 </span>            : */
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            : /* Bin types, widths and sizes */
<span class="lineNum">    2060 </span>            : #define NSMALLBINS        (32U)
<span class="lineNum">    2061 </span>            : #define NTREEBINS         (32U)
<span class="lineNum">    2062 </span>            : #define SMALLBIN_SHIFT    (3U)
<span class="lineNum">    2063 </span>            : #define SMALLBIN_WIDTH    (SIZE_T_ONE &lt;&lt; SMALLBIN_SHIFT)
<span class="lineNum">    2064 </span>            : #define TREEBIN_SHIFT     (8U)
<span class="lineNum">    2065 </span>            : #define MIN_LARGE_SIZE    (SIZE_T_ONE &lt;&lt; TREEBIN_SHIFT)
<span class="lineNum">    2066 </span>            : #define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
<span class="lineNum">    2067 </span>            : #define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span>            : struct malloc_state {
<span class="lineNum">    2070 </span>            :   binmap_t   smallmap;
<span class="lineNum">    2071 </span>            :   binmap_t   treemap;
<span class="lineNum">    2072 </span>            :   size_t     dvsize;
<span class="lineNum">    2073 </span>            :   size_t     topsize;
<span class="lineNum">    2074 </span>            :   char*      least_addr;
<span class="lineNum">    2075 </span>            :   mchunkptr  dv;
<span class="lineNum">    2076 </span>            :   mchunkptr  top;
<span class="lineNum">    2077 </span>            :   size_t     trim_check;
<span class="lineNum">    2078 </span>            :   size_t     magic;
<span class="lineNum">    2079 </span>            :   mchunkptr  smallbins[(NSMALLBINS+1)*2];
<span class="lineNum">    2080 </span>            :   tbinptr    treebins[NTREEBINS];
<span class="lineNum">    2081 </span>            :   size_t     footprint;
<span class="lineNum">    2082 </span>            :   size_t     max_footprint;
<span class="lineNum">    2083 </span>            :   flag_t     mflags;
<span class="lineNum">    2084 </span>            : #if USE_LOCKS
<span class="lineNum">    2085 </span>            :   MLOCK_T    mutex;     /* locate lock among fields that rarely change */
<span class="lineNum">    2086 </span>            : #endif /* USE_LOCKS */
<span class="lineNum">    2087 </span>            :   msegment   seg;
<span class="lineNum">    2088 </span>            : };
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            : typedef struct malloc_state*    mstate;
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : /* ------------- Global malloc_state and malloc_params ------------------- */
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            : /*
<span class="lineNum">    2095 </span>            :   malloc_params holds global properties, including those that can be
<span class="lineNum">    2096 </span>            :   dynamically set using mallopt. There is a single instance, mparams,
<span class="lineNum">    2097 </span>            :   initialized in init_mparams.
<span class="lineNum">    2098 </span>            : */
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            : struct malloc_params {
<span class="lineNum">    2101 </span>            :   size_t magic;
<span class="lineNum">    2102 </span>            :   size_t page_size;
<span class="lineNum">    2103 </span>            :   size_t granularity;
<span class="lineNum">    2104 </span>            :   size_t mmap_threshold;
<span class="lineNum">    2105 </span>            :   size_t trim_threshold;
<span class="lineNum">    2106 </span>            :   flag_t default_mflags;
<span class="lineNum">    2107 </span>            : };
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span>            : static struct malloc_params mparams;
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span>            : /* The global malloc_state used for all non-&quot;mspace&quot; calls */
<span class="lineNum">    2112 </span>            : static struct malloc_state _gm_;
<span class="lineNum">    2113 </span>            : #define gm                 (&amp;_gm_)
<span class="lineNum">    2114 </span>            : #define is_global(M)       ((M) == &amp;_gm_)
<span class="lineNum">    2115 </span>            : #define is_initialized(M)  ((M)-&gt;top != 0)
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            : /* -------------------------- system alloc setup ------------------------- */
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span>            : /* Operations on mflags */
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span>            : #define use_lock(M)           ((M)-&gt;mflags &amp;   USE_LOCK_BIT)
<span class="lineNum">    2122 </span>            : #define enable_lock(M)        ((M)-&gt;mflags |=  USE_LOCK_BIT)
<span class="lineNum">    2123 </span>            : #define disable_lock(M)       ((M)-&gt;mflags &amp;= ~USE_LOCK_BIT)
<span class="lineNum">    2124 </span>            : 
<span class="lineNum">    2125 </span>            : #define use_mmap(M)           ((M)-&gt;mflags &amp;   USE_MMAP_BIT)
<span class="lineNum">    2126 </span>            : #define enable_mmap(M)        ((M)-&gt;mflags |=  USE_MMAP_BIT)
<span class="lineNum">    2127 </span>            : #define disable_mmap(M)       ((M)-&gt;mflags &amp;= ~USE_MMAP_BIT)
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span>            : #define use_noncontiguous(M)  ((M)-&gt;mflags &amp;   USE_NONCONTIGUOUS_BIT)
<span class="lineNum">    2130 </span>            : #define disable_contiguous(M) ((M)-&gt;mflags |=  USE_NONCONTIGUOUS_BIT)
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            : #define set_lock(M,L)\
<span class="lineNum">    2133 </span>            :  ((M)-&gt;mflags = (L)?\
<span class="lineNum">    2134 </span>            :   ((M)-&gt;mflags | USE_LOCK_BIT) :\
<span class="lineNum">    2135 </span>            :   ((M)-&gt;mflags &amp; ~USE_LOCK_BIT))
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            : /* page-align a size */
<span class="lineNum">    2138 </span>            : #define page_align(S)\
<span class="lineNum">    2139 </span>            :  (((S) + (mparams.page_size)) &amp; ~(mparams.page_size - SIZE_T_ONE))
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            : /* granularity-align a size */
<span class="lineNum">    2142 </span>            : #define granularity_align(S)\
<span class="lineNum">    2143 </span>            :   (((S) + (mparams.granularity)) &amp; ~(mparams.granularity - SIZE_T_ONE))
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span>            : #define is_page_aligned(S)\
<span class="lineNum">    2146 </span>            :    (((size_t)(S) &amp; (mparams.page_size - SIZE_T_ONE)) == 0)
<span class="lineNum">    2147 </span>            : #define is_granularity_aligned(S)\
<span class="lineNum">    2148 </span>            :    (((size_t)(S) &amp; (mparams.granularity - SIZE_T_ONE)) == 0)
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span>            : /*  True if segment S holds address A */
<span class="lineNum">    2151 </span>            : #define segment_holds(S, A)\
<span class="lineNum">    2152 </span>            :   ((char*)(A) &gt;= S-&gt;base &amp;&amp; (char*)(A) &lt; S-&gt;base + S-&gt;size)
<a name="2153"><span class="lineNum">    2153 </span>            : </a>
<span class="lineNum">    2154 </span>            : /* Return segment holding given address */
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 : static msegmentptr segment_holding(mstate m, char* addr) {</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :   msegmentptr sp = &amp;m-&gt;seg;</span>
<span class="lineNum">    2157 </span>            :   for (;;) {
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :     if (addr &gt;= sp-&gt;base &amp;&amp; addr &lt; sp-&gt;base + sp-&gt;size)</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :       return sp;</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :     if ((sp = sp-&gt;next) == 0)</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    2162 </span>            :   }
<span class="lineNum">    2163 </span>            : }
<a name="2164"><span class="lineNum">    2164 </span>            : </a>
<span class="lineNum">    2165 </span>            : /* Return true if segment contains a segment link */
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 : static int has_segment_link(mstate m, msegmentptr ss) {</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :   msegmentptr sp = &amp;m-&gt;seg;</span>
<span class="lineNum">    2168 </span>            :   for (;;) {
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :     if ((char*)sp &gt;= ss-&gt;base &amp;&amp; (char*)sp &lt; ss-&gt;base + ss-&gt;size)</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :     if ((sp = sp-&gt;next) == 0)</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    2173 </span>            :   }
<span class="lineNum">    2174 </span>            : }
<span class="lineNum">    2175 </span>            : 
<span class="lineNum">    2176 </span>            : #ifndef MORECORE_CANNOT_TRIM
<span class="lineNum">    2177 </span>            : #define should_trim(M,s)  ((s) &gt; (M)-&gt;trim_check)
<span class="lineNum">    2178 </span>            : #else  /* MORECORE_CANNOT_TRIM */
<span class="lineNum">    2179 </span>            : #define should_trim(M,s)  (0)
<span class="lineNum">    2180 </span>            : #endif /* MORECORE_CANNOT_TRIM */
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            : /*
<span class="lineNum">    2183 </span>            :   TOP_FOOT_SIZE is padding at the end of a segment, including space
<span class="lineNum">    2184 </span>            :   that may be needed to place segment records and fenceposts when new
<span class="lineNum">    2185 </span>            :   noncontiguous segments are added.
<span class="lineNum">    2186 </span>            : */
<span class="lineNum">    2187 </span>            : #define TOP_FOOT_SIZE\
<span class="lineNum">    2188 </span>            :   (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span>            : /* -------------------------------  Hooks -------------------------------- */
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span>            : /*
<span class="lineNum">    2194 </span>            :   PREACTION should be defined to return 0 on success, and nonzero on
<span class="lineNum">    2195 </span>            :   failure. If you are not using locking, you can redefine these to do
<span class="lineNum">    2196 </span>            :   anything you like.
<span class="lineNum">    2197 </span>            : */
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span>            : #if USE_LOCKS
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span>            : /* Ensure locks are initialized */
<span class="lineNum">    2202 </span>            : #define GLOBALLY_INITIALIZE() (mparams.page_size == 0 &amp;&amp; init_mparams())
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            : #define PREACTION(M)  ((GLOBALLY_INITIALIZE() || use_lock(M))? ACQUIRE_LOCK(&amp;(M)-&gt;mutex) : 0)
<span class="lineNum">    2205 </span>            : #define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&amp;(M)-&gt;mutex); }
<span class="lineNum">    2206 </span>            : #else /* USE_LOCKS */
<span class="lineNum">    2207 </span>            : 
<span class="lineNum">    2208 </span>            : #ifndef PREACTION
<span class="lineNum">    2209 </span>            : #define PREACTION(M) (0)
<span class="lineNum">    2210 </span>            : #endif  /* PREACTION */
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            : #ifndef POSTACTION
<span class="lineNum">    2213 </span>            : #define POSTACTION(M)
<span class="lineNum">    2214 </span>            : #endif  /* POSTACTION */
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span>            : #endif /* USE_LOCKS */
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span>            : /*
<span class="lineNum">    2219 </span>            :   CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
<span class="lineNum">    2220 </span>            :   USAGE_ERROR_ACTION is triggered on detected bad frees and
<span class="lineNum">    2221 </span>            :   reallocs. The argument p is an address that might have triggered the
<span class="lineNum">    2222 </span>            :   fault. It is ignored by the two predefined actions, but might be
<span class="lineNum">    2223 </span>            :   useful in custom actions that try to help diagnose errors.
<span class="lineNum">    2224 </span>            : */
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span>            : #if PROCEED_ON_ERROR
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span>            : /* A count of the number of corruption errors causing resets */
<span class="lineNum">    2229 </span>            : int malloc_corruption_error_count;
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span>            : /* default corruption action */
<span class="lineNum">    2232 </span>            : static void reset_on_error(mstate m);
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span>            : #define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
<span class="lineNum">    2235 </span>            : #define USAGE_ERROR_ACTION(m, p)
<span class="lineNum">    2236 </span>            : 
<span class="lineNum">    2237 </span>            : #else /* PROCEED_ON_ERROR */
<span class="lineNum">    2238 </span>            : 
<span class="lineNum">    2239 </span>            : #ifndef CORRUPTION_ERROR_ACTION
<span class="lineNum">    2240 </span>            : #define CORRUPTION_ERROR_ACTION(m) ABORT
<span class="lineNum">    2241 </span>            : #endif /* CORRUPTION_ERROR_ACTION */
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            : #ifndef USAGE_ERROR_ACTION
<span class="lineNum">    2244 </span>            : #define USAGE_ERROR_ACTION(m,p) ABORT
<span class="lineNum">    2245 </span>            : #endif /* USAGE_ERROR_ACTION */
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span>            : #endif /* PROCEED_ON_ERROR */
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span>            : /* -------------------------- Debugging setup ---------------------------- */
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            : #if ! DEBUG
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span>            : #define check_free_chunk(M,P)
<span class="lineNum">    2254 </span>            : #define check_inuse_chunk(M,P)
<span class="lineNum">    2255 </span>            : #define check_malloced_chunk(M,P,N)
<span class="lineNum">    2256 </span>            : #define check_mmapped_chunk(M,P)
<span class="lineNum">    2257 </span>            : #define check_malloc_state(M)
<span class="lineNum">    2258 </span>            : #define check_top_chunk(M,P)
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            : #else /* DEBUG */
<span class="lineNum">    2261 </span>            : #define check_free_chunk(M,P)       do_check_free_chunk(M,P)
<span class="lineNum">    2262 </span>            : #define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
<span class="lineNum">    2263 </span>            : #define check_top_chunk(M,P)        do_check_top_chunk(M,P)
<span class="lineNum">    2264 </span>            : #define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
<span class="lineNum">    2265 </span>            : #define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
<span class="lineNum">    2266 </span>            : #define check_malloc_state(M)       do_check_malloc_state(M)
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            : static void   do_check_any_chunk(mstate m, mchunkptr p);
<span class="lineNum">    2269 </span>            : static void   do_check_top_chunk(mstate m, mchunkptr p);
<span class="lineNum">    2270 </span>            : static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
<span class="lineNum">    2271 </span>            : static void   do_check_inuse_chunk(mstate m, mchunkptr p);
<span class="lineNum">    2272 </span>            : static void   do_check_free_chunk(mstate m, mchunkptr p);
<span class="lineNum">    2273 </span>            : static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
<span class="lineNum">    2274 </span>            : static void   do_check_tree(mstate m, tchunkptr t);
<span class="lineNum">    2275 </span>            : static void   do_check_treebin(mstate m, bindex_t i);
<span class="lineNum">    2276 </span>            : static void   do_check_smallbin(mstate m, bindex_t i);
<span class="lineNum">    2277 </span>            : static void   do_check_malloc_state(mstate m);
<span class="lineNum">    2278 </span>            : static int    bin_find(mstate m, mchunkptr x);
<span class="lineNum">    2279 </span>            : static size_t traverse_and_check(mstate m);
<span class="lineNum">    2280 </span>            : #endif /* DEBUG */
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span>            : /* ---------------------------- Indexing Bins ---------------------------- */
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            : #define is_small(s)         (((s) &gt;&gt; SMALLBIN_SHIFT) &lt; NSMALLBINS)
<span class="lineNum">    2285 </span>            : #define small_index(s)      ((s)  &gt;&gt; SMALLBIN_SHIFT)
<span class="lineNum">    2286 </span>            : #define small_index2size(i) ((i)  &lt;&lt; SMALLBIN_SHIFT)
<span class="lineNum">    2287 </span>            : #define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            : /* addressing by index. See above about smallbin repositioning */
<span class="lineNum">    2290 </span>            : #define smallbin_at(M, i)   ((sbinptr)((char*)&amp;((M)-&gt;smallbins[(i)&lt;&lt;1])))
<span class="lineNum">    2291 </span>            : #define treebin_at(M,i)     (&amp;((M)-&gt;treebins[i]))
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            : /* assign tree index for size S to variable I */
<span class="lineNum">    2294 </span>            : #if defined(__GNUC__) &amp;&amp; defined(i386)
<span class="lineNum">    2295 </span>            : #define compute_tree_index(S, I)\
<span class="lineNum">    2296 </span>            : {\
<span class="lineNum">    2297 </span>            :   size_t X = S &gt;&gt; TREEBIN_SHIFT;\
<span class="lineNum">    2298 </span>            :   if (X == 0)\
<span class="lineNum">    2299 </span>            :     I = 0;\
<span class="lineNum">    2300 </span>            :   else if (X &gt; 0xFFFF)\
<span class="lineNum">    2301 </span>            :     I = NTREEBINS-1;\
<span class="lineNum">    2302 </span>            :   else {\
<span class="lineNum">    2303 </span>            :     unsigned int K;\
<span class="lineNum">    2304 </span>            :     __asm__(&quot;bsrl %1,%0\n\t&quot; : &quot;=r&quot; (K) : &quot;rm&quot;  (X));\
<span class="lineNum">    2305 </span>            :     I =  (bindex_t)((K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1)));\
<span class="lineNum">    2306 </span>            :   }\
<span class="lineNum">    2307 </span>            : }
<span class="lineNum">    2308 </span>            : #else /* GNUC */
<span class="lineNum">    2309 </span>            : #define compute_tree_index(S, I)\
<span class="lineNum">    2310 </span>            : {\
<span class="lineNum">    2311 </span>            :   size_t X = S &gt;&gt; TREEBIN_SHIFT;\
<span class="lineNum">    2312 </span>            :   if (X == 0)\
<span class="lineNum">    2313 </span>            :     I = 0;\
<span class="lineNum">    2314 </span>            :   else if (X &gt; 0xFFFF)\
<span class="lineNum">    2315 </span>            :     I = NTREEBINS-1;\
<span class="lineNum">    2316 </span>            :   else {\
<span class="lineNum">    2317 </span>            :     unsigned int Y = (unsigned int)X;\
<span class="lineNum">    2318 </span>            :     unsigned int N = ((Y - 0x100) &gt;&gt; 16) &amp; 8;\
<span class="lineNum">    2319 </span>            :     unsigned int K = (((Y &lt;&lt;= N) - 0x1000) &gt;&gt; 16) &amp; 4;\
<span class="lineNum">    2320 </span>            :     N += K;\
<span class="lineNum">    2321 </span>            :     N += K = (((Y &lt;&lt;= K) - 0x4000) &gt;&gt; 16) &amp; 2;\
<span class="lineNum">    2322 </span>            :     K = 14 - N + ((Y &lt;&lt;= K) &gt;&gt; 15);\
<span class="lineNum">    2323 </span>            :     I = (K &lt;&lt; 1) + ((S &gt;&gt; (K + (TREEBIN_SHIFT-1)) &amp; 1));\
<span class="lineNum">    2324 </span>            :   }\
<span class="lineNum">    2325 </span>            : }
<span class="lineNum">    2326 </span>            : #endif /* GNUC */
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            : /* Bit representing maximum resolved size in a treebin at i */
<span class="lineNum">    2329 </span>            : #define bit_for_tree_index(i) \
<span class="lineNum">    2330 </span>            :    (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span>            : /* Shift placing maximum resolved bit in a treebin at i as sign bit */
<span class="lineNum">    2333 </span>            : #define leftshift_for_tree_index(i) \
<span class="lineNum">    2334 </span>            :    ((i == NTREEBINS-1)? 0 : \
<span class="lineNum">    2335 </span>            :     ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 2)))
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            : /* The size of the smallest chunk held in bin with index i */
<span class="lineNum">    2338 </span>            : #define minsize_for_tree_index(i) \
<span class="lineNum">    2339 </span>            :    ((SIZE_T_ONE &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT)) |  \
<span class="lineNum">    2340 </span>            :    (((size_t)((i) &amp; SIZE_T_ONE)) &lt;&lt; (((i) &gt;&gt; 1) + TREEBIN_SHIFT - 1)))
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span>            : /* ------------------------ Operations on bin maps ----------------------- */
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            : /* bit corresponding to given index */
<span class="lineNum">    2346 </span>            : #define idx2bit(i)              ((binmap_t)(1) &lt;&lt; (i))
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            : /* Mark/Clear bits with given index */
<span class="lineNum">    2349 </span>            : #define mark_smallmap(M,i)      ((M)-&gt;smallmap |=  idx2bit(i))
<span class="lineNum">    2350 </span>            : #define clear_smallmap(M,i)     ((M)-&gt;smallmap &amp;= ~idx2bit(i))
<span class="lineNum">    2351 </span>            : #define smallmap_is_marked(M,i) ((M)-&gt;smallmap &amp;   idx2bit(i))
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            : #define mark_treemap(M,i)       ((M)-&gt;treemap  |=  idx2bit(i))
<span class="lineNum">    2354 </span>            : #define clear_treemap(M,i)      ((M)-&gt;treemap  &amp;= ~idx2bit(i))
<span class="lineNum">    2355 </span>            : #define treemap_is_marked(M,i)  ((M)-&gt;treemap  &amp;   idx2bit(i))
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span>            : /* index corresponding to given bit */
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            : #if defined(__GNUC__) &amp;&amp; defined(i386)
<span class="lineNum">    2360 </span>            : #define compute_bit2idx(X, I)\
<span class="lineNum">    2361 </span>            : {\
<span class="lineNum">    2362 </span>            :   unsigned int J;\
<span class="lineNum">    2363 </span>            :   __asm__(&quot;bsfl %1,%0\n\t&quot; : &quot;=r&quot; (J) : &quot;rm&quot; (X));\
<span class="lineNum">    2364 </span>            :   I = (bindex_t)J;\
<span class="lineNum">    2365 </span>            : }
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span>            : #else /* GNUC */
<span class="lineNum">    2368 </span>            : #if  USE_BUILTIN_FFS
<span class="lineNum">    2369 </span>            : #define compute_bit2idx(X, I) I = ffs(X)-1
<span class="lineNum">    2370 </span>            : 
<span class="lineNum">    2371 </span>            : #else /* USE_BUILTIN_FFS */
<span class="lineNum">    2372 </span>            : #define compute_bit2idx(X, I)\
<span class="lineNum">    2373 </span>            : {\
<span class="lineNum">    2374 </span>            :   unsigned int Y = X - 1;\
<span class="lineNum">    2375 </span>            :   unsigned int K = Y &gt;&gt; (16-4) &amp; 16;\
<span class="lineNum">    2376 </span>            :   unsigned int N = K;        Y &gt;&gt;= K;\
<span class="lineNum">    2377 </span>            :   N += K = Y &gt;&gt; (8-3) &amp;  8;  Y &gt;&gt;= K;\
<span class="lineNum">    2378 </span>            :   N += K = Y &gt;&gt; (4-2) &amp;  4;  Y &gt;&gt;= K;\
<span class="lineNum">    2379 </span>            :   N += K = Y &gt;&gt; (2-1) &amp;  2;  Y &gt;&gt;= K;\
<span class="lineNum">    2380 </span>            :   N += K = Y &gt;&gt; (1-0) &amp;  1;  Y &gt;&gt;= K;\
<span class="lineNum">    2381 </span>            :   I = (bindex_t)(N + Y);\
<span class="lineNum">    2382 </span>            : }
<span class="lineNum">    2383 </span>            : #endif /* USE_BUILTIN_FFS */
<span class="lineNum">    2384 </span>            : #endif /* GNUC */
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span>            : /* isolate the least set bit of a bitmap */
<span class="lineNum">    2387 </span>            : #define least_bit(x)         ((x) &amp; -(x))
<span class="lineNum">    2388 </span>            : 
<span class="lineNum">    2389 </span>            : /* mask with all bits to left of least bit of x on */
<span class="lineNum">    2390 </span>            : #define left_bits(x)         ((x&lt;&lt;1) | -(x&lt;&lt;1))
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span>            : /* mask with all bits to left of or equal to least bit of x on */
<span class="lineNum">    2393 </span>            : #define same_or_left_bits(x) ((x) | -(x))
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span>            : /* ----------------------- Runtime Check Support ------------------------- */
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            : /*
<span class="lineNum">    2399 </span>            :   For security, the main invariant is that malloc/free/etc never
<span class="lineNum">    2400 </span>            :   writes to a static address other than malloc_state, unless static
<span class="lineNum">    2401 </span>            :   malloc_state itself has been corrupted, which cannot occur via
<span class="lineNum">    2402 </span>            :   malloc (because of these checks). In essence this means that we
<span class="lineNum">    2403 </span>            :   believe all pointers, sizes, maps etc held in malloc_state, but
<span class="lineNum">    2404 </span>            :   check all of those linked or offsetted from other embedded data
<span class="lineNum">    2405 </span>            :   structures.  These checks are interspersed with main code in a way
<span class="lineNum">    2406 </span>            :   that tends to minimize their run-time cost.
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span>            :   When FOOTERS is defined, in addition to range checking, we also
<span class="lineNum">    2409 </span>            :   verify footer fields of inuse chunks, which can be used guarantee
<span class="lineNum">    2410 </span>            :   that the mstate controlling malloc/free is intact.  This is a
<span class="lineNum">    2411 </span>            :   streamlined version of the approach described by William Robertson
<span class="lineNum">    2412 </span>            :   et al in &quot;Run-time Detection of Heap-based Overflows&quot; LISA'03
<span class="lineNum">    2413 </span>            :   http://www.usenix.org/events/lisa03/tech/robertson.html The footer
<span class="lineNum">    2414 </span>            :   of an inuse chunk holds the xor of its mstate and a random seed,
<span class="lineNum">    2415 </span>            :   that is checked upon calls to free() and realloc().  This is
<span class="lineNum">    2416 </span>            :   (probablistically) unguessable from outside the program, but can be
<span class="lineNum">    2417 </span>            :   computed by any code successfully malloc'ing any chunk, so does not
<span class="lineNum">    2418 </span>            :   itself provide protection against code that has already broken
<span class="lineNum">    2419 </span>            :   security through some other means.  Unlike Robertson et al, we
<span class="lineNum">    2420 </span>            :   always dynamically check addresses of all offset chunks (previous,
<span class="lineNum">    2421 </span>            :   next, etc). This turns out to be cheaper than relying on hashes.
<span class="lineNum">    2422 </span>            : */
<span class="lineNum">    2423 </span>            : 
<span class="lineNum">    2424 </span>            : #if !INSECURE
<span class="lineNum">    2425 </span>            : /* Check if address a is at least as high as any from MORECORE or MMAP */
<span class="lineNum">    2426 </span>            : #define ok_address(M, a) ((char*)(a) &gt;= (M)-&gt;least_addr)
<span class="lineNum">    2427 </span>            : /* Check if address of next chunk n is higher than base chunk p */
<span class="lineNum">    2428 </span>            : #define ok_next(p, n)    ((char*)(p) &lt; (char*)(n))
<span class="lineNum">    2429 </span>            : /* Check if p has its cinuse bit on */
<span class="lineNum">    2430 </span>            : #define ok_cinuse(p)     cinuse(p)
<span class="lineNum">    2431 </span>            : /* Check if p has its pinuse bit on */
<span class="lineNum">    2432 </span>            : #define ok_pinuse(p)     pinuse(p)
<span class="lineNum">    2433 </span>            : 
<span class="lineNum">    2434 </span>            : #else /* !INSECURE */
<span class="lineNum">    2435 </span>            : #define ok_address(M, a) (1)
<span class="lineNum">    2436 </span>            : #define ok_next(b, n)    (1)
<span class="lineNum">    2437 </span>            : #define ok_cinuse(p)     (1)
<span class="lineNum">    2438 </span>            : #define ok_pinuse(p)     (1)
<span class="lineNum">    2439 </span>            : #endif /* !INSECURE */
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span>            : #if (FOOTERS &amp;&amp; !INSECURE)
<span class="lineNum">    2442 </span>            : /* Check if (alleged) mstate m has expected magic field */
<span class="lineNum">    2443 </span>            : #define ok_magic(M)      ((M)-&gt;magic == mparams.magic)
<span class="lineNum">    2444 </span>            : #else  /* (FOOTERS &amp;&amp; !INSECURE) */
<span class="lineNum">    2445 </span>            : #define ok_magic(M)      (1)
<span class="lineNum">    2446 </span>            : #endif /* (FOOTERS &amp;&amp; !INSECURE) */
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span>            : /* In gcc, use __builtin_expect to minimize impact of checks */
<span class="lineNum">    2450 </span>            : #if !INSECURE
<span class="lineNum">    2451 </span>            : #if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 3
<span class="lineNum">    2452 </span>            : #define RTCHECK(e)  __builtin_expect(e, 1)
<span class="lineNum">    2453 </span>            : #else /* GNUC */
<span class="lineNum">    2454 </span>            : #define RTCHECK(e)  (e)
<span class="lineNum">    2455 </span>            : #endif /* GNUC */
<span class="lineNum">    2456 </span>            : #else /* !INSECURE */
<span class="lineNum">    2457 </span>            : #define RTCHECK(e)  (1)
<span class="lineNum">    2458 </span>            : #endif /* !INSECURE */
<span class="lineNum">    2459 </span>            : 
<span class="lineNum">    2460 </span>            : /* macros to set up inuse chunks with or without footers */
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span>            : #if !FOOTERS
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span>            : #define mark_inuse_foot(M,p,s)
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span>            : /* Set cinuse bit and pinuse bit of next chunk */
<span class="lineNum">    2467 </span>            : #define set_inuse(M,p,s)\
<span class="lineNum">    2468 </span>            :   ((p)-&gt;head = (((p)-&gt;head &amp; PINUSE_BIT)|s|CINUSE_BIT),\
<span class="lineNum">    2469 </span>            :   ((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT)
<span class="lineNum">    2470 </span>            : 
<span class="lineNum">    2471 </span>            : /* Set cinuse and pinuse of this chunk and pinuse of next chunk */
<span class="lineNum">    2472 </span>            : #define set_inuse_and_pinuse(M,p,s)\
<span class="lineNum">    2473 </span>            :   ((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),\
<span class="lineNum">    2474 </span>            :   ((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT)
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span>            : /* Set size, cinuse and pinuse bit of this chunk */
<span class="lineNum">    2477 </span>            : #define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
<span class="lineNum">    2478 </span>            :   ((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT))
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span>            : #else /* FOOTERS */
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span>            : /* Set foot of inuse chunk to be xor of mstate and seed */
<span class="lineNum">    2483 </span>            : #define mark_inuse_foot(M,p,s)\
<span class="lineNum">    2484 </span>            :   (((mchunkptr)((char*)(p) + (s)))-&gt;prev_foot = ((size_t)(M) ^ mparams.magic))
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span>            : #define get_mstate_for(p)\
<span class="lineNum">    2487 </span>            :   ((mstate)(((mchunkptr)((char*)(p) +\
<span class="lineNum">    2488 </span>            :     (chunksize(p))))-&gt;prev_foot ^ mparams.magic))
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span>            : #define set_inuse(M,p,s)\
<span class="lineNum">    2491 </span>            :   ((p)-&gt;head = (((p)-&gt;head &amp; PINUSE_BIT)|s|CINUSE_BIT),\
<span class="lineNum">    2492 </span>            :   (((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT), \
<span class="lineNum">    2493 </span>            :   mark_inuse_foot(M,p,s))
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            : #define set_inuse_and_pinuse(M,p,s)\
<span class="lineNum">    2496 </span>            :   ((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),\
<span class="lineNum">    2497 </span>            :   (((mchunkptr)(((char*)(p)) + (s)))-&gt;head |= PINUSE_BIT),\
<span class="lineNum">    2498 </span>            :  mark_inuse_foot(M,p,s))
<span class="lineNum">    2499 </span>            : 
<span class="lineNum">    2500 </span>            : #define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
<span class="lineNum">    2501 </span>            :   ((p)-&gt;head = (s|PINUSE_BIT|CINUSE_BIT),\
<span class="lineNum">    2502 </span>            :   mark_inuse_foot(M, p, s))
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span>            : #endif /* !FOOTERS */
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span>            : /* ---------------------------- setting mparams -------------------------- */
<a name="2507"><span class="lineNum">    2507 </span>            : </a>
<span class="lineNum">    2508 </span>            : /* Initialize mparams */
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 : static int init_mparams(void) {</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :   if (mparams.page_size == 0) {</span>
<span class="lineNum">    2511 </span>            :     size_t s;
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :     mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :     mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span>
<span class="lineNum">    2515 </span>            : #if MORECORE_CONTIGUOUS
<span class="lineNum">    2516 </span>            :     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
<span class="lineNum">    2517 </span>            : #else  /* MORECORE_CONTIGUOUS */
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;</span>
<span class="lineNum">    2519 </span>            : #endif /* MORECORE_CONTIGUOUS */
<span class="lineNum">    2520 </span>            : 
<span class="lineNum">    2521 </span>            : #if (FOOTERS &amp;&amp; !INSECURE)
<span class="lineNum">    2522 </span>            :     {
<span class="lineNum">    2523 </span>            : #if USE_DEV_RANDOM
<span class="lineNum">    2524 </span>            :       int fd;
<span class="lineNum">    2525 </span>            :       unsigned char buf[sizeof(size_t)];
<span class="lineNum">    2526 </span>            :       /* Try to use /dev/urandom, else fall back on using time */
<span class="lineNum">    2527 </span>            :       if ((fd = open(&quot;/dev/urandom&quot;, O_RDONLY)) &gt;= 0 &amp;&amp;
<span class="lineNum">    2528 </span>            :           read(fd, buf, sizeof(buf)) == sizeof(buf)) {
<span class="lineNum">    2529 </span>            :         s = *((size_t *) buf);
<span class="lineNum">    2530 </span>            :         close(fd);
<span class="lineNum">    2531 </span>            :       }
<span class="lineNum">    2532 </span>            :       else
<span class="lineNum">    2533 </span>            : #endif /* USE_DEV_RANDOM */
<span class="lineNum">    2534 </span>            :         s = (size_t)(time(0) ^ (size_t)0x55555555U);
<span class="lineNum">    2535 </span>            : 
<span class="lineNum">    2536 </span>            :       s |= (size_t)8U;    /* ensure nonzero */
<span class="lineNum">    2537 </span>            :       s &amp;= ~(size_t)7U;   /* improve chances of fault for bad values */
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            :     }
<span class="lineNum">    2540 </span>            : #else /* (FOOTERS &amp;&amp; !INSECURE) */
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :     s = (size_t)0x58585858U;</span>
<span class="lineNum">    2542 </span>            : #endif /* (FOOTERS &amp;&amp; !INSECURE) */
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :     ACQUIRE_MAGIC_INIT_LOCK();</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :     if (mparams.magic == 0) {</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :       mparams.magic = s;</span>
<span class="lineNum">    2546 </span>            :       /* Set up lock for main malloc area */
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :       INITIAL_LOCK(&amp;gm-&gt;mutex);</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :       gm-&gt;mflags = mparams.default_mflags;</span>
<span class="lineNum">    2549 </span>            :     }
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :     RELEASE_MAGIC_INIT_LOCK();</span>
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            : #if !defined(WIN32) &amp;&amp; !defined(__OS2__)
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :     mparams.page_size = malloc_getpagesize;</span>
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :     mparams.granularity = ((DEFAULT_GRANULARITY != 0)?</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :                            DEFAULT_GRANULARITY : mparams.page_size);</span>
<span class="lineNum">    2556 </span>            : #elif defined (__OS2__)
<span class="lineNum">    2557 </span>            :  /* if low-memory is used, os2munmap() would break
<span class="lineNum">    2558 </span>            :     if it were anything other than 64k */
<span class="lineNum">    2559 </span>            :     mparams.page_size = 4096u;
<span class="lineNum">    2560 </span>            :     mparams.granularity = 65536u;
<span class="lineNum">    2561 </span>            : #else /* WIN32 */
<span class="lineNum">    2562 </span>            :     {
<span class="lineNum">    2563 </span>            :       SYSTEM_INFO system_info;
<span class="lineNum">    2564 </span>            :       GetSystemInfo(&amp;system_info);
<span class="lineNum">    2565 </span>            :       mparams.page_size = system_info.dwPageSize;
<span class="lineNum">    2566 </span>            :       mparams.granularity = system_info.dwAllocationGranularity;
<span class="lineNum">    2567 </span>            :     }
<span class="lineNum">    2568 </span>            : #endif /* WIN32 */
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span>            :     /* Sanity-check configuration:
<span class="lineNum">    2571 </span>            :        size_t must be unsigned and as wide as pointer type.
<span class="lineNum">    2572 </span>            :        ints must be at least 4 bytes.
<span class="lineNum">    2573 </span>            :        alignment must be at least 8.
<span class="lineNum">    2574 </span>            :        Alignment, min chunk size, and page size must all be powers of 2.
<span class="lineNum">    2575 </span>            :     */
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :     if ((sizeof(size_t) != sizeof(char*)) ||</span>
<span class="lineNum">    2577 </span>            :         (MAX_SIZE_T &lt; MIN_CHUNK_SIZE)  ||
<span class="lineNum">    2578 </span>            :         (sizeof(int) &lt; 4)  ||
<span class="lineNum">    2579 </span>            :         (MALLOC_ALIGNMENT &lt; (size_t)8U) ||
<span class="lineNum">    2580 </span>            :         ((MALLOC_ALIGNMENT    &amp; (MALLOC_ALIGNMENT-SIZE_T_ONE))    != 0) ||
<span class="lineNum">    2581 </span>            :         ((MCHUNK_SIZE         &amp; (MCHUNK_SIZE-SIZE_T_ONE))         != 0) ||
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :         ((mparams.granularity &amp; (mparams.granularity-SIZE_T_ONE)) != 0) ||</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :         ((mparams.page_size   &amp; (mparams.page_size-SIZE_T_ONE))   != 0))</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :       ABORT;</span>
<span class="lineNum">    2585 </span>            :   }
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    2587 </span>            : }
<a name="2588"><span class="lineNum">    2588 </span>            : </a>
<span class="lineNum">    2589 </span>            : /* support for mallopt */
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 : static int change_mparam(int param_number, int value) {</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :   size_t val = (size_t)value;</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :   init_mparams();</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :   switch(param_number) {</span>
<span class="lineNum">    2594 </span>            :   case M_TRIM_THRESHOLD:
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :     mparams.trim_threshold = val;</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    2597 </span>            :   case M_GRANULARITY:
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :     if (val &gt;= mparams.page_size &amp;&amp; ((val &amp; (val-1)) == 0)) {</span>
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :       mparams.granularity = val;</span>
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">    2601 </span>            :     }
<span class="lineNum">    2602 </span>            :     else
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    2604 </span>            :   case M_MMAP_THRESHOLD:
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :     mparams.mmap_threshold = val;</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    2607 </span>            :   default:
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    2609 </span>            :   }
<span class="lineNum">    2610 </span>            : }
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span>            : #if DEBUG
<span class="lineNum">    2613 </span>            : /* ------------------------- Debugging Support --------------------------- */
<a name="2614"><span class="lineNum">    2614 </span>            : </a>
<span class="lineNum">    2615 </span>            : /* Check properties of any chunk, whether free, inuse, mmapped etc  */
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 : static void do_check_any_chunk(mstate m, mchunkptr p) {</span>
<span class="lineNum">    2617 </span><span class="lineNoCov">          0 :   assert((is_aligned(chunk2mem(p))) || (p-&gt;head == FENCEPOST_HEAD));</span>
<span class="lineNum">    2618 </span><span class="lineNoCov">          0 :   assert(ok_address(m, p));</span>
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 : }</span>
<a name="2620"><span class="lineNum">    2620 </span>            : </a>
<span class="lineNum">    2621 </span>            : /* Check properties of top chunk */
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 : static void do_check_top_chunk(mstate m, mchunkptr p) {</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :   msegmentptr sp = segment_holding(m, (char*)p);</span>
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :   size_t  sz = chunksize(p);</span>
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :   assert(sp != 0);</span>
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :   assert((is_aligned(chunk2mem(p))) || (p-&gt;head == FENCEPOST_HEAD));</span>
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :   assert(ok_address(m, p));</span>
<span class="lineNum">    2628 </span><span class="lineNoCov">          0 :   assert(sz == m-&gt;topsize);</span>
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :   assert(sz &gt; 0);</span>
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :   assert(sz == ((sp-&gt;base + sp-&gt;size) - (char*)p) - TOP_FOOT_SIZE);</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :   assert(pinuse(p));</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :   assert(!next_pinuse(p));</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 : }</span>
<a name="2634"><span class="lineNum">    2634 </span>            : </a>
<span class="lineNum">    2635 </span>            : /* Check properties of (inuse) mmapped chunks */
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 : static void do_check_mmapped_chunk(mstate m, mchunkptr p) {</span>
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :   size_t  sz = chunksize(p);</span>
<span class="lineNum">    2638 </span><span class="lineNoCov">          0 :   size_t len = (sz + (p-&gt;prev_foot &amp; ~IS_MMAPPED_BIT) + MMAP_FOOT_PAD);</span>
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :   assert(is_mmapped(p));</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :   assert(use_mmap(m));</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :   assert((is_aligned(chunk2mem(p))) || (p-&gt;head == FENCEPOST_HEAD));</span>
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :   assert(ok_address(m, p));</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :   assert(!is_small(sz));</span>
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :   assert((len &amp; (mparams.page_size-SIZE_T_ONE)) == 0);</span>
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :   assert(chunk_plus_offset(p, sz)-&gt;head == FENCEPOST_HEAD);</span>
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :   assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)-&gt;head == 0);</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 : }</span>
<a name="2648"><span class="lineNum">    2648 </span>            : </a>
<span class="lineNum">    2649 </span>            : /* Check properties of inuse chunks */
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 : static void do_check_inuse_chunk(mstate m, mchunkptr p) {</span>
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :   do_check_any_chunk(m, p);</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :   assert(cinuse(p));</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :   assert(next_pinuse(p));</span>
<span class="lineNum">    2654 </span>            :   /* If not pinuse and not mmapped, previous chunk has OK offset */
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :   assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :   if (is_mmapped(p))</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :     do_check_mmapped_chunk(m, p);</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 : }</span>
<a name="2659"><span class="lineNum">    2659 </span>            : </a>
<span class="lineNum">    2660 </span>            : /* Check properties of free chunks */
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 : static void do_check_free_chunk(mstate m, mchunkptr p) {</span>
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :   size_t sz = p-&gt;head &amp; ~(PINUSE_BIT|CINUSE_BIT);</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :   mchunkptr next = chunk_plus_offset(p, sz);</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :   do_check_any_chunk(m, p);</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :   assert(!cinuse(p));</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :   assert(!next_pinuse(p));</span>
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :   assert (!is_mmapped(p));</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :   if (p != m-&gt;dv &amp;&amp; p != m-&gt;top) {</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :     if (sz &gt;= MIN_CHUNK_SIZE) {</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :       assert((sz &amp; CHUNK_ALIGN_MASK) == 0);</span>
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :       assert(is_aligned(chunk2mem(p)));</span>
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :       assert(next-&gt;prev_foot == sz);</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :       assert(pinuse(p));</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :       assert (next == m-&gt;top || cinuse(next));</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :       assert(p-&gt;fd-&gt;bk == p);</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :       assert(p-&gt;bk-&gt;fd == p);</span>
<span class="lineNum">    2677 </span>            :     }
<span class="lineNum">    2678 </span>            :     else  /* markers are always of size SIZE_T_SIZE */
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :       assert(sz == SIZE_T_SIZE);</span>
<span class="lineNum">    2680 </span>            :   }
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 : }</span>
<a name="2682"><span class="lineNum">    2682 </span>            : </a>
<span class="lineNum">    2683 </span>            : /* Check properties of malloced chunks at the point they are malloced */
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 : static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :   if (mem != 0) {</span>
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 :     mchunkptr p = mem2chunk(mem);</span>
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :     size_t sz = p-&gt;head &amp; ~(PINUSE_BIT|CINUSE_BIT);</span>
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :     do_check_inuse_chunk(m, p);</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :     assert((sz &amp; CHUNK_ALIGN_MASK) == 0);</span>
<span class="lineNum">    2690 </span><span class="lineNoCov">          0 :     assert(sz &gt;= MIN_CHUNK_SIZE);</span>
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :     assert(sz &gt;= s);</span>
<span class="lineNum">    2692 </span>            :     /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :     assert(is_mmapped(p) || sz &lt; (s + MIN_CHUNK_SIZE));</span>
<span class="lineNum">    2694 </span>            :   }
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 : }</span>
<a name="2696"><span class="lineNum">    2696 </span>            : </a>
<span class="lineNum">    2697 </span>            : /* Check a tree and its subtrees.  */
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 : static void do_check_tree(mstate m, tchunkptr t) {</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :   tchunkptr head = 0;</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :   tchunkptr u = t;</span>
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :   bindex_t tindex = t-&gt;index;</span>
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :   size_t tsize = chunksize(t);</span>
<span class="lineNum">    2703 </span>            :   bindex_t idx;
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :   compute_tree_index(tsize, idx);</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :   assert(tindex == idx);</span>
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :   assert(tsize &gt;= MIN_LARGE_SIZE);</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :   assert(tsize &gt;= minsize_for_tree_index(idx));</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :   assert((idx == NTREEBINS-1) || (tsize &lt; minsize_for_tree_index((idx+1))));</span>
<span class="lineNum">    2709 </span>            : 
<span class="lineNum">    2710 </span>            :   do { /* traverse through chain of same-sized nodes */
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :     do_check_any_chunk(m, ((mchunkptr)u));</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :     assert(u-&gt;index == tindex);</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :     assert(chunksize(u) == tsize);</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :     assert(!cinuse(u));</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :     assert(!next_pinuse(u));</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :     assert(u-&gt;fd-&gt;bk == u);</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :     assert(u-&gt;bk-&gt;fd == u);</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :     if (u-&gt;parent == 0) {</span>
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :       assert(u-&gt;child[0] == 0);</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :       assert(u-&gt;child[1] == 0);</span>
<span class="lineNum">    2721 </span>            :     }
<span class="lineNum">    2722 </span>            :     else {
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :       assert(head == 0); /* only one node on chain has parent */</span>
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :       head = u;</span>
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :       assert(u-&gt;parent != u);</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :       assert (u-&gt;parent-&gt;child[0] == u ||</span>
<span class="lineNum">    2727 </span>            :               u-&gt;parent-&gt;child[1] == u ||
<span class="lineNum">    2728 </span>            :               *((tbinptr*)(u-&gt;parent)) == u);
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :       if (u-&gt;child[0] != 0) {</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :         assert(u-&gt;child[0]-&gt;parent == u);</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :         assert(u-&gt;child[0] != u);</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :         do_check_tree(m, u-&gt;child[0]);</span>
<span class="lineNum">    2733 </span>            :       }
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :       if (u-&gt;child[1] != 0) {</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :         assert(u-&gt;child[1]-&gt;parent == u);</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :         assert(u-&gt;child[1] != u);</span>
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :         do_check_tree(m, u-&gt;child[1]);</span>
<span class="lineNum">    2738 </span>            :       }
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :       if (u-&gt;child[0] != 0 &amp;&amp; u-&gt;child[1] != 0) {</span>
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :         assert(chunksize(u-&gt;child[0]) &lt; chunksize(u-&gt;child[1]));</span>
<span class="lineNum">    2741 </span>            :       }
<span class="lineNum">    2742 </span>            :     }
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :     u = u-&gt;fd;</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :   } while (u != t);</span>
<span class="lineNum">    2745 </span><span class="lineNoCov">          0 :   assert(head != 0);</span>
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 : }</span>
<a name="2747"><span class="lineNum">    2747 </span>            : </a>
<span class="lineNum">    2748 </span>            : /*  Check all the chunks in a treebin.  */
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 : static void do_check_treebin(mstate m, bindex_t i) {</span>
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :   tbinptr* tb = treebin_at(m, i);</span>
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :   tchunkptr t = *tb;</span>
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :   int empty = (m-&gt;treemap &amp; (1U &lt;&lt; i)) == 0;</span>
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :   if (t == 0)</span>
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :     assert(empty);</span>
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :   if (!empty)</span>
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :     do_check_tree(m, t);</span>
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 : }</span>
<a name="2758"><span class="lineNum">    2758 </span>            : </a>
<span class="lineNum">    2759 </span>            : /*  Check all the chunks in a smallbin.  */
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 : static void do_check_smallbin(mstate m, bindex_t i) {</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :   sbinptr b = smallbin_at(m, i);</span>
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :   mchunkptr p = b-&gt;bk;</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :   unsigned int empty = (m-&gt;smallmap &amp; (1U &lt;&lt; i)) == 0;</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :   if (p == b)</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :     assert(empty);</span>
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :   if (!empty) {</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :     for (; p != b; p = p-&gt;bk) {</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :       size_t size = chunksize(p);</span>
<span class="lineNum">    2769 </span>            :       mchunkptr q;
<span class="lineNum">    2770 </span>            :       /* each chunk claims to be free */
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :       do_check_free_chunk(m, p);</span>
<span class="lineNum">    2772 </span>            :       /* chunk belongs in bin */
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :       assert(small_index(size) == i);</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :       assert(p-&gt;bk == b || chunksize(p-&gt;bk) == chunksize(p));</span>
<span class="lineNum">    2775 </span>            :       /* chunk is followed by an inuse chunk */
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :       q = next_chunk(p);</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :       if (q-&gt;head != FENCEPOST_HEAD)</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :         do_check_inuse_chunk(m, q);</span>
<span class="lineNum">    2779 </span>            :     }
<span class="lineNum">    2780 </span>            :   }
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 : }</span>
<a name="2782"><span class="lineNum">    2782 </span>            : </a>
<span class="lineNum">    2783 </span>            : /* Find x in a bin. Used in other check functions. */
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 : static int bin_find(mstate m, mchunkptr x) {</span>
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :   size_t size = chunksize(x);</span>
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :   if (is_small(size)) {</span>
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :     bindex_t sidx = small_index(size);</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :     sbinptr b = smallbin_at(m, sidx);</span>
<span class="lineNum">    2789 </span><span class="lineNoCov">          0 :     if (smallmap_is_marked(m, sidx)) {</span>
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :       mchunkptr p = b;</span>
<span class="lineNum">    2791 </span>            :       do {
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :         if (p == x)</span>
<span class="lineNum">    2793 </span><span class="lineNoCov">          0 :           return 1;</span>
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :       } while ((p = p-&gt;fd) != b);</span>
<span class="lineNum">    2795 </span>            :     }
<span class="lineNum">    2796 </span>            :   }
<span class="lineNum">    2797 </span>            :   else {
<span class="lineNum">    2798 </span>            :     bindex_t tidx;
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :     compute_tree_index(size, tidx);</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     if (treemap_is_marked(m, tidx)) {</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :       tchunkptr t = *treebin_at(m, tidx);</span>
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :       size_t sizebits = size &lt;&lt; leftshift_for_tree_index(tidx);</span>
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :       while (t != 0 &amp;&amp; chunksize(t) != size) {</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :         t = t-&gt;child[(sizebits &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE)) &amp; 1];</span>
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :         sizebits &lt;&lt;= 1;</span>
<span class="lineNum">    2806 </span>            :       }
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :       if (t != 0) {</span>
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :         tchunkptr u = t;</span>
<span class="lineNum">    2809 </span>            :         do {
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :           if (u == (tchunkptr)x)</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :             return 1;</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :         } while ((u = u-&gt;fd) != t);</span>
<span class="lineNum">    2813 </span>            :       }
<span class="lineNum">    2814 </span>            :     }
<span class="lineNum">    2815 </span>            :   }
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    2817 </span>            : }
<a name="2818"><span class="lineNum">    2818 </span>            : </a>
<span class="lineNum">    2819 </span>            : /* Traverse each chunk and check it; return total */
<span class="lineNum">    2820 </span><span class="lineNoCov">          0 : static size_t traverse_and_check(mstate m) {</span>
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :   size_t sum = 0;</span>
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :   if (is_initialized(m)) {</span>
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 :     msegmentptr s = &amp;m-&gt;seg;</span>
<span class="lineNum">    2824 </span><span class="lineNoCov">          0 :     sum += m-&gt;topsize + TOP_FOOT_SIZE;</span>
<span class="lineNum">    2825 </span><span class="lineNoCov">          0 :     while (s != 0) {</span>
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :       mchunkptr q = align_as_chunk(s-&gt;base);</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :       mchunkptr lastq = 0;</span>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :       assert(pinuse(q));</span>
<span class="lineNum">    2829 </span><span class="lineNoCov">          0 :       while (segment_holds(s, q) &amp;&amp;</span>
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :              q != m-&gt;top &amp;&amp; q-&gt;head != FENCEPOST_HEAD) {</span>
<span class="lineNum">    2831 </span><span class="lineNoCov">          0 :         sum += chunksize(q);</span>
<span class="lineNum">    2832 </span><span class="lineNoCov">          0 :         if (cinuse(q)) {</span>
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :           assert(!bin_find(m, q));</span>
<span class="lineNum">    2834 </span><span class="lineNoCov">          0 :           do_check_inuse_chunk(m, q);</span>
<span class="lineNum">    2835 </span>            :         }
<span class="lineNum">    2836 </span>            :         else {
<span class="lineNum">    2837 </span><span class="lineNoCov">          0 :           assert(q == m-&gt;dv || bin_find(m, q));</span>
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :           assert(lastq == 0 || cinuse(lastq)); /* Not 2 consecutive free */</span>
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :           do_check_free_chunk(m, q);</span>
<span class="lineNum">    2840 </span>            :         }
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :         lastq = q;</span>
<span class="lineNum">    2842 </span><span class="lineNoCov">          0 :         q = next_chunk(q);</span>
<span class="lineNum">    2843 </span>            :       }
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 :       s = s-&gt;next;</span>
<span class="lineNum">    2845 </span>            :     }
<span class="lineNum">    2846 </span>            :   }
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :   return sum;</span>
<span class="lineNum">    2848 </span>            : }
<a name="2849"><span class="lineNum">    2849 </span>            : </a>
<span class="lineNum">    2850 </span>            : /* Check all properties of malloc_state. */
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 : static void do_check_malloc_state(mstate m) {</span>
<span class="lineNum">    2852 </span>            :   bindex_t i;
<span class="lineNum">    2853 </span>            :   size_t total;
<span class="lineNum">    2854 </span>            :   /* check bins */
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NSMALLBINS; ++i)</span>
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :     do_check_smallbin(m, i);</span>
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NTREEBINS; ++i)</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :     do_check_treebin(m, i);</span>
<span class="lineNum">    2859 </span>            : 
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :   if (m-&gt;dvsize != 0) { /* check dv chunk */</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :     do_check_any_chunk(m, m-&gt;dv);</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :     assert(m-&gt;dvsize == chunksize(m-&gt;dv));</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :     assert(m-&gt;dvsize &gt;= MIN_CHUNK_SIZE);</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :     assert(bin_find(m, m-&gt;dv) == 0);</span>
<span class="lineNum">    2865 </span>            :   }
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :   if (m-&gt;top != 0) {   /* check top chunk */</span>
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :     do_check_top_chunk(m, m-&gt;top);</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :     assert(m-&gt;topsize == chunksize(m-&gt;top));</span>
<span class="lineNum">    2870 </span><span class="lineNoCov">          0 :     assert(m-&gt;topsize &gt; 0);</span>
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :     assert(bin_find(m, m-&gt;top) == 0);</span>
<span class="lineNum">    2872 </span>            :   }
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :   total = traverse_and_check(m);</span>
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :   assert(total &lt;= m-&gt;footprint);</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :   assert(m-&gt;footprint &lt;= m-&gt;max_footprint);</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2878 </span>            : #endif /* DEBUG */
<span class="lineNum">    2879 </span>            : 
<span class="lineNum">    2880 </span>            : /* ----------------------------- statistics ------------------------------ */
<span class="lineNum">    2881 </span>            : 
<span class="lineNum">    2882 </span>            : #if !NO_MALLINFO
<span class="lineNum">    2883 </span>            : static struct mallinfo internal_mallinfo(mstate m) {
<span class="lineNum">    2884 </span>            :   struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
<span class="lineNum">    2885 </span>            :   if (!PREACTION(m)) {
<span class="lineNum">    2886 </span>            :     check_malloc_state(m);
<span class="lineNum">    2887 </span>            :     if (is_initialized(m)) {
<span class="lineNum">    2888 </span>            :       size_t nfree = SIZE_T_ONE; /* top always free */
<span class="lineNum">    2889 </span>            :       size_t mfree = m-&gt;topsize + TOP_FOOT_SIZE;
<span class="lineNum">    2890 </span>            :       size_t sum = mfree;
<span class="lineNum">    2891 </span>            :       msegmentptr s = &amp;m-&gt;seg;
<span class="lineNum">    2892 </span>            :       while (s != 0) {
<span class="lineNum">    2893 </span>            :         mchunkptr q = align_as_chunk(s-&gt;base);
<span class="lineNum">    2894 </span>            :         while (segment_holds(s, q) &amp;&amp;
<span class="lineNum">    2895 </span>            :                q != m-&gt;top &amp;&amp; q-&gt;head != FENCEPOST_HEAD) {
<span class="lineNum">    2896 </span>            :           size_t sz = chunksize(q);
<span class="lineNum">    2897 </span>            :           sum += sz;
<span class="lineNum">    2898 </span>            :           if (!cinuse(q)) {
<span class="lineNum">    2899 </span>            :             mfree += sz;
<span class="lineNum">    2900 </span>            :             ++nfree;
<span class="lineNum">    2901 </span>            :           }
<span class="lineNum">    2902 </span>            :           q = next_chunk(q);
<span class="lineNum">    2903 </span>            :         }
<span class="lineNum">    2904 </span>            :         s = s-&gt;next;
<span class="lineNum">    2905 </span>            :       }
<span class="lineNum">    2906 </span>            : 
<span class="lineNum">    2907 </span>            :       nm.arena    = sum;
<span class="lineNum">    2908 </span>            :       nm.ordblks  = nfree;
<span class="lineNum">    2909 </span>            :       nm.hblkhd   = m-&gt;footprint - sum;
<span class="lineNum">    2910 </span>            :       nm.usmblks  = m-&gt;max_footprint;
<span class="lineNum">    2911 </span>            :       nm.uordblks = m-&gt;footprint - mfree;
<span class="lineNum">    2912 </span>            :       nm.fordblks = mfree;
<span class="lineNum">    2913 </span>            :       nm.keepcost = m-&gt;topsize;
<span class="lineNum">    2914 </span>            :     }
<span class="lineNum">    2915 </span>            : 
<span class="lineNum">    2916 </span>            :     POSTACTION(m);
<span class="lineNum">    2917 </span>            :   }
<span class="lineNum">    2918 </span>            :   return nm;
<span class="lineNum">    2919 </span>            : }
<a name="2920"><span class="lineNum">    2920 </span>            : #endif /* !NO_MALLINFO */</a>
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 : static void internal_malloc_stats(mstate m) {</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :   if (!PREACTION(m)) {</span>
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :     size_t maxfp = 0;</span>
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :     size_t fp = 0;</span>
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :     size_t used = 0;</span>
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :     check_malloc_state(m);</span>
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :     if (is_initialized(m)) {</span>
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :       msegmentptr s = &amp;m-&gt;seg;</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :       maxfp = m-&gt;max_footprint;</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :       fp = m-&gt;footprint;</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :       used = fp - (m-&gt;topsize + TOP_FOOT_SIZE);</span>
<span class="lineNum">    2933 </span>            : 
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :       while (s != 0) {</span>
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :         mchunkptr q = align_as_chunk(s-&gt;base);</span>
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :         while (segment_holds(s, q) &amp;&amp;</span>
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :                q != m-&gt;top &amp;&amp; q-&gt;head != FENCEPOST_HEAD) {</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :           if (!cinuse(q))</span>
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :             used -= chunksize(q);</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :           q = next_chunk(q);</span>
<span class="lineNum">    2941 </span>            :         }
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :         s = s-&gt;next;</span>
<span class="lineNum">    2943 </span>            :       }
<span class="lineNum">    2944 </span>            :     }
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :     fprintf(stderr, &quot;max system bytes = %10lu\n&quot;, (unsigned long)(maxfp));</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :     fprintf(stderr, &quot;system bytes     = %10lu\n&quot;, (unsigned long)(fp));</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :     fprintf(stderr, &quot;in use bytes     = %10lu\n&quot;, (unsigned long)(used));</span>
<span class="lineNum">    2949 </span>            : 
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :     POSTACTION(m);</span>
<span class="lineNum">    2951 </span>            :   }
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span>            : /* ----------------------- Operations on smallbins ----------------------- */
<span class="lineNum">    2955 </span>            : 
<span class="lineNum">    2956 </span>            : /*
<span class="lineNum">    2957 </span>            :   Various forms of linking and unlinking are defined as macros.  Even
<span class="lineNum">    2958 </span>            :   the ones for trees, which are very long but have very short typical
<span class="lineNum">    2959 </span>            :   paths.  This is ugly but reduces reliance on inlining support of
<span class="lineNum">    2960 </span>            :   compilers.
<span class="lineNum">    2961 </span>            : */
<span class="lineNum">    2962 </span>            : 
<span class="lineNum">    2963 </span>            : /* Link a free chunk into a smallbin  */
<span class="lineNum">    2964 </span>            : #define insert_small_chunk(M, P, S) {\
<span class="lineNum">    2965 </span>            :   bindex_t I  = small_index(S);\
<span class="lineNum">    2966 </span>            :   mchunkptr B = smallbin_at(M, I);\
<span class="lineNum">    2967 </span>            :   mchunkptr F = B;\
<span class="lineNum">    2968 </span>            :   assert(S &gt;= MIN_CHUNK_SIZE);\
<span class="lineNum">    2969 </span>            :   if (!smallmap_is_marked(M, I))\
<span class="lineNum">    2970 </span>            :     mark_smallmap(M, I);\
<span class="lineNum">    2971 </span>            :   else if (RTCHECK(ok_address(M, B-&gt;fd)))\
<span class="lineNum">    2972 </span>            :     F = B-&gt;fd;\
<span class="lineNum">    2973 </span>            :   else {\
<span class="lineNum">    2974 </span>            :     CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    2975 </span>            :   }\
<span class="lineNum">    2976 </span>            :   B-&gt;fd = P;\
<span class="lineNum">    2977 </span>            :   F-&gt;bk = P;\
<span class="lineNum">    2978 </span>            :   P-&gt;fd = F;\
<span class="lineNum">    2979 </span>            :   P-&gt;bk = B;\
<span class="lineNum">    2980 </span>            : }
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span>            : /* Unlink a chunk from a smallbin  */
<span class="lineNum">    2983 </span>            : #define unlink_small_chunk(M, P, S) {\
<span class="lineNum">    2984 </span>            :   mchunkptr F = P-&gt;fd;\
<span class="lineNum">    2985 </span>            :   mchunkptr B = P-&gt;bk;\
<span class="lineNum">    2986 </span>            :   bindex_t I = small_index(S);\
<span class="lineNum">    2987 </span>            :   assert(P != B);\
<span class="lineNum">    2988 </span>            :   assert(P != F);\
<span class="lineNum">    2989 </span>            :   assert(chunksize(P) == small_index2size(I));\
<span class="lineNum">    2990 </span>            :   if (F == B)\
<span class="lineNum">    2991 </span>            :     clear_smallmap(M, I);\
<span class="lineNum">    2992 </span>            :   else if (RTCHECK((F == smallbin_at(M,I) || ok_address(M, F)) &amp;&amp;\
<span class="lineNum">    2993 </span>            :                    (B == smallbin_at(M,I) || ok_address(M, B)))) {\
<span class="lineNum">    2994 </span>            :     F-&gt;bk = B;\
<span class="lineNum">    2995 </span>            :     B-&gt;fd = F;\
<span class="lineNum">    2996 </span>            :   }\
<span class="lineNum">    2997 </span>            :   else {\
<span class="lineNum">    2998 </span>            :     CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    2999 </span>            :   }\
<span class="lineNum">    3000 </span>            : }
<span class="lineNum">    3001 </span>            : 
<span class="lineNum">    3002 </span>            : /* Unlink the first chunk from a smallbin */
<span class="lineNum">    3003 </span>            : #define unlink_first_small_chunk(M, B, P, I) {\
<span class="lineNum">    3004 </span>            :   mchunkptr F = P-&gt;fd;\
<span class="lineNum">    3005 </span>            :   assert(P != B);\
<span class="lineNum">    3006 </span>            :   assert(P != F);\
<span class="lineNum">    3007 </span>            :   assert(chunksize(P) == small_index2size(I));\
<span class="lineNum">    3008 </span>            :   if (B == F)\
<span class="lineNum">    3009 </span>            :     clear_smallmap(M, I);\
<span class="lineNum">    3010 </span>            :   else if (RTCHECK(ok_address(M, F))) {\
<span class="lineNum">    3011 </span>            :     B-&gt;fd = F;\
<span class="lineNum">    3012 </span>            :     F-&gt;bk = B;\
<span class="lineNum">    3013 </span>            :   }\
<span class="lineNum">    3014 </span>            :   else {\
<span class="lineNum">    3015 </span>            :     CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3016 </span>            :   }\
<span class="lineNum">    3017 </span>            : }
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span>            : /* Replace dv node, binning the old one */
<span class="lineNum">    3020 </span>            : /* Used only when dvsize known to be small */
<span class="lineNum">    3021 </span>            : #define replace_dv(M, P, S) {\
<span class="lineNum">    3022 </span>            :   size_t DVS = M-&gt;dvsize;\
<span class="lineNum">    3023 </span>            :   if (DVS != 0) {\
<span class="lineNum">    3024 </span>            :     mchunkptr DV = M-&gt;dv;\
<span class="lineNum">    3025 </span>            :     assert(is_small(DVS));\
<span class="lineNum">    3026 </span>            :     insert_small_chunk(M, DV, DVS);\
<span class="lineNum">    3027 </span>            :   }\
<span class="lineNum">    3028 </span>            :   M-&gt;dvsize = S;\
<span class="lineNum">    3029 </span>            :   M-&gt;dv = P;\
<span class="lineNum">    3030 </span>            : }
<span class="lineNum">    3031 </span>            : 
<span class="lineNum">    3032 </span>            : /* ------------------------- Operations on trees ------------------------- */
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span>            : /* Insert chunk into tree */
<span class="lineNum">    3035 </span>            : #define insert_large_chunk(M, X, S) {\
<span class="lineNum">    3036 </span>            :   tbinptr* H;\
<span class="lineNum">    3037 </span>            :   bindex_t I;\
<span class="lineNum">    3038 </span>            :   compute_tree_index(S, I);\
<span class="lineNum">    3039 </span>            :   H = treebin_at(M, I);\
<span class="lineNum">    3040 </span>            :   X-&gt;index = I;\
<span class="lineNum">    3041 </span>            :   X-&gt;child[0] = X-&gt;child[1] = 0;\
<span class="lineNum">    3042 </span>            :   if (!treemap_is_marked(M, I)) {\
<span class="lineNum">    3043 </span>            :     mark_treemap(M, I);\
<span class="lineNum">    3044 </span>            :     *H = X;\
<span class="lineNum">    3045 </span>            :     X-&gt;parent = (tchunkptr)H;\
<span class="lineNum">    3046 </span>            :     X-&gt;fd = X-&gt;bk = X;\
<span class="lineNum">    3047 </span>            :   }\
<span class="lineNum">    3048 </span>            :   else {\
<span class="lineNum">    3049 </span>            :     tchunkptr T = *H;\
<span class="lineNum">    3050 </span>            :     size_t K = S &lt;&lt; leftshift_for_tree_index(I);\
<span class="lineNum">    3051 </span>            :     for (;;) {\
<span class="lineNum">    3052 </span>            :       if (chunksize(T) != S) {\
<span class="lineNum">    3053 </span>            :         tchunkptr* C = &amp;(T-&gt;child[(K &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE)) &amp; 1]);\
<span class="lineNum">    3054 </span>            :         K &lt;&lt;= 1;\
<span class="lineNum">    3055 </span>            :         if (*C != 0)\
<span class="lineNum">    3056 </span>            :           T = *C;\
<span class="lineNum">    3057 </span>            :         else if (RTCHECK(ok_address(M, C))) {\
<span class="lineNum">    3058 </span>            :           *C = X;\
<span class="lineNum">    3059 </span>            :           X-&gt;parent = T;\
<span class="lineNum">    3060 </span>            :           X-&gt;fd = X-&gt;bk = X;\
<span class="lineNum">    3061 </span>            :           break;\
<span class="lineNum">    3062 </span>            :         }\
<span class="lineNum">    3063 </span>            :         else {\
<span class="lineNum">    3064 </span>            :           CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3065 </span>            :           break;\
<span class="lineNum">    3066 </span>            :         }\
<span class="lineNum">    3067 </span>            :       }\
<span class="lineNum">    3068 </span>            :       else {\
<span class="lineNum">    3069 </span>            :         tchunkptr F = T-&gt;fd;\
<span class="lineNum">    3070 </span>            :         if (RTCHECK(ok_address(M, T) &amp;&amp; ok_address(M, F))) {\
<span class="lineNum">    3071 </span>            :           T-&gt;fd = F-&gt;bk = X;\
<span class="lineNum">    3072 </span>            :           X-&gt;fd = F;\
<span class="lineNum">    3073 </span>            :           X-&gt;bk = T;\
<span class="lineNum">    3074 </span>            :           X-&gt;parent = 0;\
<span class="lineNum">    3075 </span>            :           break;\
<span class="lineNum">    3076 </span>            :         }\
<span class="lineNum">    3077 </span>            :         else {\
<span class="lineNum">    3078 </span>            :           CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3079 </span>            :           break;\
<span class="lineNum">    3080 </span>            :         }\
<span class="lineNum">    3081 </span>            :       }\
<span class="lineNum">    3082 </span>            :     }\
<span class="lineNum">    3083 </span>            :   }\
<span class="lineNum">    3084 </span>            : }
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span>            : /*
<span class="lineNum">    3087 </span>            :   Unlink steps:
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span>            :   1. If x is a chained node, unlink it from its same-sized fd/bk links
<span class="lineNum">    3090 </span>            :      and choose its bk node as its replacement.
<span class="lineNum">    3091 </span>            :   2. If x was the last node of its size, but not a leaf node, it must
<span class="lineNum">    3092 </span>            :      be replaced with a leaf node (not merely one with an open left or
<span class="lineNum">    3093 </span>            :      right), to make sure that lefts and rights of descendants
<span class="lineNum">    3094 </span>            :      correspond properly to bit masks.  We use the rightmost descendant
<span class="lineNum">    3095 </span>            :      of x.  We could use any other leaf, but this is easy to locate and
<span class="lineNum">    3096 </span>            :      tends to counteract removal of leftmosts elsewhere, and so keeps
<span class="lineNum">    3097 </span>            :      paths shorter than minimally guaranteed.  This doesn't loop much
<span class="lineNum">    3098 </span>            :      because on average a node in a tree is near the bottom.
<span class="lineNum">    3099 </span>            :   3. If x is the base of a chain (i.e., has parent links) relink
<span class="lineNum">    3100 </span>            :      x's parent and children to x's replacement (or null if none).
<span class="lineNum">    3101 </span>            : */
<span class="lineNum">    3102 </span>            : 
<span class="lineNum">    3103 </span>            : #define unlink_large_chunk(M, X) {\
<span class="lineNum">    3104 </span>            :   tchunkptr XP = X-&gt;parent;\
<span class="lineNum">    3105 </span>            :   tchunkptr R;\
<span class="lineNum">    3106 </span>            :   if (X-&gt;bk != X) {\
<span class="lineNum">    3107 </span>            :     tchunkptr F = X-&gt;fd;\
<span class="lineNum">    3108 </span>            :     R = X-&gt;bk;\
<span class="lineNum">    3109 </span>            :     if (RTCHECK(ok_address(M, F))) {\
<span class="lineNum">    3110 </span>            :       F-&gt;bk = R;\
<span class="lineNum">    3111 </span>            :       R-&gt;fd = F;\
<span class="lineNum">    3112 </span>            :     }\
<span class="lineNum">    3113 </span>            :     else {\
<span class="lineNum">    3114 </span>            :       CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3115 </span>            :     }\
<span class="lineNum">    3116 </span>            :   }\
<span class="lineNum">    3117 </span>            :   else {\
<span class="lineNum">    3118 </span>            :     tchunkptr* RP;\
<span class="lineNum">    3119 </span>            :     if (((R = *(RP = &amp;(X-&gt;child[1]))) != 0) ||\
<span class="lineNum">    3120 </span>            :         ((R = *(RP = &amp;(X-&gt;child[0]))) != 0)) {\
<span class="lineNum">    3121 </span>            :       tchunkptr* CP;\
<span class="lineNum">    3122 </span>            :       while ((*(CP = &amp;(R-&gt;child[1])) != 0) ||\
<span class="lineNum">    3123 </span>            :              (*(CP = &amp;(R-&gt;child[0])) != 0)) {\
<span class="lineNum">    3124 </span>            :         R = *(RP = CP);\
<span class="lineNum">    3125 </span>            :       }\
<span class="lineNum">    3126 </span>            :       if (RTCHECK(ok_address(M, RP)))\
<span class="lineNum">    3127 </span>            :         *RP = 0;\
<span class="lineNum">    3128 </span>            :       else {\
<span class="lineNum">    3129 </span>            :         CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3130 </span>            :       }\
<span class="lineNum">    3131 </span>            :     }\
<span class="lineNum">    3132 </span>            :   }\
<span class="lineNum">    3133 </span>            :   if (XP != 0) {\
<span class="lineNum">    3134 </span>            :     tbinptr* H = treebin_at(M, X-&gt;index);\
<span class="lineNum">    3135 </span>            :     if (X == *H) {\
<span class="lineNum">    3136 </span>            :       if ((*H = R) == 0) \
<span class="lineNum">    3137 </span>            :         clear_treemap(M, X-&gt;index);\
<span class="lineNum">    3138 </span>            :     }\
<span class="lineNum">    3139 </span>            :     else if (RTCHECK(ok_address(M, XP))) {\
<span class="lineNum">    3140 </span>            :       if (XP-&gt;child[0] == X) \
<span class="lineNum">    3141 </span>            :         XP-&gt;child[0] = R;\
<span class="lineNum">    3142 </span>            :       else \
<span class="lineNum">    3143 </span>            :         XP-&gt;child[1] = R;\
<span class="lineNum">    3144 </span>            :     }\
<span class="lineNum">    3145 </span>            :     else\
<span class="lineNum">    3146 </span>            :       CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3147 </span>            :     if (R != 0) {\
<span class="lineNum">    3148 </span>            :       if (RTCHECK(ok_address(M, R))) {\
<span class="lineNum">    3149 </span>            :         tchunkptr C0, C1;\
<span class="lineNum">    3150 </span>            :         R-&gt;parent = XP;\
<span class="lineNum">    3151 </span>            :         if ((C0 = X-&gt;child[0]) != 0) {\
<span class="lineNum">    3152 </span>            :           if (RTCHECK(ok_address(M, C0))) {\
<span class="lineNum">    3153 </span>            :             R-&gt;child[0] = C0;\
<span class="lineNum">    3154 </span>            :             C0-&gt;parent = R;\
<span class="lineNum">    3155 </span>            :           }\
<span class="lineNum">    3156 </span>            :           else\
<span class="lineNum">    3157 </span>            :             CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3158 </span>            :         }\
<span class="lineNum">    3159 </span>            :         if ((C1 = X-&gt;child[1]) != 0) {\
<span class="lineNum">    3160 </span>            :           if (RTCHECK(ok_address(M, C1))) {\
<span class="lineNum">    3161 </span>            :             R-&gt;child[1] = C1;\
<span class="lineNum">    3162 </span>            :             C1-&gt;parent = R;\
<span class="lineNum">    3163 </span>            :           }\
<span class="lineNum">    3164 </span>            :           else\
<span class="lineNum">    3165 </span>            :             CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3166 </span>            :         }\
<span class="lineNum">    3167 </span>            :       }\
<span class="lineNum">    3168 </span>            :       else\
<span class="lineNum">    3169 </span>            :         CORRUPTION_ERROR_ACTION(M);\
<span class="lineNum">    3170 </span>            :     }\
<span class="lineNum">    3171 </span>            :   }\
<span class="lineNum">    3172 </span>            : }
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span>            : /* Relays to large vs small bin operations */
<span class="lineNum">    3175 </span>            : 
<span class="lineNum">    3176 </span>            : #define insert_chunk(M, P, S)\
<span class="lineNum">    3177 </span>            :   if (is_small(S)) insert_small_chunk(M, P, S)\
<span class="lineNum">    3178 </span>            :   else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
<span class="lineNum">    3179 </span>            : 
<span class="lineNum">    3180 </span>            : #define unlink_chunk(M, P, S)\
<span class="lineNum">    3181 </span>            :   if (is_small(S)) unlink_small_chunk(M, P, S)\
<span class="lineNum">    3182 </span>            :   else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span>            : 
<span class="lineNum">    3185 </span>            : /* Relays to internal calls to malloc/free from realloc, memalign etc */
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span>            : #if ONLY_MSPACES
<span class="lineNum">    3188 </span>            : #define internal_malloc(m, b) mspace_malloc(m, b)
<span class="lineNum">    3189 </span>            : #define internal_free(m, mem) mspace_free(m,mem);
<span class="lineNum">    3190 </span>            : #else /* ONLY_MSPACES */
<span class="lineNum">    3191 </span>            : #if MSPACES
<span class="lineNum">    3192 </span>            : #define internal_malloc(m, b)\
<span class="lineNum">    3193 </span>            :    (m == gm)? dlmalloc(b) : mspace_malloc(m, b)
<span class="lineNum">    3194 </span>            : #define internal_free(m, mem)\
<span class="lineNum">    3195 </span>            :    if (m == gm) dlfree(mem); else mspace_free(m,mem);
<span class="lineNum">    3196 </span>            : #else /* MSPACES */
<span class="lineNum">    3197 </span>            : #define internal_malloc(m, b) dlmalloc(b)
<span class="lineNum">    3198 </span>            : #define internal_free(m, mem) dlfree(mem)
<span class="lineNum">    3199 </span>            : #endif /* MSPACES */
<span class="lineNum">    3200 </span>            : #endif /* ONLY_MSPACES */
<span class="lineNum">    3201 </span>            : 
<span class="lineNum">    3202 </span>            : /* -----------------------  Direct-mmapping chunks ----------------------- */
<span class="lineNum">    3203 </span>            : 
<span class="lineNum">    3204 </span>            : /*
<span class="lineNum">    3205 </span>            :   Directly mmapped chunks are set up with an offset to the start of
<span class="lineNum">    3206 </span>            :   the mmapped region stored in the prev_foot field of the chunk. This
<span class="lineNum">    3207 </span>            :   allows reconstruction of the required argument to MUNMAP when freed,
<span class="lineNum">    3208 </span>            :   and also allows adjustment of the returned chunk to meet alignment
<span class="lineNum">    3209 </span>            :   requirements (especially in memalign).  There is also enough space
<span class="lineNum">    3210 </span>            :   allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain
<span class="lineNum">    3211 </span>            :   the PINUSE bit so frees can be checked.
<span class="lineNum">    3212 </span>            : */
<a name="3213"><span class="lineNum">    3213 </span>            : </a>
<span class="lineNum">    3214 </span>            : /* Malloc using mmap */
<span class="lineNum">    3215 </span><span class="lineNoCov">          0 : static void* mmap_alloc(mstate m, size_t nb) {</span>
<span class="lineNum">    3216 </span><span class="lineNoCov">          0 :   size_t mmsize = granularity_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);</span>
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 :   if (mmsize &gt; nb) {     /* Check for wrap around 0 */</span>
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :     char* mm = (char*)(DIRECT_MMAP(mmsize));</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :     if (mm != CMFAIL) {</span>
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :       size_t offset = align_offset(chunk2mem(mm));</span>
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :       size_t psize = mmsize - offset - MMAP_FOOT_PAD;</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :       mchunkptr p = (mchunkptr)(mm + offset);</span>
<span class="lineNum">    3223 </span><span class="lineNoCov">          0 :       p-&gt;prev_foot = offset | IS_MMAPPED_BIT;</span>
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :       (p)-&gt;head = (psize|CINUSE_BIT);</span>
<span class="lineNum">    3225 </span>            :       mark_inuse_foot(m, p, psize);
<span class="lineNum">    3226 </span><span class="lineNoCov">          0 :       chunk_plus_offset(p, psize)-&gt;head = FENCEPOST_HEAD;</span>
<span class="lineNum">    3227 </span><span class="lineNoCov">          0 :       chunk_plus_offset(p, psize+SIZE_T_SIZE)-&gt;head = 0;</span>
<span class="lineNum">    3228 </span>            : 
<span class="lineNum">    3229 </span><span class="lineNoCov">          0 :       if (mm &lt; m-&gt;least_addr)</span>
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :         m-&gt;least_addr = mm;</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :       if ((m-&gt;footprint += mmsize) &gt; m-&gt;max_footprint)</span>
<span class="lineNum">    3232 </span><span class="lineNoCov">          0 :         m-&gt;max_footprint = m-&gt;footprint;</span>
<span class="lineNum">    3233 </span><span class="lineNoCov">          0 :       assert(is_aligned(chunk2mem(p)));</span>
<span class="lineNum">    3234 </span><span class="lineNoCov">          0 :       check_mmapped_chunk(m, p);</span>
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :       return chunk2mem(p);</span>
<span class="lineNum">    3236 </span>            :     }
<span class="lineNum">    3237 </span>            :   }
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3239 </span>            : }
<a name="3240"><span class="lineNum">    3240 </span>            : </a>
<span class="lineNum">    3241 </span>            : /* Realloc using mmap */
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 : static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb) {</span>
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :   size_t oldsize = chunksize(oldp);</span>
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :   if (is_small(nb)) /* Can't shrink mmap regions below small size */</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    3246 </span>            :   /* Keep old chunk if big enough but not too big */
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :   if (oldsize &gt;= nb + SIZE_T_SIZE &amp;&amp;</span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :       (oldsize - nb) &lt;= (mparams.granularity &lt;&lt; 1))</span>
<span class="lineNum">    3249 </span><span class="lineNoCov">          0 :     return oldp;</span>
<span class="lineNum">    3250 </span>            :   else {
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :     size_t offset = oldp-&gt;prev_foot &amp; ~IS_MMAPPED_BIT;</span>
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :     size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;</span>
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :     size_t newmmsize = granularity_align(nb + SIX_SIZE_T_SIZES +</span>
<span class="lineNum">    3254 </span>            :                                          CHUNK_ALIGN_MASK);
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :     char* cp = (char*)CALL_MREMAP((char*)oldp - offset,</span>
<span class="lineNum">    3256 </span>            :                                   oldmmsize, newmmsize, 1);
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :     if (cp != CMFAIL) {</span>
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :       mchunkptr newp = (mchunkptr)(cp + offset);</span>
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :       size_t psize = newmmsize - offset - MMAP_FOOT_PAD;</span>
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :       newp-&gt;head = (psize|CINUSE_BIT);</span>
<span class="lineNum">    3261 </span>            :       mark_inuse_foot(m, newp, psize);
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :       chunk_plus_offset(newp, psize)-&gt;head = FENCEPOST_HEAD;</span>
<span class="lineNum">    3263 </span><span class="lineNoCov">          0 :       chunk_plus_offset(newp, psize+SIZE_T_SIZE)-&gt;head = 0;</span>
<span class="lineNum">    3264 </span>            : 
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 :       if (cp &lt; m-&gt;least_addr)</span>
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 :         m-&gt;least_addr = cp;</span>
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :       if ((m-&gt;footprint += newmmsize - oldmmsize) &gt; m-&gt;max_footprint)</span>
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :         m-&gt;max_footprint = m-&gt;footprint;</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :       check_mmapped_chunk(m, newp);</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :       return newp;</span>
<span class="lineNum">    3271 </span>            :     }
<span class="lineNum">    3272 </span>            :   }
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3274 </span>            : }
<span class="lineNum">    3275 </span>            : 
<span class="lineNum">    3276 </span>            : /* -------------------------- mspace management -------------------------- */
<a name="3277"><span class="lineNum">    3277 </span>            : </a>
<span class="lineNum">    3278 </span>            : /* Initialize top chunk and its size */
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 : static void init_top(mstate m, mchunkptr p, size_t psize) {</span>
<span class="lineNum">    3280 </span>            :   /* Ensure alignment */
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 :   size_t offset = align_offset(chunk2mem(p));</span>
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :   p = (mchunkptr)((char*)p + offset);</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 :   psize -= offset;</span>
<span class="lineNum">    3284 </span>            : 
<span class="lineNum">    3285 </span><span class="lineNoCov">          0 :   m-&gt;top = p;</span>
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 :   m-&gt;topsize = psize;</span>
<span class="lineNum">    3287 </span><span class="lineNoCov">          0 :   p-&gt;head = psize | PINUSE_BIT;</span>
<span class="lineNum">    3288 </span>            :   /* set size of fake trailing chunk holding overhead space only once */
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :   chunk_plus_offset(p, psize)-&gt;head = TOP_FOOT_SIZE;</span>
<span class="lineNum">    3290 </span><span class="lineNoCov">          0 :   m-&gt;trim_check = mparams.trim_threshold; /* reset on each update */</span>
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 : }</span>
<a name="3292"><span class="lineNum">    3292 </span>            : </a>
<span class="lineNum">    3293 </span>            : /* Initialize bins for a new mstate that is otherwise zeroed out */
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 : static void init_bins(mstate m) {</span>
<span class="lineNum">    3295 </span>            :   /* Establish circular links for smallbins */
<span class="lineNum">    3296 </span>            :   bindex_t i;
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NSMALLBINS; ++i) {</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 :     sbinptr bin = smallbin_at(m,i);</span>
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :     bin-&gt;fd = bin-&gt;bk = bin;</span>
<span class="lineNum">    3300 </span>            :   }
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3302 </span>            : 
<span class="lineNum">    3303 </span>            : #if PROCEED_ON_ERROR
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span>            : /* default corruption action */
<span class="lineNum">    3306 </span>            : static void reset_on_error(mstate m) {
<span class="lineNum">    3307 </span>            :   int i;
<span class="lineNum">    3308 </span>            :   ++malloc_corruption_error_count;
<span class="lineNum">    3309 </span>            :   /* Reinitialize fields to forget about all memory */
<span class="lineNum">    3310 </span>            :   m-&gt;smallbins = m-&gt;treebins = 0;
<span class="lineNum">    3311 </span>            :   m-&gt;dvsize = m-&gt;topsize = 0;
<span class="lineNum">    3312 </span>            :   m-&gt;seg.base = 0;
<span class="lineNum">    3313 </span>            :   m-&gt;seg.size = 0;
<span class="lineNum">    3314 </span>            :   m-&gt;seg.next = 0;
<span class="lineNum">    3315 </span>            :   m-&gt;top = m-&gt;dv = 0;
<span class="lineNum">    3316 </span>            :   for (i = 0; i &lt; NTREEBINS; ++i)
<span class="lineNum">    3317 </span>            :     *treebin_at(m, i) = 0;
<span class="lineNum">    3318 </span>            :   init_bins(m);
<span class="lineNum">    3319 </span>            : }
<span class="lineNum">    3320 </span>            : #endif /* PROCEED_ON_ERROR */
<a name="3321"><span class="lineNum">    3321 </span>            : </a>
<span class="lineNum">    3322 </span>            : /* Allocate chunk and prepend remainder with chunk in successor base. */
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 : static void* prepend_alloc(mstate m, char* newbase, char* oldbase,</span>
<span class="lineNum">    3324 </span>            :                            size_t nb) {
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 :   mchunkptr p = align_as_chunk(newbase);</span>
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :   mchunkptr oldfirst = align_as_chunk(oldbase);</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :   size_t psize = (char*)oldfirst - (char*)p;</span>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 :   mchunkptr q = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 :   size_t qsize = psize - nb;</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :   set_size_and_pinuse_of_inuse_chunk(m, p, nb);</span>
<span class="lineNum">    3331 </span>            : 
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :   assert((char*)oldfirst &gt; (char*)q);</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :   assert(pinuse(oldfirst));</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :   assert(qsize &gt;= MIN_CHUNK_SIZE);</span>
<span class="lineNum">    3335 </span>            : 
<span class="lineNum">    3336 </span>            :   /* consolidate remainder with first chunk of old base */
<span class="lineNum">    3337 </span><span class="lineNoCov">          0 :   if (oldfirst == m-&gt;top) {</span>
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 :     size_t tsize = m-&gt;topsize += qsize;</span>
<span class="lineNum">    3339 </span><span class="lineNoCov">          0 :     m-&gt;top = q;</span>
<span class="lineNum">    3340 </span><span class="lineNoCov">          0 :     q-&gt;head = tsize | PINUSE_BIT;</span>
<span class="lineNum">    3341 </span><span class="lineNoCov">          0 :     check_top_chunk(m, q);</span>
<span class="lineNum">    3342 </span>            :   }
<span class="lineNum">    3343 </span><span class="lineNoCov">          0 :   else if (oldfirst == m-&gt;dv) {</span>
<span class="lineNum">    3344 </span><span class="lineNoCov">          0 :     size_t dsize = m-&gt;dvsize += qsize;</span>
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :     m-&gt;dv = q;</span>
<span class="lineNum">    3346 </span><span class="lineNoCov">          0 :     set_size_and_pinuse_of_free_chunk(q, dsize);</span>
<span class="lineNum">    3347 </span>            :   }
<span class="lineNum">    3348 </span>            :   else {
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :     if (!cinuse(oldfirst)) {</span>
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :       size_t nsize = chunksize(oldfirst);</span>
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :       unlink_chunk(m, oldfirst, nsize);</span>
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :       oldfirst = chunk_plus_offset(oldfirst, nsize);</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :       qsize += nsize;</span>
<span class="lineNum">    3354 </span>            :     }
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :     set_free_with_pinuse(q, qsize, oldfirst);</span>
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :     insert_chunk(m, q, qsize);</span>
<span class="lineNum">    3357 </span><span class="lineNoCov">          0 :     check_free_chunk(m, q);</span>
<span class="lineNum">    3358 </span>            :   }
<span class="lineNum">    3359 </span>            : 
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :   check_malloced_chunk(m, chunk2mem(p), nb);</span>
<span class="lineNum">    3361 </span><span class="lineNoCov">          0 :   return chunk2mem(p);</span>
<span class="lineNum">    3362 </span>            : }
<span class="lineNum">    3363 </span>            : 
<a name="3364"><span class="lineNum">    3364 </span>            : </a>
<span class="lineNum">    3365 </span>            : /* Add a segment to hold a new noncontiguous region */
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 : static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {</span>
<span class="lineNum">    3367 </span>            :   /* Determine locations and sizes of segment, fenceposts, old top */
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :   char* old_top = (char*)m-&gt;top;</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :   msegmentptr oldsp = segment_holding(m, old_top);</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :   char* old_end = oldsp-&gt;base + oldsp-&gt;size;</span>
<span class="lineNum">    3371 </span><span class="lineNoCov">          0 :   size_t ssize = pad_request(sizeof(struct malloc_segment));</span>
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :   char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);</span>
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 :   size_t offset = align_offset(chunk2mem(rawsp));</span>
<span class="lineNum">    3374 </span><span class="lineNoCov">          0 :   char* asp = rawsp + offset;</span>
<span class="lineNum">    3375 </span><span class="lineNoCov">          0 :   char* csp = (asp &lt; (old_top + MIN_CHUNK_SIZE))? old_top : asp;</span>
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 :   mchunkptr sp = (mchunkptr)csp;</span>
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 :   msegmentptr ss = (msegmentptr)(chunk2mem(sp));</span>
<span class="lineNum">    3378 </span><span class="lineNoCov">          0 :   mchunkptr tnext = chunk_plus_offset(sp, ssize);</span>
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :   mchunkptr p = tnext;</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :   int nfences = 0;</span>
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span>            :   /* reset top to new space */
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :   init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);</span>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span>            :   /* Set up segment record */
<span class="lineNum">    3386 </span><span class="lineNoCov">          0 :   assert(is_aligned(ss));</span>
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :   set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);</span>
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :   *ss = m-&gt;seg; /* Push current record */</span>
<span class="lineNum">    3389 </span><span class="lineNoCov">          0 :   m-&gt;seg.base = tbase;</span>
<span class="lineNum">    3390 </span><span class="lineNoCov">          0 :   m-&gt;seg.size = tsize;</span>
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 :   (void)set_segment_flags(&amp;m-&gt;seg, mmapped);</span>
<span class="lineNum">    3392 </span><span class="lineNoCov">          0 :   m-&gt;seg.next = ss;</span>
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span>            :   /* Insert trailing fenceposts */
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :   for (;;) {</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :     mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :     p-&gt;head = FENCEPOST_HEAD;</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :     ++nfences;</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :     if ((char*)(&amp;(nextp-&gt;head)) &lt; old_end)</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :       p = nextp;</span>
<span class="lineNum">    3401 </span>            :     else
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3403 </span>            :   }
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :   assert(nfences &gt;= 2);</span>
<span class="lineNum">    3405 </span>            : 
<span class="lineNum">    3406 </span>            :   /* Insert the rest of old top into a bin as an ordinary free chunk */
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :   if (csp != old_top) {</span>
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :     mchunkptr q = (mchunkptr)old_top;</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :     size_t psize = csp - old_top;</span>
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :     mchunkptr tn = chunk_plus_offset(q, psize);</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :     set_free_with_pinuse(q, psize, tn);</span>
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :     insert_chunk(m, q, psize);</span>
<span class="lineNum">    3413 </span>            :   }
<span class="lineNum">    3414 </span>            : 
<span class="lineNum">    3415 </span><span class="lineNoCov">          0 :   check_top_chunk(m, m-&gt;top);</span>
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span>            : /* -------------------------- System allocation -------------------------- */
<a name="3419"><span class="lineNum">    3419 </span>            : </a>
<span class="lineNum">    3420 </span>            : /* Get memory from system using MORECORE or MMAP */
<span class="lineNum">    3421 </span><span class="lineNoCov">          0 : static void* sys_alloc(mstate m, size_t nb) {</span>
<span class="lineNum">    3422 </span><span class="lineNoCov">          0 :   char* tbase = CMFAIL;</span>
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :   size_t tsize = 0;</span>
<span class="lineNum">    3424 </span><span class="lineNoCov">          0 :   flag_t mmap_flag = 0;</span>
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span><span class="lineNoCov">          0 :   init_mparams();</span>
<span class="lineNum">    3427 </span>            : 
<span class="lineNum">    3428 </span>            :   /* Directly map large chunks */
<span class="lineNum">    3429 </span><span class="lineNoCov">          0 :   if (use_mmap(m) &amp;&amp; nb &gt;= mparams.mmap_threshold) {</span>
<span class="lineNum">    3430 </span><span class="lineNoCov">          0 :     void* mem = mmap_alloc(m, nb);</span>
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :     if (mem != 0)</span>
<span class="lineNum">    3432 </span><span class="lineNoCov">          0 :       return mem;</span>
<span class="lineNum">    3433 </span>            :   }
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span>            :   /*
<span class="lineNum">    3436 </span>            :     Try getting memory in any of three ways (in most-preferred to
<span class="lineNum">    3437 </span>            :     least-preferred order):
<span class="lineNum">    3438 </span>            :     1. A call to MORECORE that can normally contiguously extend memory.
<span class="lineNum">    3439 </span>            :        (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
<span class="lineNum">    3440 </span>            :        or main space is mmapped or a previous contiguous call failed)
<span class="lineNum">    3441 </span>            :     2. A call to MMAP new space (disabled if not HAVE_MMAP).
<span class="lineNum">    3442 </span>            :        Note that under the default settings, if MORECORE is unable to
<span class="lineNum">    3443 </span>            :        fulfill a request, and HAVE_MMAP is true, then mmap is
<span class="lineNum">    3444 </span>            :        used as a noncontiguous system allocator. This is a useful backup
<span class="lineNum">    3445 </span>            :        strategy for systems with holes in address spaces -- in this case
<span class="lineNum">    3446 </span>            :        sbrk cannot contiguously expand the heap, but mmap may be able to
<span class="lineNum">    3447 </span>            :        find space.
<span class="lineNum">    3448 </span>            :     3. A call to MORECORE that cannot usually contiguously extend memory.
<span class="lineNum">    3449 </span>            :        (disabled if not HAVE_MORECORE)
<span class="lineNum">    3450 </span>            :   */
<span class="lineNum">    3451 </span>            : 
<span class="lineNum">    3452 </span>            :   if (MORECORE_CONTIGUOUS &amp;&amp; !use_noncontiguous(m)) {
<span class="lineNum">    3453 </span>            :     char* br = CMFAIL;
<span class="lineNum">    3454 </span>            :     msegmentptr ss = (m-&gt;top == 0)? 0 : segment_holding(m, (char*)m-&gt;top);
<span class="lineNum">    3455 </span>            :     size_t asize = 0;
<span class="lineNum">    3456 </span>            :     ACQUIRE_MORECORE_LOCK();
<span class="lineNum">    3457 </span>            : 
<span class="lineNum">    3458 </span>            :     if (ss == 0) {  /* First time through or recovery */
<span class="lineNum">    3459 </span>            :       char* base = (char*)CALL_MORECORE(0);
<span class="lineNum">    3460 </span>            :       if (base != CMFAIL) {
<span class="lineNum">    3461 </span>            :         asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
<span class="lineNum">    3462 </span>            :         /* Adjust to end on a page boundary */
<span class="lineNum">    3463 </span>            :         if (!is_page_aligned(base))
<span class="lineNum">    3464 </span>            :           asize += (page_align((size_t)base) - (size_t)base);
<span class="lineNum">    3465 </span>            :         /* Can't call MORECORE if size is negative when treated as signed */
<span class="lineNum">    3466 </span>            :         if (asize &lt; HALF_MAX_SIZE_T &amp;&amp;
<span class="lineNum">    3467 </span>            :             (br = (char*)(CALL_MORECORE(asize))) == base) {
<span class="lineNum">    3468 </span>            :           tbase = base;
<span class="lineNum">    3469 </span>            :           tsize = asize;
<span class="lineNum">    3470 </span>            :         }
<span class="lineNum">    3471 </span>            :       }
<span class="lineNum">    3472 </span>            :     }
<span class="lineNum">    3473 </span>            :     else {
<span class="lineNum">    3474 </span>            :       /* Subtract out existing available top space from MORECORE request. */
<span class="lineNum">    3475 </span>            :       asize = granularity_align(nb - m-&gt;topsize + TOP_FOOT_SIZE + SIZE_T_ONE);
<span class="lineNum">    3476 </span>            :       /* Use mem here only if it did continuously extend old space */
<span class="lineNum">    3477 </span>            :       if (asize &lt; HALF_MAX_SIZE_T &amp;&amp;
<span class="lineNum">    3478 </span>            :           (br = (char*)(CALL_MORECORE(asize))) == ss-&gt;base+ss-&gt;size) {
<span class="lineNum">    3479 </span>            :         tbase = br;
<span class="lineNum">    3480 </span>            :         tsize = asize;
<span class="lineNum">    3481 </span>            :       }
<span class="lineNum">    3482 </span>            :     }
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            :     if (tbase == CMFAIL) {    /* Cope with partial failure */
<span class="lineNum">    3485 </span>            :       if (br != CMFAIL) {    /* Try to use/extend the space we did get */
<span class="lineNum">    3486 </span>            :         if (asize &lt; HALF_MAX_SIZE_T &amp;&amp;
<span class="lineNum">    3487 </span>            :             asize &lt; nb + TOP_FOOT_SIZE + SIZE_T_ONE) {
<span class="lineNum">    3488 </span>            :           size_t esize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE - asize);
<span class="lineNum">    3489 </span>            :           if (esize &lt; HALF_MAX_SIZE_T) {
<span class="lineNum">    3490 </span>            :             char* end = (char*)CALL_MORECORE(esize);
<span class="lineNum">    3491 </span>            :             if (end != CMFAIL)
<span class="lineNum">    3492 </span>            :               asize += esize;
<span class="lineNum">    3493 </span>            :             else {            /* Can't use; try to release */
<span class="lineNum">    3494 </span>            :               (void)CALL_MORECORE(-asize);
<span class="lineNum">    3495 </span>            :               br = CMFAIL;
<span class="lineNum">    3496 </span>            :             }
<span class="lineNum">    3497 </span>            :           }
<span class="lineNum">    3498 </span>            :         }
<span class="lineNum">    3499 </span>            :       }
<span class="lineNum">    3500 </span>            :       if (br != CMFAIL) {    /* Use the space we did get */
<span class="lineNum">    3501 </span>            :         tbase = br;
<span class="lineNum">    3502 </span>            :         tsize = asize;
<span class="lineNum">    3503 </span>            :       }
<span class="lineNum">    3504 </span>            :       else
<span class="lineNum">    3505 </span>            :         disable_contiguous(m); /* Don't try contiguous path in the future */
<span class="lineNum">    3506 </span>            :     }
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span>            :     RELEASE_MORECORE_LOCK();
<span class="lineNum">    3509 </span>            :   }
<span class="lineNum">    3510 </span>            : 
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :   if (HAVE_MMAP &amp;&amp; tbase == CMFAIL) {  /* Try MMAP */</span>
<span class="lineNum">    3512 </span><span class="lineNoCov">          0 :     size_t req = nb + TOP_FOOT_SIZE + SIZE_T_ONE;</span>
<span class="lineNum">    3513 </span><span class="lineNoCov">          0 :     size_t rsize = granularity_align(req);</span>
<span class="lineNum">    3514 </span><span class="lineNoCov">          0 :     if (rsize &gt; nb) { /* Fail if wraps around zero */</span>
<span class="lineNum">    3515 </span><span class="lineNoCov">          0 :       char* mp = (char*)(CALL_MMAP(rsize));</span>
<span class="lineNum">    3516 </span><span class="lineNoCov">          0 :       if (mp != CMFAIL) {</span>
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :         tbase = mp;</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :         tsize = rsize;</span>
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :         mmap_flag = IS_MMAPPED_BIT;</span>
<span class="lineNum">    3520 </span>            :       }
<span class="lineNum">    3521 </span>            :     }
<span class="lineNum">    3522 </span>            :   }
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span>            :   if (HAVE_MORECORE &amp;&amp; tbase == CMFAIL) { /* Try noncontiguous MORECORE */
<span class="lineNum">    3525 </span>            :     size_t asize = granularity_align(nb + TOP_FOOT_SIZE + SIZE_T_ONE);
<span class="lineNum">    3526 </span>            :     if (asize &lt; HALF_MAX_SIZE_T) {
<span class="lineNum">    3527 </span>            :       char* br = CMFAIL;
<span class="lineNum">    3528 </span>            :       char* end = CMFAIL;
<span class="lineNum">    3529 </span>            :       ACQUIRE_MORECORE_LOCK();
<span class="lineNum">    3530 </span>            :       br = (char*)(CALL_MORECORE(asize));
<span class="lineNum">    3531 </span>            :       end = (char*)(CALL_MORECORE(0));
<span class="lineNum">    3532 </span>            :       RELEASE_MORECORE_LOCK();
<span class="lineNum">    3533 </span>            :       if (br != CMFAIL &amp;&amp; end != CMFAIL &amp;&amp; br &lt; end) {
<span class="lineNum">    3534 </span>            :         size_t ssize = end - br;
<span class="lineNum">    3535 </span>            :         if (ssize &gt; nb + TOP_FOOT_SIZE) {
<span class="lineNum">    3536 </span>            :           tbase = br;
<span class="lineNum">    3537 </span>            :           tsize = ssize;
<span class="lineNum">    3538 </span>            :         }
<span class="lineNum">    3539 </span>            :       }
<span class="lineNum">    3540 </span>            :     }
<span class="lineNum">    3541 </span>            :   }
<span class="lineNum">    3542 </span>            : 
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 :   if (tbase != CMFAIL) {</span>
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span><span class="lineNoCov">          0 :     if ((m-&gt;footprint += tsize) &gt; m-&gt;max_footprint)</span>
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :       m-&gt;max_footprint = m-&gt;footprint;</span>
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span><span class="lineNoCov">          0 :     if (!is_initialized(m)) { /* first-time initialization */</span>
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :       m-&gt;seg.base = m-&gt;least_addr = tbase;</span>
<span class="lineNum">    3550 </span><span class="lineNoCov">          0 :       m-&gt;seg.size = tsize;</span>
<span class="lineNum">    3551 </span><span class="lineNoCov">          0 :       (void)set_segment_flags(&amp;m-&gt;seg, mmap_flag);</span>
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :       m-&gt;magic = mparams.magic;</span>
<span class="lineNum">    3553 </span><span class="lineNoCov">          0 :       init_bins(m);</span>
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :       if (is_global(m)) </span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :         init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);</span>
<span class="lineNum">    3556 </span>            :       else {
<span class="lineNum">    3557 </span>            :         /* Offset top by embedded malloc_state */
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :         mchunkptr mn = next_chunk(mem2chunk(m));</span>
<span class="lineNum">    3559 </span><span class="lineNoCov">          0 :         init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);</span>
<span class="lineNum">    3560 </span>            :       }
<span class="lineNum">    3561 </span>            :     }
<span class="lineNum">    3562 </span>            : 
<span class="lineNum">    3563 </span>            :     else {
<span class="lineNum">    3564 </span>            :       /* Try to merge with an existing segment */
<span class="lineNum">    3565 </span><span class="lineNoCov">          0 :       msegmentptr sp = &amp;m-&gt;seg;</span>
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 :       while (sp != 0 &amp;&amp; tbase != sp-&gt;base + sp-&gt;size)</span>
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :         sp = sp-&gt;next;</span>
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :       if (sp != 0 &amp;&amp;</span>
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :           !is_extern_segment(sp) &amp;&amp;</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :           check_segment_merge(sp, tbase, tsize) &amp;&amp;</span>
<span class="lineNum">    3571 </span><span class="lineNoCov">          0 :           (get_segment_flags(sp) &amp; IS_MMAPPED_BIT) == mmap_flag &amp;&amp;</span>
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :           segment_holds(sp, m-&gt;top)) { /* append */</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :         sp-&gt;size += tsize;</span>
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :         init_top(m, m-&gt;top, m-&gt;topsize + tsize);</span>
<span class="lineNum">    3575 </span>            :       }
<span class="lineNum">    3576 </span>            :       else {
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :         if (tbase &lt; m-&gt;least_addr)</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :           m-&gt;least_addr = tbase;</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :         sp = &amp;m-&gt;seg;</span>
<span class="lineNum">    3580 </span><span class="lineNoCov">          0 :         while (sp != 0 &amp;&amp; sp-&gt;base != tbase + tsize)</span>
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :           sp = sp-&gt;next;</span>
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :         if (sp != 0 &amp;&amp;</span>
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :             !is_extern_segment(sp) &amp;&amp;</span>
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :             check_segment_merge(sp, tbase, tsize) &amp;&amp;</span>
<span class="lineNum">    3585 </span>            :             (get_segment_flags(sp) &amp; IS_MMAPPED_BIT) == mmap_flag) {
<span class="lineNum">    3586 </span><span class="lineNoCov">          0 :           char* oldbase = sp-&gt;base;</span>
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :           sp-&gt;base = tbase;</span>
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :           sp-&gt;size += tsize;</span>
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 :           return prepend_alloc(m, tbase, oldbase, nb);</span>
<span class="lineNum">    3590 </span>            :         }
<span class="lineNum">    3591 </span>            :         else
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 :           add_segment(m, tbase, tsize, mmap_flag);</span>
<span class="lineNum">    3593 </span>            :       }
<span class="lineNum">    3594 </span>            :     }
<span class="lineNum">    3595 </span>            : 
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :     if (nb &lt; m-&gt;topsize) { /* Allocate from new or extended top space */</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :       size_t rsize = m-&gt;topsize -= nb;</span>
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :       mchunkptr p = m-&gt;top;</span>
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :       mchunkptr r = m-&gt;top = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :       r-&gt;head = rsize | PINUSE_BIT;</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :       set_size_and_pinuse_of_inuse_chunk(m, p, nb);</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :       check_top_chunk(m, m-&gt;top);</span>
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :       check_malloced_chunk(m, chunk2mem(p), nb);</span>
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :       return chunk2mem(p);</span>
<span class="lineNum">    3605 </span>            :     }
<span class="lineNum">    3606 </span>            :   }
<span class="lineNum">    3607 </span>            : 
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :   MALLOC_FAILURE_ACTION;</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3610 </span>            : }
<span class="lineNum">    3611 </span>            : 
<span class="lineNum">    3612 </span>            : /* -----------------------  system deallocation -------------------------- */
<a name="3613"><span class="lineNum">    3613 </span>            : </a>
<span class="lineNum">    3614 </span>            : /* Unmap and unlink any mmapped segments that don't contain used chunks */
<span class="lineNum">    3615 </span><span class="lineNoCov">          0 : static size_t release_unused_segments(mstate m) {</span>
<span class="lineNum">    3616 </span><span class="lineNoCov">          0 :   size_t released = 0;</span>
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :   msegmentptr pred = &amp;m-&gt;seg;</span>
<span class="lineNum">    3618 </span><span class="lineNoCov">          0 :   msegmentptr sp = pred-&gt;next;</span>
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :   while (sp != 0) {</span>
<span class="lineNum">    3620 </span><span class="lineNoCov">          0 :     char* base = sp-&gt;base;</span>
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 :     size_t size = sp-&gt;size;</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :     msegmentptr next = sp-&gt;next;</span>
<span class="lineNum">    3623 </span>            :     if (is_mmapped_segment(sp) &amp;&amp; !is_extern_segment(sp)) {
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :       mchunkptr p = align_as_chunk(base);</span>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :       size_t psize = chunksize(p);</span>
<span class="lineNum">    3626 </span>            :       /* Can unmap if first chunk holds entire segment and not pinned */
<span class="lineNum">    3627 </span><span class="lineNoCov">          0 :       if (!cinuse(p) &amp;&amp; (char*)p + psize &gt;= base + size - TOP_FOOT_SIZE) {</span>
<span class="lineNum">    3628 </span><span class="lineNoCov">          0 :         tchunkptr tp = (tchunkptr)p;</span>
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 :         assert(segment_holds(sp, (char*)sp));</span>
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :         if (p == m-&gt;dv) {</span>
<span class="lineNum">    3631 </span><span class="lineNoCov">          0 :           m-&gt;dv = 0;</span>
<span class="lineNum">    3632 </span><span class="lineNoCov">          0 :           m-&gt;dvsize = 0;</span>
<span class="lineNum">    3633 </span>            :         }
<span class="lineNum">    3634 </span>            :         else {
<span class="lineNum">    3635 </span><span class="lineNoCov">          0 :           unlink_large_chunk(m, tp);</span>
<span class="lineNum">    3636 </span>            :         }
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 :         if (CALL_MUNMAP(base, size) == 0) {</span>
<span class="lineNum">    3638 </span><span class="lineNoCov">          0 :           released += size;</span>
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :           m-&gt;footprint -= size;</span>
<span class="lineNum">    3640 </span>            :           /* unlink obsoleted record */
<span class="lineNum">    3641 </span><span class="lineNoCov">          0 :           sp = pred;</span>
<span class="lineNum">    3642 </span><span class="lineNoCov">          0 :           sp-&gt;next = next;</span>
<span class="lineNum">    3643 </span>            :         }
<span class="lineNum">    3644 </span>            :         else { /* back out if cannot unmap */
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :           insert_large_chunk(m, tp, psize);</span>
<span class="lineNum">    3646 </span>            :         }
<span class="lineNum">    3647 </span>            :       }
<span class="lineNum">    3648 </span>            :     }
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :     pred = sp;</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :     sp = next;</span>
<span class="lineNum">    3651 </span>            :   }
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 :   return released;</span>
<a name="3653"><span class="lineNum">    3653 </span>            : }</a>
<span class="lineNum">    3654 </span>            : 
<span class="lineNum">    3655 </span><span class="lineNoCov">          0 : static int sys_trim(mstate m, size_t pad) {</span>
<span class="lineNum">    3656 </span><span class="lineNoCov">          0 :   size_t released = 0;</span>
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 :   if (pad &lt; MAX_REQUEST &amp;&amp; is_initialized(m)) {</span>
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :     pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */</span>
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :     if (m-&gt;topsize &gt; pad) {</span>
<span class="lineNum">    3661 </span>            :       /* Shrink top space in granularity-size units, keeping at least one */
<span class="lineNum">    3662 </span><span class="lineNoCov">          0 :       size_t unit = mparams.granularity;</span>
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :       size_t extra = ((m-&gt;topsize - pad + (unit - SIZE_T_ONE)) / unit -</span>
<span class="lineNum">    3664 </span>            :                       SIZE_T_ONE) * unit;
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :       msegmentptr sp = segment_holding(m, (char*)m-&gt;top);</span>
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            :       if (!is_extern_segment(sp)) {
<span class="lineNum">    3668 </span>            :         if (is_mmapped_segment(sp)) {
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :           if (HAVE_MMAP &amp;&amp;</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :               sp-&gt;size &gt;= extra &amp;&amp;</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :               !has_segment_link(m, sp)) { /* can't shrink if pinned */</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :             size_t newsize = sp-&gt;size - extra;</span>
<span class="lineNum">    3673 </span>            :             /* Prefer mremap, fall back to munmap */
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :             if ((CALL_MREMAP(sp-&gt;base, sp-&gt;size, newsize, 0) != MFAIL) ||</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :                 (CALL_MUNMAP(sp-&gt;base + newsize, extra) == 0)) {</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :               released = extra;</span>
<span class="lineNum">    3677 </span>            :             }
<span class="lineNum">    3678 </span>            :           }
<span class="lineNum">    3679 </span>            :         }
<span class="lineNum">    3680 </span>            :         else if (HAVE_MORECORE) {
<span class="lineNum">    3681 </span>            :           if (extra &gt;= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
<span class="lineNum">    3682 </span>            :             extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
<span class="lineNum">    3683 </span>            :           ACQUIRE_MORECORE_LOCK();
<span class="lineNum">    3684 </span>            :           {
<span class="lineNum">    3685 </span>            :             /* Make sure end of memory is where we last set it. */
<span class="lineNum">    3686 </span>            :             char* old_br = (char*)(CALL_MORECORE(0));
<span class="lineNum">    3687 </span>            :             if (old_br == sp-&gt;base + sp-&gt;size) {
<span class="lineNum">    3688 </span>            :               char* rel_br = (char*)(CALL_MORECORE(-extra));
<span class="lineNum">    3689 </span>            :               char* new_br = (char*)(CALL_MORECORE(0));
<span class="lineNum">    3690 </span>            :               if (rel_br != CMFAIL &amp;&amp; new_br &lt; old_br)
<span class="lineNum">    3691 </span>            :                 released = old_br - new_br;
<span class="lineNum">    3692 </span>            :             }
<span class="lineNum">    3693 </span>            :           }
<span class="lineNum">    3694 </span>            :           RELEASE_MORECORE_LOCK();
<span class="lineNum">    3695 </span>            :         }
<span class="lineNum">    3696 </span>            :       }
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :       if (released != 0) {</span>
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 :         sp-&gt;size -= released;</span>
<span class="lineNum">    3700 </span><span class="lineNoCov">          0 :         m-&gt;footprint -= released;</span>
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :         init_top(m, m-&gt;top, m-&gt;topsize - released);</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :         check_top_chunk(m, m-&gt;top);</span>
<span class="lineNum">    3703 </span>            :       }
<span class="lineNum">    3704 </span>            :     }
<span class="lineNum">    3705 </span>            : 
<span class="lineNum">    3706 </span>            :     /* Unmap any unused mmapped segments */
<span class="lineNum">    3707 </span>            :     if (HAVE_MMAP) 
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :       released += release_unused_segments(m);</span>
<span class="lineNum">    3709 </span>            : 
<span class="lineNum">    3710 </span>            :     /* On failure, disable autotrim to avoid repeated failed future calls */
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :     if (released == 0)</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :       m-&gt;trim_check = MAX_SIZE_T;</span>
<span class="lineNum">    3713 </span>            :   }
<span class="lineNum">    3714 </span>            : 
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :   return (released != 0)? 1 : 0;</span>
<span class="lineNum">    3716 </span>            : }
<span class="lineNum">    3717 </span>            : 
<span class="lineNum">    3718 </span>            : /* ---------------------------- malloc support --------------------------- */
<a name="3719"><span class="lineNum">    3719 </span>            : </a>
<span class="lineNum">    3720 </span>            : /* allocate a large request from the best fitting chunk in a treebin */
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 : static void* tmalloc_large(mstate m, size_t nb) {</span>
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :   tchunkptr v = 0;</span>
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 :   size_t rsize = -nb; /* Unsigned negation */</span>
<span class="lineNum">    3724 </span>            :   tchunkptr t;
<span class="lineNum">    3725 </span>            :   bindex_t idx;
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :   compute_tree_index(nb, idx);</span>
<span class="lineNum">    3727 </span>            : 
<span class="lineNum">    3728 </span><span class="lineNoCov">          0 :   if ((t = *treebin_at(m, idx)) != 0) {</span>
<span class="lineNum">    3729 </span>            :     /* Traverse tree for this bin looking for node with size == nb */
<span class="lineNum">    3730 </span><span class="lineNoCov">          0 :     size_t sizebits = nb &lt;&lt; leftshift_for_tree_index(idx);</span>
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :     tchunkptr rst = 0;  /* The deepest untaken right subtree */</span>
<span class="lineNum">    3732 </span><span class="lineNoCov">          0 :     for (;;) {</span>
<span class="lineNum">    3733 </span>            :       tchunkptr rt;
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :       size_t trem = chunksize(t) - nb;</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :       if (trem &lt; rsize) {</span>
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 :         v = t;</span>
<span class="lineNum">    3737 </span><span class="lineNoCov">          0 :         if ((rsize = trem) == 0)</span>
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    3739 </span>            :       }
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :       rt = t-&gt;child[1];</span>
<span class="lineNum">    3741 </span><span class="lineNoCov">          0 :       t = t-&gt;child[(sizebits &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE)) &amp; 1];</span>
<span class="lineNum">    3742 </span><span class="lineNoCov">          0 :       if (rt != 0 &amp;&amp; rt != t)</span>
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :         rst = rt;</span>
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :       if (t == 0) {</span>
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :         t = rst; /* set t to least subtree holding sizes &gt; nb */</span>
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3747 </span>            :       }
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :       sizebits &lt;&lt;= 1;</span>
<span class="lineNum">    3749 </span>            :     }
<span class="lineNum">    3750 </span>            :   }
<span class="lineNum">    3751 </span>            : 
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :   if (t == 0 &amp;&amp; v == 0) { /* set t to root of next non-empty treebin */</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :     binmap_t leftbits = left_bits(idx2bit(idx)) &amp; m-&gt;treemap;</span>
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :     if (leftbits != 0) {</span>
<span class="lineNum">    3755 </span>            :       bindex_t i;
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :       binmap_t leastbit = least_bit(leftbits);</span>
<span class="lineNum">    3757 </span><span class="lineNoCov">          0 :       compute_bit2idx(leastbit, i);</span>
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :       t = *treebin_at(m, i);</span>
<span class="lineNum">    3759 </span>            :     }
<span class="lineNum">    3760 </span>            :   }
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :   while (t != 0) { /* find smallest of tree or subtree */</span>
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :     size_t trem = chunksize(t) - nb;</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :     if (trem &lt; rsize) {</span>
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 :       rsize = trem;</span>
<span class="lineNum">    3766 </span><span class="lineNoCov">          0 :       v = t;</span>
<span class="lineNum">    3767 </span>            :     }
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :     t = leftmost_child(t);</span>
<span class="lineNum">    3769 </span>            :   }
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span>            :   /*  If dv is a better fit, return 0 so malloc will use it */
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :   if (v != 0 &amp;&amp; rsize &lt; (size_t)(m-&gt;dvsize - nb)) {</span>
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :     if (RTCHECK(ok_address(m, v))) { /* split */</span>
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :       mchunkptr r = chunk_plus_offset(v, nb);</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :       assert(chunksize(v) == rsize + nb);</span>
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :       if (RTCHECK(ok_next(v, r))) {</span>
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :         unlink_large_chunk(m, v);</span>
<span class="lineNum">    3778 </span><span class="lineNoCov">          0 :         if (rsize &lt; MIN_CHUNK_SIZE)</span>
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :           set_inuse_and_pinuse(m, v, (rsize + nb));</span>
<span class="lineNum">    3780 </span>            :         else {
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :           set_size_and_pinuse_of_inuse_chunk(m, v, nb);</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :           set_size_and_pinuse_of_free_chunk(r, rsize);</span>
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :           insert_chunk(m, r, rsize);</span>
<span class="lineNum">    3784 </span>            :         }
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :         return chunk2mem(v);</span>
<span class="lineNum">    3786 </span>            :       }
<span class="lineNum">    3787 </span>            :     }
<span class="lineNum">    3788 </span><span class="lineNoCov">          0 :     CORRUPTION_ERROR_ACTION(m);</span>
<span class="lineNum">    3789 </span>            :   }
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3791 </span>            : }
<a name="3792"><span class="lineNum">    3792 </span>            : </a>
<span class="lineNum">    3793 </span>            : /* allocate a small request from the best fitting chunk in a treebin */
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 : static void* tmalloc_small(mstate m, size_t nb) {</span>
<span class="lineNum">    3795 </span>            :   tchunkptr t, v;
<span class="lineNum">    3796 </span>            :   size_t rsize;
<span class="lineNum">    3797 </span>            :   bindex_t i;
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :   binmap_t leastbit = least_bit(m-&gt;treemap);</span>
<span class="lineNum">    3799 </span><span class="lineNoCov">          0 :   compute_bit2idx(leastbit, i);</span>
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :   v = t = *treebin_at(m, i);</span>
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :   rsize = chunksize(t) - nb;</span>
<span class="lineNum">    3803 </span>            : 
<span class="lineNum">    3804 </span><span class="lineNoCov">          0 :   while ((t = leftmost_child(t)) != 0) {</span>
<span class="lineNum">    3805 </span><span class="lineNoCov">          0 :     size_t trem = chunksize(t) - nb;</span>
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :     if (trem &lt; rsize) {</span>
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :       rsize = trem;</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :       v = t;</span>
<span class="lineNum">    3809 </span>            :     }
<span class="lineNum">    3810 </span>            :   }
<span class="lineNum">    3811 </span>            : 
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :   if (RTCHECK(ok_address(m, v))) {</span>
<span class="lineNum">    3813 </span><span class="lineNoCov">          0 :     mchunkptr r = chunk_plus_offset(v, nb);</span>
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :     assert(chunksize(v) == rsize + nb);</span>
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :     if (RTCHECK(ok_next(v, r))) {</span>
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 :       unlink_large_chunk(m, v);</span>
<span class="lineNum">    3817 </span><span class="lineNoCov">          0 :       if (rsize &lt; MIN_CHUNK_SIZE)</span>
<span class="lineNum">    3818 </span><span class="lineNoCov">          0 :         set_inuse_and_pinuse(m, v, (rsize + nb));</span>
<span class="lineNum">    3819 </span>            :       else {
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :         set_size_and_pinuse_of_inuse_chunk(m, v, nb);</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :         set_size_and_pinuse_of_free_chunk(r, rsize);</span>
<span class="lineNum">    3822 </span><span class="lineNoCov">          0 :         replace_dv(m, r, rsize);</span>
<span class="lineNum">    3823 </span>            :       }
<span class="lineNum">    3824 </span><span class="lineNoCov">          0 :       return chunk2mem(v);</span>
<span class="lineNum">    3825 </span>            :     }
<span class="lineNum">    3826 </span>            :   }
<span class="lineNum">    3827 </span>            : 
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 :   CORRUPTION_ERROR_ACTION(m);</span>
<span class="lineNum">    3829 </span>            :   return 0;
<span class="lineNum">    3830 </span>            : }
<span class="lineNum">    3831 </span>            : 
<a name="3832"><span class="lineNum">    3832 </span>            : /* --------------------------- realloc support --------------------------- */</a>
<span class="lineNum">    3833 </span>            : 
<span class="lineNum">    3834 </span><span class="lineNoCov">          0 : static void* internal_realloc(mstate m, void* oldmem, size_t bytes) {</span>
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :   if (bytes &gt;= MAX_REQUEST) {</span>
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :     MALLOC_FAILURE_ACTION;</span>
<span class="lineNum">    3837 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    3838 </span>            :   }
<span class="lineNum">    3839 </span><span class="lineNoCov">          0 :   if (!PREACTION(m)) {</span>
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :     mchunkptr oldp = mem2chunk(oldmem);</span>
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 :     size_t oldsize = chunksize(oldp);</span>
<span class="lineNum">    3842 </span><span class="lineNoCov">          0 :     mchunkptr next = chunk_plus_offset(oldp, oldsize);</span>
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :     mchunkptr newp = 0;</span>
<span class="lineNum">    3844 </span><span class="lineNoCov">          0 :     void* extra = 0;</span>
<span class="lineNum">    3845 </span>            : 
<span class="lineNum">    3846 </span>            :     /* Try to either shrink or extend into top. Else malloc-copy-free */
<span class="lineNum">    3847 </span>            : 
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :     if (RTCHECK(ok_address(m, oldp) &amp;&amp; ok_cinuse(oldp) &amp;&amp;</span>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :                 ok_next(oldp, next) &amp;&amp; ok_pinuse(next))) {</span>
<span class="lineNum">    3850 </span><span class="lineNoCov">          0 :       size_t nb = request2size(bytes);</span>
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :       if (is_mmapped(oldp))</span>
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 :         newp = mmap_resize(m, oldp, nb);</span>
<span class="lineNum">    3853 </span><span class="lineNoCov">          0 :       else if (oldsize &gt;= nb) { /* already big enough */</span>
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :         size_t rsize = oldsize - nb;</span>
<span class="lineNum">    3855 </span><span class="lineNoCov">          0 :         newp = oldp;</span>
<span class="lineNum">    3856 </span><span class="lineNoCov">          0 :         if (rsize &gt;= MIN_CHUNK_SIZE) {</span>
<span class="lineNum">    3857 </span><span class="lineNoCov">          0 :           mchunkptr remainder = chunk_plus_offset(newp, nb);</span>
<span class="lineNum">    3858 </span><span class="lineNoCov">          0 :           set_inuse(m, newp, nb);</span>
<span class="lineNum">    3859 </span><span class="lineNoCov">          0 :           set_inuse(m, remainder, rsize);</span>
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :           extra = chunk2mem(remainder);</span>
<span class="lineNum">    3861 </span>            :         }
<span class="lineNum">    3862 </span>            :       }
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :       else if (next == m-&gt;top &amp;&amp; oldsize + m-&gt;topsize &gt; nb) {</span>
<span class="lineNum">    3864 </span>            :         /* Expand into top */
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :         size_t newsize = oldsize + m-&gt;topsize;</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :         size_t newtopsize = newsize - nb;</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :         mchunkptr newtop = chunk_plus_offset(oldp, nb);</span>
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :         set_inuse(m, oldp, nb);</span>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :         newtop-&gt;head = newtopsize |PINUSE_BIT;</span>
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :         m-&gt;top = newtop;</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :         m-&gt;topsize = newtopsize;</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :         newp = oldp;</span>
<span class="lineNum">    3873 </span>            :       }
<span class="lineNum">    3874 </span>            :     }
<span class="lineNum">    3875 </span>            :     else {
<span class="lineNum">    3876 </span><span class="lineNoCov">          0 :       USAGE_ERROR_ACTION(m, oldmem);</span>
<span class="lineNum">    3877 </span>            :       POSTACTION(m);
<span class="lineNum">    3878 </span>            :       return 0;
<span class="lineNum">    3879 </span>            :     }
<span class="lineNum">    3880 </span>            : 
<span class="lineNum">    3881 </span><span class="lineNoCov">          0 :     POSTACTION(m);</span>
<span class="lineNum">    3882 </span>            : 
<span class="lineNum">    3883 </span><span class="lineNoCov">          0 :     if (newp != 0) {</span>
<span class="lineNum">    3884 </span><span class="lineNoCov">          0 :       if (extra != 0) {</span>
<span class="lineNum">    3885 </span><span class="lineNoCov">          0 :         internal_free(m, extra);</span>
<span class="lineNum">    3886 </span>            :       }
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :       check_inuse_chunk(m, newp);</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :       return chunk2mem(newp);</span>
<span class="lineNum">    3889 </span>            :     }
<span class="lineNum">    3890 </span>            :     else {
<span class="lineNum">    3891 </span><span class="lineNoCov">          0 :       void* newmem = internal_malloc(m, bytes);</span>
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :       if (newmem != 0) {</span>
<span class="lineNum">    3893 </span><span class="lineNoCov">          0 :         size_t oc = oldsize - overhead_for(oldp);</span>
<span class="lineNum">    3894 </span><span class="lineNoCov">          0 :         memcpy(newmem, oldmem, (oc &lt; bytes)? oc : bytes);</span>
<span class="lineNum">    3895 </span><span class="lineNoCov">          0 :         internal_free(m, oldmem);</span>
<span class="lineNum">    3896 </span>            :       }
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :       return newmem;</span>
<span class="lineNum">    3898 </span>            :     }
<span class="lineNum">    3899 </span>            :   }
<span class="lineNum">    3900 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3901 </span>            : }
<span class="lineNum">    3902 </span>            : 
<a name="3903"><span class="lineNum">    3903 </span>            : /* --------------------------- memalign support -------------------------- */</a>
<span class="lineNum">    3904 </span>            : 
<span class="lineNum">    3905 </span><span class="lineNoCov">          0 : static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {</span>
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 :   if (alignment &lt;= MALLOC_ALIGNMENT)    /* Can just use malloc */</span>
<span class="lineNum">    3907 </span><span class="lineNoCov">          0 :     return internal_malloc(m, bytes);</span>
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :   if (alignment &lt;  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */</span>
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :     alignment = MIN_CHUNK_SIZE;</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :   if ((alignment &amp; (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :     size_t a = MALLOC_ALIGNMENT &lt;&lt; 1;</span>
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :     while (a &lt; alignment) a &lt;&lt;= 1;</span>
<span class="lineNum">    3913 </span><span class="lineNoCov">          0 :     alignment = a;</span>
<span class="lineNum">    3914 </span>            :   }
<span class="lineNum">    3915 </span>            :   
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :   if (bytes &gt;= MAX_REQUEST - alignment) {</span>
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :     if (m != 0)  { /* Test isn't needed but avoids compiler warning */</span>
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :       MALLOC_FAILURE_ACTION;</span>
<span class="lineNum">    3919 </span>            :     }
<span class="lineNum">    3920 </span>            :   }
<span class="lineNum">    3921 </span>            :   else {
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :     size_t nb = request2size(bytes);</span>
<span class="lineNum">    3923 </span><span class="lineNoCov">          0 :     size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;</span>
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :     char* mem = (char*)internal_malloc(m, req);</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :     if (mem != 0) {</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :       void* leader = 0;</span>
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :       void* trailer = 0;</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :       mchunkptr p = mem2chunk(mem);</span>
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :       if (PREACTION(m)) return 0;</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :       if ((((size_t)(mem)) % alignment) != 0) { /* misaligned */</span>
<span class="lineNum">    3932 </span>            :         /*
<span class="lineNum">    3933 </span>            :           Find an aligned spot inside chunk.  Since we need to give
<span class="lineNum">    3934 </span>            :           back leading space in a chunk of at least MIN_CHUNK_SIZE, if
<span class="lineNum">    3935 </span>            :           the first calculation places us at a spot with less than
<span class="lineNum">    3936 </span>            :           MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
<span class="lineNum">    3937 </span>            :           We've allocated enough total room so that this is always
<span class="lineNum">    3938 </span>            :           possible.
<span class="lineNum">    3939 </span>            :         */
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :         char* br = (char*)mem2chunk((size_t)(((size_t)(mem +</span>
<span class="lineNum">    3941 </span>            :                                                        alignment -
<span class="lineNum">    3942 </span>            :                                                        SIZE_T_ONE)) &amp;
<span class="lineNum">    3943 </span>            :                                              -alignment));
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :         char* pos = ((size_t)(br - (char*)(p)) &gt;= MIN_CHUNK_SIZE)?</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :           br : br+alignment;</span>
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :         mchunkptr newp = (mchunkptr)pos;</span>
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :         size_t leadsize = pos - (char*)(p);</span>
<span class="lineNum">    3948 </span><span class="lineNoCov">          0 :         size_t newsize = chunksize(p) - leadsize;</span>
<span class="lineNum">    3949 </span>            : 
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :         if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */</span>
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :           newp-&gt;prev_foot = p-&gt;prev_foot + leadsize;</span>
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :           newp-&gt;head = (newsize|CINUSE_BIT);</span>
<span class="lineNum">    3953 </span>            :         }
<span class="lineNum">    3954 </span>            :         else { /* Otherwise, give back leader, use the rest */
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :           set_inuse(m, newp, newsize);</span>
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :           set_inuse(m, p, leadsize);</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :           leader = chunk2mem(p);</span>
<span class="lineNum">    3958 </span>            :         }
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :         p = newp;</span>
<span class="lineNum">    3960 </span>            :       }
<span class="lineNum">    3961 </span>            : 
<span class="lineNum">    3962 </span>            :       /* Give back spare room at the end */
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :       if (!is_mmapped(p)) {</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :         size_t size = chunksize(p);</span>
<span class="lineNum">    3965 </span><span class="lineNoCov">          0 :         if (size &gt; nb + MIN_CHUNK_SIZE) {</span>
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :           size_t remainder_size = size - nb;</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :           mchunkptr remainder = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :           set_inuse(m, p, nb);</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :           set_inuse(m, remainder, remainder_size);</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :           trailer = chunk2mem(remainder);</span>
<span class="lineNum">    3971 </span>            :         }
<span class="lineNum">    3972 </span>            :       }
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :       assert (chunksize(p) &gt;= nb);</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :       assert((((size_t)(chunk2mem(p))) % alignment) == 0);</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :       check_inuse_chunk(m, p);</span>
<span class="lineNum">    3977 </span><span class="lineNoCov">          0 :       POSTACTION(m);</span>
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :       if (leader != 0) {</span>
<span class="lineNum">    3979 </span><span class="lineNoCov">          0 :         internal_free(m, leader);</span>
<span class="lineNum">    3980 </span>            :       }
<span class="lineNum">    3981 </span><span class="lineNoCov">          0 :       if (trailer != 0) {</span>
<span class="lineNum">    3982 </span><span class="lineNoCov">          0 :         internal_free(m, trailer);</span>
<span class="lineNum">    3983 </span>            :       }
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :       return chunk2mem(p);</span>
<span class="lineNum">    3985 </span>            :     }
<span class="lineNum">    3986 </span>            :   }
<span class="lineNum">    3987 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3988 </span>            : }
<span class="lineNum">    3989 </span>            : 
<a name="3990"><span class="lineNum">    3990 </span>            : /* ------------------------ comalloc/coalloc support --------------------- */</a>
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 : static void** ialloc(mstate m,</span>
<span class="lineNum">    3993 </span>            :                      size_t n_elements,
<span class="lineNum">    3994 </span>            :                      size_t* sizes,
<span class="lineNum">    3995 </span>            :                      int opts,
<span class="lineNum">    3996 </span>            :                      void* chunks[]) {
<span class="lineNum">    3997 </span>            :   /*
<span class="lineNum">    3998 </span>            :     This provides common support for independent_X routines, handling
<span class="lineNum">    3999 </span>            :     all of the combinations that can result.
<span class="lineNum">    4000 </span>            : 
<span class="lineNum">    4001 </span>            :     The opts arg has:
<span class="lineNum">    4002 </span>            :     bit 0 set if all elements are same size (using sizes[0])
<span class="lineNum">    4003 </span>            :     bit 1 set if elements should be zeroed
<span class="lineNum">    4004 </span>            :   */
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span>            :   size_t    element_size;   /* chunksize of each element, if all same */
<span class="lineNum">    4007 </span>            :   size_t    contents_size;  /* total size of elements */
<span class="lineNum">    4008 </span>            :   size_t    array_size;     /* request size of pointer array */
<span class="lineNum">    4009 </span>            :   void*     mem;            /* malloced aggregate space */
<span class="lineNum">    4010 </span>            :   mchunkptr p;              /* corresponding chunk */
<span class="lineNum">    4011 </span>            :   size_t    remainder_size; /* remaining bytes while splitting */
<span class="lineNum">    4012 </span>            :   void**    marray;         /* either &quot;chunks&quot; or malloced ptr array */
<span class="lineNum">    4013 </span>            :   mchunkptr array_chunk;    /* chunk for malloced ptr array */
<span class="lineNum">    4014 </span>            :   flag_t    was_enabled;    /* to disable mmap */
<span class="lineNum">    4015 </span>            :   size_t    size;
<span class="lineNum">    4016 </span>            :   size_t    i;
<span class="lineNum">    4017 </span>            : 
<span class="lineNum">    4018 </span>            :   /* compute array length, if needed */
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :   if (chunks != 0) {</span>
<span class="lineNum">    4020 </span><span class="lineNoCov">          0 :     if (n_elements == 0)</span>
<span class="lineNum">    4021 </span><span class="lineNoCov">          0 :       return chunks; /* nothing to do */</span>
<span class="lineNum">    4022 </span><span class="lineNoCov">          0 :     marray = chunks;</span>
<span class="lineNum">    4023 </span><span class="lineNoCov">          0 :     array_size = 0;</span>
<span class="lineNum">    4024 </span>            :   }
<span class="lineNum">    4025 </span>            :   else {
<span class="lineNum">    4026 </span>            :     /* if empty req, must still return chunk representing empty array */
<span class="lineNum">    4027 </span><span class="lineNoCov">          0 :     if (n_elements == 0)</span>
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :       return (void**)internal_malloc(m, 0);</span>
<span class="lineNum">    4029 </span><span class="lineNoCov">          0 :     marray = 0;</span>
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :     array_size = request2size(n_elements * (sizeof(void*)));</span>
<span class="lineNum">    4031 </span>            :   }
<span class="lineNum">    4032 </span>            : 
<span class="lineNum">    4033 </span>            :   /* compute total element size */
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :   if (opts &amp; 0x1) { /* all-same-size */</span>
<span class="lineNum">    4035 </span><span class="lineNoCov">          0 :     element_size = request2size(*sizes);</span>
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :     contents_size = n_elements * element_size;</span>
<span class="lineNum">    4037 </span>            :   }
<span class="lineNum">    4038 </span>            :   else { /* add up all the sizes */
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :     element_size = 0;</span>
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 :     contents_size = 0;</span>
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :     for (i = 0; i != n_elements; ++i)</span>
<span class="lineNum">    4042 </span><span class="lineNoCov">          0 :       contents_size += request2size(sizes[i]);</span>
<span class="lineNum">    4043 </span>            :   }
<span class="lineNum">    4044 </span>            : 
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :   size = contents_size + array_size;</span>
<span class="lineNum">    4046 </span>            : 
<span class="lineNum">    4047 </span>            :   /*
<span class="lineNum">    4048 </span>            :      Allocate the aggregate chunk.  First disable direct-mmapping so
<span class="lineNum">    4049 </span>            :      malloc won't use it, since we would not be able to later
<span class="lineNum">    4050 </span>            :      free/realloc space internal to a segregated mmap region.
<span class="lineNum">    4051 </span>            :   */
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :   was_enabled = use_mmap(m);</span>
<span class="lineNum">    4053 </span><span class="lineNoCov">          0 :   disable_mmap(m);</span>
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 :   mem = internal_malloc(m, size - CHUNK_OVERHEAD);</span>
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :   if (was_enabled)</span>
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :     enable_mmap(m);</span>
<span class="lineNum">    4057 </span><span class="lineNoCov">          0 :   if (mem == 0)</span>
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineNoCov">          0 :   if (PREACTION(m)) return 0;</span>
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :   p = mem2chunk(mem);</span>
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :   remainder_size = chunksize(p);</span>
<span class="lineNum">    4063 </span>            : 
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :   assert(!is_mmapped(p));</span>
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :   if (opts &amp; 0x2) {       /* optionally clear the elements */</span>
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :     memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);</span>
<span class="lineNum">    4068 </span>            :   }
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span>            :   /* If not provided, allocate the pointer array as final part of chunk */
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :   if (marray == 0) {</span>
<span class="lineNum">    4072 </span>            :     size_t  array_chunk_size;
<span class="lineNum">    4073 </span><span class="lineNoCov">          0 :     array_chunk = chunk_plus_offset(p, contents_size);</span>
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :     array_chunk_size = remainder_size - contents_size;</span>
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :     marray = (void**) (chunk2mem(array_chunk));</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :     set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :     remainder_size = contents_size;</span>
<span class="lineNum">    4078 </span>            :   }
<span class="lineNum">    4079 </span>            : 
<span class="lineNum">    4080 </span>            :   /* split out elements */
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :   for (i = 0; ; ++i) {</span>
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :     marray[i] = chunk2mem(p);</span>
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 :     if (i != n_elements-1) {</span>
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :       if (element_size != 0)</span>
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :         size = element_size;</span>
<span class="lineNum">    4086 </span>            :       else
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :         size = request2size(sizes[i]);</span>
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :       remainder_size -= size;</span>
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :       set_size_and_pinuse_of_inuse_chunk(m, p, size);</span>
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 :       p = chunk_plus_offset(p, size);</span>
<span class="lineNum">    4091 </span>            :     }
<span class="lineNum">    4092 </span>            :     else { /* the final element absorbs any overallocation slop */
<span class="lineNum">    4093 </span><span class="lineNoCov">          0 :       set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);</span>
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4095 </span>            :     }
<span class="lineNum">    4096 </span>            :   }
<span class="lineNum">    4097 </span>            : 
<span class="lineNum">    4098 </span>            : #if DEBUG
<span class="lineNum">    4099 </span><span class="lineNoCov">          0 :   if (marray != chunks) {</span>
<span class="lineNum">    4100 </span>            :     /* final element must have exactly exhausted chunk */
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :     if (element_size != 0) {</span>
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :       assert(remainder_size == element_size);</span>
<span class="lineNum">    4103 </span>            :     }
<span class="lineNum">    4104 </span>            :     else {
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :       assert(remainder_size == request2size(sizes[i]));</span>
<span class="lineNum">    4106 </span>            :     }
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :     check_inuse_chunk(m, mem2chunk(marray));</span>
<span class="lineNum">    4108 </span>            :   }
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :   for (i = 0; i != n_elements; ++i)</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :     check_inuse_chunk(m, mem2chunk(marray[i]));</span>
<span class="lineNum">    4111 </span>            : 
<span class="lineNum">    4112 </span>            : #endif /* DEBUG */
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :   POSTACTION(m);</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :   return marray;</span>
<span class="lineNum">    4116 </span>            : }
<span class="lineNum">    4117 </span>            : 
<span class="lineNum">    4118 </span>            : 
<span class="lineNum">    4119 </span>            : /* -------------------------- public routines ---------------------------- */
<span class="lineNum">    4120 </span>            : 
<a name="4121"><span class="lineNum">    4121 </span>            : #if !ONLY_MSPACES</a>
<span class="lineNum">    4122 </span>            : 
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 : void* dlmalloc(size_t bytes) {</span>
<span class="lineNum">    4124 </span>            :   /*
<span class="lineNum">    4125 </span>            :      Basic algorithm:
<span class="lineNum">    4126 </span>            :      If a small request (&lt; 256 bytes minus per-chunk overhead):
<span class="lineNum">    4127 </span>            :        1. If one exists, use a remainderless chunk in associated smallbin.
<span class="lineNum">    4128 </span>            :           (Remainderless means that there are too few excess bytes to
<span class="lineNum">    4129 </span>            :           represent as a chunk.)
<span class="lineNum">    4130 </span>            :        2. If it is big enough, use the dv chunk, which is normally the
<span class="lineNum">    4131 </span>            :           chunk adjacent to the one used for the most recent small request.
<span class="lineNum">    4132 </span>            :        3. If one exists, split the smallest available chunk in a bin,
<span class="lineNum">    4133 </span>            :           saving remainder in dv.
<span class="lineNum">    4134 </span>            :        4. If it is big enough, use the top chunk.
<span class="lineNum">    4135 </span>            :        5. If available, get memory from system and use it
<span class="lineNum">    4136 </span>            :      Otherwise, for a large request:
<span class="lineNum">    4137 </span>            :        1. Find the smallest available binned chunk that fits, and use it
<span class="lineNum">    4138 </span>            :           if it is better fitting than dv chunk, splitting if necessary.
<span class="lineNum">    4139 </span>            :        2. If better fitting than any binned chunk, use the dv chunk.
<span class="lineNum">    4140 </span>            :        3. If it is big enough, use the top chunk.
<span class="lineNum">    4141 </span>            :        4. If request size &gt;= mmap threshold, try to directly mmap this chunk.
<span class="lineNum">    4142 </span>            :        5. If available, get memory from system and use it
<span class="lineNum">    4143 </span>            : 
<span class="lineNum">    4144 </span>            :      The ugly goto's here ensure that postaction occurs along all paths.
<span class="lineNum">    4145 </span>            :   */
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span><span class="lineNoCov">          0 :   if (!PREACTION(gm)) {</span>
<span class="lineNum">    4148 </span>            :     void* mem;
<span class="lineNum">    4149 </span>            :     size_t nb;
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :     if (bytes &lt;= MAX_SMALL_REQUEST) {</span>
<span class="lineNum">    4151 </span>            :       bindex_t idx;
<span class="lineNum">    4152 </span>            :       binmap_t smallbits;
<span class="lineNum">    4153 </span><span class="lineNoCov">          0 :       nb = (bytes &lt; MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);</span>
<span class="lineNum">    4154 </span><span class="lineNoCov">          0 :       idx = small_index(nb);</span>
<span class="lineNum">    4155 </span><span class="lineNoCov">          0 :       smallbits = gm-&gt;smallmap &gt;&gt; idx;</span>
<span class="lineNum">    4156 </span>            : 
<span class="lineNum">    4157 </span><span class="lineNoCov">          0 :       if ((smallbits &amp; 0x3U) != 0) { /* Remainderless fit to a smallbin. */</span>
<span class="lineNum">    4158 </span>            :         mchunkptr b, p;
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :         idx += ~smallbits &amp; 1;       /* Uses next bin if idx empty */</span>
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :         b = smallbin_at(gm, idx);</span>
<span class="lineNum">    4161 </span><span class="lineNoCov">          0 :         p = b-&gt;fd;</span>
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :         assert(chunksize(p) == small_index2size(idx));</span>
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :         unlink_first_small_chunk(gm, b, p, idx);</span>
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :         set_inuse_and_pinuse(gm, p, small_index2size(idx));</span>
<span class="lineNum">    4165 </span><span class="lineNoCov">          0 :         mem = chunk2mem(p);</span>
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 :         check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4167 </span><span class="lineNoCov">          0 :         goto postaction;</span>
<span class="lineNum">    4168 </span>            :       }
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineNoCov">          0 :       else if (nb &gt; gm-&gt;dvsize) {</span>
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */</span>
<span class="lineNum">    4172 </span>            :           mchunkptr b, p, r;
<span class="lineNum">    4173 </span>            :           size_t rsize;
<span class="lineNum">    4174 </span>            :           bindex_t i;
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :           binmap_t leftbits = (smallbits &lt;&lt; idx) &amp; left_bits(idx2bit(idx));</span>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :           binmap_t leastbit = least_bit(leftbits);</span>
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :           compute_bit2idx(leastbit, i);</span>
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :           b = smallbin_at(gm, i);</span>
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :           p = b-&gt;fd;</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :           assert(chunksize(p) == small_index2size(i));</span>
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :           unlink_first_small_chunk(gm, b, p, i);</span>
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :           rsize = small_index2size(i) - nb;</span>
<span class="lineNum">    4183 </span>            :           /* Fit here cannot be remainderless if 4byte sizes */
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :           if (SIZE_T_SIZE != 4 &amp;&amp; rsize &lt; MIN_CHUNK_SIZE)</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :             set_inuse_and_pinuse(gm, p, small_index2size(i));</span>
<span class="lineNum">    4186 </span>            :           else {
<span class="lineNum">    4187 </span><span class="lineNoCov">          0 :             set_size_and_pinuse_of_inuse_chunk(gm, p, nb);</span>
<span class="lineNum">    4188 </span><span class="lineNoCov">          0 :             r = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :             set_size_and_pinuse_of_free_chunk(r, rsize);</span>
<span class="lineNum">    4190 </span><span class="lineNoCov">          0 :             replace_dv(gm, r, rsize);</span>
<span class="lineNum">    4191 </span>            :           }
<span class="lineNum">    4192 </span><span class="lineNoCov">          0 :           mem = chunk2mem(p);</span>
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :           check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4194 </span><span class="lineNoCov">          0 :           goto postaction;</span>
<span class="lineNum">    4195 </span>            :         }
<span class="lineNum">    4196 </span>            : 
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :         else if (gm-&gt;treemap != 0 &amp;&amp; (mem = tmalloc_small(gm, nb)) != 0) {</span>
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :           check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :           goto postaction;</span>
<span class="lineNum">    4200 </span>            :         }
<span class="lineNum">    4201 </span>            :       }
<span class="lineNum">    4202 </span>            :     }
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :     else if (bytes &gt;= MAX_REQUEST)</span>
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */</span>
<span class="lineNum">    4205 </span>            :     else {
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :       nb = pad_request(bytes);</span>
<span class="lineNum">    4207 </span><span class="lineNoCov">          0 :       if (gm-&gt;treemap != 0 &amp;&amp; (mem = tmalloc_large(gm, nb)) != 0) {</span>
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :         check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :         goto postaction;</span>
<span class="lineNum">    4210 </span>            :       }
<span class="lineNum">    4211 </span>            :     }
<span class="lineNum">    4212 </span>            : 
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :     if (nb &lt;= gm-&gt;dvsize) {</span>
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 :       size_t rsize = gm-&gt;dvsize - nb;</span>
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :       mchunkptr p = gm-&gt;dv;</span>
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 :       if (rsize &gt;= MIN_CHUNK_SIZE) { /* split dv */</span>
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :         mchunkptr r = gm-&gt;dv = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :         gm-&gt;dvsize = rsize;</span>
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :         set_size_and_pinuse_of_free_chunk(r, rsize);</span>
<span class="lineNum">    4220 </span><span class="lineNoCov">          0 :         set_size_and_pinuse_of_inuse_chunk(gm, p, nb);</span>
<span class="lineNum">    4221 </span>            :       }
<span class="lineNum">    4222 </span>            :       else { /* exhaust dv */
<span class="lineNum">    4223 </span><span class="lineNoCov">          0 :         size_t dvs = gm-&gt;dvsize;</span>
<span class="lineNum">    4224 </span><span class="lineNoCov">          0 :         gm-&gt;dvsize = 0;</span>
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :         gm-&gt;dv = 0;</span>
<span class="lineNum">    4226 </span><span class="lineNoCov">          0 :         set_inuse_and_pinuse(gm, p, dvs);</span>
<span class="lineNum">    4227 </span>            :       }
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :       mem = chunk2mem(p);</span>
<span class="lineNum">    4229 </span><span class="lineNoCov">          0 :       check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :       goto postaction;</span>
<span class="lineNum">    4231 </span>            :     }
<span class="lineNum">    4232 </span>            : 
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :     else if (nb &lt; gm-&gt;topsize) { /* Split top */</span>
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :       size_t rsize = gm-&gt;topsize -= nb;</span>
<span class="lineNum">    4235 </span><span class="lineNoCov">          0 :       mchunkptr p = gm-&gt;top;</span>
<span class="lineNum">    4236 </span><span class="lineNoCov">          0 :       mchunkptr r = gm-&gt;top = chunk_plus_offset(p, nb);</span>
<span class="lineNum">    4237 </span><span class="lineNoCov">          0 :       r-&gt;head = rsize | PINUSE_BIT;</span>
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :       set_size_and_pinuse_of_inuse_chunk(gm, p, nb);</span>
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :       mem = chunk2mem(p);</span>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :       check_top_chunk(gm, gm-&gt;top);</span>
<span class="lineNum">    4241 </span><span class="lineNoCov">          0 :       check_malloced_chunk(gm, mem, nb);</span>
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :       goto postaction;</span>
<span class="lineNum">    4243 </span>            :     }
<span class="lineNum">    4244 </span>            : 
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :     mem = sys_alloc(gm, nb);</span>
<span class="lineNum">    4246 </span>            : 
<span class="lineNum">    4247 </span>            :   postaction:
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :     POSTACTION(gm);</span>
<span class="lineNum">    4249 </span><span class="lineNoCov">          0 :     return mem;</span>
<span class="lineNum">    4250 </span>            :   }
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="4253"><span class="lineNum">    4253 </span>            : }</a>
<span class="lineNum">    4254 </span>            : 
<span class="lineNum">    4255 </span><span class="lineNoCov">          0 : void dlfree(void* mem) {</span>
<span class="lineNum">    4256 </span>            :   /*
<span class="lineNum">    4257 </span>            :      Consolidate freed chunks with preceding or succeeding bordering
<span class="lineNum">    4258 </span>            :      free chunks, if they exist, and then place in a bin.  Intermixed
<span class="lineNum">    4259 </span>            :      with special cases for top, dv, mmapped chunks, and usage errors.
<span class="lineNum">    4260 </span>            :   */
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :   if (mem != 0) {</span>
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :     mchunkptr p  = mem2chunk(mem);</span>
<span class="lineNum">    4264 </span>            : #if FOOTERS
<span class="lineNum">    4265 </span>            :     mstate fm = get_mstate_for(p);
<span class="lineNum">    4266 </span>            :     if (!ok_magic(fm)) {
<span class="lineNum">    4267 </span>            :       USAGE_ERROR_ACTION(fm, p);
<span class="lineNum">    4268 </span>            :       return;
<span class="lineNum">    4269 </span>            :     }
<span class="lineNum">    4270 </span>            : #else /* FOOTERS */
<span class="lineNum">    4271 </span>            : #define fm gm
<span class="lineNum">    4272 </span>            : #endif /* FOOTERS */
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :     if (!PREACTION(fm)) {</span>
<span class="lineNum">    4274 </span><span class="lineNoCov">          0 :       check_inuse_chunk(fm, p);</span>
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :       if (RTCHECK(ok_address(fm, p) &amp;&amp; ok_cinuse(p))) {</span>
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :         size_t psize = chunksize(p);</span>
<span class="lineNum">    4277 </span><span class="lineNoCov">          0 :         mchunkptr next = chunk_plus_offset(p, psize);</span>
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 :         if (!pinuse(p)) {</span>
<span class="lineNum">    4279 </span><span class="lineNoCov">          0 :           size_t prevsize = p-&gt;prev_foot;</span>
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :           if ((prevsize &amp; IS_MMAPPED_BIT) != 0) {</span>
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :             prevsize &amp;= ~IS_MMAPPED_BIT;</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :             psize += prevsize + MMAP_FOOT_PAD;</span>
<span class="lineNum">    4283 </span><span class="lineNoCov">          0 :             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)</span>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :               fm-&gt;footprint -= psize;</span>
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :             goto postaction;</span>
<span class="lineNum">    4286 </span>            :           }
<span class="lineNum">    4287 </span>            :           else {
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :             mchunkptr prev = chunk_minus_offset(p, prevsize);</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :             psize += prevsize;</span>
<span class="lineNum">    4290 </span><span class="lineNoCov">          0 :             p = prev;</span>
<span class="lineNum">    4291 </span><span class="lineNoCov">          0 :             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */</span>
<span class="lineNum">    4292 </span><span class="lineNoCov">          0 :               if (p != fm-&gt;dv) {</span>
<span class="lineNum">    4293 </span><span class="lineNoCov">          0 :                 unlink_chunk(fm, p, prevsize);</span>
<span class="lineNum">    4294 </span>            :               }
<span class="lineNum">    4295 </span><span class="lineNoCov">          0 :               else if ((next-&gt;head &amp; INUSE_BITS) == INUSE_BITS) {</span>
<span class="lineNum">    4296 </span><span class="lineNoCov">          0 :                 fm-&gt;dvsize = psize;</span>
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :                 set_free_with_pinuse(p, psize, next);</span>
<span class="lineNum">    4298 </span><span class="lineNoCov">          0 :                 goto postaction;</span>
<span class="lineNum">    4299 </span>            :               }
<span class="lineNum">    4300 </span>            :             }
<span class="lineNum">    4301 </span>            :             else
<span class="lineNum">    4302 </span><span class="lineNoCov">          0 :               goto erroraction;</span>
<span class="lineNum">    4303 </span>            :           }
<span class="lineNum">    4304 </span>            :         }
<span class="lineNum">    4305 </span>            : 
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :         if (RTCHECK(ok_next(p, next) &amp;&amp; ok_pinuse(next))) {</span>
<span class="lineNum">    4307 </span><span class="lineNoCov">          0 :           if (!cinuse(next)) {  /* consolidate forward */</span>
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :             if (next == fm-&gt;top) {</span>
<span class="lineNum">    4309 </span><span class="lineNoCov">          0 :               size_t tsize = fm-&gt;topsize += psize;</span>
<span class="lineNum">    4310 </span><span class="lineNoCov">          0 :               fm-&gt;top = p;</span>
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 :               p-&gt;head = tsize | PINUSE_BIT;</span>
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :               if (p == fm-&gt;dv) {</span>
<span class="lineNum">    4313 </span><span class="lineNoCov">          0 :                 fm-&gt;dv = 0;</span>
<span class="lineNum">    4314 </span><span class="lineNoCov">          0 :                 fm-&gt;dvsize = 0;</span>
<span class="lineNum">    4315 </span>            :               }
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :               if (should_trim(fm, tsize))</span>
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :                 sys_trim(fm, 0);</span>
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :               goto postaction;</span>
<span class="lineNum">    4319 </span>            :             }
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :             else if (next == fm-&gt;dv) {</span>
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :               size_t dsize = fm-&gt;dvsize += psize;</span>
<span class="lineNum">    4322 </span><span class="lineNoCov">          0 :               fm-&gt;dv = p;</span>
<span class="lineNum">    4323 </span><span class="lineNoCov">          0 :               set_size_and_pinuse_of_free_chunk(p, dsize);</span>
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :               goto postaction;</span>
<span class="lineNum">    4325 </span>            :             }
<span class="lineNum">    4326 </span>            :             else {
<span class="lineNum">    4327 </span><span class="lineNoCov">          0 :               size_t nsize = chunksize(next);</span>
<span class="lineNum">    4328 </span><span class="lineNoCov">          0 :               psize += nsize;</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :               unlink_chunk(fm, next, nsize);</span>
<span class="lineNum">    4330 </span><span class="lineNoCov">          0 :               set_size_and_pinuse_of_free_chunk(p, psize);</span>
<span class="lineNum">    4331 </span><span class="lineNoCov">          0 :               if (p == fm-&gt;dv) {</span>
<span class="lineNum">    4332 </span><span class="lineNoCov">          0 :                 fm-&gt;dvsize = psize;</span>
<span class="lineNum">    4333 </span><span class="lineNoCov">          0 :                 goto postaction;</span>
<span class="lineNum">    4334 </span>            :               }
<span class="lineNum">    4335 </span>            :             }
<span class="lineNum">    4336 </span>            :           }
<span class="lineNum">    4337 </span>            :           else
<span class="lineNum">    4338 </span><span class="lineNoCov">          0 :             set_free_with_pinuse(p, psize, next);</span>
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :           insert_chunk(fm, p, psize);</span>
<span class="lineNum">    4340 </span><span class="lineNoCov">          0 :           check_free_chunk(fm, p);</span>
<span class="lineNum">    4341 </span><span class="lineNoCov">          0 :           goto postaction;</span>
<span class="lineNum">    4342 </span>            :         }
<span class="lineNum">    4343 </span>            :       }
<span class="lineNum">    4344 </span>            :     erroraction:
<span class="lineNum">    4345 </span><span class="lineNoCov">          0 :       USAGE_ERROR_ACTION(fm, p);</span>
<span class="lineNum">    4346 </span>            :     postaction:
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :       POSTACTION(fm);</span>
<span class="lineNum">    4348 </span>            :     }
<span class="lineNum">    4349 </span>            :   }
<span class="lineNum">    4350 </span>            : #if !FOOTERS
<span class="lineNum">    4351 </span>            : #undef fm
<span class="lineNum">    4352 </span>            : #endif /* FOOTERS */
<a name="4353"><span class="lineNum">    4353 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4354 </span>            : 
<span class="lineNum">    4355 </span><span class="lineNoCov">          0 : void* dlcalloc(size_t n_elements, size_t elem_size) {</span>
<span class="lineNum">    4356 </span>            :   void* mem;
<span class="lineNum">    4357 </span><span class="lineNoCov">          0 :   size_t req = 0;</span>
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :   if (n_elements != 0) {</span>
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :     req = n_elements * elem_size;</span>
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :     if (((n_elements | elem_size) &amp; ~(size_t)0xffff) &amp;&amp;</span>
<span class="lineNum">    4361 </span><span class="lineNoCov">          0 :         (req / n_elements != elem_size))</span>
<span class="lineNum">    4362 </span><span class="lineNoCov">          0 :       req = MAX_SIZE_T; /* force downstream failure on overflow */</span>
<span class="lineNum">    4363 </span>            :   }
<span class="lineNum">    4364 </span><span class="lineNoCov">          0 :   mem = dlmalloc(req);</span>
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :   if (mem != 0 &amp;&amp; calloc_must_clear(mem2chunk(mem)))</span>
<span class="lineNum">    4366 </span><span class="lineNoCov">          0 :     memset(mem, 0, req);</span>
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 :   return mem;</span>
<a name="4368"><span class="lineNum">    4368 </span>            : }</a>
<span class="lineNum">    4369 </span>            : 
<span class="lineNum">    4370 </span><span class="lineNoCov">          0 : void* dlrealloc(void* oldmem, size_t bytes) {</span>
<span class="lineNum">    4371 </span><span class="lineNoCov">          0 :   if (oldmem == 0)</span>
<span class="lineNum">    4372 </span><span class="lineNoCov">          0 :     return dlmalloc(bytes);</span>
<span class="lineNum">    4373 </span>            : #ifdef REALLOC_ZERO_BYTES_FREES
<span class="lineNum">    4374 </span>            :   if (bytes == 0) {
<span class="lineNum">    4375 </span>            :     dlfree(oldmem);
<span class="lineNum">    4376 </span>            :     return 0;
<span class="lineNum">    4377 </span>            :   }
<span class="lineNum">    4378 </span>            : #endif /* REALLOC_ZERO_BYTES_FREES */
<span class="lineNum">    4379 </span>            :   else {
<span class="lineNum">    4380 </span>            : #if ! FOOTERS
<span class="lineNum">    4381 </span><span class="lineNoCov">          0 :     mstate m = gm;</span>
<span class="lineNum">    4382 </span>            : #else /* FOOTERS */
<span class="lineNum">    4383 </span>            :     mstate m = get_mstate_for(mem2chunk(oldmem));
<span class="lineNum">    4384 </span>            :     if (!ok_magic(m)) {
<span class="lineNum">    4385 </span>            :       USAGE_ERROR_ACTION(m, oldmem);
<span class="lineNum">    4386 </span>            :       return 0;
<span class="lineNum">    4387 </span>            :     }
<span class="lineNum">    4388 </span>            : #endif /* FOOTERS */
<span class="lineNum">    4389 </span><span class="lineNoCov">          0 :     return internal_realloc(m, oldmem, bytes);</span>
<span class="lineNum">    4390 </span>            :   }
<a name="4391"><span class="lineNum">    4391 </span>            : }</a>
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span><span class="lineNoCov">          0 : void* dlmemalign(size_t alignment, size_t bytes) {</span>
<span class="lineNum">    4394 </span><span class="lineNoCov">          0 :   return internal_memalign(gm, alignment, bytes);</span>
<a name="4395"><span class="lineNum">    4395 </span>            : }</a>
<span class="lineNum">    4396 </span>            : 
<span class="lineNum">    4397 </span><span class="lineNoCov">          0 : void** dlindependent_calloc(size_t n_elements, size_t elem_size,</span>
<span class="lineNum">    4398 </span>            :                                  void* chunks[]) {
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :   size_t sz = elem_size; /* serves as 1-element array */</span>
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :   return ialloc(gm, n_elements, &amp;sz, 3, chunks);</span>
<a name="4401"><span class="lineNum">    4401 </span>            : }</a>
<span class="lineNum">    4402 </span>            : 
<span class="lineNum">    4403 </span><span class="lineNoCov">          0 : void** dlindependent_comalloc(size_t n_elements, size_t sizes[],</span>
<span class="lineNum">    4404 </span>            :                                    void* chunks[]) {
<span class="lineNum">    4405 </span><span class="lineNoCov">          0 :   return ialloc(gm, n_elements, sizes, 0, chunks);</span>
<a name="4406"><span class="lineNum">    4406 </span>            : }</a>
<span class="lineNum">    4407 </span>            : 
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 : void* dlvalloc(size_t bytes) {</span>
<span class="lineNum">    4409 </span>            :   size_t pagesz;
<span class="lineNum">    4410 </span><span class="lineNoCov">          0 :   init_mparams();</span>
<span class="lineNum">    4411 </span><span class="lineNoCov">          0 :   pagesz = mparams.page_size;</span>
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :   return dlmemalign(pagesz, bytes);</span>
<a name="4413"><span class="lineNum">    4413 </span>            : }</a>
<span class="lineNum">    4414 </span>            : 
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 : void* dlpvalloc(size_t bytes) {</span>
<span class="lineNum">    4416 </span>            :   size_t pagesz;
<span class="lineNum">    4417 </span><span class="lineNoCov">          0 :   init_mparams();</span>
<span class="lineNum">    4418 </span><span class="lineNoCov">          0 :   pagesz = mparams.page_size;</span>
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :   return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) &amp; ~(pagesz - SIZE_T_ONE));</span>
<a name="4420"><span class="lineNum">    4420 </span>            : }</a>
<span class="lineNum">    4421 </span>            : 
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 : int dlmalloc_trim(size_t pad) {</span>
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 :   int result = 0;</span>
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :   if (!PREACTION(gm)) {</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :     result = sys_trim(gm, pad);</span>
<span class="lineNum">    4426 </span><span class="lineNoCov">          0 :     POSTACTION(gm);</span>
<span class="lineNum">    4427 </span>            :   }
<span class="lineNum">    4428 </span><span class="lineNoCov">          0 :   return result;</span>
<a name="4429"><span class="lineNum">    4429 </span>            : }</a>
<span class="lineNum">    4430 </span>            : 
<span class="lineNum">    4431 </span><span class="lineNoCov">          0 : size_t dlmalloc_footprint(void) {</span>
<span class="lineNum">    4432 </span><span class="lineNoCov">          0 :   return gm-&gt;footprint;</span>
<a name="4433"><span class="lineNum">    4433 </span>            : }</a>
<span class="lineNum">    4434 </span>            : 
<span class="lineNum">    4435 </span><span class="lineNoCov">          0 : size_t dlmalloc_max_footprint(void) {</span>
<span class="lineNum">    4436 </span><span class="lineNoCov">          0 :   return gm-&gt;max_footprint;</span>
<span class="lineNum">    4437 </span>            : }
<span class="lineNum">    4438 </span>            : 
<span class="lineNum">    4439 </span>            : #if !NO_MALLINFO
<span class="lineNum">    4440 </span>            : struct mallinfo dlmallinfo(void) {
<span class="lineNum">    4441 </span>            :   return internal_mallinfo(gm);
<span class="lineNum">    4442 </span>            : }
<a name="4443"><span class="lineNum">    4443 </span>            : #endif /* NO_MALLINFO */</a>
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span><span class="lineNoCov">          0 : void dlmalloc_stats() {</span>
<span class="lineNum">    4446 </span><span class="lineNoCov">          0 :   internal_malloc_stats(gm);</span>
<a name="4447"><span class="lineNum">    4447 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4448 </span>            : 
<span class="lineNum">    4449 </span><span class="lineNoCov">          0 : size_t dlmalloc_usable_size(void* mem) {</span>
<span class="lineNum">    4450 </span><span class="lineNoCov">          0 :   if (mem != 0) {</span>
<span class="lineNum">    4451 </span><span class="lineNoCov">          0 :     mchunkptr p = mem2chunk(mem);</span>
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :     if (cinuse(p))</span>
<span class="lineNum">    4453 </span><span class="lineNoCov">          0 :       return chunksize(p) - overhead_for(p);</span>
<span class="lineNum">    4454 </span>            :   }
<span class="lineNum">    4455 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="4456"><span class="lineNum">    4456 </span>            : }</a>
<span class="lineNum">    4457 </span>            : 
<span class="lineNum">    4458 </span><span class="lineNoCov">          0 : int dlmallopt(int param_number, int value) {</span>
<span class="lineNum">    4459 </span><span class="lineNoCov">          0 :   return change_mparam(param_number, value);</span>
<span class="lineNum">    4460 </span>            : }
<span class="lineNum">    4461 </span>            : 
<span class="lineNum">    4462 </span>            : #endif /* !ONLY_MSPACES */
<span class="lineNum">    4463 </span>            : 
<span class="lineNum">    4464 </span>            : /* ----------------------------- user mspaces ---------------------------- */
<span class="lineNum">    4465 </span>            : 
<span class="lineNum">    4466 </span>            : #if MSPACES
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            : static mstate init_user_mstate(char* tbase, size_t tsize) {
<span class="lineNum">    4469 </span>            :   size_t msize = pad_request(sizeof(struct malloc_state));
<span class="lineNum">    4470 </span>            :   mchunkptr mn;
<span class="lineNum">    4471 </span>            :   mchunkptr msp = align_as_chunk(tbase);
<span class="lineNum">    4472 </span>            :   mstate m = (mstate)(chunk2mem(msp));
<span class="lineNum">    4473 </span>            :   memset(m, 0, msize);
<span class="lineNum">    4474 </span>            :   INITIAL_LOCK(&amp;m-&gt;mutex);
<span class="lineNum">    4475 </span>            :   msp-&gt;head = (msize|PINUSE_BIT|CINUSE_BIT);
<span class="lineNum">    4476 </span>            :   m-&gt;seg.base = m-&gt;least_addr = tbase;
<span class="lineNum">    4477 </span>            :   m-&gt;seg.size = m-&gt;footprint = m-&gt;max_footprint = tsize;
<span class="lineNum">    4478 </span>            :   m-&gt;magic = mparams.magic;
<span class="lineNum">    4479 </span>            :   m-&gt;mflags = mparams.default_mflags;
<span class="lineNum">    4480 </span>            :   disable_contiguous(m);
<span class="lineNum">    4481 </span>            :   init_bins(m);
<span class="lineNum">    4482 </span>            :   mn = next_chunk(mem2chunk(m));
<span class="lineNum">    4483 </span>            :   init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
<span class="lineNum">    4484 </span>            :   check_top_chunk(m, m-&gt;top);
<span class="lineNum">    4485 </span>            :   return m;
<span class="lineNum">    4486 </span>            : }
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span>            : mspace create_mspace(size_t capacity, int locked) {
<span class="lineNum">    4489 </span>            :   mstate m = 0;
<span class="lineNum">    4490 </span>            :   size_t msize = pad_request(sizeof(struct malloc_state));
<span class="lineNum">    4491 </span>            :   init_mparams(); /* Ensure pagesize etc initialized */
<span class="lineNum">    4492 </span>            : 
<span class="lineNum">    4493 </span>            :   if (capacity &lt; (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
<span class="lineNum">    4494 </span>            :     size_t rs = ((capacity == 0)? mparams.granularity :
<span class="lineNum">    4495 </span>            :                  (capacity + TOP_FOOT_SIZE + msize));
<span class="lineNum">    4496 </span>            :     size_t tsize = granularity_align(rs);
<span class="lineNum">    4497 </span>            :     char* tbase = (char*)(CALL_MMAP(tsize));
<span class="lineNum">    4498 </span>            :     if (tbase != CMFAIL) {
<span class="lineNum">    4499 </span>            :       m = init_user_mstate(tbase, tsize);
<span class="lineNum">    4500 </span>            :       set_segment_flags(&amp;m-&gt;seg, IS_MMAPPED_BIT);
<span class="lineNum">    4501 </span>            :       set_lock(m, locked);
<span class="lineNum">    4502 </span>            :     }
<span class="lineNum">    4503 </span>            :   }
<span class="lineNum">    4504 </span>            :   return (mspace)m;
<span class="lineNum">    4505 </span>            : }
<span class="lineNum">    4506 </span>            : 
<span class="lineNum">    4507 </span>            : mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
<span class="lineNum">    4508 </span>            :   mstate m = 0;
<span class="lineNum">    4509 </span>            :   size_t msize = pad_request(sizeof(struct malloc_state));
<span class="lineNum">    4510 </span>            :   init_mparams(); /* Ensure pagesize etc initialized */
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span>            :   if (capacity &gt; msize + TOP_FOOT_SIZE &amp;&amp;
<span class="lineNum">    4513 </span>            :       capacity &lt; (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
<span class="lineNum">    4514 </span>            :     m = init_user_mstate((char*)base, capacity);
<span class="lineNum">    4515 </span>            :     set_segment_flags(&amp;m-&gt;seg, EXTERN_BIT);
<span class="lineNum">    4516 </span>            :     set_lock(m, locked);
<span class="lineNum">    4517 </span>            :   }
<span class="lineNum">    4518 </span>            :   return (mspace)m;
<span class="lineNum">    4519 </span>            : }
<span class="lineNum">    4520 </span>            : 
<span class="lineNum">    4521 </span>            : size_t destroy_mspace(mspace msp) {
<span class="lineNum">    4522 </span>            :   size_t freed = 0;
<span class="lineNum">    4523 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4524 </span>            :   if (ok_magic(ms)) {
<span class="lineNum">    4525 </span>            :     msegmentptr sp = &amp;ms-&gt;seg;
<span class="lineNum">    4526 </span>            :     while (sp != 0) {
<span class="lineNum">    4527 </span>            :       char* base = sp-&gt;base;
<span class="lineNum">    4528 </span>            :       size_t size = sp-&gt;size;
<span class="lineNum">    4529 </span>            :       flag_t flag = get_segment_flags(sp);
<span class="lineNum">    4530 </span>            :       sp = sp-&gt;next;
<span class="lineNum">    4531 </span>            :       if ((flag &amp; IS_MMAPPED_BIT) &amp;&amp; !(flag &amp; EXTERN_BIT) &amp;&amp;
<span class="lineNum">    4532 </span>            :           CALL_MUNMAP(base, size) == 0)
<span class="lineNum">    4533 </span>            :         freed += size;
<span class="lineNum">    4534 </span>            :     }
<span class="lineNum">    4535 </span>            :   }
<span class="lineNum">    4536 </span>            :   else {
<span class="lineNum">    4537 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4538 </span>            :   }
<span class="lineNum">    4539 </span>            :   return freed;
<span class="lineNum">    4540 </span>            : }
<span class="lineNum">    4541 </span>            : 
<span class="lineNum">    4542 </span>            : /*
<span class="lineNum">    4543 </span>            :   mspace versions of routines are near-clones of the global
<span class="lineNum">    4544 </span>            :   versions. This is not so nice but better than the alternatives.
<span class="lineNum">    4545 </span>            : */
<span class="lineNum">    4546 </span>            : 
<span class="lineNum">    4547 </span>            : 
<span class="lineNum">    4548 </span>            : void* mspace_malloc(mspace msp, size_t bytes) {
<span class="lineNum">    4549 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4550 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4551 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4552 </span>            :     return 0;
<span class="lineNum">    4553 </span>            :   }
<span class="lineNum">    4554 </span>            :   if (!PREACTION(ms)) {
<span class="lineNum">    4555 </span>            :     void* mem;
<span class="lineNum">    4556 </span>            :     size_t nb;
<span class="lineNum">    4557 </span>            :     if (bytes &lt;= MAX_SMALL_REQUEST) {
<span class="lineNum">    4558 </span>            :       bindex_t idx;
<span class="lineNum">    4559 </span>            :       binmap_t smallbits;
<span class="lineNum">    4560 </span>            :       nb = (bytes &lt; MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
<span class="lineNum">    4561 </span>            :       idx = small_index(nb);
<span class="lineNum">    4562 </span>            :       smallbits = ms-&gt;smallmap &gt;&gt; idx;
<span class="lineNum">    4563 </span>            : 
<span class="lineNum">    4564 </span>            :       if ((smallbits &amp; 0x3U) != 0) { /* Remainderless fit to a smallbin. */
<span class="lineNum">    4565 </span>            :         mchunkptr b, p;
<span class="lineNum">    4566 </span>            :         idx += ~smallbits &amp; 1;       /* Uses next bin if idx empty */
<span class="lineNum">    4567 </span>            :         b = smallbin_at(ms, idx);
<span class="lineNum">    4568 </span>            :         p = b-&gt;fd;
<span class="lineNum">    4569 </span>            :         assert(chunksize(p) == small_index2size(idx));
<span class="lineNum">    4570 </span>            :         unlink_first_small_chunk(ms, b, p, idx);
<span class="lineNum">    4571 </span>            :         set_inuse_and_pinuse(ms, p, small_index2size(idx));
<span class="lineNum">    4572 </span>            :         mem = chunk2mem(p);
<span class="lineNum">    4573 </span>            :         check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4574 </span>            :         goto postaction;
<span class="lineNum">    4575 </span>            :       }
<span class="lineNum">    4576 </span>            : 
<span class="lineNum">    4577 </span>            :       else if (nb &gt; ms-&gt;dvsize) {
<span class="lineNum">    4578 </span>            :         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
<span class="lineNum">    4579 </span>            :           mchunkptr b, p, r;
<span class="lineNum">    4580 </span>            :           size_t rsize;
<span class="lineNum">    4581 </span>            :           bindex_t i;
<span class="lineNum">    4582 </span>            :           binmap_t leftbits = (smallbits &lt;&lt; idx) &amp; left_bits(idx2bit(idx));
<span class="lineNum">    4583 </span>            :           binmap_t leastbit = least_bit(leftbits);
<span class="lineNum">    4584 </span>            :           compute_bit2idx(leastbit, i);
<span class="lineNum">    4585 </span>            :           b = smallbin_at(ms, i);
<span class="lineNum">    4586 </span>            :           p = b-&gt;fd;
<span class="lineNum">    4587 </span>            :           assert(chunksize(p) == small_index2size(i));
<span class="lineNum">    4588 </span>            :           unlink_first_small_chunk(ms, b, p, i);
<span class="lineNum">    4589 </span>            :           rsize = small_index2size(i) - nb;
<span class="lineNum">    4590 </span>            :           /* Fit here cannot be remainderless if 4byte sizes */
<span class="lineNum">    4591 </span>            :           if (SIZE_T_SIZE != 4 &amp;&amp; rsize &lt; MIN_CHUNK_SIZE)
<span class="lineNum">    4592 </span>            :             set_inuse_and_pinuse(ms, p, small_index2size(i));
<span class="lineNum">    4593 </span>            :           else {
<span class="lineNum">    4594 </span>            :             set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
<span class="lineNum">    4595 </span>            :             r = chunk_plus_offset(p, nb);
<span class="lineNum">    4596 </span>            :             set_size_and_pinuse_of_free_chunk(r, rsize);
<span class="lineNum">    4597 </span>            :             replace_dv(ms, r, rsize);
<span class="lineNum">    4598 </span>            :           }
<span class="lineNum">    4599 </span>            :           mem = chunk2mem(p);
<span class="lineNum">    4600 </span>            :           check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4601 </span>            :           goto postaction;
<span class="lineNum">    4602 </span>            :         }
<span class="lineNum">    4603 </span>            : 
<span class="lineNum">    4604 </span>            :         else if (ms-&gt;treemap != 0 &amp;&amp; (mem = tmalloc_small(ms, nb)) != 0) {
<span class="lineNum">    4605 </span>            :           check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4606 </span>            :           goto postaction;
<span class="lineNum">    4607 </span>            :         }
<span class="lineNum">    4608 </span>            :       }
<span class="lineNum">    4609 </span>            :     }
<span class="lineNum">    4610 </span>            :     else if (bytes &gt;= MAX_REQUEST)
<span class="lineNum">    4611 </span>            :       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
<span class="lineNum">    4612 </span>            :     else {
<span class="lineNum">    4613 </span>            :       nb = pad_request(bytes);
<span class="lineNum">    4614 </span>            :       if (ms-&gt;treemap != 0 &amp;&amp; (mem = tmalloc_large(ms, nb)) != 0) {
<span class="lineNum">    4615 </span>            :         check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4616 </span>            :         goto postaction;
<span class="lineNum">    4617 </span>            :       }
<span class="lineNum">    4618 </span>            :     }
<span class="lineNum">    4619 </span>            : 
<span class="lineNum">    4620 </span>            :     if (nb &lt;= ms-&gt;dvsize) {
<span class="lineNum">    4621 </span>            :       size_t rsize = ms-&gt;dvsize - nb;
<span class="lineNum">    4622 </span>            :       mchunkptr p = ms-&gt;dv;
<span class="lineNum">    4623 </span>            :       if (rsize &gt;= MIN_CHUNK_SIZE) { /* split dv */
<span class="lineNum">    4624 </span>            :         mchunkptr r = ms-&gt;dv = chunk_plus_offset(p, nb);
<span class="lineNum">    4625 </span>            :         ms-&gt;dvsize = rsize;
<span class="lineNum">    4626 </span>            :         set_size_and_pinuse_of_free_chunk(r, rsize);
<span class="lineNum">    4627 </span>            :         set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
<span class="lineNum">    4628 </span>            :       }
<span class="lineNum">    4629 </span>            :       else { /* exhaust dv */
<span class="lineNum">    4630 </span>            :         size_t dvs = ms-&gt;dvsize;
<span class="lineNum">    4631 </span>            :         ms-&gt;dvsize = 0;
<span class="lineNum">    4632 </span>            :         ms-&gt;dv = 0;
<span class="lineNum">    4633 </span>            :         set_inuse_and_pinuse(ms, p, dvs);
<span class="lineNum">    4634 </span>            :       }
<span class="lineNum">    4635 </span>            :       mem = chunk2mem(p);
<span class="lineNum">    4636 </span>            :       check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4637 </span>            :       goto postaction;
<span class="lineNum">    4638 </span>            :     }
<span class="lineNum">    4639 </span>            : 
<span class="lineNum">    4640 </span>            :     else if (nb &lt; ms-&gt;topsize) { /* Split top */
<span class="lineNum">    4641 </span>            :       size_t rsize = ms-&gt;topsize -= nb;
<span class="lineNum">    4642 </span>            :       mchunkptr p = ms-&gt;top;
<span class="lineNum">    4643 </span>            :       mchunkptr r = ms-&gt;top = chunk_plus_offset(p, nb);
<span class="lineNum">    4644 </span>            :       r-&gt;head = rsize | PINUSE_BIT;
<span class="lineNum">    4645 </span>            :       set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
<span class="lineNum">    4646 </span>            :       mem = chunk2mem(p);
<span class="lineNum">    4647 </span>            :       check_top_chunk(ms, ms-&gt;top);
<span class="lineNum">    4648 </span>            :       check_malloced_chunk(ms, mem, nb);
<span class="lineNum">    4649 </span>            :       goto postaction;
<span class="lineNum">    4650 </span>            :     }
<span class="lineNum">    4651 </span>            : 
<span class="lineNum">    4652 </span>            :     mem = sys_alloc(ms, nb);
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span>            :   postaction:
<span class="lineNum">    4655 </span>            :     POSTACTION(ms);
<span class="lineNum">    4656 </span>            :     return mem;
<span class="lineNum">    4657 </span>            :   }
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span>            :   return 0;
<span class="lineNum">    4660 </span>            : }
<span class="lineNum">    4661 </span>            : 
<span class="lineNum">    4662 </span>            : void mspace_free(mspace msp, void* mem) {
<span class="lineNum">    4663 </span>            :   if (mem != 0) {
<span class="lineNum">    4664 </span>            :     mchunkptr p  = mem2chunk(mem);
<span class="lineNum">    4665 </span>            : #if FOOTERS
<span class="lineNum">    4666 </span>            :     mstate fm = get_mstate_for(p);
<span class="lineNum">    4667 </span>            : #else /* FOOTERS */
<span class="lineNum">    4668 </span>            :     mstate fm = (mstate)msp;
<span class="lineNum">    4669 </span>            : #endif /* FOOTERS */
<span class="lineNum">    4670 </span>            :     if (!ok_magic(fm)) {
<span class="lineNum">    4671 </span>            :       USAGE_ERROR_ACTION(fm, p);
<span class="lineNum">    4672 </span>            :       return;
<span class="lineNum">    4673 </span>            :     }
<span class="lineNum">    4674 </span>            :     if (!PREACTION(fm)) {
<span class="lineNum">    4675 </span>            :       check_inuse_chunk(fm, p);
<span class="lineNum">    4676 </span>            :       if (RTCHECK(ok_address(fm, p) &amp;&amp; ok_cinuse(p))) {
<span class="lineNum">    4677 </span>            :         size_t psize = chunksize(p);
<span class="lineNum">    4678 </span>            :         mchunkptr next = chunk_plus_offset(p, psize);
<span class="lineNum">    4679 </span>            :         if (!pinuse(p)) {
<span class="lineNum">    4680 </span>            :           size_t prevsize = p-&gt;prev_foot;
<span class="lineNum">    4681 </span>            :           if ((prevsize &amp; IS_MMAPPED_BIT) != 0) {
<span class="lineNum">    4682 </span>            :             prevsize &amp;= ~IS_MMAPPED_BIT;
<span class="lineNum">    4683 </span>            :             psize += prevsize + MMAP_FOOT_PAD;
<span class="lineNum">    4684 </span>            :             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
<span class="lineNum">    4685 </span>            :               fm-&gt;footprint -= psize;
<span class="lineNum">    4686 </span>            :             goto postaction;
<span class="lineNum">    4687 </span>            :           }
<span class="lineNum">    4688 </span>            :           else {
<span class="lineNum">    4689 </span>            :             mchunkptr prev = chunk_minus_offset(p, prevsize);
<span class="lineNum">    4690 </span>            :             psize += prevsize;
<span class="lineNum">    4691 </span>            :             p = prev;
<span class="lineNum">    4692 </span>            :             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
<span class="lineNum">    4693 </span>            :               if (p != fm-&gt;dv) {
<span class="lineNum">    4694 </span>            :                 unlink_chunk(fm, p, prevsize);
<span class="lineNum">    4695 </span>            :               }
<span class="lineNum">    4696 </span>            :               else if ((next-&gt;head &amp; INUSE_BITS) == INUSE_BITS) {
<span class="lineNum">    4697 </span>            :                 fm-&gt;dvsize = psize;
<span class="lineNum">    4698 </span>            :                 set_free_with_pinuse(p, psize, next);
<span class="lineNum">    4699 </span>            :                 goto postaction;
<span class="lineNum">    4700 </span>            :               }
<span class="lineNum">    4701 </span>            :             }
<span class="lineNum">    4702 </span>            :             else
<span class="lineNum">    4703 </span>            :               goto erroraction;
<span class="lineNum">    4704 </span>            :           }
<span class="lineNum">    4705 </span>            :         }
<span class="lineNum">    4706 </span>            : 
<span class="lineNum">    4707 </span>            :         if (RTCHECK(ok_next(p, next) &amp;&amp; ok_pinuse(next))) {
<span class="lineNum">    4708 </span>            :           if (!cinuse(next)) {  /* consolidate forward */
<span class="lineNum">    4709 </span>            :             if (next == fm-&gt;top) {
<span class="lineNum">    4710 </span>            :               size_t tsize = fm-&gt;topsize += psize;
<span class="lineNum">    4711 </span>            :               fm-&gt;top = p;
<span class="lineNum">    4712 </span>            :               p-&gt;head = tsize | PINUSE_BIT;
<span class="lineNum">    4713 </span>            :               if (p == fm-&gt;dv) {
<span class="lineNum">    4714 </span>            :                 fm-&gt;dv = 0;
<span class="lineNum">    4715 </span>            :                 fm-&gt;dvsize = 0;
<span class="lineNum">    4716 </span>            :               }
<span class="lineNum">    4717 </span>            :               if (should_trim(fm, tsize))
<span class="lineNum">    4718 </span>            :                 sys_trim(fm, 0);
<span class="lineNum">    4719 </span>            :               goto postaction;
<span class="lineNum">    4720 </span>            :             }
<span class="lineNum">    4721 </span>            :             else if (next == fm-&gt;dv) {
<span class="lineNum">    4722 </span>            :               size_t dsize = fm-&gt;dvsize += psize;
<span class="lineNum">    4723 </span>            :               fm-&gt;dv = p;
<span class="lineNum">    4724 </span>            :               set_size_and_pinuse_of_free_chunk(p, dsize);
<span class="lineNum">    4725 </span>            :               goto postaction;
<span class="lineNum">    4726 </span>            :             }
<span class="lineNum">    4727 </span>            :             else {
<span class="lineNum">    4728 </span>            :               size_t nsize = chunksize(next);
<span class="lineNum">    4729 </span>            :               psize += nsize;
<span class="lineNum">    4730 </span>            :               unlink_chunk(fm, next, nsize);
<span class="lineNum">    4731 </span>            :               set_size_and_pinuse_of_free_chunk(p, psize);
<span class="lineNum">    4732 </span>            :               if (p == fm-&gt;dv) {
<span class="lineNum">    4733 </span>            :                 fm-&gt;dvsize = psize;
<span class="lineNum">    4734 </span>            :                 goto postaction;
<span class="lineNum">    4735 </span>            :               }
<span class="lineNum">    4736 </span>            :             }
<span class="lineNum">    4737 </span>            :           }
<span class="lineNum">    4738 </span>            :           else
<span class="lineNum">    4739 </span>            :             set_free_with_pinuse(p, psize, next);
<span class="lineNum">    4740 </span>            :           insert_chunk(fm, p, psize);
<span class="lineNum">    4741 </span>            :           check_free_chunk(fm, p);
<span class="lineNum">    4742 </span>            :           goto postaction;
<span class="lineNum">    4743 </span>            :         }
<span class="lineNum">    4744 </span>            :       }
<span class="lineNum">    4745 </span>            :     erroraction:
<span class="lineNum">    4746 </span>            :       USAGE_ERROR_ACTION(fm, p);
<span class="lineNum">    4747 </span>            :     postaction:
<span class="lineNum">    4748 </span>            :       POSTACTION(fm);
<span class="lineNum">    4749 </span>            :     }
<span class="lineNum">    4750 </span>            :   }
<span class="lineNum">    4751 </span>            : }
<span class="lineNum">    4752 </span>            : 
<span class="lineNum">    4753 </span>            : void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
<span class="lineNum">    4754 </span>            :   void* mem;
<span class="lineNum">    4755 </span>            :   size_t req = 0;
<span class="lineNum">    4756 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4757 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4758 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4759 </span>            :     return 0;
<span class="lineNum">    4760 </span>            :   }
<span class="lineNum">    4761 </span>            :   if (n_elements != 0) {
<span class="lineNum">    4762 </span>            :     req = n_elements * elem_size;
<span class="lineNum">    4763 </span>            :     if (((n_elements | elem_size) &amp; ~(size_t)0xffff) &amp;&amp;
<span class="lineNum">    4764 </span>            :         (req / n_elements != elem_size))
<span class="lineNum">    4765 </span>            :       req = MAX_SIZE_T; /* force downstream failure on overflow */
<span class="lineNum">    4766 </span>            :   }
<span class="lineNum">    4767 </span>            :   mem = internal_malloc(ms, req);
<span class="lineNum">    4768 </span>            :   if (mem != 0 &amp;&amp; calloc_must_clear(mem2chunk(mem)))
<span class="lineNum">    4769 </span>            :     memset(mem, 0, req);
<span class="lineNum">    4770 </span>            :   return mem;
<span class="lineNum">    4771 </span>            : }
<span class="lineNum">    4772 </span>            : 
<span class="lineNum">    4773 </span>            : void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
<span class="lineNum">    4774 </span>            :   if (oldmem == 0)
<span class="lineNum">    4775 </span>            :     return mspace_malloc(msp, bytes);
<span class="lineNum">    4776 </span>            : #ifdef REALLOC_ZERO_BYTES_FREES
<span class="lineNum">    4777 </span>            :   if (bytes == 0) {
<span class="lineNum">    4778 </span>            :     mspace_free(msp, oldmem);
<span class="lineNum">    4779 </span>            :     return 0;
<span class="lineNum">    4780 </span>            :   }
<span class="lineNum">    4781 </span>            : #endif /* REALLOC_ZERO_BYTES_FREES */
<span class="lineNum">    4782 </span>            :   else {
<span class="lineNum">    4783 </span>            : #if FOOTERS
<span class="lineNum">    4784 </span>            :     mchunkptr p  = mem2chunk(oldmem);
<span class="lineNum">    4785 </span>            :     mstate ms = get_mstate_for(p);
<span class="lineNum">    4786 </span>            : #else /* FOOTERS */
<span class="lineNum">    4787 </span>            :     mstate ms = (mstate)msp;
<span class="lineNum">    4788 </span>            : #endif /* FOOTERS */
<span class="lineNum">    4789 </span>            :     if (!ok_magic(ms)) {
<span class="lineNum">    4790 </span>            :       USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4791 </span>            :       return 0;
<span class="lineNum">    4792 </span>            :     }
<span class="lineNum">    4793 </span>            :     return internal_realloc(ms, oldmem, bytes);
<span class="lineNum">    4794 </span>            :   }
<span class="lineNum">    4795 </span>            : }
<span class="lineNum">    4796 </span>            : 
<span class="lineNum">    4797 </span>            : void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
<span class="lineNum">    4798 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4799 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4800 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4801 </span>            :     return 0;
<span class="lineNum">    4802 </span>            :   }
<span class="lineNum">    4803 </span>            :   return internal_memalign(ms, alignment, bytes);
<span class="lineNum">    4804 </span>            : }
<span class="lineNum">    4805 </span>            : 
<span class="lineNum">    4806 </span>            : void** mspace_independent_calloc(mspace msp, size_t n_elements,
<span class="lineNum">    4807 </span>            :                                  size_t elem_size, void* chunks[]) {
<span class="lineNum">    4808 </span>            :   size_t sz = elem_size; /* serves as 1-element array */
<span class="lineNum">    4809 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4810 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4811 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4812 </span>            :     return 0;
<span class="lineNum">    4813 </span>            :   }
<span class="lineNum">    4814 </span>            :   return ialloc(ms, n_elements, &amp;sz, 3, chunks);
<span class="lineNum">    4815 </span>            : }
<span class="lineNum">    4816 </span>            : 
<span class="lineNum">    4817 </span>            : void** mspace_independent_comalloc(mspace msp, size_t n_elements,
<span class="lineNum">    4818 </span>            :                                    size_t sizes[], void* chunks[]) {
<span class="lineNum">    4819 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4820 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4821 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4822 </span>            :     return 0;
<span class="lineNum">    4823 </span>            :   }
<span class="lineNum">    4824 </span>            :   return ialloc(ms, n_elements, sizes, 0, chunks);
<span class="lineNum">    4825 </span>            : }
<span class="lineNum">    4826 </span>            : 
<span class="lineNum">    4827 </span>            : int mspace_trim(mspace msp, size_t pad) {
<span class="lineNum">    4828 </span>            :   int result = 0;
<span class="lineNum">    4829 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4830 </span>            :   if (ok_magic(ms)) {
<span class="lineNum">    4831 </span>            :     if (!PREACTION(ms)) {
<span class="lineNum">    4832 </span>            :       result = sys_trim(ms, pad);
<span class="lineNum">    4833 </span>            :       POSTACTION(ms);
<span class="lineNum">    4834 </span>            :     }
<span class="lineNum">    4835 </span>            :   }
<span class="lineNum">    4836 </span>            :   else {
<span class="lineNum">    4837 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4838 </span>            :   }
<span class="lineNum">    4839 </span>            :   return result;
<span class="lineNum">    4840 </span>            : }
<span class="lineNum">    4841 </span>            : 
<span class="lineNum">    4842 </span>            : void mspace_malloc_stats(mspace msp) {
<span class="lineNum">    4843 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4844 </span>            :   if (ok_magic(ms)) {
<span class="lineNum">    4845 </span>            :     internal_malloc_stats(ms);
<span class="lineNum">    4846 </span>            :   }
<span class="lineNum">    4847 </span>            :   else {
<span class="lineNum">    4848 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4849 </span>            :   }
<span class="lineNum">    4850 </span>            : }
<span class="lineNum">    4851 </span>            : 
<span class="lineNum">    4852 </span>            : size_t mspace_footprint(mspace msp) {
<span class="lineNum">    4853 </span>            :   size_t result;
<span class="lineNum">    4854 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4855 </span>            :   if (ok_magic(ms)) {
<span class="lineNum">    4856 </span>            :     result = ms-&gt;footprint;
<span class="lineNum">    4857 </span>            :   }
<span class="lineNum">    4858 </span>            :   USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4859 </span>            :   return result;
<span class="lineNum">    4860 </span>            : }
<span class="lineNum">    4861 </span>            : 
<span class="lineNum">    4862 </span>            : 
<span class="lineNum">    4863 </span>            : size_t mspace_max_footprint(mspace msp) {
<span class="lineNum">    4864 </span>            :   size_t result;
<span class="lineNum">    4865 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4866 </span>            :   if (ok_magic(ms)) {
<span class="lineNum">    4867 </span>            :     result = ms-&gt;max_footprint;
<span class="lineNum">    4868 </span>            :   }
<span class="lineNum">    4869 </span>            :   USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4870 </span>            :   return result;
<span class="lineNum">    4871 </span>            : }
<span class="lineNum">    4872 </span>            : 
<span class="lineNum">    4873 </span>            : 
<span class="lineNum">    4874 </span>            : #if !NO_MALLINFO
<span class="lineNum">    4875 </span>            : struct mallinfo mspace_mallinfo(mspace msp) {
<span class="lineNum">    4876 </span>            :   mstate ms = (mstate)msp;
<span class="lineNum">    4877 </span>            :   if (!ok_magic(ms)) {
<span class="lineNum">    4878 </span>            :     USAGE_ERROR_ACTION(ms,ms);
<span class="lineNum">    4879 </span>            :   }
<span class="lineNum">    4880 </span>            :   return internal_mallinfo(ms);
<span class="lineNum">    4881 </span>            : }
<span class="lineNum">    4882 </span>            : #endif /* NO_MALLINFO */
<span class="lineNum">    4883 </span>            : 
<span class="lineNum">    4884 </span>            : int mspace_mallopt(int param_number, int value) {
<span class="lineNum">    4885 </span>            :   return change_mparam(param_number, value);
<span class="lineNum">    4886 </span>            : }
<span class="lineNum">    4887 </span>            : 
<span class="lineNum">    4888 </span>            : #endif /* MSPACES */
<span class="lineNum">    4889 </span>            : 
<span class="lineNum">    4890 </span>            : /* -------------------- Alternative MORECORE functions ------------------- */
<span class="lineNum">    4891 </span>            : 
<span class="lineNum">    4892 </span>            : /*
<span class="lineNum">    4893 </span>            :   Guidelines for creating a custom version of MORECORE:
<span class="lineNum">    4894 </span>            : 
<span class="lineNum">    4895 </span>            :   * For best performance, MORECORE should allocate in multiples of pagesize.
<span class="lineNum">    4896 </span>            :   * MORECORE may allocate more memory than requested. (Or even less,
<span class="lineNum">    4897 </span>            :       but this will usually result in a malloc failure.)
<span class="lineNum">    4898 </span>            :   * MORECORE must not allocate memory when given argument zero, but
<span class="lineNum">    4899 </span>            :       instead return one past the end address of memory from previous
<span class="lineNum">    4900 </span>            :       nonzero call.
<span class="lineNum">    4901 </span>            :   * For best performance, consecutive calls to MORECORE with positive
<span class="lineNum">    4902 </span>            :       arguments should return increasing addresses, indicating that
<span class="lineNum">    4903 </span>            :       space has been contiguously extended.
<span class="lineNum">    4904 </span>            :   * Even though consecutive calls to MORECORE need not return contiguous
<span class="lineNum">    4905 </span>            :       addresses, it must be OK for malloc'ed chunks to span multiple
<span class="lineNum">    4906 </span>            :       regions in those cases where they do happen to be contiguous.
<span class="lineNum">    4907 </span>            :   * MORECORE need not handle negative arguments -- it may instead
<span class="lineNum">    4908 </span>            :       just return MFAIL when given negative arguments.
<span class="lineNum">    4909 </span>            :       Negative arguments are always multiples of pagesize. MORECORE
<span class="lineNum">    4910 </span>            :       must not misinterpret negative args as large positive unsigned
<span class="lineNum">    4911 </span>            :       args. You can suppress all such calls from even occurring by defining
<span class="lineNum">    4912 </span>            :       MORECORE_CANNOT_TRIM,
<span class="lineNum">    4913 </span>            : 
<span class="lineNum">    4914 </span>            :   As an example alternative MORECORE, here is a custom allocator
<span class="lineNum">    4915 </span>            :   kindly contributed for pre-OSX macOS.  It uses virtually but not
<span class="lineNum">    4916 </span>            :   necessarily physically contiguous non-paged memory (locked in,
<span class="lineNum">    4917 </span>            :   present and won't get swapped out).  You can use it by uncommenting
<span class="lineNum">    4918 </span>            :   this section, adding some #includes, and setting up the appropriate
<span class="lineNum">    4919 </span>            :   defines above:
<span class="lineNum">    4920 </span>            : 
<span class="lineNum">    4921 </span>            :       #define MORECORE osMoreCore
<span class="lineNum">    4922 </span>            : 
<span class="lineNum">    4923 </span>            :   There is also a shutdown routine that should somehow be called for
<span class="lineNum">    4924 </span>            :   cleanup upon program exit.
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span>            :   #define MAX_POOL_ENTRIES 100
<span class="lineNum">    4927 </span>            :   #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
<span class="lineNum">    4928 </span>            :   static int next_os_pool;
<span class="lineNum">    4929 </span>            :   void *our_os_pools[MAX_POOL_ENTRIES];
<span class="lineNum">    4930 </span>            : 
<span class="lineNum">    4931 </span>            :   void *osMoreCore(int size)
<span class="lineNum">    4932 </span>            :   {
<span class="lineNum">    4933 </span>            :     void *ptr = 0;
<span class="lineNum">    4934 </span>            :     static void *sbrk_top = 0;
<span class="lineNum">    4935 </span>            : 
<span class="lineNum">    4936 </span>            :     if (size &gt; 0)
<span class="lineNum">    4937 </span>            :     {
<span class="lineNum">    4938 </span>            :       if (size &lt; MINIMUM_MORECORE_SIZE)
<span class="lineNum">    4939 </span>            :          size = MINIMUM_MORECORE_SIZE;
<span class="lineNum">    4940 </span>            :       if (CurrentExecutionLevel() == kTaskLevel)
<span class="lineNum">    4941 </span>            :          ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
<span class="lineNum">    4942 </span>            :       if (ptr == 0)
<span class="lineNum">    4943 </span>            :       {
<span class="lineNum">    4944 </span>            :         return (void *) MFAIL;
<span class="lineNum">    4945 </span>            :       }
<span class="lineNum">    4946 </span>            :       // save ptrs so they can be freed during cleanup
<span class="lineNum">    4947 </span>            :       our_os_pools[next_os_pool] = ptr;
<span class="lineNum">    4948 </span>            :       next_os_pool++;
<span class="lineNum">    4949 </span>            :       ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) &amp; ~RM_PAGE_MASK);
<span class="lineNum">    4950 </span>            :       sbrk_top = (char *) ptr + size;
<span class="lineNum">    4951 </span>            :       return ptr;
<span class="lineNum">    4952 </span>            :     }
<span class="lineNum">    4953 </span>            :     else if (size &lt; 0)
<span class="lineNum">    4954 </span>            :     {
<span class="lineNum">    4955 </span>            :       // we don't currently support shrink behavior
<span class="lineNum">    4956 </span>            :       return (void *) MFAIL;
<span class="lineNum">    4957 </span>            :     }
<span class="lineNum">    4958 </span>            :     else
<span class="lineNum">    4959 </span>            :     {
<span class="lineNum">    4960 </span>            :       return sbrk_top;
<span class="lineNum">    4961 </span>            :     }
<span class="lineNum">    4962 </span>            :   }
<span class="lineNum">    4963 </span>            : 
<span class="lineNum">    4964 </span>            :   // cleanup any allocated memory pools
<span class="lineNum">    4965 </span>            :   // called as last thing before shutting down driver
<span class="lineNum">    4966 </span>            : 
<span class="lineNum">    4967 </span>            :   void osCleanupMem(void)
<span class="lineNum">    4968 </span>            :   {
<span class="lineNum">    4969 </span>            :     void **ptr;
<span class="lineNum">    4970 </span>            : 
<span class="lineNum">    4971 </span>            :     for (ptr = our_os_pools; ptr &lt; &amp;our_os_pools[MAX_POOL_ENTRIES]; ptr++)
<span class="lineNum">    4972 </span>            :       if (*ptr)
<span class="lineNum">    4973 </span>            :       {
<span class="lineNum">    4974 </span>            :          PoolDeallocate(*ptr);
<span class="lineNum">    4975 </span>            :          *ptr = 0;
<span class="lineNum">    4976 </span>            :       }
<span class="lineNum">    4977 </span>            :   }
<span class="lineNum">    4978 </span>            : 
<span class="lineNum">    4979 </span>            : */
<span class="lineNum">    4980 </span>            : 
<span class="lineNum">    4981 </span>            : 
<span class="lineNum">    4982 </span>            : /* -----------------------------------------------------------------------
<span class="lineNum">    4983 </span>            : History:
<span class="lineNum">    4984 </span>            :     V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
<span class="lineNum">    4985 </span>            :       * Add max_footprint functions
<span class="lineNum">    4986 </span>            :       * Ensure all appropriate literals are size_t
<span class="lineNum">    4987 </span>            :       * Fix conditional compilation problem for some #define settings
<span class="lineNum">    4988 </span>            :       * Avoid concatenating segments with the one provided
<span class="lineNum">    4989 </span>            :         in create_mspace_with_base
<span class="lineNum">    4990 </span>            :       * Rename some variables to avoid compiler shadowing warnings
<span class="lineNum">    4991 </span>            :       * Use explicit lock initialization.
<span class="lineNum">    4992 </span>            :       * Better handling of sbrk interference.
<span class="lineNum">    4993 </span>            :       * Simplify and fix segment insertion, trimming and mspace_destroy
<span class="lineNum">    4994 </span>            :       * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
<span class="lineNum">    4995 </span>            :       * Thanks especially to Dennis Flanagan for help on these.
<span class="lineNum">    4996 </span>            : 
<span class="lineNum">    4997 </span>            :     V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
<span class="lineNum">    4998 </span>            :       * Fix memalign brace error.
<span class="lineNum">    4999 </span>            : 
<span class="lineNum">    5000 </span>            :     V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
<span class="lineNum">    5001 </span>            :       * Fix improper #endif nesting in C++
<span class="lineNum">    5002 </span>            :       * Add explicit casts needed for C++
<span class="lineNum">    5003 </span>            : 
<span class="lineNum">    5004 </span>            :     V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
<span class="lineNum">    5005 </span>            :       * Use trees for large bins
<span class="lineNum">    5006 </span>            :       * Support mspaces
<span class="lineNum">    5007 </span>            :       * Use segments to unify sbrk-based and mmap-based system allocation,
<span class="lineNum">    5008 </span>            :         removing need for emulation on most platforms without sbrk.
<span class="lineNum">    5009 </span>            :       * Default safety checks
<span class="lineNum">    5010 </span>            :       * Optional footer checks. Thanks to William Robertson for the idea.
<span class="lineNum">    5011 </span>            :       * Internal code refactoring
<span class="lineNum">    5012 </span>            :       * Incorporate suggestions and platform-specific changes.
<span class="lineNum">    5013 </span>            :         Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
<span class="lineNum">    5014 </span>            :         Aaron Bachmann,  Emery Berger, and others.
<span class="lineNum">    5015 </span>            :       * Speed up non-fastbin processing enough to remove fastbins.
<span class="lineNum">    5016 </span>            :       * Remove useless cfree() to avoid conflicts with other apps.
<span class="lineNum">    5017 </span>            :       * Remove internal memcpy, memset. Compilers handle builtins better.
<span class="lineNum">    5018 </span>            :       * Remove some options that no one ever used and rename others.
<span class="lineNum">    5019 </span>            : 
<span class="lineNum">    5020 </span>            :     V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
<span class="lineNum">    5021 </span>            :       * Fix malloc_state bitmap array misdeclaration
<span class="lineNum">    5022 </span>            : 
<span class="lineNum">    5023 </span>            :     V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
<span class="lineNum">    5024 </span>            :       * Allow tuning of FIRST_SORTED_BIN_SIZE
<span class="lineNum">    5025 </span>            :       * Use PTR_UINT as type for all ptr-&gt;int casts. Thanks to John Belmonte.
<span class="lineNum">    5026 </span>            :       * Better detection and support for non-contiguousness of MORECORE.
<span class="lineNum">    5027 </span>            :         Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
<span class="lineNum">    5028 </span>            :       * Bypass most of malloc if no frees. Thanks To Emery Berger.
<span class="lineNum">    5029 </span>            :       * Fix freeing of old top non-contiguous chunk im sysmalloc.
<span class="lineNum">    5030 </span>            :       * Raised default trim and map thresholds to 256K.
<span class="lineNum">    5031 </span>            :       * Fix mmap-related #defines. Thanks to Lubos Lunak.
<span class="lineNum">    5032 </span>            :       * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
<span class="lineNum">    5033 </span>            :       * Branch-free bin calculation
<span class="lineNum">    5034 </span>            :       * Default trim and mmap thresholds now 256K.
<span class="lineNum">    5035 </span>            : 
<span class="lineNum">    5036 </span>            :     V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
<span class="lineNum">    5037 </span>            :       * Introduce independent_comalloc and independent_calloc.
<span class="lineNum">    5038 </span>            :         Thanks to Michael Pachos for motivation and help.
<span class="lineNum">    5039 </span>            :       * Make optional .h file available
<span class="lineNum">    5040 </span>            :       * Allow &gt; 2GB requests on 32bit systems.
<span class="lineNum">    5041 </span>            :       * new WIN32 sbrk, mmap, munmap, lock code from &lt;Walter@GeNeSys-e.de&gt;.
<span class="lineNum">    5042 </span>            :         Thanks also to Andreas Mueller &lt;a.mueller at paradatec.de&gt;,
<span class="lineNum">    5043 </span>            :         and Anonymous.
<span class="lineNum">    5044 </span>            :       * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
<span class="lineNum">    5045 </span>            :         helping test this.)
<span class="lineNum">    5046 </span>            :       * memalign: check alignment arg
<span class="lineNum">    5047 </span>            :       * realloc: don't try to shift chunks backwards, since this
<span class="lineNum">    5048 </span>            :         leads to  more fragmentation in some programs and doesn't
<span class="lineNum">    5049 </span>            :         seem to help in any others.
<span class="lineNum">    5050 </span>            :       * Collect all cases in malloc requiring system memory into sysmalloc
<span class="lineNum">    5051 </span>            :       * Use mmap as backup to sbrk
<span class="lineNum">    5052 </span>            :       * Place all internal state in malloc_state
<span class="lineNum">    5053 </span>            :       * Introduce fastbins (although similar to 2.5.1)
<span class="lineNum">    5054 </span>            :       * Many minor tunings and cosmetic improvements
<span class="lineNum">    5055 </span>            :       * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
<span class="lineNum">    5056 </span>            :       * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
<span class="lineNum">    5057 </span>            :         Thanks to Tony E. Bennett &lt;tbennett@nvidia.com&gt; and others.
<span class="lineNum">    5058 </span>            :       * Include errno.h to support default failure action.
<span class="lineNum">    5059 </span>            : 
<span class="lineNum">    5060 </span>            :     V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
<span class="lineNum">    5061 </span>            :       * return null for negative arguments
<span class="lineNum">    5062 </span>            :       * Added Several WIN32 cleanups from Martin C. Fong &lt;mcfong at yahoo.com&gt;
<span class="lineNum">    5063 </span>            :          * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
<span class="lineNum">    5064 </span>            :           (e.g. WIN32 platforms)
<span class="lineNum">    5065 </span>            :          * Cleanup header file inclusion for WIN32 platforms
<span class="lineNum">    5066 </span>            :          * Cleanup code to avoid Microsoft Visual C++ compiler complaints
<span class="lineNum">    5067 </span>            :          * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
<span class="lineNum">    5068 </span>            :            memory allocation routines
<span class="lineNum">    5069 </span>            :          * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
<span class="lineNum">    5070 </span>            :          * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
<span class="lineNum">    5071 </span>            :            usage of 'assert' in non-WIN32 code
<span class="lineNum">    5072 </span>            :          * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
<span class="lineNum">    5073 </span>            :            avoid infinite loop
<span class="lineNum">    5074 </span>            :       * Always call 'fREe()' rather than 'free()'
<span class="lineNum">    5075 </span>            : 
<span class="lineNum">    5076 </span>            :     V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
<span class="lineNum">    5077 </span>            :       * Fixed ordering problem with boundary-stamping
<span class="lineNum">    5078 </span>            : 
<span class="lineNum">    5079 </span>            :     V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
<span class="lineNum">    5080 </span>            :       * Added pvalloc, as recommended by H.J. Liu
<span class="lineNum">    5081 </span>            :       * Added 64bit pointer support mainly from Wolfram Gloger
<span class="lineNum">    5082 </span>            :       * Added anonymously donated WIN32 sbrk emulation
<span class="lineNum">    5083 </span>            :       * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
<span class="lineNum">    5084 </span>            :       * malloc_extend_top: fix mask error that caused wastage after
<span class="lineNum">    5085 </span>            :         foreign sbrks
<span class="lineNum">    5086 </span>            :       * Add linux mremap support code from HJ Liu
<span class="lineNum">    5087 </span>            : 
<span class="lineNum">    5088 </span>            :     V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
<span class="lineNum">    5089 </span>            :       * Integrated most documentation with the code.
<span class="lineNum">    5090 </span>            :       * Add support for mmap, with help from
<span class="lineNum">    5091 </span>            :         Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
<span class="lineNum">    5092 </span>            :       * Use last_remainder in more cases.
<span class="lineNum">    5093 </span>            :       * Pack bins using idea from  colin@nyx10.cs.du.edu
<span class="lineNum">    5094 </span>            :       * Use ordered bins instead of best-fit threshold
<span class="lineNum">    5095 </span>            :       * Eliminate block-local decls to simplify tracing and debugging.
<span class="lineNum">    5096 </span>            :       * Support another case of realloc via move into top
<span class="lineNum">    5097 </span>            :       * Fix error occurring when initial sbrk_base not word-aligned.
<span class="lineNum">    5098 </span>            :       * Rely on page size for units instead of SBRK_UNIT to
<span class="lineNum">    5099 </span>            :         avoid surprises about sbrk alignment conventions.
<span class="lineNum">    5100 </span>            :       * Add mallinfo, mallopt. Thanks to Raymond Nijssen
<span class="lineNum">    5101 </span>            :         (raymond@es.ele.tue.nl) for the suggestion.
<span class="lineNum">    5102 </span>            :       * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
<span class="lineNum">    5103 </span>            :       * More precautions for cases where other routines call sbrk,
<span class="lineNum">    5104 </span>            :         courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
<span class="lineNum">    5105 </span>            :       * Added macros etc., allowing use in linux libc from
<span class="lineNum">    5106 </span>            :         H.J. Lu (hjl@gnu.ai.mit.edu)
<span class="lineNum">    5107 </span>            :       * Inverted this history list
<span class="lineNum">    5108 </span>            : 
<span class="lineNum">    5109 </span>            :     V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
<span class="lineNum">    5110 </span>            :       * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
<span class="lineNum">    5111 </span>            :       * Removed all preallocation code since under current scheme
<span class="lineNum">    5112 </span>            :         the work required to undo bad preallocations exceeds
<span class="lineNum">    5113 </span>            :         the work saved in good cases for most test programs.
<span class="lineNum">    5114 </span>            :       * No longer use return list or unconsolidated bins since
<span class="lineNum">    5115 </span>            :         no scheme using them consistently outperforms those that don't
<span class="lineNum">    5116 </span>            :         given above changes.
<span class="lineNum">    5117 </span>            :       * Use best fit for very large chunks to prevent some worst-cases.
<span class="lineNum">    5118 </span>            :       * Added some support for debugging
<span class="lineNum">    5119 </span>            : 
<span class="lineNum">    5120 </span>            :     V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
<span class="lineNum">    5121 </span>            :       * Removed footers when chunks are in use. Thanks to
<span class="lineNum">    5122 </span>            :         Paul Wilson (wilson@cs.texas.edu) for the suggestion.
<span class="lineNum">    5123 </span>            : 
<span class="lineNum">    5124 </span>            :     V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
<span class="lineNum">    5125 </span>            :       * Added malloc_trim, with help from Wolfram Gloger
<span class="lineNum">    5126 </span>            :         (wmglo@Dent.MED.Uni-Muenchen.DE).
<span class="lineNum">    5127 </span>            : 
<span class="lineNum">    5128 </span>            :     V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)
<span class="lineNum">    5129 </span>            : 
<span class="lineNum">    5130 </span>            :     V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
<span class="lineNum">    5131 </span>            :       * realloc: try to expand in both directions
<span class="lineNum">    5132 </span>            :       * malloc: swap order of clean-bin strategy;
<span class="lineNum">    5133 </span>            :       * realloc: only conditionally expand backwards
<span class="lineNum">    5134 </span>            :       * Try not to scavenge used bins
<span class="lineNum">    5135 </span>            :       * Use bin counts as a guide to preallocation
<span class="lineNum">    5136 </span>            :       * Occasionally bin return list chunks in first scan
<span class="lineNum">    5137 </span>            :       * Add a few optimizations from colin@nyx10.cs.du.edu
<span class="lineNum">    5138 </span>            : 
<span class="lineNum">    5139 </span>            :     V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
<span class="lineNum">    5140 </span>            :       * faster bin computation &amp; slightly different binning
<span class="lineNum">    5141 </span>            :       * merged all consolidations to one part of malloc proper
<span class="lineNum">    5142 </span>            :          (eliminating old malloc_find_space &amp; malloc_clean_bin)
<span class="lineNum">    5143 </span>            :       * Scan 2 returns chunks (not just 1)
<span class="lineNum">    5144 </span>            :       * Propagate failure in realloc if malloc returns 0
<span class="lineNum">    5145 </span>            :       * Add stuff to allow compilation on non-ANSI compilers
<span class="lineNum">    5146 </span>            :           from kpv@research.att.com
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span>            :     V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
<span class="lineNum">    5149 </span>            :       * removed potential for odd address access in prev_chunk
<span class="lineNum">    5150 </span>            :       * removed dependency on getpagesize.h
<span class="lineNum">    5151 </span>            :       * misc cosmetics and a bit more internal documentation
<span class="lineNum">    5152 </span>            :       * anticosmetics: mangled names in macros to evade debugger strangeness
<span class="lineNum">    5153 </span>            :       * tested on sparc, hp-700, dec-mips, rs6000
<span class="lineNum">    5154 </span>            :           with gcc &amp; native cc (hp, dec only) allowing
<span class="lineNum">    5155 </span>            :           Detlefs &amp; Zorn comparison study (in SIGPLAN Notices.)
<span class="lineNum">    5156 </span>            : 
<span class="lineNum">    5157 </span>            :     Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
<span class="lineNum">    5158 </span>            :       * Based loosely on libg++-1.2X malloc. (It retains some of the overall
<span class="lineNum">    5159 </span>            :          structure of old version,  but most details differ.)
<span class="lineNum">    5160 </span>            :  
<span class="lineNum">    5161 </span>            : */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

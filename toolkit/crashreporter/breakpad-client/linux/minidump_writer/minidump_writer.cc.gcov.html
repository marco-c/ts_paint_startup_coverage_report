<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - toolkit/crashreporter/breakpad-client/linux/minidump_writer/minidump_writer.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">toolkit/crashreporter/breakpad-client/linux/minidump_writer</a> - minidump_writer.cc<span style="font-size: 80%;"> (source / <a href="minidump_writer.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">547</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">32</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2010, Google Inc.</a>
<span class="lineNum">       2 </span>            : // All rights reserved.
<span class="lineNum">       3 </span>            : //
<span class="lineNum">       4 </span>            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       5 </span>            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       6 </span>            : // met:
<span class="lineNum">       7 </span>            : //
<span class="lineNum">       8 </span>            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">       9 </span>            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      10 </span>            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      11 </span>            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      12 </span>            : // in the documentation and/or other materials provided with the
<span class="lineNum">      13 </span>            : // distribution.
<span class="lineNum">      14 </span>            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      15 </span>            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      16 </span>            : // this software without specific prior written permission.
<span class="lineNum">      17 </span>            : //
<span class="lineNum">      18 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      19 </span>            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      20 </span>            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      21 </span>            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      22 </span>            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      23 </span>            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      24 </span>            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      25 </span>            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      26 </span>            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      27 </span>            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      28 </span>            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : // This code writes out minidump files:
<span class="lineNum">      31 </span>            : //   http://msdn.microsoft.com/en-us/library/ms680378(VS.85,loband).aspx
<span class="lineNum">      32 </span>            : //
<span class="lineNum">      33 </span>            : // Minidumps are a Microsoft format which Breakpad uses for recording crash
<span class="lineNum">      34 </span>            : // dumps. This code has to run in a compromised environment (the address space
<span class="lineNum">      35 </span>            : // may have received SIGSEGV), thus the following rules apply:
<span class="lineNum">      36 </span>            : //   * You may not enter the dynamic linker. This means that we cannot call
<span class="lineNum">      37 </span>            : //     any symbols in a shared library (inc libc). Because of this we replace
<span class="lineNum">      38 </span>            : //     libc functions in linux_libc_support.h.
<span class="lineNum">      39 </span>            : //   * You may not call syscalls via the libc wrappers. This rule is a subset
<span class="lineNum">      40 </span>            : //     of the first rule but it bears repeating. We have direct wrappers
<span class="lineNum">      41 </span>            : //     around the system calls in linux_syscall_support.h.
<span class="lineNum">      42 </span>            : //   * You may not malloc. There's an alternative allocator in memory.h and
<span class="lineNum">      43 </span>            : //     a canonical instance in the LinuxDumper object. We use the placement
<span class="lineNum">      44 </span>            : //     new form to allocate objects and we don't delete them.
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #include &quot;linux/handler/minidump_descriptor.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;linux/minidump_writer/minidump_writer.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;minidump_file_writer-inl.h&quot;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;link.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      55 </span>            : #if defined(__ANDROID__)
<span class="lineNum">      56 </span>            : #include &lt;sys/system_properties.h&gt;
<span class="lineNum">      57 </span>            : #endif
<span class="lineNum">      58 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      59 </span>            : #include &lt;sys/ucontext.h&gt;
<span class="lineNum">      60 </span>            : #include &lt;sys/user.h&gt;
<span class="lineNum">      61 </span>            : #include &lt;sys/utsname.h&gt;
<span class="lineNum">      62 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      63 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #include &quot;linux/dump_writer_common/thread_info.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;linux/dump_writer_common/ucontext_reader.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;linux/handler/exception_handler.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;linux/minidump_writer/cpu_set.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;linux/minidump_writer/line_reader.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;linux/minidump_writer/linux_dumper.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;linux/minidump_writer/linux_ptrace_dumper.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;linux/minidump_writer/proc_cpuinfo_reader.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;minidump_file_writer.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;common/linux/file_id.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;common/linux/linux_libc_support.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;common/minidump_type_helper.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;google_breakpad/common/minidump_format.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;third_party/lss/linux_syscall_support.h&quot;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : namespace {
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : using google_breakpad::AppMemoryList;
<span class="lineNum">      85 </span>            : using google_breakpad::auto_wasteful_vector;
<span class="lineNum">      86 </span>            : using google_breakpad::ExceptionHandler;
<span class="lineNum">      87 </span>            : using google_breakpad::CpuSet;
<span class="lineNum">      88 </span>            : using google_breakpad::kDefaultBuildIdSize;
<span class="lineNum">      89 </span>            : using google_breakpad::LineReader;
<span class="lineNum">      90 </span>            : using google_breakpad::LinuxDumper;
<span class="lineNum">      91 </span>            : using google_breakpad::LinuxPtraceDumper;
<span class="lineNum">      92 </span>            : using google_breakpad::MDTypeHelper;
<span class="lineNum">      93 </span>            : using google_breakpad::MappingEntry;
<span class="lineNum">      94 </span>            : using google_breakpad::MappingInfo;
<span class="lineNum">      95 </span>            : using google_breakpad::MappingList;
<span class="lineNum">      96 </span>            : using google_breakpad::MinidumpFileWriter;
<span class="lineNum">      97 </span>            : using google_breakpad::PageAllocator;
<span class="lineNum">      98 </span>            : using google_breakpad::ProcCpuInfoReader;
<span class="lineNum">      99 </span>            : using google_breakpad::RawContextCPU;
<span class="lineNum">     100 </span>            : using google_breakpad::ThreadInfo;
<span class="lineNum">     101 </span>            : using google_breakpad::TypedMDRVA;
<span class="lineNum">     102 </span>            : using google_breakpad::UContextReader;
<span class="lineNum">     103 </span>            : using google_breakpad::UntypedMDRVA;
<span class="lineNum">     104 </span>            : using google_breakpad::wasteful_vector;
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : typedef MDTypeHelper&lt;sizeof(void*)&gt;::MDRawDebug MDRawDebug;
<span class="lineNum">     107 </span>            : typedef MDTypeHelper&lt;sizeof(void*)&gt;::MDRawLinkMap MDRawLinkMap;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : class MinidumpWriter {
<span class="lineNum">     110 </span>            :  public:
<span class="lineNum">     111 </span>            :   // The following kLimit* constants are for when minidump_size_limit_ is set
<span class="lineNum">     112 </span>            :   // and the minidump size might exceed it.
<span class="lineNum">     113 </span>            :   //
<span class="lineNum">     114 </span>            :   // Estimate for how big each thread's stack will be (in bytes).
<span class="lineNum">     115 </span>            :   static const unsigned kLimitAverageThreadStackLength = 8 * 1024;
<span class="lineNum">     116 </span>            :   // Number of threads whose stack size we don't want to limit.  These base
<span class="lineNum">     117 </span>            :   // threads will simply be the first N threads returned by the dumper (although
<span class="lineNum">     118 </span>            :   // the crashing thread will never be limited).  Threads beyond this count are
<span class="lineNum">     119 </span>            :   // the extra threads.
<span class="lineNum">     120 </span>            :   static const unsigned kLimitBaseThreadCount = 20;
<span class="lineNum">     121 </span>            :   // Maximum stack size to dump for any extra thread (in bytes).
<span class="lineNum">     122 </span>            :   static const unsigned kLimitMaxExtraThreadStackLen = 2 * 1024;
<span class="lineNum">     123 </span>            :   // Make sure this number of additional bytes can fit in the minidump
<span class="lineNum">     124 </span>            :   // (exclude the stack data).
<a name="125"><span class="lineNum">     125 </span>            :   static const unsigned kLimitMinidumpFudgeFactor = 64 * 1024;</a>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   MinidumpWriter(const char* minidump_path,</span>
<span class="lineNum">     128 </span>            :                  int minidump_fd,
<span class="lineNum">     129 </span>            :                  const ExceptionHandler::CrashContext* context,
<span class="lineNum">     130 </span>            :                  const MappingList&amp; mappings,
<span class="lineNum">     131 </span>            :                  const AppMemoryList&amp; appmem,
<span class="lineNum">     132 </span>            :                  LinuxDumper* dumper)
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       : fd_(minidump_fd),</span>
<span class="lineNum">     134 </span>            :         path_(minidump_path),
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         ucontext_(context ? &amp;context-&gt;context : NULL),</span>
<span class="lineNum">     136 </span>            : #if !defined(__ARM_EABI__) &amp;&amp; !defined(__mips__)
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         float_state_(context ? &amp;context-&gt;float_state : NULL),</span>
<span class="lineNum">     138 </span>            : #endif
<span class="lineNum">     139 </span>            :         dumper_(dumper),
<span class="lineNum">     140 </span>            :         minidump_size_limit_(-1),
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         memory_blocks_(dumper_-&gt;allocator()),</span>
<span class="lineNum">     142 </span>            :         mapping_list_(mappings),
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :         app_memory_list_(appmem) {</span>
<span class="lineNum">     144 </span>            :     // Assert there should be either a valid fd or a valid path, not both.
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     assert(fd_ != -1 || minidump_path);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     assert(fd_ == -1 || !minidump_path);</span>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   bool Init() {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     if (!dumper_-&gt;Init())</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     if (fd_ != -1)</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :       minidump_writer_.SetFile(fd_);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     else if (!minidump_writer_.Open(path_))</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     return dumper_-&gt;ThreadsSuspend() &amp;&amp; dumper_-&gt;LateInit();</span>
<a name="159"><span class="lineNum">     159 </span>            :   }</a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   ~MinidumpWriter() {</span>
<span class="lineNum">     162 </span>            :     // Don't close the file descriptor when it's been provided explicitly.
<span class="lineNum">     163 </span>            :     // Callers might still need to use it.
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     if (fd_ == -1)</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       minidump_writer_.Close();</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     dumper_-&gt;ThreadsResume();</span>
<a name="167"><span class="lineNum">     167 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   bool Dump() {</span>
<span class="lineNum">     170 </span>            :     // A minidump file contains a number of tagged streams. This is the number
<span class="lineNum">     171 </span>            :     // of stream which we write.
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     unsigned kNumWriters = 13;</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;MDRawDirectory&gt; dir(&amp;minidump_writer_);</span>
<span class="lineNum">     175 </span>            :     {
<span class="lineNum">     176 </span>            :       // Ensure the header gets flushed, as that happens in the destructor.
<span class="lineNum">     177 </span>            :       // If we crash somewhere below, we should have a mostly-intact dump
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :       TypedMDRVA&lt;MDRawHeader&gt; header(&amp;minidump_writer_);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       if (!header.Allocate())</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       if (!dir.AllocateArray(kNumWriters))</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       my_memset(header.get(), 0, sizeof(MDRawHeader));</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       header.get()-&gt;signature = MD_HEADER_SIGNATURE;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :       header.get()-&gt;version = MD_HEADER_VERSION;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       header.get()-&gt;time_date_stamp = time(NULL);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       header.get()-&gt;stream_count = kNumWriters;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :       header.get()-&gt;stream_directory_rva = dir.position();</span>
<span class="lineNum">     192 </span>            :     }
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     unsigned dir_index = 0;</span>
<span class="lineNum">     195 </span>            :     MDRawDirectory dirent;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     if (!WriteThreadListStream(&amp;dirent))</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     if (!WriteMappings(&amp;dirent))</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     if (!WriteAppMemory())</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     if (!WriteMemoryListStream(&amp;dirent))</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (!WriteExceptionStream(&amp;dirent))</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     if (!WriteSystemInfoStream(&amp;dirent))</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_CPU_INFO;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (!WriteFile(&amp;dirent.location, &quot;/proc/cpuinfo&quot;))</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_PROC_STATUS;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     if (!WriteProcFile(&amp;dirent.location, GetCrashThread(), &quot;status&quot;))</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_LSB_RELEASE;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     if (!WriteFile(&amp;dirent.location, &quot;/etc/lsb-release&quot;))</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_CMD_LINE;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (!WriteProcFile(&amp;dirent.location, GetCrashThread(), &quot;cmdline&quot;))</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_ENVIRON;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if (!WriteProcFile(&amp;dirent.location, GetCrashThread(), &quot;environ&quot;))</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_AUXV;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     if (!WriteProcFile(&amp;dirent.location, GetCrashThread(), &quot;auxv&quot;))</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_MAPS;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     if (!WriteProcFile(&amp;dirent.location, GetCrashThread(), &quot;maps&quot;))</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     dirent.stream_type = MD_LINUX_DSO_DEBUG;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     if (!WriteDSODebugStream(&amp;dirent))</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       NullifyDirectoryEntry(&amp;dirent);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     dir.CopyIndex(dir_index++, &amp;dirent);</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     // If you add more directory entries, don't forget to update kNumWriters,
<span class="lineNum">     261 </span>            :     // above.
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     dumper_-&gt;ThreadsResume();</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="265"><span class="lineNum">     265 </span>            :   }</a>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   bool FillThreadStack(MDRawThread* thread, uintptr_t stack_pointer,</span>
<span class="lineNum">     268 </span>            :                        int max_stack_len, uint8_t** stack_copy) {
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     *stack_copy = NULL;</span>
<span class="lineNum">     270 </span>            :     const void* stack;
<span class="lineNum">     271 </span>            :     size_t stack_len;
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     if (dumper_-&gt;GetStackInfo(&amp;stack, &amp;stack_len, stack_pointer)) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       UntypedMDRVA memory(&amp;minidump_writer_);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       if (max_stack_len &gt;= 0 &amp;&amp;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :           stack_len &gt; static_cast&lt;unsigned int&gt;(max_stack_len)) {</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         stack_len = max_stack_len;</span>
<span class="lineNum">     277 </span>            :         // Skip empty chunks of length max_stack_len.
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         uintptr_t int_stack = reinterpret_cast&lt;uintptr_t&gt;(stack);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         if (max_stack_len &gt; 0) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :           while (int_stack + max_stack_len &lt; stack_pointer) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :             int_stack += max_stack_len;</span>
<span class="lineNum">     282 </span>            :           }
<span class="lineNum">     283 </span>            :         }
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         stack = reinterpret_cast&lt;const void*&gt;(int_stack);</span>
<span class="lineNum">     285 </span>            :       }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :       if (!memory.Allocate(stack_len))</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       *stack_copy = reinterpret_cast&lt;uint8_t*&gt;(Alloc(stack_len));</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       dumper_-&gt;CopyFromProcess(*stack_copy, thread-&gt;thread_id, stack,</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :                                stack_len);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       memory.Copy(*stack_copy, stack_len);</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       thread-&gt;stack.start_of_memory_range =</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :           reinterpret_cast&lt;uintptr_t&gt;(stack);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       thread-&gt;stack.memory = memory.location();</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       memory_blocks_.push_back(thread-&gt;stack);</span>
<span class="lineNum">     296 </span>            :     } else {
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :       thread-&gt;stack.start_of_memory_range = stack_pointer;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :       thread-&gt;stack.memory.data_size = 0;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       thread-&gt;stack.memory.rva = minidump_writer_.position();</span>
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     302 </span>            :   }
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            :   // Write information about the threads.
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   bool WriteThreadListStream(MDRawDirectory* dirent) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     const unsigned num_threads = dumper_-&gt;threads().size();</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;uint32_t&gt; list(&amp;minidump_writer_);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     if (!list.AllocateObjectAndArray(num_threads, sizeof(MDRawThread)))</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_THREAD_LIST_STREAM;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     dirent-&gt;location = list.location();</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     *list.get() = num_threads;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :     // If there's a minidump size limit, check if it might be exceeded.  Since
<span class="lineNum">     318 </span>            :     // most of the space is filled with stack data, just check against that.
<span class="lineNum">     319 </span>            :     // If this expects to exceed the limit, set extra_thread_stack_len such
<span class="lineNum">     320 </span>            :     // that any thread beyond the first kLimitBaseThreadCount threads will
<span class="lineNum">     321 </span>            :     // have only kLimitMaxExtraThreadStackLen bytes dumped.
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     int extra_thread_stack_len = -1;  // default to no maximum</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     if (minidump_size_limit_ &gt;= 0) {</span>
<span class="lineNum">     324 </span>            :       const unsigned estimated_total_stack_size = num_threads *
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :           kLimitAverageThreadStackLength;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :       const off_t estimated_minidump_size = minidump_writer_.position() +</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :           estimated_total_stack_size + kLimitMinidumpFudgeFactor;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       if (estimated_minidump_size &gt; minidump_size_limit_)</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         extra_thread_stack_len = kLimitMaxExtraThreadStackLen;</span>
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; num_threads; ++i) {</span>
<span class="lineNum">     333 </span>            :       MDRawThread thread;
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :       my_memset(&amp;thread, 0, sizeof(thread));</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       thread.thread_id = dumper_-&gt;threads()[i];</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :       // We have a different source of information for the crashing thread. If
<span class="lineNum">     338 </span>            :       // we used the actual state of the thread we would find it running in the
<span class="lineNum">     339 </span>            :       // signal handler with the alternative stack, which would be deeply
<span class="lineNum">     340 </span>            :       // unhelpful.
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       if (static_cast&lt;pid_t&gt;(thread.thread_id) == GetCrashThread() &amp;&amp;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :           ucontext_ &amp;&amp;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :           !dumper_-&gt;IsPostMortem()) {</span>
<span class="lineNum">     344 </span>            :         uint8_t* stack_copy;
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         const uintptr_t stack_ptr = UContextReader::GetStackPointer(ucontext_);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         if (!FillThreadStack(&amp;thread, stack_ptr, -1, &amp;stack_copy))</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :         // Copy 256 bytes around crashing instruction pointer to minidump.
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         const size_t kIPMemorySize = 256;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         uint64_t ip = UContextReader::GetInstructionPointer(ucontext_);</span>
<span class="lineNum">     352 </span>            :         // Bound it to the upper and lower bounds of the memory map
<span class="lineNum">     353 </span>            :         // it's contained within. If it's not in mapped memory,
<span class="lineNum">     354 </span>            :         // don't bother trying to write it.
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         bool ip_is_mapped = false;</span>
<span class="lineNum">     356 </span>            :         MDMemoryDescriptor ip_memory_d;
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         for (unsigned j = 0; j &lt; dumper_-&gt;mappings().size(); ++j) {</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :           const MappingInfo&amp; mapping = *dumper_-&gt;mappings()[j];</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :           if (ip &gt;= mapping.start_addr &amp;&amp;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :               ip &lt; mapping.start_addr + mapping.size) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             ip_is_mapped = true;</span>
<span class="lineNum">     362 </span>            :             // Try to get 128 bytes before and after the IP, but
<span class="lineNum">     363 </span>            :             // settle for whatever's available.
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             ip_memory_d.start_of_memory_range =</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :               std::max(mapping.start_addr,</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                        uintptr_t(ip - (kIPMemorySize / 2)));</span>
<span class="lineNum">     367 </span>            :             uintptr_t end_of_range =
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :               std::min(uintptr_t(ip + (kIPMemorySize / 2)),</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                        uintptr_t(mapping.start_addr + mapping.size));</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :             ip_memory_d.memory.data_size =</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :               end_of_range - ip_memory_d.start_of_memory_range;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     373 </span>            :           }
<span class="lineNum">     374 </span>            :         }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         if (ip_is_mapped) {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :           UntypedMDRVA ip_memory(&amp;minidump_writer_);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :           if (!ip_memory.Allocate(ip_memory_d.memory.data_size))</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     380 </span>            :           uint8_t* memory_copy =
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :               reinterpret_cast&lt;uint8_t*&gt;(Alloc(ip_memory_d.memory.data_size));</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :           dumper_-&gt;CopyFromProcess(</span>
<span class="lineNum">     383 </span>            :               memory_copy,
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :               thread.thread_id,</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :               reinterpret_cast&lt;void*&gt;(ip_memory_d.start_of_memory_range),</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :               ip_memory_d.memory.data_size);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :           ip_memory.Copy(memory_copy, ip_memory_d.memory.data_size);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :           ip_memory_d.memory = ip_memory.location();</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :           memory_blocks_.push_back(ip_memory_d);</span>
<span class="lineNum">     390 </span>            :         }
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         TypedMDRVA&lt;RawContextCPU&gt; cpu(&amp;minidump_writer_);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         if (!cpu.Allocate())</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         my_memset(cpu.get(), 0, sizeof(RawContextCPU));</span>
<span class="lineNum">     396 </span>            : #if !defined(__ARM_EABI__) &amp;&amp; !defined(__mips__)
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);</span>
<span class="lineNum">     398 </span>            : #else
<span class="lineNum">     399 </span>            :         UContextReader::FillCPUContext(cpu.get(), ucontext_);
<span class="lineNum">     400 </span>            : #endif
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         thread.thread_context = cpu.location();</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         crashing_thread_context_ = cpu.location();</span>
<span class="lineNum">     403 </span>            :       } else {
<span class="lineNum">     404 </span>            :         ThreadInfo info;
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         if (!dumper_-&gt;GetThreadInfoByIndex(i, &amp;info))</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         uint8_t* stack_copy;
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         int max_stack_len = -1;  // default to no maximum for this thread</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         if (minidump_size_limit_ &gt;= 0 &amp;&amp; i &gt;= kLimitBaseThreadCount)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :           max_stack_len = extra_thread_stack_len;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         if (!FillThreadStack(&amp;thread, info.stack_pointer, max_stack_len,</span>
<span class="lineNum">     413 </span>            :             &amp;stack_copy))
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         TypedMDRVA&lt;RawContextCPU&gt; cpu(&amp;minidump_writer_);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         if (!cpu.Allocate())</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         my_memset(cpu.get(), 0, sizeof(RawContextCPU));</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         info.FillCPUContext(cpu.get());</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         thread.thread_context = cpu.location();</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         if (dumper_-&gt;threads()[i] == GetCrashThread()) {</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :           crashing_thread_context_ = cpu.location();</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :           if (!dumper_-&gt;IsPostMortem()) {</span>
<span class="lineNum">     425 </span>            :             // This is the crashing thread of a live process, but
<span class="lineNum">     426 </span>            :             // no context was provided, so set the crash address
<span class="lineNum">     427 </span>            :             // while the instruction pointer is already here.
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :             dumper_-&gt;set_crash_address(info.GetInstructionPointer());</span>
<span class="lineNum">     429 </span>            :           }
<span class="lineNum">     430 </span>            :         }
<span class="lineNum">     431 </span>            :       }
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       list.CopyIndexAfterObject(i, &amp;thread, sizeof(thread));</span>
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     437 </span>            :   }
<a name="438"><span class="lineNum">     438 </span>            : </a>
<span class="lineNum">     439 </span>            :   // Write application-provided memory regions.
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   bool WriteAppMemory() {</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     for (AppMemoryList::const_iterator iter = app_memory_list_.begin();</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :          iter != app_memory_list_.end();</span>
<span class="lineNum">     443 </span>            :          ++iter) {
<span class="lineNum">     444 </span>            :       uint8_t* data_copy =
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         reinterpret_cast&lt;uint8_t*&gt;(dumper_-&gt;allocator()-&gt;Alloc(iter-&gt;length));</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       dumper_-&gt;CopyFromProcess(data_copy, GetCrashThread(), iter-&gt;ptr,</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                                iter-&gt;length);</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       UntypedMDRVA memory(&amp;minidump_writer_);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :       if (!memory.Allocate(iter-&gt;length)) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     452 </span>            :       }
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       memory.Copy(data_copy, iter-&gt;length);</span>
<span class="lineNum">     454 </span>            :       MDMemoryDescriptor desc;
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       desc.start_of_memory_range = reinterpret_cast&lt;uintptr_t&gt;(iter-&gt;ptr);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       desc.memory = memory.location();</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       memory_blocks_.push_back(desc);</span>
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="461"><span class="lineNum">     461 </span>            :   }</a>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   static bool ShouldIncludeMapping(const MappingInfo&amp; mapping) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     if (mapping.name[0] == 0 ||  // only want modules with filenames.</span>
<span class="lineNum">     465 </span>            :         // Only want to include one mapping per shared lib.
<span class="lineNum">     466 </span>            :         // Avoid filtering executable mappings.
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         (mapping.offset != 0 &amp;&amp; !mapping.exec) ||</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         mapping.size &lt; 4096) {  // too small to get a signature for.</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     470 </span>            :     }
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     473 </span>            :   }
<span class="lineNum">     474 </span>            : 
<a name="475"><span class="lineNum">     475 </span>            :   // If there is caller-provided information about this mapping</a>
<span class="lineNum">     476 </span>            :   // in the mapping_list_ list, return true. Otherwise, return false.
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   bool HaveMappingInfo(const MappingInfo&amp; mapping) {</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     for (MappingList::const_iterator iter = mapping_list_.begin();</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :          iter != mapping_list_.end();</span>
<span class="lineNum">     480 </span>            :          ++iter) {
<span class="lineNum">     481 </span>            :       // Ignore any mappings that are wholly contained within
<span class="lineNum">     482 </span>            :       // mappings in the mapping_info_ list.
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       if (mapping.start_addr &gt;= iter-&gt;first.start_addr &amp;&amp;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :           (mapping.start_addr + mapping.size) &lt;=</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :           (iter-&gt;first.start_addr + iter-&gt;first.size)) {</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     487 </span>            :       }
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     490 </span>            :   }
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // Write information about the mappings in effect. Because we are using the
<span class="lineNum">     493 </span>            :   // minidump format, the information about the mappings is pretty limited.
<a name="494"><span class="lineNum">     494 </span>            :   // Because of this, we also include the full, unparsed, /proc/$x/maps file in</a>
<span class="lineNum">     495 </span>            :   // another stream in the file.
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   bool WriteMappings(MDRawDirectory* dirent) {</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     const unsigned num_mappings = dumper_-&gt;mappings().size();</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     unsigned num_output_mappings = mapping_list_.size();</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; dumper_-&gt;mappings().size(); ++i) {</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :       const MappingInfo&amp; mapping = *dumper_-&gt;mappings()[i];</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       if (ShouldIncludeMapping(mapping) &amp;&amp; !HaveMappingInfo(mapping))</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         num_output_mappings++;</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;uint32_t&gt; list(&amp;minidump_writer_);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     if (num_output_mappings) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :       if (!list.AllocateObjectAndArray(num_output_mappings, MD_MODULE_SIZE))</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     510 </span>            :     } else {
<span class="lineNum">     511 </span>            :       // Still create the module list stream, although it will have zero
<span class="lineNum">     512 </span>            :       // modules.
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       if (!list.Allocate())</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_MODULE_LIST_STREAM;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     dirent-&gt;location = list.location();</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     *list.get() = num_output_mappings;</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :     // First write all the mappings from the dumper
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     unsigned int j = 0;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     for (unsigned i = 0; i &lt; num_mappings; ++i) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       const MappingInfo&amp; mapping = *dumper_-&gt;mappings()[i];</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       if (!ShouldIncludeMapping(mapping) || HaveMappingInfo(mapping))</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :       MDRawModule mod;
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       if (!FillRawModule(mapping, true, i, &amp;mod, NULL))</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       list.CopyIndexAfterObject(j++, &amp;mod, MD_MODULE_SIZE);</span>
<span class="lineNum">     532 </span>            :     }
<span class="lineNum">     533 </span>            :     // Next write all the mappings provided by the caller
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     for (MappingList::const_iterator iter = mapping_list_.begin();</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :          iter != mapping_list_.end();</span>
<span class="lineNum">     536 </span>            :          ++iter) {
<span class="lineNum">     537 </span>            :       MDRawModule mod;
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :       if (!FillRawModule(iter-&gt;first, false, 0, &amp;mod, iter-&gt;second))</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       list.CopyIndexAfterObject(j++, &amp;mod, MD_MODULE_SIZE);</span>
<span class="lineNum">     541 </span>            :     }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   // Fill the MDRawModule |mod| with information about the provided
<a name="547"><span class="lineNum">     547 </span>            :   // |mapping|. If |identifier| is non-NULL, use it instead of calculating</a>
<span class="lineNum">     548 </span>            :   // a file ID from the mapping.
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   bool FillRawModule(const MappingInfo&amp; mapping,</span>
<span class="lineNum">     550 </span>            :                      bool member,
<span class="lineNum">     551 </span>            :                      unsigned int mapping_id,
<span class="lineNum">     552 </span>            :                      MDRawModule* mod,
<span class="lineNum">     553 </span>            :                      const uint8_t* identifier) {
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     my_memset(mod, 0, MD_MODULE_SIZE);</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     mod-&gt;base_of_image = mapping.start_addr;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     mod-&gt;size_of_image = mapping.size;</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :     auto_wasteful_vector&lt;uint8_t, kDefaultBuildIdSize&gt; identifier_bytes(
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         dumper_-&gt;allocator());</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     if (identifier) {</span>
<span class="lineNum">     563 </span>            :       // GUID was provided by caller.
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       identifier_bytes.insert(identifier_bytes.end(),</span>
<span class="lineNum">     565 </span>            :                               identifier,
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                               identifier + sizeof(MDGUID));</span>
<span class="lineNum">     567 </span>            :     } else {
<span class="lineNum">     568 </span>            :       // Note: ElfFileIdentifierForMapping() can manipulate the |mapping.name|.
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :       dumper_-&gt;ElfFileIdentifierForMapping(mapping,</span>
<span class="lineNum">     570 </span>            :                                            member,
<span class="lineNum">     571 </span>            :                                            mapping_id,
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                                            identifier_bytes);</span>
<span class="lineNum">     573 </span>            :     }
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     if (!identifier_bytes.empty()) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       UntypedMDRVA cv(&amp;minidump_writer_);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       if (!cv.Allocate(MDCVInfoELF_minsize + identifier_bytes.size()))</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :       const uint32_t cv_signature = MD_CVINFOELF_SIGNATURE;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       cv.Copy(&amp;cv_signature, sizeof(cv_signature));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       cv.Copy(cv.position() + sizeof(cv_signature), &amp;identifier_bytes[0],</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :               identifier_bytes.size());</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       mod-&gt;cv_record = cv.location();</span>
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :     char file_name[NAME_MAX];
<span class="lineNum">     589 </span>            :     char file_path[NAME_MAX];
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     dumper_-&gt;GetMappingEffectiveNameAndPath(</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         mapping, file_path, sizeof(file_path), file_name, sizeof(file_name));</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :     MDLocationDescriptor ld;
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     if (!minidump_writer_.WriteString(file_path, my_strlen(file_path), &amp;ld))</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     mod-&gt;module_name_rva = ld.rva;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="598"><span class="lineNum">     598 </span>            :   }</a>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   bool WriteMemoryListStream(MDRawDirectory* dirent) {</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;uint32_t&gt; list(&amp;minidump_writer_);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     if (memory_blocks_.size()) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       if (!list.AllocateObjectAndArray(memory_blocks_.size(),</span>
<span class="lineNum">     604 </span>            :                                        sizeof(MDMemoryDescriptor)))
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     606 </span>            :     } else {
<span class="lineNum">     607 </span>            :       // Still create the memory list stream, although it will have zero
<span class="lineNum">     608 </span>            :       // memory blocks.
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       if (!list.Allocate())</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_MEMORY_LIST_STREAM;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     dirent-&gt;location = list.location();</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     *list.get() = memory_blocks_.size();</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; memory_blocks_.size(); ++i) {</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       list.CopyIndexAfterObject(i, &amp;memory_blocks_[i],</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                                 sizeof(MDMemoryDescriptor));</span>
<span class="lineNum">     621 </span>            :     }
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="623"><span class="lineNum">     623 </span>            :   }</a>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   bool WriteExceptionStream(MDRawDirectory* dirent) {</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;MDRawExceptionStream&gt; exc(&amp;minidump_writer_);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     if (!exc.Allocate())</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     my_memset(exc.get(), 0, sizeof(MDRawExceptionStream));</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_EXCEPTION_STREAM;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     dirent-&gt;location = exc.location();</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     exc.get()-&gt;thread_id = GetCrashThread();</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     exc.get()-&gt;exception_record.exception_code = dumper_-&gt;crash_signal();</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     exc.get()-&gt;exception_record.exception_address = dumper_-&gt;crash_address();</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     exc.get()-&gt;thread_context = crashing_thread_context_;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="640"><span class="lineNum">     640 </span>            :   }</a>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   bool WriteSystemInfoStream(MDRawDirectory* dirent) {</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;MDRawSystemInfo&gt; si(&amp;minidump_writer_);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     if (!si.Allocate())</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     my_memset(si.get(), 0, sizeof(MDRawSystemInfo));</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_SYSTEM_INFO_STREAM;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     dirent-&gt;location = si.location();</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     WriteCPUInformation(si.get());</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     WriteOSInformation(si.get());</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="655"><span class="lineNum">     655 </span>            :   }</a>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   bool WriteDSODebugStream(MDRawDirectory* dirent) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     ElfW(Phdr)* phdr = reinterpret_cast&lt;ElfW(Phdr) *&gt;(dumper_-&gt;auxv()[AT_PHDR]);</span>
<span class="lineNum">     659 </span>            :     char* base;
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     int phnum = dumper_-&gt;auxv()[AT_PHNUM];</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     if (!phnum || !phdr)</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     // Assume the program base is at the beginning of the same page as the PHDR
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     base = reinterpret_cast&lt;char *&gt;(reinterpret_cast&lt;uintptr_t&gt;(phdr) &amp; ~0xfff);</span>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :     // Search for the program PT_DYNAMIC segment
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     ElfW(Addr) dyn_addr = 0;</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     for (; phnum &gt;= 0; phnum--, phdr++) {</span>
<span class="lineNum">     670 </span>            :       ElfW(Phdr) ph;
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       if (!dumper_-&gt;CopyFromProcess(&amp;ph, GetCrashThread(), phdr, sizeof(ph)))</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :       // Adjust base address with the virtual address of the PT_LOAD segment
<span class="lineNum">     675 </span>            :       // corresponding to offset 0
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :       if (ph.p_type == PT_LOAD &amp;&amp; ph.p_offset == 0) {</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         base -= ph.p_vaddr;</span>
<span class="lineNum">     678 </span>            :       }
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :       if (ph.p_type == PT_DYNAMIC) {</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         dyn_addr = ph.p_vaddr;</span>
<span class="lineNum">     681 </span>            :       }
<span class="lineNum">     682 </span>            :     }
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     if (!dyn_addr)</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     ElfW(Dyn) *dynamic = reinterpret_cast&lt;ElfW(Dyn) *&gt;(dyn_addr + base);</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :     // The dynamic linker makes information available that helps gdb find all
<span class="lineNum">     689 </span>            :     // DSOs loaded into the program. If this information is indeed available,
<span class="lineNum">     690 </span>            :     // dump it to a MD_LINUX_DSO_DEBUG stream.
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     struct r_debug* r_debug = NULL;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     uint32_t dynamic_length = 0;</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     for (int i = 0; ; ++i) {</span>
<span class="lineNum">     695 </span>            :       ElfW(Dyn) dyn;
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       dynamic_length += sizeof(dyn);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       if (!dumper_-&gt;CopyFromProcess(&amp;dyn, GetCrashThread(), dynamic + i,</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                                     sizeof(dyn))) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     700 </span>            :       }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : #ifdef __mips__
<span class="lineNum">     703 </span>            :       const int32_t debug_tag = DT_MIPS_RLD_MAP;
<span class="lineNum">     704 </span>            : #else
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :       const int32_t debug_tag = DT_DEBUG;</span>
<span class="lineNum">     706 </span>            : #endif
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       if (dyn.d_tag == debug_tag) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         r_debug = reinterpret_cast&lt;struct r_debug*&gt;(dyn.d_un.d_ptr);</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       } else if (dyn.d_tag == DT_NULL) {</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     712 </span>            :       }
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     // The &quot;r_map&quot; field of that r_debug struct contains a linked list of all
<span class="lineNum">     716 </span>            :     // loaded DSOs.
<span class="lineNum">     717 </span>            :     // Our list of DSOs potentially is different from the ones in the crashing
<span class="lineNum">     718 </span>            :     // process. So, we have to be careful to never dereference pointers
<span class="lineNum">     719 </span>            :     // directly. Instead, we use CopyFromProcess() everywhere.
<span class="lineNum">     720 </span>            :     // See &lt;link.h&gt; for a more detailed discussion of the how the dynamic
<span class="lineNum">     721 </span>            :     // loader communicates with debuggers.
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :     // Count the number of loaded DSOs
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     int dso_count = 0;</span>
<span class="lineNum">     725 </span>            :     struct r_debug debug_entry;
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     if (!dumper_-&gt;CopyFromProcess(&amp;debug_entry, GetCrashThread(), r_debug,</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :                                   sizeof(debug_entry))) {</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     729 </span>            :     }
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     for (struct link_map* ptr = debug_entry.r_map; ptr; ) {</span>
<span class="lineNum">     731 </span>            :       struct link_map map;
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       if (!dumper_-&gt;CopyFromProcess(&amp;map, GetCrashThread(), ptr, sizeof(map)))</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :       ptr = map.l_next;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       dso_count++;</span>
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     MDRVA linkmap_rva = minidump_writer_.kInvalidMDRVA;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     if (dso_count &gt; 0) {</span>
<span class="lineNum">     741 </span>            :       // If we have at least one DSO, create an array of MDRawLinkMap
<span class="lineNum">     742 </span>            :       // entries in the minidump file.
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :       TypedMDRVA&lt;MDRawLinkMap&gt; linkmap(&amp;minidump_writer_);</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       if (!linkmap.AllocateArray(dso_count))</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       linkmap_rva = linkmap.location().rva;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       int idx = 0;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :       // Iterate over DSOs and write their information to mini dump
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :       for (struct link_map* ptr = debug_entry.r_map; ptr; ) {</span>
<span class="lineNum">     751 </span>            :         struct link_map map;
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         if (!dumper_-&gt;CopyFromProcess(&amp;map, GetCrashThread(), ptr, sizeof(map)))</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :           return  false;</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         ptr = map.l_next;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         char filename[257] = { 0 };</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         if (map.l_name) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :           dumper_-&gt;CopyFromProcess(filename, GetCrashThread(), map.l_name,</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                                    sizeof(filename) - 1);</span>
<span class="lineNum">     760 </span>            :         }
<span class="lineNum">     761 </span>            :         MDLocationDescriptor location;
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         if (!minidump_writer_.WriteString(filename, 0, &amp;location))</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     764 </span>            :         MDRawLinkMap entry;
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         entry.name = location.rva;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :         entry.addr = map.l_addr;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         entry.ld = reinterpret_cast&lt;uintptr_t&gt;(map.l_ld);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         linkmap.CopyIndex(idx++, &amp;entry);</span>
<span class="lineNum">     769 </span>            :       }
<span class="lineNum">     770 </span>            :     }
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :     // Write MD_LINUX_DSO_DEBUG record
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     TypedMDRVA&lt;MDRawDebug&gt; debug(&amp;minidump_writer_);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     if (!debug.AllocateObjectAndArray(1, dynamic_length))</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     my_memset(debug.get(), 0, sizeof(MDRawDebug));</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = MD_LINUX_DSO_DEBUG;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     dirent-&gt;location = debug.location();</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     debug.get()-&gt;version = debug_entry.r_version;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     debug.get()-&gt;map = linkmap_rva;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     debug.get()-&gt;dso_count = dso_count;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     debug.get()-&gt;brk = debug_entry.r_brk;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     debug.get()-&gt;ldbase = debug_entry.r_ldbase;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     debug.get()-&gt;dynamic = reinterpret_cast&lt;uintptr_t&gt;(dynamic);</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     wasteful_vector&lt;char&gt; dso_debug_data(dumper_-&gt;allocator(), dynamic_length);</span>
<span class="lineNum">     788 </span>            :     // The passed-in size to the constructor (above) is only a hint.
<span class="lineNum">     789 </span>            :     // Must call .resize() to do actual initialization of the elements.
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     dso_debug_data.resize(dynamic_length);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     dumper_-&gt;CopyFromProcess(&amp;dso_debug_data[0], GetCrashThread(), dynamic,</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :                              dynamic_length);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     debug.CopyIndexAfterObject(0, &amp;dso_debug_data[0], dynamic_length);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="796"><span class="lineNum">     796 </span>            :   }</a>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   void set_minidump_size_limit(off_t limit) { minidump_size_limit_ = limit; }</span>
<a name="799"><span class="lineNum">     799 </span>            : </a>
<span class="lineNum">     800 </span>            :  private:
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   void* Alloc(unsigned bytes) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     return dumper_-&gt;allocator()-&gt;Alloc(bytes);</span>
<a name="803"><span class="lineNum">     803 </span>            :   }</a>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   pid_t GetCrashThread() const {</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     return dumper_-&gt;crash_thread();</span>
<a name="807"><span class="lineNum">     807 </span>            :   }</a>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   void NullifyDirectoryEntry(MDRawDirectory* dirent) {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     dirent-&gt;stream_type = 0;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     dirent-&gt;location.data_size = 0;</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     dirent-&gt;location.rva = 0;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   }</span>
<a name="814"><span class="lineNum">     814 </span>            : </a>
<span class="lineNum">     815 </span>            : #if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     char vendor_id[sizeof(sys_info-&gt;cpu.x86_cpu_info.vendor_id) + 1] = {0};</span>
<span class="lineNum">     818 </span>            :     static const char vendor_id_name[] = &quot;vendor_id&quot;;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     struct CpuInfoEntry {
<span class="lineNum">     821 </span>            :       const char* info_name;
<span class="lineNum">     822 </span>            :       int value;
<span class="lineNum">     823 </span>            :       bool found;
<span class="lineNum">     824 </span>            :     } cpu_info_table[] = {
<span class="lineNum">     825 </span>            :       { &quot;processor&quot;, -1, false },
<span class="lineNum">     826 </span>            : #if defined(__i386__) || defined(__x86_64__)
<span class="lineNum">     827 </span>            :       { &quot;model&quot;, 0, false },
<span class="lineNum">     828 </span>            :       { &quot;stepping&quot;,  0, false },
<span class="lineNum">     829 </span>            :       { &quot;cpu family&quot;, 0, false },
<span class="lineNum">     830 </span>            : #endif
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :     // processor_architecture should always be set, do this first
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     sys_info-&gt;processor_architecture =</span>
<span class="lineNum">     835 </span>            : #if defined(__mips__)
<span class="lineNum">     836 </span>            : # if _MIPS_SIM == _ABIO32
<span class="lineNum">     837 </span>            :         MD_CPU_ARCHITECTURE_MIPS;
<span class="lineNum">     838 </span>            : # elif _MIPS_SIM == _ABI64
<span class="lineNum">     839 </span>            :         MD_CPU_ARCHITECTURE_MIPS64;
<span class="lineNum">     840 </span>            : # else
<span class="lineNum">     841 </span>            : #  error &quot;This mips ABI is currently not supported (n32)&quot;
<span class="lineNum">     842 </span>            : #endif
<span class="lineNum">     843 </span>            : #elif defined(__i386__)
<span class="lineNum">     844 </span>            :         MD_CPU_ARCHITECTURE_X86;
<span class="lineNum">     845 </span>            : #else
<span class="lineNum">     846 </span>            :         MD_CPU_ARCHITECTURE_AMD64;
<span class="lineNum">     847 </span>            : #endif
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     const int fd = sys_open(&quot;/proc/cpuinfo&quot;, O_RDONLY, 0);</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     if (fd &lt; 0)</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :     {
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       PageAllocator allocator;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       ProcCpuInfoReader* const reader = new(allocator) ProcCpuInfoReader(fd);</span>
<span class="lineNum">     856 </span>            :       const char* field;
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       while (reader-&gt;GetNextField(&amp;field)) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         bool is_first_entry = true;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :         for (CpuInfoEntry&amp; entry : cpu_info_table) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :           if (!is_first_entry &amp;&amp; entry.found) {</span>
<span class="lineNum">     861 </span>            :             // except for the 'processor' field, ignore repeated values.
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     863 </span>            :           }
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :           is_first_entry = false;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :           if (!my_strcmp(field, entry.info_name)) {</span>
<span class="lineNum">     866 </span>            :             size_t value_len;
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :             const char* value = reader-&gt;GetValueAndLen(&amp;value_len);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :             if (value_len == 0)</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :             uintptr_t val;
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :             if (my_read_decimal_ptr(&amp;val, value) == value)</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :             entry.value = static_cast&lt;int&gt;(val);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :             entry.found = true;</span>
<span class="lineNum">     877 </span>            :           }
<span class="lineNum">     878 </span>            :         }
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            :         // special case for vendor_id
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         if (!my_strcmp(field, vendor_id_name)) {</span>
<span class="lineNum">     882 </span>            :           size_t value_len;
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :           const char* value = reader-&gt;GetValueAndLen(&amp;value_len);</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :           if (value_len &gt; 0)</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             my_strlcpy(vendor_id, value, sizeof(vendor_id));</span>
<span class="lineNum">     886 </span>            :         }
<span class="lineNum">     887 </span>            :       }
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :       sys_close(fd);</span>
<span class="lineNum">     889 </span>            :     }
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :     // make sure we got everything we wanted
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     for (const CpuInfoEntry&amp; entry : cpu_info_table) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       if (!entry.found) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     895 </span>            :       }
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span>            :     // cpu_info_table[0] holds the last cpu id listed in /proc/cpuinfo,
<span class="lineNum">     898 </span>            :     // assuming this is the highest id, change it to the number of CPUs
<span class="lineNum">     899 </span>            :     // by adding one.
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     cpu_info_table[0].value++;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     sys_info-&gt;number_of_processors = cpu_info_table[0].value;</span>
<span class="lineNum">     903 </span>            : #if defined(__i386__) || defined(__x86_64__)
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     sys_info-&gt;processor_level      = cpu_info_table[3].value;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     sys_info-&gt;processor_revision   = cpu_info_table[1].value &lt;&lt; 8 |</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :                                      cpu_info_table[2].value;</span>
<span class="lineNum">     907 </span>            : #endif
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     if (vendor_id[0] != '\0') {</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       my_memcpy(sys_info-&gt;cpu.x86_cpu_info.vendor_id, vendor_id,</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 sizeof(sys_info-&gt;cpu.x86_cpu_info.vendor_id));</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     914 </span>            :   }
<span class="lineNum">     915 </span>            : #elif defined(__arm__) || defined(__aarch64__)
<span class="lineNum">     916 </span>            :   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
<span class="lineNum">     917 </span>            :     // The CPUID value is broken up in several entries in /proc/cpuinfo.
<span class="lineNum">     918 </span>            :     // This table is used to rebuild it from the entries.
<span class="lineNum">     919 </span>            :     const struct CpuIdEntry {
<span class="lineNum">     920 </span>            :       const char* field;
<span class="lineNum">     921 </span>            :       char        format;
<span class="lineNum">     922 </span>            :       char        bit_lshift;
<span class="lineNum">     923 </span>            :       char        bit_length;
<span class="lineNum">     924 </span>            :     } cpu_id_entries[] = {
<span class="lineNum">     925 </span>            :       { &quot;CPU implementer&quot;, 'x', 24, 8 },
<span class="lineNum">     926 </span>            :       { &quot;CPU variant&quot;, 'x', 20, 4 },
<span class="lineNum">     927 </span>            :       { &quot;CPU part&quot;, 'x', 4, 12 },
<span class="lineNum">     928 </span>            :       { &quot;CPU revision&quot;, 'd', 0, 4 },
<span class="lineNum">     929 </span>            :     };
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :     // The ELF hwcaps are listed in the &quot;Features&quot; entry as textual tags.
<span class="lineNum">     932 </span>            :     // This table is used to rebuild them.
<span class="lineNum">     933 </span>            :     const struct CpuFeaturesEntry {
<span class="lineNum">     934 </span>            :       const char* tag;
<span class="lineNum">     935 </span>            :       uint32_t hwcaps;
<span class="lineNum">     936 </span>            :     } cpu_features_entries[] = {
<span class="lineNum">     937 </span>            : #if defined(__arm__)
<span class="lineNum">     938 </span>            :       { &quot;swp&quot;,  MD_CPU_ARM_ELF_HWCAP_SWP },
<span class="lineNum">     939 </span>            :       { &quot;half&quot;, MD_CPU_ARM_ELF_HWCAP_HALF },
<span class="lineNum">     940 </span>            :       { &quot;thumb&quot;, MD_CPU_ARM_ELF_HWCAP_THUMB },
<span class="lineNum">     941 </span>            :       { &quot;26bit&quot;, MD_CPU_ARM_ELF_HWCAP_26BIT },
<span class="lineNum">     942 </span>            :       { &quot;fastmult&quot;, MD_CPU_ARM_ELF_HWCAP_FAST_MULT },
<span class="lineNum">     943 </span>            :       { &quot;fpa&quot;, MD_CPU_ARM_ELF_HWCAP_FPA },
<span class="lineNum">     944 </span>            :       { &quot;vfp&quot;, MD_CPU_ARM_ELF_HWCAP_VFP },
<span class="lineNum">     945 </span>            :       { &quot;edsp&quot;, MD_CPU_ARM_ELF_HWCAP_EDSP },
<span class="lineNum">     946 </span>            :       { &quot;java&quot;, MD_CPU_ARM_ELF_HWCAP_JAVA },
<span class="lineNum">     947 </span>            :       { &quot;iwmmxt&quot;, MD_CPU_ARM_ELF_HWCAP_IWMMXT },
<span class="lineNum">     948 </span>            :       { &quot;crunch&quot;, MD_CPU_ARM_ELF_HWCAP_CRUNCH },
<span class="lineNum">     949 </span>            :       { &quot;thumbee&quot;, MD_CPU_ARM_ELF_HWCAP_THUMBEE },
<span class="lineNum">     950 </span>            :       { &quot;neon&quot;, MD_CPU_ARM_ELF_HWCAP_NEON },
<span class="lineNum">     951 </span>            :       { &quot;vfpv3&quot;, MD_CPU_ARM_ELF_HWCAP_VFPv3 },
<span class="lineNum">     952 </span>            :       { &quot;vfpv3d16&quot;, MD_CPU_ARM_ELF_HWCAP_VFPv3D16 },
<span class="lineNum">     953 </span>            :       { &quot;tls&quot;, MD_CPU_ARM_ELF_HWCAP_TLS },
<span class="lineNum">     954 </span>            :       { &quot;vfpv4&quot;, MD_CPU_ARM_ELF_HWCAP_VFPv4 },
<span class="lineNum">     955 </span>            :       { &quot;idiva&quot;, MD_CPU_ARM_ELF_HWCAP_IDIVA },
<span class="lineNum">     956 </span>            :       { &quot;idivt&quot;, MD_CPU_ARM_ELF_HWCAP_IDIVT },
<span class="lineNum">     957 </span>            :       { &quot;idiv&quot;, MD_CPU_ARM_ELF_HWCAP_IDIVA | MD_CPU_ARM_ELF_HWCAP_IDIVT },
<span class="lineNum">     958 </span>            : #elif defined(__aarch64__)
<span class="lineNum">     959 </span>            :       // No hwcaps on aarch64.
<span class="lineNum">     960 </span>            : #endif
<span class="lineNum">     961 </span>            :     };
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :     // processor_architecture should always be set, do this first
<span class="lineNum">     964 </span>            :     sys_info-&gt;processor_architecture =
<span class="lineNum">     965 </span>            : #if defined(__aarch64__)
<span class="lineNum">     966 </span>            :         MD_CPU_ARCHITECTURE_ARM64;
<span class="lineNum">     967 </span>            : #else
<span class="lineNum">     968 </span>            :         MD_CPU_ARCHITECTURE_ARM;
<span class="lineNum">     969 </span>            : #endif
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            :     // /proc/cpuinfo is not readable under various sandboxed environments
<span class="lineNum">     972 </span>            :     // (e.g. Android services with the android:isolatedProcess attribute)
<span class="lineNum">     973 </span>            :     // prepare for this by setting default values now, which will be
<span class="lineNum">     974 </span>            :     // returned when this happens.
<span class="lineNum">     975 </span>            :     //
<span class="lineNum">     976 </span>            :     // Note: Bogus values are used to distinguish between failures (to
<span class="lineNum">     977 </span>            :     //       read /sys and /proc files) and really badly configured kernels.
<span class="lineNum">     978 </span>            :     sys_info-&gt;number_of_processors = 0;
<span class="lineNum">     979 </span>            :     sys_info-&gt;processor_level = 1U;  // There is no ARMv1
<span class="lineNum">     980 </span>            :     sys_info-&gt;processor_revision = 42;
<span class="lineNum">     981 </span>            :     sys_info-&gt;cpu.arm_cpu_info.cpuid = 0;
<span class="lineNum">     982 </span>            :     sys_info-&gt;cpu.arm_cpu_info.elf_hwcaps = 0;
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :     // Counting the number of CPUs involves parsing two sysfs files,
<span class="lineNum">     985 </span>            :     // because the content of /proc/cpuinfo will only mirror the number
<span class="lineNum">     986 </span>            :     // of 'online' cores, and thus will vary with time.
<span class="lineNum">     987 </span>            :     // See http://www.kernel.org/doc/Documentation/cputopology.txt
<span class="lineNum">     988 </span>            :     {
<span class="lineNum">     989 </span>            :       CpuSet cpus_present;
<span class="lineNum">     990 </span>            :       CpuSet cpus_possible;
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :       int fd = sys_open(&quot;/sys/devices/system/cpu/present&quot;, O_RDONLY, 0);
<span class="lineNum">     993 </span>            :       if (fd &gt;= 0) {
<span class="lineNum">     994 </span>            :         cpus_present.ParseSysFile(fd);
<span class="lineNum">     995 </span>            :         sys_close(fd);
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            :         fd = sys_open(&quot;/sys/devices/system/cpu/possible&quot;, O_RDONLY, 0);
<span class="lineNum">     998 </span>            :         if (fd &gt;= 0) {
<span class="lineNum">     999 </span>            :           cpus_possible.ParseSysFile(fd);
<span class="lineNum">    1000 </span>            :           sys_close(fd);
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :           cpus_present.IntersectWith(cpus_possible);
<span class="lineNum">    1003 </span>            :           int cpu_count = cpus_present.GetCount();
<span class="lineNum">    1004 </span>            :           if (cpu_count &gt; 255)
<span class="lineNum">    1005 </span>            :             cpu_count = 255;
<span class="lineNum">    1006 </span>            :           sys_info-&gt;number_of_processors = static_cast&lt;uint8_t&gt;(cpu_count);
<span class="lineNum">    1007 </span>            :         }
<span class="lineNum">    1008 </span>            :       }
<span class="lineNum">    1009 </span>            :     }
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :     // Parse /proc/cpuinfo to reconstruct the CPUID value, as well
<span class="lineNum">    1012 </span>            :     // as the ELF hwcaps field. For the latter, it would be easier to
<span class="lineNum">    1013 </span>            :     // read /proc/self/auxv but unfortunately, this file is not always
<span class="lineNum">    1014 </span>            :     // readable from regular Android applications on later versions
<span class="lineNum">    1015 </span>            :     // (&gt;= 4.1) of the Android platform.
<span class="lineNum">    1016 </span>            :     const int fd = sys_open(&quot;/proc/cpuinfo&quot;, O_RDONLY, 0);
<span class="lineNum">    1017 </span>            :     if (fd &lt; 0) {
<span class="lineNum">    1018 </span>            :       // Do not return false here to allow the minidump generation
<span class="lineNum">    1019 </span>            :       // to happen properly.
<span class="lineNum">    1020 </span>            :       return true;
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :     {
<span class="lineNum">    1024 </span>            :       PageAllocator allocator;
<span class="lineNum">    1025 </span>            :       ProcCpuInfoReader* const reader =
<span class="lineNum">    1026 </span>            :           new(allocator) ProcCpuInfoReader(fd);
<span class="lineNum">    1027 </span>            :       const char* field;
<span class="lineNum">    1028 </span>            :       while (reader-&gt;GetNextField(&amp;field)) {
<span class="lineNum">    1029 </span>            :         for (const CpuIdEntry&amp; entry : cpu_id_entries) {
<span class="lineNum">    1030 </span>            :           if (my_strcmp(entry.field, field) != 0)
<span class="lineNum">    1031 </span>            :             continue;
<span class="lineNum">    1032 </span>            :           uintptr_t result = 0;
<span class="lineNum">    1033 </span>            :           const char* value = reader-&gt;GetValue();
<span class="lineNum">    1034 </span>            :           const char* p = value;
<span class="lineNum">    1035 </span>            :           if (value[0] == '0' &amp;&amp; value[1] == 'x') {
<span class="lineNum">    1036 </span>            :             p = my_read_hex_ptr(&amp;result, value+2);
<span class="lineNum">    1037 </span>            :           } else if (entry.format == 'x') {
<span class="lineNum">    1038 </span>            :             p = my_read_hex_ptr(&amp;result, value);
<span class="lineNum">    1039 </span>            :           } else {
<span class="lineNum">    1040 </span>            :             p = my_read_decimal_ptr(&amp;result, value);
<span class="lineNum">    1041 </span>            :           }
<span class="lineNum">    1042 </span>            :           if (p == value)
<span class="lineNum">    1043 </span>            :             continue;
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :           result &amp;= (1U &lt;&lt; entry.bit_length)-1;
<span class="lineNum">    1046 </span>            :           result &lt;&lt;= entry.bit_lshift;
<span class="lineNum">    1047 </span>            :           sys_info-&gt;cpu.arm_cpu_info.cpuid |=
<span class="lineNum">    1048 </span>            :               static_cast&lt;uint32_t&gt;(result);
<span class="lineNum">    1049 </span>            :         }
<span class="lineNum">    1050 </span>            : #if defined(__arm__)
<span class="lineNum">    1051 </span>            :         // Get the architecture version from the &quot;Processor&quot; field.
<span class="lineNum">    1052 </span>            :         // Note that it is also available in the &quot;CPU architecture&quot; field,
<span class="lineNum">    1053 </span>            :         // however, some existing kernels are misconfigured and will report
<span class="lineNum">    1054 </span>            :         // invalid values here (e.g. 6, while the CPU is ARMv7-A based).
<span class="lineNum">    1055 </span>            :         // The &quot;Processor&quot; field doesn't have this issue.
<span class="lineNum">    1056 </span>            :         if (!my_strcmp(field, &quot;Processor&quot;)) {
<span class="lineNum">    1057 </span>            :           size_t value_len;
<span class="lineNum">    1058 </span>            :           const char* value = reader-&gt;GetValueAndLen(&amp;value_len);
<span class="lineNum">    1059 </span>            :           // Expected format: &lt;text&gt; (v&lt;level&gt;&lt;endian&gt;)
<span class="lineNum">    1060 </span>            :           // Where &lt;text&gt; is some text like &quot;ARMv7 Processor rev 2&quot;
<span class="lineNum">    1061 </span>            :           // and &lt;level&gt; is a decimal corresponding to the ARM
<span class="lineNum">    1062 </span>            :           // architecture number. &lt;endian&gt; is either 'l' or 'b'
<span class="lineNum">    1063 </span>            :           // and corresponds to the endianess, it is ignored here.
<span class="lineNum">    1064 </span>            :           while (value_len &gt; 0 &amp;&amp; my_isspace(value[value_len-1]))
<span class="lineNum">    1065 </span>            :             value_len--;
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :           size_t nn = value_len;
<span class="lineNum">    1068 </span>            :           while (nn &gt; 0 &amp;&amp; value[nn-1] != '(')
<span class="lineNum">    1069 </span>            :             nn--;
<span class="lineNum">    1070 </span>            :           if (nn &gt; 0 &amp;&amp; value[nn] == 'v') {
<span class="lineNum">    1071 </span>            :             uintptr_t arch_level = 5;
<span class="lineNum">    1072 </span>            :             my_read_decimal_ptr(&amp;arch_level, value + nn + 1);
<span class="lineNum">    1073 </span>            :             sys_info-&gt;processor_level = static_cast&lt;uint16_t&gt;(arch_level);
<span class="lineNum">    1074 </span>            :           }
<span class="lineNum">    1075 </span>            :         }
<span class="lineNum">    1076 </span>            : #elif defined(__aarch64__)
<span class="lineNum">    1077 </span>            :         // The aarch64 architecture does not provide the architecture level
<span class="lineNum">    1078 </span>            :         // in the Processor field, so we instead check the &quot;CPU architecture&quot;
<span class="lineNum">    1079 </span>            :         // field.
<span class="lineNum">    1080 </span>            :         if (!my_strcmp(field, &quot;CPU architecture&quot;)) {
<span class="lineNum">    1081 </span>            :           uintptr_t arch_level = 0;
<span class="lineNum">    1082 </span>            :           const char* value = reader-&gt;GetValue();
<span class="lineNum">    1083 </span>            :           const char* p = value;
<span class="lineNum">    1084 </span>            :           p = my_read_decimal_ptr(&amp;arch_level, value);
<span class="lineNum">    1085 </span>            :           if (p == value)
<span class="lineNum">    1086 </span>            :             continue;
<span class="lineNum">    1087 </span>            :           sys_info-&gt;processor_level = static_cast&lt;uint16_t&gt;(arch_level);
<span class="lineNum">    1088 </span>            :         }
<span class="lineNum">    1089 </span>            : #endif
<span class="lineNum">    1090 </span>            :         // Rebuild the ELF hwcaps from the 'Features' field.
<span class="lineNum">    1091 </span>            :         if (!my_strcmp(field, &quot;Features&quot;)) {
<span class="lineNum">    1092 </span>            :           size_t value_len;
<span class="lineNum">    1093 </span>            :           const char* value = reader-&gt;GetValueAndLen(&amp;value_len);
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :           // Parse each space-separated tag.
<span class="lineNum">    1096 </span>            :           while (value_len &gt; 0) {
<span class="lineNum">    1097 </span>            :             const char* tag = value;
<span class="lineNum">    1098 </span>            :             size_t tag_len = value_len;
<span class="lineNum">    1099 </span>            :             const char* p = my_strchr(tag, ' ');
<span class="lineNum">    1100 </span>            :             if (p) {
<span class="lineNum">    1101 </span>            :               tag_len = static_cast&lt;size_t&gt;(p - tag);
<span class="lineNum">    1102 </span>            :               value += tag_len + 1;
<span class="lineNum">    1103 </span>            :               value_len -= tag_len + 1;
<span class="lineNum">    1104 </span>            :             } else {
<span class="lineNum">    1105 </span>            :               tag_len = strlen(tag);
<span class="lineNum">    1106 </span>            :               value_len = 0;
<span class="lineNum">    1107 </span>            :             }
<span class="lineNum">    1108 </span>            :             for (const CpuFeaturesEntry&amp; entry : cpu_features_entries) {
<span class="lineNum">    1109 </span>            :               if (tag_len == strlen(entry.tag) &amp;&amp;
<span class="lineNum">    1110 </span>            :                   !memcmp(tag, entry.tag, tag_len)) {
<span class="lineNum">    1111 </span>            :                 sys_info-&gt;cpu.arm_cpu_info.elf_hwcaps |= entry.hwcaps;
<span class="lineNum">    1112 </span>            :                 break;
<span class="lineNum">    1113 </span>            :               }
<span class="lineNum">    1114 </span>            :             }
<span class="lineNum">    1115 </span>            :           }
<span class="lineNum">    1116 </span>            :         }
<span class="lineNum">    1117 </span>            :       }
<span class="lineNum">    1118 </span>            :       sys_close(fd);
<span class="lineNum">    1119 </span>            :     }
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            :     return true;
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span>            : #else
<span class="lineNum">    1124 </span>            : #  error &quot;Unsupported CPU&quot;
<a name="1125"><span class="lineNum">    1125 </span>            : #endif</a>
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   bool WriteFile(MDLocationDescriptor* result, const char* filename) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     const int fd = sys_open(filename, O_RDONLY, 0);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     if (fd &lt; 0)</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :     // We can't stat the files because several of the files that we want to
<span class="lineNum">    1133 </span>            :     // read are kernel seqfiles, which always have a length of zero. So we have
<span class="lineNum">    1134 </span>            :     // to read as much as we can into a buffer.
<span class="lineNum">    1135 </span>            :     static const unsigned kBufSize = 1024 - 2*sizeof(void*);
<span class="lineNum">    1136 </span>            :     struct Buffers {
<span class="lineNum">    1137 </span>            :       Buffers* next;
<span class="lineNum">    1138 </span>            :       size_t len;
<span class="lineNum">    1139 </span>            :       uint8_t data[kBufSize];
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     } *buffers = reinterpret_cast&lt;Buffers*&gt;(Alloc(sizeof(Buffers)));</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     buffers-&gt;next = NULL;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     buffers-&gt;len = 0;</span>
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     size_t total = 0;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     for (Buffers* bufptr = buffers;;) {</span>
<span class="lineNum">    1146 </span>            :       ssize_t r;
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :       do {</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         r = sys_read(fd, &amp;bufptr-&gt;data[bufptr-&gt;len], kBufSize - bufptr-&gt;len);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :       } while (r == -1 &amp;&amp; errno == EINTR);</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :       if (r &lt; 1)</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       total += r;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       bufptr-&gt;len += r;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       if (bufptr-&gt;len == kBufSize) {</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         bufptr-&gt;next = reinterpret_cast&lt;Buffers*&gt;(Alloc(sizeof(Buffers)));</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         bufptr = bufptr-&gt;next;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         bufptr-&gt;next = NULL;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         bufptr-&gt;len = 0;</span>
<span class="lineNum">    1161 </span>            :       }
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :     sys_close(fd);</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :     if (!total)</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     UntypedMDRVA memory(&amp;minidump_writer_);</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :     if (!memory.Allocate(total))</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     for (MDRVA pos = memory.position(); buffers; buffers = buffers-&gt;next) {</span>
<span class="lineNum">    1172 </span>            :       // Check for special case of a zero-length buffer.  This should only
<span class="lineNum">    1173 </span>            :       // occur if a file's size happens to be a multiple of the buffer's
<span class="lineNum">    1174 </span>            :       // size, in which case the final sys_read() will have resulted in
<span class="lineNum">    1175 </span>            :       // zero bytes being read after the final buffer was just allocated.
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :       if (buffers-&gt;len == 0) {</span>
<span class="lineNum">    1177 </span>            :         // This can only occur with final buffer.
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         assert(buffers-&gt;next == NULL);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1180 </span>            :       }
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :       memory.Copy(pos, &amp;buffers-&gt;data, buffers-&gt;len);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       pos += buffers-&gt;len;</span>
<span class="lineNum">    1183 </span>            :     }
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     *result = memory.location();</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1186"><span class="lineNum">    1186 </span>            :   }</a>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   bool WriteOSInformation(MDRawSystemInfo* sys_info) {</span>
<span class="lineNum">    1189 </span>            : #if defined(__ANDROID__)
<span class="lineNum">    1190 </span>            :     sys_info-&gt;platform_id = MD_OS_ANDROID;
<span class="lineNum">    1191 </span>            : #else
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     sys_info-&gt;platform_id = MD_OS_LINUX;</span>
<span class="lineNum">    1193 </span>            : #endif
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            :     struct utsname uts;
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     if (uname(&amp;uts))</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            :     static const size_t buf_len = 512;
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     char buf[buf_len] = {0};</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     size_t space_left = buf_len - 1;</span>
<span class="lineNum">    1202 </span>            :     const char* info_table[] = {
<span class="lineNum">    1203 </span>            :       uts.sysname,
<span class="lineNum">    1204 </span>            :       uts.release,
<span class="lineNum">    1205 </span>            :       uts.version,
<span class="lineNum">    1206 </span>            :       uts.machine,
<span class="lineNum">    1207 </span>            :       NULL
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     bool first_item = true;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     for (const char** cur_info = info_table; *cur_info; cur_info++) {</span>
<span class="lineNum">    1211 </span>            :       static const char separator[] = &quot; &quot;;
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :       size_t separator_len = sizeof(separator) - 1;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :       size_t info_len = my_strlen(*cur_info);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :       if (info_len == 0)</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :       if (space_left &lt; info_len + (first_item ? 0 : separator_len))</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :       if (!first_item) {</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :         my_strlcat(buf, separator, sizeof(buf));</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         space_left -= separator_len;</span>
<span class="lineNum">    1223 </span>            :       }
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :       first_item = false;</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :       my_strlcat(buf, *cur_info, sizeof(buf));</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :       space_left -= info_len;</span>
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            :     MDLocationDescriptor location;
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     if (!minidump_writer_.WriteString(buf, 0, &amp;location))</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     sys_info-&gt;csd_version_rva = location.rva;</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1236"><span class="lineNum">    1236 </span>            :   }</a>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   bool WriteProcFile(MDLocationDescriptor* result, pid_t pid,</span>
<span class="lineNum">    1239 </span>            :                      const char* filename) {
<span class="lineNum">    1240 </span>            :     char buf[NAME_MAX];
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     if (!dumper_-&gt;BuildProcPath(buf, pid, filename))</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     return WriteFile(result, buf);</span>
<span class="lineNum">    1244 </span>            :   }
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :   // Only one of the 2 member variables below should be set to a valid value.
<span class="lineNum">    1247 </span>            :   const int fd_;  // File descriptor where the minidum should be written.
<span class="lineNum">    1248 </span>            :   const char* path_;  // Path to the file where the minidum should be written.
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :   const struct ucontext* const ucontext_;  // also from the signal handler
<span class="lineNum">    1251 </span>            : #if !defined(__ARM_EABI__) &amp;&amp; !defined(__mips__)
<span class="lineNum">    1252 </span>            :   const google_breakpad::fpstate_t* const float_state_;  // ditto
<span class="lineNum">    1253 </span>            : #endif
<span class="lineNum">    1254 </span>            :   LinuxDumper* dumper_;
<span class="lineNum">    1255 </span>            :   MinidumpFileWriter minidump_writer_;
<span class="lineNum">    1256 </span>            :   off_t minidump_size_limit_;
<span class="lineNum">    1257 </span>            :   MDLocationDescriptor crashing_thread_context_;
<span class="lineNum">    1258 </span>            :   // Blocks of memory written to the dump. These are all currently
<span class="lineNum">    1259 </span>            :   // written while writing the thread list stream, but saved here
<span class="lineNum">    1260 </span>            :   // so a memory list stream can be written afterwards.
<span class="lineNum">    1261 </span>            :   wasteful_vector&lt;MDMemoryDescriptor&gt; memory_blocks_;
<span class="lineNum">    1262 </span>            :   // Additional information about some mappings provided by the caller.
<span class="lineNum">    1263 </span>            :   const MappingList&amp; mapping_list_;
<span class="lineNum">    1264 </span>            :   // Additional memory regions to be included in the dump,
<span class="lineNum">    1265 </span>            :   // provided by the caller.
<span class="lineNum">    1266 </span>            :   const AppMemoryList&amp; app_memory_list_;
<span class="lineNum">    1267 </span>            : };
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 : bool WriteMinidumpImpl(const char* minidump_path,</span>
<span class="lineNum">    1271 </span>            :                        int minidump_fd,
<span class="lineNum">    1272 </span>            :                        off_t minidump_size_limit,
<span class="lineNum">    1273 </span>            :                        pid_t crashing_process,
<span class="lineNum">    1274 </span>            :                        const void* blob, size_t blob_size,
<span class="lineNum">    1275 </span>            :                        const MappingList&amp; mappings,
<span class="lineNum">    1276 </span>            :                        const AppMemoryList&amp; appmem) {
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   LinuxPtraceDumper dumper(crashing_process);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   const ExceptionHandler::CrashContext* context = NULL;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :   if (blob) {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     if (blob_size != sizeof(ExceptionHandler::CrashContext))</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     context = reinterpret_cast&lt;const ExceptionHandler::CrashContext*&gt;(blob);</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     dumper.set_crash_address(</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :         reinterpret_cast&lt;uintptr_t&gt;(context-&gt;siginfo.si_addr));</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     dumper.set_crash_signal(context-&gt;siginfo.si_signo);</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :     dumper.set_crash_thread(context-&gt;tid);</span>
<span class="lineNum">    1287 </span>            :   }
<span class="lineNum">    1288 </span>            :   MinidumpWriter writer(minidump_path, minidump_fd, context, mappings,
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :                         appmem, &amp;dumper);</span>
<span class="lineNum">    1290 </span>            :   // Set desired limit for file size of minidump (-1 means no limit).
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   writer.set_minidump_size_limit(minidump_size_limit);</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   if (!writer.Init())</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   return writer.Dump();</span>
<span class="lineNum">    1295 </span>            : }
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : }  // namespace
<span class="lineNum">    1298 </span>            : 
<a name="1299"><span class="lineNum">    1299 </span>            : namespace google_breakpad {</a>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 : bool WriteMinidump(const char* minidump_path, pid_t crashing_process,</span>
<span class="lineNum">    1302 </span>            :                    const void* blob, size_t blob_size) {
<span class="lineNum">    1303 </span>            :   return WriteMinidumpImpl(minidump_path, -1, -1,
<span class="lineNum">    1304 </span>            :                            crashing_process, blob, blob_size,
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                            MappingList(), AppMemoryList());</span>
<a name="1306"><span class="lineNum">    1306 </span>            : }</a>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 : bool WriteMinidump(int minidump_fd, pid_t crashing_process,</span>
<span class="lineNum">    1309 </span>            :                    const void* blob, size_t blob_size) {
<span class="lineNum">    1310 </span>            :   return WriteMinidumpImpl(NULL, minidump_fd, -1,
<span class="lineNum">    1311 </span>            :                            crashing_process, blob, blob_size,
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                            MappingList(), AppMemoryList());</span>
<a name="1313"><span class="lineNum">    1313 </span>            : }</a>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 : bool WriteMinidump(const char* minidump_path, pid_t process,</span>
<span class="lineNum">    1316 </span>            :                    pid_t process_blamed_thread) {
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   LinuxPtraceDumper dumper(process);</span>
<span class="lineNum">    1318 </span>            :   // MinidumpWriter will set crash address
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :   dumper.set_crash_signal(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   dumper.set_crash_thread(process_blamed_thread);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   MinidumpWriter writer(minidump_path, -1, NULL, MappingList(),</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                         AppMemoryList(), &amp;dumper);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   if (!writer.Init())</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   return writer.Dump();</span>
<a name="1326"><span class="lineNum">    1326 </span>            : }</a>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 : bool WriteMinidump(const char* minidump_path, pid_t crashing_process,</span>
<span class="lineNum">    1329 </span>            :                    const void* blob, size_t blob_size,
<span class="lineNum">    1330 </span>            :                    const MappingList&amp; mappings,
<span class="lineNum">    1331 </span>            :                    const AppMemoryList&amp; appmem) {
<span class="lineNum">    1332 </span>            :   return WriteMinidumpImpl(minidump_path, -1, -1, crashing_process,
<span class="lineNum">    1333 </span>            :                            blob, blob_size,
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                            mappings, appmem);</span>
<a name="1335"><span class="lineNum">    1335 </span>            : }</a>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 : bool WriteMinidump(int minidump_fd, pid_t crashing_process,</span>
<span class="lineNum">    1338 </span>            :                    const void* blob, size_t blob_size,
<span class="lineNum">    1339 </span>            :                    const MappingList&amp; mappings,
<span class="lineNum">    1340 </span>            :                    const AppMemoryList&amp; appmem) {
<span class="lineNum">    1341 </span>            :   return WriteMinidumpImpl(NULL, minidump_fd, -1, crashing_process,
<span class="lineNum">    1342 </span>            :                            blob, blob_size,
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                            mappings, appmem);</span>
<a name="1344"><span class="lineNum">    1344 </span>            : }</a>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 : bool WriteMinidump(const char* minidump_path, off_t minidump_size_limit,</span>
<span class="lineNum">    1347 </span>            :                    pid_t crashing_process,
<span class="lineNum">    1348 </span>            :                    const void* blob, size_t blob_size,
<span class="lineNum">    1349 </span>            :                    const MappingList&amp; mappings,
<span class="lineNum">    1350 </span>            :                    const AppMemoryList&amp; appmem) {
<span class="lineNum">    1351 </span>            :   return WriteMinidumpImpl(minidump_path, -1, minidump_size_limit,
<span class="lineNum">    1352 </span>            :                            crashing_process, blob, blob_size,
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :                            mappings, appmem);</span>
<a name="1354"><span class="lineNum">    1354 </span>            : }</a>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 : bool WriteMinidump(int minidump_fd, off_t minidump_size_limit,</span>
<span class="lineNum">    1357 </span>            :                    pid_t crashing_process,
<span class="lineNum">    1358 </span>            :                    const void* blob, size_t blob_size,
<span class="lineNum">    1359 </span>            :                    const MappingList&amp; mappings,
<span class="lineNum">    1360 </span>            :                    const AppMemoryList&amp; appmem) {
<span class="lineNum">    1361 </span>            :   return WriteMinidumpImpl(NULL, minidump_fd, minidump_size_limit,
<span class="lineNum">    1362 </span>            :                            crashing_process, blob, blob_size,
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :                            mappings, appmem);</span>
<a name="1364"><span class="lineNum">    1364 </span>            : }</a>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 : bool WriteMinidump(const char* filename,</span>
<span class="lineNum">    1367 </span>            :                    const MappingList&amp; mappings,
<span class="lineNum">    1368 </span>            :                    const AppMemoryList&amp; appmem,
<span class="lineNum">    1369 </span>            :                    LinuxDumper* dumper) {
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   MinidumpWriter writer(filename, -1, NULL, mappings, appmem, dumper);</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   if (!writer.Init())</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   return writer.Dump();</span>
<span class="lineNum">    1374 </span>            : }
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : }  // namespace google_breakpad
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

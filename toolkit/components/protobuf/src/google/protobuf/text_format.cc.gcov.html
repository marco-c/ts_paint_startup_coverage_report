<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - toolkit/components/protobuf/src/google/protobuf/text_format.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">toolkit/components/protobuf/src/google/protobuf</a> - text_format.cc<span style="font-size: 80%;"> (source / <a href="text_format.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">792</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">110</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Protocol Buffers - Google's data interchange format</a>
<span class="lineNum">       2 </span>            : // Copyright 2008 Google Inc.  All rights reserved.
<span class="lineNum">       3 </span>            : // https://developers.google.com/protocol-buffers/
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       7 </span>            : // met:
<span class="lineNum">       8 </span>            : //
<span class="lineNum">       9 </span>            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">      10 </span>            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      12 </span>            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      13 </span>            : // in the documentation and/or other materials provided with the
<span class="lineNum">      14 </span>            : // distribution.
<span class="lineNum">      15 </span>            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      16 </span>            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      17 </span>            : // this software without specific prior written permission.
<span class="lineNum">      18 </span>            : //
<span class="lineNum">      19 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      20 </span>            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      21 </span>            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      22 </span>            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      23 </span>            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      24 </span>            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      25 </span>            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      26 </span>            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      27 </span>            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      28 </span>            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      29 </span>            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // Author: jschorr@google.com (Joseph Schorr)
<span class="lineNum">      32 </span>            : //  Based on original Protocol Buffers design by
<span class="lineNum">      33 </span>            : //  Sanjay Ghemawat, Jeff Dean, and others.
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      36 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;stack&gt;
<span class="lineNum">      40 </span>            : #include &lt;limits&gt;
<span class="lineNum">      41 </span>            : #include &lt;vector&gt;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include &lt;google/protobuf/text_format.h&gt;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #include &lt;google/protobuf/descriptor.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;google/protobuf/wire_format_lite.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;google/protobuf/io/coded_stream.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;google/protobuf/io/zero_copy_stream.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;google/protobuf/io/zero_copy_stream_impl.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;google/protobuf/unknown_field_set.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;google/protobuf/descriptor.pb.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;google/protobuf/io/tokenizer.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;google/protobuf/stubs/strutil.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;google/protobuf/stubs/map_util.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;google/protobuf/stubs/stl_util.h&gt;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : namespace google {
<span class="lineNum">      58 </span>            : namespace protobuf {
<span class="lineNum">      59 </span>            : 
<a name="60"><span class="lineNum">      60 </span>            : namespace {</a>
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span><span class="lineNoCov">          0 : inline bool IsHexNumber(const string&amp; str) {</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   return (str.length() &gt;= 2 &amp;&amp; str[0] == '0' &amp;&amp;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :           (str[1] == 'x' || str[1] == 'X'));</span>
<a name="65"><span class="lineNum">      65 </span>            : }</a>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : inline bool IsOctNumber(const string&amp; str) {</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   return (str.length() &gt;= 2 &amp;&amp; str[0] == '0' &amp;&amp;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :           (str[1] &gt;= '0' &amp;&amp; str[1] &lt; '8'));</span>
<span class="lineNum">      70 </span>            : }
<span class="lineNum">      71 </span>            : 
<a name="72"><span class="lineNum">      72 </span>            : }  // namespace</a>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span><span class="lineNoCov">          0 : string Message::DebugString() const {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   string debug_string;</span>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   TextFormat::PrintToString(*this, &amp;debug_string);</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   return debug_string;</span>
<a name="80"><span class="lineNum">      80 </span>            : }</a>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : string Message::ShortDebugString() const {</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   string debug_string;</span>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   TextFormat::Printer printer;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   printer.SetSingleLineMode(true);</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   printer.PrintToString(*this, &amp;debug_string);</span>
<span class="lineNum">      89 </span>            :   // Single line mode currently might have an extra space at the end.
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   if (debug_string.size() &gt; 0 &amp;&amp;</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :       debug_string[debug_string.size() - 1] == ' ') {</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     debug_string.resize(debug_string.size() - 1);</span>
<span class="lineNum">      93 </span>            :   }
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   return debug_string;</span>
<a name="96"><span class="lineNum">      96 </span>            : }</a>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 : string Message::Utf8DebugString() const {</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   string debug_string;</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   TextFormat::Printer printer;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   printer.SetUseUtf8StringEscaping(true);</span>
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   printer.PrintToString(*this, &amp;debug_string);</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   return debug_string;</span>
<a name="107"><span class="lineNum">     107 </span>            : }</a>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : void Message::PrintDebugString() const {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   printf(&quot;%s&quot;, DebugString().c_str());</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<a name="114"><span class="lineNum">     114 </span>            : // ===========================================================================</a>
<span class="lineNum">     115 </span>            : // Implementation of the parse information tree class.
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 : TextFormat::ParseInfoTree::ParseInfoTree() { }</span></a>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineNoCov">          0 : TextFormat::ParseInfoTree::~ParseInfoTree() {</span>
<span class="lineNum">     119 </span>            :   // Remove any nested information trees, as they are owned by this tree.
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   for (NestedMap::iterator it = nested_.begin(); it != nested_.end(); ++it) {</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     STLDeleteElements(&amp;(it-&gt;second));</span>
<span class="lineNum">     122 </span>            :   }
<a name="123"><span class="lineNum">     123 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineNoCov">          0 : void TextFormat::ParseInfoTree::RecordLocation(</span>
<span class="lineNum">     126 </span>            :     const FieldDescriptor* field,
<span class="lineNum">     127 </span>            :     TextFormat::ParseLocation location) {
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   locations_[field].push_back(location);</span>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : TextFormat::ParseInfoTree* TextFormat::ParseInfoTree::CreateNested(</span>
<span class="lineNum">     132 </span>            :     const FieldDescriptor* field) {
<span class="lineNum">     133 </span>            :   // Owned by us in the map.
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   TextFormat::ParseInfoTree* instance = new TextFormat::ParseInfoTree();</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   vector&lt;TextFormat::ParseInfoTree*&gt;* trees = &amp;nested_[field];</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   GOOGLE_CHECK(trees);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   trees-&gt;push_back(instance);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   return instance;</span>
<a name="139"><span class="lineNum">     139 </span>            : }</a>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : void CheckFieldIndex(const FieldDescriptor* field, int index) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   if (field == NULL) { return; }</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   if (field-&gt;is_repeated() &amp;&amp; index == -1) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     GOOGLE_LOG(DFATAL) &lt;&lt; &quot;Index must be in range of repeated field values. &quot;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :                 &lt;&lt; &quot;Field: &quot; &lt;&lt; field-&gt;name();</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   } else if (!field-&gt;is_repeated() &amp;&amp; index != -1) {</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     GOOGLE_LOG(DFATAL) &lt;&lt; &quot;Index must be -1 for singular fields.&quot;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 &lt;&lt; &quot;Field: &quot; &lt;&lt; field-&gt;name();</span>
<span class="lineNum">     150 </span>            :   }
<a name="151"><span class="lineNum">     151 </span>            : }</a>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 : TextFormat::ParseLocation TextFormat::ParseInfoTree::GetLocation(</span>
<span class="lineNum">     154 </span>            :     const FieldDescriptor* field, int index) const {
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   CheckFieldIndex(field, index);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   if (index == -1) { index = 0; }</span>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :   const vector&lt;TextFormat::ParseLocation&gt;* locations =
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       FindOrNull(locations_, field);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   if (locations == NULL || index &gt;= locations-&gt;size()) {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     return TextFormat::ParseLocation();</span>
<span class="lineNum">     162 </span>            :   }
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   return (*locations)[index];</span>
<a name="165"><span class="lineNum">     165 </span>            : }</a>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineNoCov">          0 : TextFormat::ParseInfoTree* TextFormat::ParseInfoTree::GetTreeForNested(</span>
<span class="lineNum">     168 </span>            :     const FieldDescriptor* field, int index) const {
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   CheckFieldIndex(field, index);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   if (index == -1) { index = 0; }</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   const vector&lt;TextFormat::ParseInfoTree*&gt;* trees = FindOrNull(nested_, field);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   if (trees == NULL || index &gt;= trees-&gt;size()) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     175 </span>            :   }
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   return (*trees)[index];</span>
<span class="lineNum">     178 </span>            : }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : // ===========================================================================
<span class="lineNum">     182 </span>            : // Internal class for parsing an ASCII representation of a Protocol Message.
<span class="lineNum">     183 </span>            : // This class makes use of the Protocol Message compiler's tokenizer found
<span class="lineNum">     184 </span>            : // in //google/protobuf/io/tokenizer.h. Note that class's Parse
<span class="lineNum">     185 </span>            : // method is *not* thread-safe and should only be used in a single thread at
<span class="lineNum">     186 </span>            : // a time.
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : // Makes code slightly more readable.  The meaning of &quot;DO(foo)&quot; is
<span class="lineNum">     189 </span>            : // &quot;Execute foo and fail if it fails.&quot;, where failure is indicated by
<span class="lineNum">     190 </span>            : // returning false. Borrowed from parser.cc (Thanks Kenton!).
<span class="lineNum">     191 </span>            : #define DO(STATEMENT) if (STATEMENT) {} else return false
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : class TextFormat::Parser::ParserImpl {
<span class="lineNum">     194 </span>            :  public:
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // Determines if repeated values for non-repeated fields and
<span class="lineNum">     197 </span>            :   // oneofs are permitted, e.g., the string &quot;foo: 1 foo: 2&quot; for a
<span class="lineNum">     198 </span>            :   // required/optional field named &quot;foo&quot;, or &quot;baz: 1 qux: 2&quot;
<span class="lineNum">     199 </span>            :   // where &quot;baz&quot; and &quot;qux&quot; are members of the same oneof.
<span class="lineNum">     200 </span>            :   enum SingularOverwritePolicy {
<span class="lineNum">     201 </span>            :     ALLOW_SINGULAR_OVERWRITES = 0,   // the last value is retained
<span class="lineNum">     202 </span>            :     FORBID_SINGULAR_OVERWRITES = 1,  // an error is issued
<a name="203"><span class="lineNum">     203 </span>            :   };</a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   ParserImpl(const Descriptor* root_message_type,</span>
<span class="lineNum">     206 </span>            :              io::ZeroCopyInputStream* input_stream,
<span class="lineNum">     207 </span>            :              io::ErrorCollector* error_collector,
<span class="lineNum">     208 </span>            :              TextFormat::Finder* finder,
<span class="lineNum">     209 </span>            :              ParseInfoTree* parse_info_tree,
<span class="lineNum">     210 </span>            :              SingularOverwritePolicy singular_overwrite_policy,
<span class="lineNum">     211 </span>            :              bool allow_case_insensitive_field,
<span class="lineNum">     212 </span>            :              bool allow_unknown_field,
<span class="lineNum">     213 </span>            :              bool allow_unknown_enum,
<span class="lineNum">     214 </span>            :              bool allow_field_number,
<span class="lineNum">     215 </span>            :              bool allow_relaxed_whitespace)
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     : error_collector_(error_collector),</span>
<span class="lineNum">     217 </span>            :       finder_(finder),
<span class="lineNum">     218 </span>            :       parse_info_tree_(parse_info_tree),
<span class="lineNum">     219 </span>            :       tokenizer_error_collector_(this),
<span class="lineNum">     220 </span>            :       tokenizer_(input_stream, &amp;tokenizer_error_collector_),
<span class="lineNum">     221 </span>            :       root_message_type_(root_message_type),
<span class="lineNum">     222 </span>            :       singular_overwrite_policy_(singular_overwrite_policy),
<span class="lineNum">     223 </span>            :       allow_case_insensitive_field_(allow_case_insensitive_field),
<span class="lineNum">     224 </span>            :       allow_unknown_field_(allow_unknown_field),
<span class="lineNum">     225 </span>            :       allow_unknown_enum_(allow_unknown_enum),
<span class="lineNum">     226 </span>            :       allow_field_number_(allow_field_number),
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       had_errors_(false) {</span>
<span class="lineNum">     228 </span>            :     // For backwards-compatibility with proto1, we need to allow the 'f' suffix
<span class="lineNum">     229 </span>            :     // for floats.
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     tokenizer_.set_allow_f_after_float(true);</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :     // '#' starts a comment.
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     tokenizer_.set_comment_style(io::Tokenizer::SH_COMMENT_STYLE);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     if (allow_relaxed_whitespace) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       tokenizer_.set_require_space_after_number(false);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       tokenizer_.set_allow_multiline_strings(true);</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     // Consume the starting token.
<a name="241"><span class="lineNum">     241 </span><span class="lineNoCov">          0 :     tokenizer_.Next();</span></a>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   ~ParserImpl() { }</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   // Parses the ASCII representation specified in input and saves the
<span class="lineNum">     246 </span>            :   // information into the output pointer (a Message). Returns
<a name="247"><span class="lineNum">     247 </span>            :   // false if an error occurs (an error will also be logged to</a>
<span class="lineNum">     248 </span>            :   // GOOGLE_LOG(ERROR)).
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   bool Parse(Message* output) {</span>
<span class="lineNum">     250 </span>            :     // Consume fields until we cannot do so anymore.
<span class="lineNum">     251 </span>            :     while (true) {
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       if (LookingAtType(io::Tokenizer::TYPE_END)) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         return !had_errors_;</span>
<span class="lineNum">     254 </span>            :       }
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       DO(ConsumeField(output));</span>
<span class="lineNum">     257 </span>            :     }
<a name="258"><span class="lineNum">     258 </span>            :   }</a>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   bool ParseField(const FieldDescriptor* field, Message* output) {</span>
<span class="lineNum">     261 </span>            :     bool suc;
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     if (field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       suc = ConsumeFieldMessage(output, output-&gt;GetReflection(), field);</span>
<span class="lineNum">     264 </span>            :     } else {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       suc = ConsumeFieldValue(output, output-&gt;GetReflection(), field);</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     return suc &amp;&amp; LookingAtType(io::Tokenizer::TYPE_END);</span>
<a name="268"><span class="lineNum">     268 </span>            :   }</a>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   void ReportError(int line, int col, const string&amp; message) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     had_errors_ = true;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     if (error_collector_ == NULL) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       if (line &gt;= 0) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         GOOGLE_LOG(ERROR) &lt;&lt; &quot;Error parsing text-format &quot;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                    &lt;&lt; root_message_type_-&gt;full_name()</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                    &lt;&lt; &quot;: &quot; &lt;&lt; (line + 1) &lt;&lt; &quot;:&quot;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                    &lt;&lt; (col + 1) &lt;&lt; &quot;: &quot; &lt;&lt; message;</span>
<span class="lineNum">     278 </span>            :       } else {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         GOOGLE_LOG(ERROR) &lt;&lt; &quot;Error parsing text-format &quot;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                    &lt;&lt; root_message_type_-&gt;full_name()</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                    &lt;&lt; &quot;: &quot; &lt;&lt; message;</span>
<span class="lineNum">     282 </span>            :       }
<span class="lineNum">     283 </span>            :     } else {
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       error_collector_-&gt;AddError(line, col, message);</span>
<span class="lineNum">     285 </span>            :     }
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   void ReportWarning(int line, int col, const string&amp; message) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if (error_collector_ == NULL) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       if (line &gt;= 0) {</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         GOOGLE_LOG(WARNING) &lt;&lt; &quot;Warning parsing text-format &quot;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                      &lt;&lt; root_message_type_-&gt;full_name()</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                      &lt;&lt; &quot;: &quot; &lt;&lt; (line + 1) &lt;&lt; &quot;:&quot;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                      &lt;&lt; (col + 1) &lt;&lt; &quot;: &quot; &lt;&lt; message;</span>
<span class="lineNum">     295 </span>            :       } else {
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         GOOGLE_LOG(WARNING) &lt;&lt; &quot;Warning parsing text-format &quot;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                      &lt;&lt; root_message_type_-&gt;full_name()</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                      &lt;&lt; &quot;: &quot; &lt;&lt; message;</span>
<span class="lineNum">     299 </span>            :       }
<span class="lineNum">     300 </span>            :     } else {
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       error_collector_-&gt;AddWarning(line, col, message);</span>
<span class="lineNum">     302 </span>            :     }
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :  private:
<span class="lineNum">     306 </span>            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ParserImpl);
<span class="lineNum">     307 </span>            : 
<a name="308"><span class="lineNum">     308 </span>            :   // Reports an error with the given message with information indicating</a>
<span class="lineNum">     309 </span>            :   // the position (as derived from the current token).
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   void ReportError(const string&amp; message) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     ReportError(tokenizer_.current().line, tokenizer_.current().column,</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                 message);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     314 </span>            : 
<a name="315"><span class="lineNum">     315 </span>            :   // Reports a warning with the given message with information indicating</a>
<span class="lineNum">     316 </span>            :   // the position (as derived from the current token).
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   void ReportWarning(const string&amp; message) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     ReportWarning(tokenizer_.current().line, tokenizer_.current().column,</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                   message);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   // Consumes the specified message with the given starting delimeter.
<a name="323"><span class="lineNum">     323 </span>            :   // This method checks to see that the end delimeter at the conclusion of</a>
<span class="lineNum">     324 </span>            :   // the consumption matches the starting delimeter passed in here.
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   bool ConsumeMessage(Message* message, const string delimeter) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     while (!LookingAt(&quot;&gt;&quot;) &amp;&amp;  !LookingAt(&quot;}&quot;)) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       DO(ConsumeField(message));</span>
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :     // Confirm that we have a valid ending delimeter.
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     DO(Consume(delimeter));</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : 
<a name="337"><span class="lineNum">     337 </span>            :   // Consumes the current field (as returned by the tokenizer) on the</a>
<span class="lineNum">     338 </span>            :   // passed in message.
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   bool ConsumeField(Message* message) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     const Reflection* reflection = message-&gt;GetReflection();</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     const Descriptor* descriptor = message-&gt;GetDescriptor();</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     string field_name;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     const FieldDescriptor* field = NULL;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     int start_line = tokenizer_.current().line;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     int start_column = tokenizer_.current().column;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;[&quot;)) {</span>
<span class="lineNum">     350 </span>            :       // Extension.
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       DO(ConsumeIdentifier(&amp;field_name));</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :       while (TryConsume(&quot;.&quot;)) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         string part;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         DO(ConsumeIdentifier(&amp;part));</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         field_name += &quot;.&quot;;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         field_name += part;</span>
<span class="lineNum">     357 </span>            :       }
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       DO(Consume(&quot;]&quot;));</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       field = (finder_ != NULL</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                ? finder_-&gt;FindExtension(message, field_name)</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :                : reflection-&gt;FindKnownExtensionByName(field_name));</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :       if (field == NULL) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         if (!allow_unknown_field_) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :           ReportError(&quot;Extension \&quot;&quot; + field_name + &quot;\&quot; is not defined or &quot;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                       &quot;is not an extension of \&quot;&quot; +</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                       descriptor-&gt;full_name() + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     370 </span>            :         } else {
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :           ReportWarning(&quot;Extension \&quot;&quot; + field_name + &quot;\&quot; is not defined or &quot;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                         &quot;is not an extension of \&quot;&quot; +</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                         descriptor-&gt;full_name() + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     374 </span>            :         }
<span class="lineNum">     375 </span>            :       }
<span class="lineNum">     376 </span>            :     } else {
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       DO(ConsumeIdentifier(&amp;field_name));</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :       int32 field_number;
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       if (allow_field_number_ &amp;&amp; safe_strto32(field_name, &amp;field_number)) {</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         if (descriptor-&gt;IsExtensionNumber(field_number)) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :           field = reflection-&gt;FindKnownExtensionByNumber(field_number);</span>
<span class="lineNum">     383 </span>            :         } else {
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :           field = descriptor-&gt;FindFieldByNumber(field_number);</span>
<span class="lineNum">     385 </span>            :         }
<span class="lineNum">     386 </span>            :       } else {
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         field = descriptor-&gt;FindFieldByName(field_name);</span>
<span class="lineNum">     388 </span>            :         // Group names are expected to be capitalized as they appear in the
<span class="lineNum">     389 </span>            :         // .proto file, which actually matches their type names, not their
<span class="lineNum">     390 </span>            :         // field names.
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         if (field == NULL) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :           string lower_field_name = field_name;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :           LowerString(&amp;lower_field_name);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           field = descriptor-&gt;FindFieldByName(lower_field_name);</span>
<span class="lineNum">     395 </span>            :           // If the case-insensitive match worked but the field is NOT a group,
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :           if (field != NULL &amp;&amp; field-&gt;type() != FieldDescriptor::TYPE_GROUP) {</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :             field = NULL;</span>
<span class="lineNum">     398 </span>            :           }
<span class="lineNum">     399 </span>            :         }
<span class="lineNum">     400 </span>            :         // Again, special-case group names as described above.
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         if (field != NULL &amp;&amp; field-&gt;type() == FieldDescriptor::TYPE_GROUP</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :             &amp;&amp; field-&gt;message_type()-&gt;name() != field_name) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :           field = NULL;</span>
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         if (field == NULL &amp;&amp; allow_case_insensitive_field_) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :           string lower_field_name = field_name;</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :           LowerString(&amp;lower_field_name);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :           field = descriptor-&gt;FindFieldByLowercaseName(lower_field_name);</span>
<span class="lineNum">     410 </span>            :         }
<span class="lineNum">     411 </span>            :       }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :       if (field == NULL) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         if (!allow_unknown_field_) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :           ReportError(&quot;Message type \&quot;&quot; + descriptor-&gt;full_name() +</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                       &quot;\&quot; has no field named \&quot;&quot; + field_name + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     418 </span>            :         } else {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :           ReportWarning(&quot;Message type \&quot;&quot; + descriptor-&gt;full_name() +</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :                         &quot;\&quot; has no field named \&quot;&quot; + field_name + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     421 </span>            :         }
<span class="lineNum">     422 </span>            :       }
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     // Skips unknown field.
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     if (field == NULL) {</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :       GOOGLE_CHECK(allow_unknown_field_);</span>
<span class="lineNum">     428 </span>            :       // Try to guess the type of this field.
<span class="lineNum">     429 </span>            :       // If this field is not a message, there should be a &quot;:&quot; between the
<span class="lineNum">     430 </span>            :       // field name and the field value and also the field value should not
<span class="lineNum">     431 </span>            :       // start with &quot;{&quot; or &quot;&lt;&quot; which indicates the begining of a message body.
<span class="lineNum">     432 </span>            :       // If there is no &quot;:&quot; or there is a &quot;{&quot; or &quot;&lt;&quot; after &quot;:&quot;, this field has
<span class="lineNum">     433 </span>            :       // to be a message or the input is ill-formed.
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       if (TryConsume(&quot;:&quot;) &amp;&amp; !LookingAt(&quot;{&quot;) &amp;&amp; !LookingAt(&quot;&lt;&quot;)) {</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         return SkipFieldValue();</span>
<span class="lineNum">     436 </span>            :       } else {
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         return SkipFieldMessage();</span>
<span class="lineNum">     438 </span>            :       }
<span class="lineNum">     439 </span>            :     }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     if (singular_overwrite_policy_ == FORBID_SINGULAR_OVERWRITES) {</span>
<span class="lineNum">     442 </span>            :       // Fail if the field is not repeated and it has already been specified.
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       if (!field-&gt;is_repeated() &amp;&amp; reflection-&gt;HasField(*message, field)) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         ReportError(&quot;Non-repeated field \&quot;&quot; + field_name +</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                     &quot;\&quot; is specified multiple times.&quot;);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     447 </span>            :       }
<span class="lineNum">     448 </span>            :       // Fail if the field is a member of a oneof and another member has already
<span class="lineNum">     449 </span>            :       // been specified.
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :       const OneofDescriptor* oneof = field-&gt;containing_oneof();</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       if (oneof != NULL &amp;&amp; reflection-&gt;HasOneof(*message, oneof)) {</span>
<span class="lineNum">     452 </span>            :         const FieldDescriptor* other_field =
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :             reflection-&gt;GetOneofFieldDescriptor(*message, oneof);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         ReportError(&quot;Field \&quot;&quot; + field_name + &quot;\&quot; is specified along with &quot;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                     &quot;field \&quot;&quot; + other_field-&gt;name() + &quot;\&quot;, another member &quot;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                     &quot;of oneof \&quot;&quot; + oneof-&gt;name() + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     458 </span>            :       }
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :     // Perform special handling for embedded message types.
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     if (field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">     463 </span>            :       // ':' is optional here.
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       TryConsume(&quot;:&quot;);</span>
<span class="lineNum">     465 </span>            :     } else {
<span class="lineNum">     466 </span>            :       // ':' is required here.
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       DO(Consume(&quot;:&quot;));</span>
<span class="lineNum">     468 </span>            :     }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     if (field-&gt;is_repeated() &amp;&amp; TryConsume(&quot;[&quot;)) {</span>
<span class="lineNum">     471 </span>            :       // Short repeated format, e.g.  &quot;foo: [1, 2, 3]&quot;
<span class="lineNum">     472 </span>            :       while (true) {
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         if (field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">     474 </span>            :           // Perform special handling for embedded message types.
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :           DO(ConsumeFieldMessage(message, reflection, field));</span>
<span class="lineNum">     476 </span>            :         } else {
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :           DO(ConsumeFieldValue(message, reflection, field));</span>
<span class="lineNum">     478 </span>            :         }
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         if (TryConsume(&quot;]&quot;)) {</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         DO(Consume(&quot;,&quot;));</span>
<span class="lineNum">     483 </span>            :       }
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     } else if (field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       DO(ConsumeFieldMessage(message, reflection, field));</span>
<span class="lineNum">     486 </span>            :     } else {
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       DO(ConsumeFieldValue(message, reflection, field));</span>
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :     // For historical reasons, fields may optionally be separated by commas or
<span class="lineNum">     491 </span>            :     // semicolons.
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     TryConsume(&quot;;&quot;) || TryConsume(&quot;,&quot;);</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     if (field-&gt;options().deprecated()) {</span>
<span class="lineNum">     495 </span>            :       ReportWarning(&quot;text format contains deprecated field \&quot;&quot;
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                     + field_name + &quot;\&quot;&quot;);</span>
<span class="lineNum">     497 </span>            :     }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :     // If a parse info tree exists, add the location for the parsed
<span class="lineNum">     500 </span>            :     // field.
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     if (parse_info_tree_ != NULL) {</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       RecordLocation(parse_info_tree_, field,</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                      ParseLocation(start_line, start_column));</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     507 </span>            :   }
<a name="508"><span class="lineNum">     508 </span>            : </a>
<span class="lineNum">     509 </span>            :   // Skips the next field including the field's name and value.
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   bool SkipField() {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     string field_name;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;[&quot;)) {</span>
<span class="lineNum">     513 </span>            :       // Extension name.
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       DO(ConsumeIdentifier(&amp;field_name));</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       while (TryConsume(&quot;.&quot;)) {</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         string part;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         DO(ConsumeIdentifier(&amp;part));</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         field_name += &quot;.&quot;;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         field_name += part;</span>
<span class="lineNum">     520 </span>            :       }
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       DO(Consume(&quot;]&quot;));</span>
<span class="lineNum">     522 </span>            :     } else {
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       DO(ConsumeIdentifier(&amp;field_name));</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :     // Try to guess the type of this field.
<span class="lineNum">     527 </span>            :     // If this field is not a message, there should be a &quot;:&quot; between the
<span class="lineNum">     528 </span>            :     // field name and the field value and also the field value should not
<span class="lineNum">     529 </span>            :     // start with &quot;{&quot; or &quot;&lt;&quot; which indicates the begining of a message body.
<span class="lineNum">     530 </span>            :     // If there is no &quot;:&quot; or there is a &quot;{&quot; or &quot;&lt;&quot; after &quot;:&quot;, this field has
<span class="lineNum">     531 </span>            :     // to be a message or the input is ill-formed.
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;:&quot;) &amp;&amp; !LookingAt(&quot;{&quot;) &amp;&amp; !LookingAt(&quot;&lt;&quot;)) {</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       DO(SkipFieldValue());</span>
<span class="lineNum">     534 </span>            :     } else {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       DO(SkipFieldMessage());</span>
<span class="lineNum">     536 </span>            :     }
<span class="lineNum">     537 </span>            :     // For historical reasons, fields may optionally be separated by commas or
<span class="lineNum">     538 </span>            :     // semicolons.
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     TryConsume(&quot;;&quot;) || TryConsume(&quot;,&quot;);</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="541"><span class="lineNum">     541 </span>            :   }</a>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   bool ConsumeFieldMessage(Message* message,</span>
<span class="lineNum">     544 </span>            :                            const Reflection* reflection,
<span class="lineNum">     545 </span>            :                            const FieldDescriptor* field) {
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :     // If the parse information tree is not NULL, create a nested one
<span class="lineNum">     548 </span>            :     // for the nested message.
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     ParseInfoTree* parent = parse_info_tree_;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     if (parent != NULL) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       parse_info_tree_ = CreateNested(parent, field);</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     string delimeter;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;&lt;&quot;)) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       delimeter = &quot;&gt;&quot;;</span>
<span class="lineNum">     557 </span>            :     } else {
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       DO(Consume(&quot;{&quot;));</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       delimeter = &quot;}&quot;;</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     if (field-&gt;is_repeated()) {</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       DO(ConsumeMessage(reflection-&gt;AddMessage(message, field), delimeter));</span>
<span class="lineNum">     564 </span>            :     } else {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :       DO(ConsumeMessage(reflection-&gt;MutableMessage(message, field),</span>
<span class="lineNum">     566 </span>            :                         delimeter));
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     // Reset the parse information tree.
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     parse_info_tree_ = parent;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     572 </span>            :   }
<span class="lineNum">     573 </span>            : 
<a name="574"><span class="lineNum">     574 </span>            :   // Skips the whole body of a message including the begining delimeter and</a>
<span class="lineNum">     575 </span>            :   // the ending delimeter.
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   bool SkipFieldMessage() {</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     string delimeter;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;&lt;&quot;)) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :       delimeter = &quot;&gt;&quot;;</span>
<span class="lineNum">     580 </span>            :     } else {
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       DO(Consume(&quot;{&quot;));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       delimeter = &quot;}&quot;;</span>
<span class="lineNum">     583 </span>            :     }
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     while (!LookingAt(&quot;&gt;&quot;) &amp;&amp;  !LookingAt(&quot;}&quot;)) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       DO(SkipField());</span>
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     DO(Consume(delimeter));</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="589"><span class="lineNum">     589 </span>            :   }</a>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   bool ConsumeFieldValue(Message* message,</span>
<span class="lineNum">     592 </span>            :                          const Reflection* reflection,
<span class="lineNum">     593 </span>            :                          const FieldDescriptor* field) {
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : // Define an easy to use macro for setting fields. This macro checks
<span class="lineNum">     596 </span>            : // to see if the field is repeated (in which case we need to use the Add
<span class="lineNum">     597 </span>            : // methods or not (in which case we need to use the Set methods).
<span class="lineNum">     598 </span>            : #define SET_FIELD(CPPTYPE, VALUE)                                  \
<span class="lineNum">     599 </span>            :         if (field-&gt;is_repeated()) {                                \
<span class="lineNum">     600 </span>            :           reflection-&gt;Add##CPPTYPE(message, field, VALUE);         \
<span class="lineNum">     601 </span>            :         } else {                                                   \
<span class="lineNum">     602 </span>            :           reflection-&gt;Set##CPPTYPE(message, field, VALUE);         \
<span class="lineNum">     603 </span>            :         }                                                          \
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     switch(field-&gt;cpp_type()) {</span>
<span class="lineNum">     606 </span>            :       case FieldDescriptor::CPPTYPE_INT32: {
<span class="lineNum">     607 </span>            :         int64 value;
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         DO(ConsumeSignedInteger(&amp;value, kint32max));</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         SET_FIELD(Int32, static_cast&lt;int32&gt;(value));</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     611 </span>            :       }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :       case FieldDescriptor::CPPTYPE_UINT32: {
<span class="lineNum">     614 </span>            :         uint64 value;
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         DO(ConsumeUnsignedInteger(&amp;value, kuint32max));</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         SET_FIELD(UInt32, static_cast&lt;uint32&gt;(value));</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     618 </span>            :       }
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :       case FieldDescriptor::CPPTYPE_INT64: {
<span class="lineNum">     621 </span>            :         int64 value;
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         DO(ConsumeSignedInteger(&amp;value, kint64max));</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         SET_FIELD(Int64, value);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     625 </span>            :       }
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :       case FieldDescriptor::CPPTYPE_UINT64: {
<span class="lineNum">     628 </span>            :         uint64 value;
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         DO(ConsumeUnsignedInteger(&amp;value, kuint64max));</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         SET_FIELD(UInt64, value);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     632 </span>            :       }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :       case FieldDescriptor::CPPTYPE_FLOAT: {
<span class="lineNum">     635 </span>            :         double value;
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         DO(ConsumeDouble(&amp;value));</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         SET_FIELD(Float, static_cast&lt;float&gt;(value));</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     639 </span>            :       }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :       case FieldDescriptor::CPPTYPE_DOUBLE: {
<span class="lineNum">     642 </span>            :         double value;
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         DO(ConsumeDouble(&amp;value));</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         SET_FIELD(Double, value);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     646 </span>            :       }
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :       case FieldDescriptor::CPPTYPE_STRING: {
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         string value;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         DO(ConsumeString(&amp;value));</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         SET_FIELD(String, value);</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     653 </span>            :       }
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :       case FieldDescriptor::CPPTYPE_BOOL: {
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         if (LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     657 </span>            :           uint64 value;
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :           DO(ConsumeUnsignedInteger(&amp;value, 1));</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :           SET_FIELD(Bool, value);</span>
<span class="lineNum">     660 </span>            :         } else {
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :           string value;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :           DO(ConsumeIdentifier(&amp;value));</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :           if (value == &quot;true&quot; || value == &quot;True&quot; || value == &quot;t&quot;) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :             SET_FIELD(Bool, true);</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :           } else if (value == &quot;false&quot; || value == &quot;False&quot; || value == &quot;f&quot;) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :             SET_FIELD(Bool, false);</span>
<span class="lineNum">     667 </span>            :           } else {
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :             ReportError(&quot;Invalid value for boolean field \&quot;&quot; + field-&gt;name()</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                         + &quot;\&quot;. Value: \&quot;&quot; + value  + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     671 </span>            :           }
<span class="lineNum">     672 </span>            :         }
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     674 </span>            :       }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :       case FieldDescriptor::CPPTYPE_ENUM: {
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         string value;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         const EnumDescriptor* enum_type = field-&gt;enum_type();</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         const EnumValueDescriptor* enum_value = NULL;</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         if (LookingAtType(io::Tokenizer::TYPE_IDENTIFIER)) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :           DO(ConsumeIdentifier(&amp;value));</span>
<span class="lineNum">     683 </span>            :           // Find the enumeration value.
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :           enum_value = enum_type-&gt;FindValueByName(value);</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         } else if (LookingAt(&quot;-&quot;) ||</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                    LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     688 </span>            :           int64 int_value;
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :           DO(ConsumeSignedInteger(&amp;int_value, kint32max));</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :           value = SimpleItoa(int_value);        // for error reporting</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :           enum_value = enum_type-&gt;FindValueByNumber(int_value);</span>
<span class="lineNum">     692 </span>            :         } else {
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :           ReportError(&quot;Expected integer or identifier.&quot;);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     695 </span>            :         }
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         if (enum_value == NULL) {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :           if (!allow_unknown_enum_) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :             ReportError(&quot;Unknown enumeration value of \&quot;&quot; + value  + &quot;\&quot; for &quot;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                         &quot;field \&quot;&quot; + field-&gt;name() + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     702 </span>            :           } else {
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             ReportWarning(&quot;Unknown enumeration value of \&quot;&quot; + value  + &quot;\&quot; for &quot;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :                           &quot;field \&quot;&quot; + field-&gt;name() + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     706 </span>            :           }
<span class="lineNum">     707 </span>            :         }
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         SET_FIELD(Enum, enum_value);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     711 </span>            :       }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            :       case FieldDescriptor::CPPTYPE_MESSAGE: {
<span class="lineNum">     714 </span>            :         // We should never get here. Put here instead of a default
<span class="lineNum">     715 </span>            :         // so that if new types are added, we get a nice compiler warning.
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         GOOGLE_LOG(FATAL) &lt;&lt; &quot;Reached an unintended state: CPPTYPE_MESSAGE&quot;;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     718 </span>            :       }
<span class="lineNum">     719 </span>            :     }
<span class="lineNum">     720 </span>            : #undef SET_FIELD
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="722"><span class="lineNum">     722 </span>            :   }</a>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   bool SkipFieldValue() {</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     if (LookingAtType(io::Tokenizer::TYPE_STRING)) {</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :       while (LookingAtType(io::Tokenizer::TYPE_STRING)) {</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         tokenizer_.Next();</span>
<span class="lineNum">     728 </span>            :       }
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     730 </span>            :     }
<span class="lineNum">     731 </span>            :     // Possible field values other than string:
<span class="lineNum">     732 </span>            :     //   12345        =&gt; TYPE_INTEGER
<span class="lineNum">     733 </span>            :     //   -12345       =&gt; TYPE_SYMBOL + TYPE_INTEGER
<span class="lineNum">     734 </span>            :     //   1.2345       =&gt; TYPE_FLOAT
<span class="lineNum">     735 </span>            :     //   -1.2345      =&gt; TYPE_SYMBOL + TYPE_FLOAT
<span class="lineNum">     736 </span>            :     //   inf          =&gt; TYPE_IDENTIFIER
<span class="lineNum">     737 </span>            :     //   -inf         =&gt; TYPE_SYMBOL + TYPE_IDENTIFIER
<span class="lineNum">     738 </span>            :     //   TYPE_INTEGER =&gt; TYPE_IDENTIFIER
<span class="lineNum">     739 </span>            :     // Divides them into two group, one with TYPE_SYMBOL
<span class="lineNum">     740 </span>            :     // and the other without:
<span class="lineNum">     741 </span>            :     //   Group one:
<span class="lineNum">     742 </span>            :     //     12345        =&gt; TYPE_INTEGER
<span class="lineNum">     743 </span>            :     //     1.2345       =&gt; TYPE_FLOAT
<span class="lineNum">     744 </span>            :     //     inf          =&gt; TYPE_IDENTIFIER
<span class="lineNum">     745 </span>            :     //     TYPE_INTEGER =&gt; TYPE_IDENTIFIER
<span class="lineNum">     746 </span>            :     //   Group two:
<span class="lineNum">     747 </span>            :     //     -12345       =&gt; TYPE_SYMBOL + TYPE_INTEGER
<span class="lineNum">     748 </span>            :     //     -1.2345      =&gt; TYPE_SYMBOL + TYPE_FLOAT
<span class="lineNum">     749 </span>            :     //     -inf         =&gt; TYPE_SYMBOL + TYPE_IDENTIFIER
<span class="lineNum">     750 </span>            :     // As we can see, the field value consists of an optional '-' and one of
<span class="lineNum">     751 </span>            :     // TYPE_INTEGER, TYPE_FLOAT and TYPE_IDENTIFIER.
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     bool has_minus = TryConsume(&quot;-&quot;);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     if (!LookingAtType(io::Tokenizer::TYPE_INTEGER) &amp;&amp;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         !LookingAtType(io::Tokenizer::TYPE_FLOAT) &amp;&amp;</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         !LookingAtType(io::Tokenizer::TYPE_IDENTIFIER)) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     757 </span>            :     }
<span class="lineNum">     758 </span>            :     // Combination of '-' and TYPE_IDENTIFIER may result in an invalid field
<span class="lineNum">     759 </span>            :     // value while other combinations all generate valid values.
<span class="lineNum">     760 </span>            :     // We check if the value of this combination is valid here.
<span class="lineNum">     761 </span>            :     // TYPE_IDENTIFIER after a '-' should be one of the float values listed
<span class="lineNum">     762 </span>            :     // below:
<span class="lineNum">     763 </span>            :     //   inf, inff, infinity, nan
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     if (has_minus &amp;&amp; LookingAtType(io::Tokenizer::TYPE_IDENTIFIER)) {</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :       string text = tokenizer_.current().text;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :       LowerString(&amp;text);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       if (text != &quot;inf&quot; &amp;&amp;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :           text != &quot;infinity&quot; &amp;&amp;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           text != &quot;nan&quot;) {</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         ReportError(&quot;Invalid float number: &quot; + text);</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     772 </span>            :       }
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     tokenizer_.Next();</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     776 </span>            :   }
<a name="777"><span class="lineNum">     777 </span>            : </a>
<span class="lineNum">     778 </span>            :   // Returns true if the current token's text is equal to that specified.
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   bool LookingAt(const string&amp; text) {</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     return tokenizer_.current().text == text;</span>
<span class="lineNum">     781 </span>            :   }
<a name="782"><span class="lineNum">     782 </span>            : </a>
<span class="lineNum">     783 </span>            :   // Returns true if the current token's type is equal to that specified.
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   bool LookingAtType(io::Tokenizer::TokenType token_type) {</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     return tokenizer_.current().type == token_type;</span>
<span class="lineNum">     786 </span>            :   }
<span class="lineNum">     787 </span>            : 
<a name="788"><span class="lineNum">     788 </span>            :   // Consumes an identifier and saves its value in the identifier parameter.</a>
<span class="lineNum">     789 </span>            :   // Returns false if the token is not of type IDENTFIER.
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   bool ConsumeIdentifier(string* identifier) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     if (LookingAtType(io::Tokenizer::TYPE_IDENTIFIER)) {</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       *identifier = tokenizer_.current().text;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :       tokenizer_.Next();</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     // If allow_field_numer_ or allow_unknown_field_ is true, we should able
<span class="lineNum">     798 </span>            :     // to parse integer identifiers.
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     if ((allow_field_number_ || allow_unknown_field_)</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         &amp;&amp; LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       *identifier = tokenizer_.current().text;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       tokenizer_.Next();</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     804 </span>            :     }
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     ReportError(&quot;Expected identifier.&quot;);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     808 </span>            :   }
<span class="lineNum">     809 </span>            : 
<a name="810"><span class="lineNum">     810 </span>            :   // Consumes a string and saves its value in the text parameter.</a>
<span class="lineNum">     811 </span>            :   // Returns false if the token is not of type STRING.
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   bool ConsumeString(string* text) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     if (!LookingAtType(io::Tokenizer::TYPE_STRING)) {</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expected string.&quot;);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     816 </span>            :     }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     text-&gt;clear();</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     while (LookingAtType(io::Tokenizer::TYPE_STRING)) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       io::Tokenizer::ParseStringAppend(tokenizer_.current().text, text);</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :       tokenizer_.Next();</span>
<span class="lineNum">     823 </span>            :     }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     826 </span>            :   }
<span class="lineNum">     827 </span>            : 
<a name="828"><span class="lineNum">     828 </span>            :   // Consumes a uint64 and saves its value in the value parameter.</a>
<span class="lineNum">     829 </span>            :   // Returns false if the token is not of type INTEGER.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   bool ConsumeUnsignedInteger(uint64* value, uint64 max_value) {</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     if (!LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expected integer.&quot;);</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     834 </span>            :     }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     if (!io::Tokenizer::ParseInteger(tokenizer_.current().text,</span>
<span class="lineNum">     837 </span>            :                                      max_value, value)) {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       ReportError(&quot;Integer out of range.&quot;);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     tokenizer_.Next();</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     844 </span>            :   }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :   // Consumes an int64 and saves its value in the value parameter.
<span class="lineNum">     847 </span>            :   // Note that since the tokenizer does not support negative numbers,
<span class="lineNum">     848 </span>            :   // we actually may consume an additional token (for the minus sign) in this
<a name="849"><span class="lineNum">     849 </span>            :   // method. Returns false if the token is not an integer</a>
<span class="lineNum">     850 </span>            :   // (signed or otherwise).
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   bool ConsumeSignedInteger(int64* value, uint64 max_value) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     bool negative = false;</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;-&quot;)) {</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       negative = true;</span>
<span class="lineNum">     856 </span>            :       // Two's complement always allows one more negative integer than
<span class="lineNum">     857 </span>            :       // positive.
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :       ++max_value;</span>
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     uint64 unsigned_value;
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     DO(ConsumeUnsignedInteger(&amp;unsigned_value, max_value));</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     *value = static_cast&lt;int64&gt;(unsigned_value);</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     if (negative) {</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       *value = -*value;</span>
<span class="lineNum">     869 </span>            :     }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     872 </span>            :   }
<span class="lineNum">     873 </span>            : 
<a name="874"><span class="lineNum">     874 </span>            :   // Consumes a uint64 and saves its value in the value parameter.</a>
<span class="lineNum">     875 </span>            :   // Accepts decimal numbers only, rejects hex or oct numbers.
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   bool ConsumeUnsignedDecimalInteger(uint64* value, uint64 max_value) {</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     if (!LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expected integer.&quot;);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     const string&amp; text = tokenizer_.current().text;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     if (IsHexNumber(text) || IsOctNumber(text)) {</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expect a decimal number.&quot;);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     886 </span>            :     }
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     if (!io::Tokenizer::ParseInteger(text, max_value, value)) {</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       ReportError(&quot;Integer out of range.&quot;);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     891 </span>            :     }
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     tokenizer_.Next();</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     895 </span>            :   }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :   // Consumes a double and saves its value in the value parameter.
<span class="lineNum">     898 </span>            :   // Note that since the tokenizer does not support negative numbers,
<span class="lineNum">     899 </span>            :   // we actually may consume an additional token (for the minus sign) in this
<a name="900"><span class="lineNum">     900 </span>            :   // method. Returns false if the token is not a double</a>
<span class="lineNum">     901 </span>            :   // (signed or otherwise).
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   bool ConsumeDouble(double* value) {</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     bool negative = false;</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     if (TryConsume(&quot;-&quot;)) {</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       negative = true;</span>
<span class="lineNum">     907 </span>            :     }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :     // A double can actually be an integer, according to the tokenizer.
<span class="lineNum">     910 </span>            :     // Therefore, we must check both cases here.
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     if (LookingAtType(io::Tokenizer::TYPE_INTEGER)) {</span>
<span class="lineNum">     912 </span>            :       // We have found an integer value for the double.
<span class="lineNum">     913 </span>            :       uint64 integer_value;
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :       DO(ConsumeUnsignedDecimalInteger(&amp;integer_value, kuint64max));</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :       *value = static_cast&lt;double&gt;(integer_value);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     } else if (LookingAtType(io::Tokenizer::TYPE_FLOAT)) {</span>
<span class="lineNum">     918 </span>            :       // We have found a float value for the double.
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :       *value = io::Tokenizer::ParseFloat(tokenizer_.current().text);</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :       // Mark the current token as consumed.
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       tokenizer_.Next();</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     } else if (LookingAtType(io::Tokenizer::TYPE_IDENTIFIER)) {</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       string text = tokenizer_.current().text;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :       LowerString(&amp;text);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       if (text == &quot;inf&quot; ||</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :           text == &quot;infinity&quot;) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         *value = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :         tokenizer_.Next();</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       } else if (text == &quot;nan&quot;) {</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         *value = std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         tokenizer_.Next();</span>
<span class="lineNum">     933 </span>            :       } else {
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         ReportError(&quot;Expected double.&quot;);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     936 </span>            :       }
<span class="lineNum">     937 </span>            :     } else {
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expected double.&quot;);</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     if (negative) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       *value = -*value;</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     947 </span>            :   }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            :   // Consumes a token and confirms that it matches that specified in the
<a name="950"><span class="lineNum">     950 </span>            :   // value parameter. Returns false if the token found does not match that</a>
<span class="lineNum">     951 </span>            :   // which was specified.
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   bool Consume(const string&amp; value) {</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     const string&amp; current_value = tokenizer_.current().text;</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     if (current_value != value) {</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :       ReportError(&quot;Expected \&quot;&quot; + value + &quot;\&quot;, found \&quot;&quot; + current_value</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                   + &quot;\&quot;.&quot;);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     tokenizer_.Next();</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     964 </span>            :   }
<span class="lineNum">     965 </span>            : 
<a name="966"><span class="lineNum">     966 </span>            :   // Attempts to consume the supplied value. Returns false if a the</a>
<span class="lineNum">     967 </span>            :   // token found does not match the value specified.
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   bool TryConsume(const string&amp; value) {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     if (tokenizer_.current().text == value) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :       tokenizer_.Next();</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">     972 </span>            :     } else {
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     974 </span>            :     }
<span class="lineNum">     975 </span>            :   }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   // An internal instance of the Tokenizer's error collector, used to
<span class="lineNum">     978 </span>            :   // collect any base-level parse errors and feed them to the ParserImpl.
<a name="979"><span class="lineNum">     979 </span>            :   class ParserErrorCollector : public io::ErrorCollector {</a>
<span class="lineNum">     980 </span>            :    public:
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     explicit ParserErrorCollector(TextFormat::Parser::ParserImpl* parser) :</span>
<a name="982"><span class="lineNum">     982 </span><span class="lineNoCov">          0 :         parser_(parser) { }</span></a>
<span class="lineNum">     983 </span>            : 
<a name="984"><span class="lineNum">     984 </span><span class="lineNoCov">          0 :     virtual ~ParserErrorCollector() { }</span></a>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     virtual void AddError(int line, int column, const string&amp; message) {</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :       parser_-&gt;ReportError(line, column, message);</span>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     virtual void AddWarning(int line, int column, const string&amp; message) {</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :       parser_-&gt;ReportWarning(line, column, message);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :    private:
<span class="lineNum">     995 </span>            :     GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ParserErrorCollector);
<span class="lineNum">     996 </span>            :     TextFormat::Parser::ParserImpl* parser_;
<span class="lineNum">     997 </span>            :   };
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :   io::ErrorCollector* error_collector_;
<span class="lineNum">    1000 </span>            :   TextFormat::Finder* finder_;
<span class="lineNum">    1001 </span>            :   ParseInfoTree* parse_info_tree_;
<span class="lineNum">    1002 </span>            :   ParserErrorCollector tokenizer_error_collector_;
<span class="lineNum">    1003 </span>            :   io::Tokenizer tokenizer_;
<span class="lineNum">    1004 </span>            :   const Descriptor* root_message_type_;
<span class="lineNum">    1005 </span>            :   SingularOverwritePolicy singular_overwrite_policy_;
<span class="lineNum">    1006 </span>            :   const bool allow_case_insensitive_field_;
<span class="lineNum">    1007 </span>            :   const bool allow_unknown_field_;
<span class="lineNum">    1008 </span>            :   const bool allow_unknown_enum_;
<span class="lineNum">    1009 </span>            :   const bool allow_field_number_;
<span class="lineNum">    1010 </span>            :   bool had_errors_;
<span class="lineNum">    1011 </span>            : };
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : #undef DO
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : // ===========================================================================
<span class="lineNum">    1016 </span>            : // Internal class for writing text to the io::ZeroCopyOutputStream. Adapted
<span class="lineNum">    1017 </span>            : // from the Printer found in //google/protobuf/io/printer.h
<a name="1018"><span class="lineNum">    1018 </span>            : class TextFormat::Printer::TextGenerator {</a>
<span class="lineNum">    1019 </span>            :  public:
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   explicit TextGenerator(io::ZeroCopyOutputStream* output,</span>
<span class="lineNum">    1021 </span>            :                          int initial_indent_level)
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     : output_(output),</span>
<span class="lineNum">    1023 </span>            :       buffer_(NULL),
<span class="lineNum">    1024 </span>            :       buffer_size_(0),
<span class="lineNum">    1025 </span>            :       at_start_of_line_(true),
<span class="lineNum">    1026 </span>            :       failed_(false),
<span class="lineNum">    1027 </span>            :       indent_(&quot;&quot;),
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :       initial_indent_level_(initial_indent_level) {</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     indent_.resize(initial_indent_level_ * 2, ' ');</span>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   ~TextGenerator() {</span>
<span class="lineNum">    1033 </span>            :     // Only BackUp() if we're sure we've successfully called Next() at least
<span class="lineNum">    1034 </span>            :     // once.
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     if (!failed_ &amp;&amp; buffer_size_ &gt; 0) {</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       output_-&gt;BackUp(buffer_size_);</span>
<span class="lineNum">    1037 </span>            :     }
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   // Indent text by two spaces.  After calling Indent(), two spaces will be
<a name="1041"><span class="lineNum">    1041 </span>            :   // inserted at the beginning of each line of text.  Indent() may be called</a>
<span class="lineNum">    1042 </span>            :   // multiple times to produce deeper indents.
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   void Indent() {</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     indent_ += &quot;  &quot;;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1046 </span>            : 
<a name="1047"><span class="lineNum">    1047 </span>            :   // Reduces the current indent level by two spaces, or crashes if the indent</a>
<span class="lineNum">    1048 </span>            :   // level is zero.
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   void Outdent() {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     if (indent_.empty() ||</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :         indent_.size() &lt; initial_indent_level_ * 2) {</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :       GOOGLE_LOG(DFATAL) &lt;&lt; &quot; Outdent() without matching Indent().&quot;;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1054 </span>            :     }
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     indent_.resize(indent_.size() - 2);</span>
<span class="lineNum">    1057 </span>            :   }
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<span class="lineNum">    1059 </span>            :   // Print text to the output stream.
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   void Print(const string&amp; str) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     Print(str.data(), str.size());</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   }</span>
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<span class="lineNum">    1064 </span>            :   // Print text to the output stream.
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   void Print(const char* text) {</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     Print(text, strlen(text));</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   }</span>
<a name="1068"><span class="lineNum">    1068 </span>            : </a>
<span class="lineNum">    1069 </span>            :   // Print text to the output stream.
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   void Print(const char* text, int size) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     int pos = 0;  // The number of bytes we've written so far.</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; size; i++) {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :       if (text[i] == '\n') {</span>
<span class="lineNum">    1075 </span>            :         // Saw newline.  If there is more text, we may need to insert an indent
<span class="lineNum">    1076 </span>            :         // here.  So, write what we have so far, including the '\n'.
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         Write(text + pos, i - pos + 1);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         pos = i + 1;</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :         // Setting this true will cause the next Write() to insert an indent
<span class="lineNum">    1081 </span>            :         // first.
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         at_start_of_line_ = true;</span>
<span class="lineNum">    1083 </span>            :       }
<span class="lineNum">    1084 </span>            :     }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :     // Write the rest.
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     Write(text + pos, size - pos);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :   // True if any write to the underlying stream failed.  (We don't just
<a name="1091"><span class="lineNum">    1091 </span>            :   // crash in this case because this is an I/O failure, not a programming</a>
<span class="lineNum">    1092 </span>            :   // error.)
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   bool failed() const { return failed_; }</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :  private:
<a name="1096"><span class="lineNum">    1096 </span>            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(TextGenerator);</a>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   void Write(const char* data, int size) {</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     if (failed_) return;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     if (size == 0) return;</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     if (at_start_of_line_) {</span>
<span class="lineNum">    1103 </span>            :       // Insert an indent.
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       at_start_of_line_ = false;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :       Write(indent_.data(), indent_.size());</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :       if (failed_) return;</span>
<span class="lineNum">    1107 </span>            :     }
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     while (size &gt; buffer_size_) {</span>
<span class="lineNum">    1110 </span>            :       // Data exceeds space in the buffer.  Copy what we can and request a
<span class="lineNum">    1111 </span>            :       // new buffer.
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       memcpy(buffer_, data, buffer_size_);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       data += buffer_size_;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       size -= buffer_size_;</span>
<span class="lineNum">    1115 </span>            :       void* void_buffer;
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       failed_ = !output_-&gt;Next(&amp;void_buffer, &amp;buffer_size_);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :       if (failed_) return;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :       buffer_ = reinterpret_cast&lt;char*&gt;(void_buffer);</span>
<span class="lineNum">    1119 </span>            :     }
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            :     // Buffer is big enough to receive the data; copy it.
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     memcpy(buffer_, data, size);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     buffer_ += size;</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     buffer_size_ -= size;</span>
<span class="lineNum">    1125 </span>            :   }
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :   io::ZeroCopyOutputStream* const output_;
<span class="lineNum">    1128 </span>            :   char* buffer_;
<span class="lineNum">    1129 </span>            :   int buffer_size_;
<span class="lineNum">    1130 </span>            :   bool at_start_of_line_;
<span class="lineNum">    1131 </span>            :   bool failed_;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span>            :   string indent_;
<span class="lineNum">    1134 </span>            :   int initial_indent_level_;
<span class="lineNum">    1135 </span>            : };
<span class="lineNum">    1136 </span>            : 
<a name="1137"><span class="lineNum">    1137 </span>            : // ===========================================================================</a>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 : TextFormat::Finder::~Finder() {</span>
<a name="1140"><span class="lineNum">    1140 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 : TextFormat::Parser::Parser()</span>
<span class="lineNum">    1143 </span>            :   : error_collector_(NULL),
<span class="lineNum">    1144 </span>            :     finder_(NULL),
<span class="lineNum">    1145 </span>            :     parse_info_tree_(NULL),
<span class="lineNum">    1146 </span>            :     allow_partial_(false),
<span class="lineNum">    1147 </span>            :     allow_case_insensitive_field_(false),
<span class="lineNum">    1148 </span>            :     allow_unknown_field_(false),
<span class="lineNum">    1149 </span>            :     allow_unknown_enum_(false),
<span class="lineNum">    1150 </span>            :     allow_field_number_(false),
<span class="lineNum">    1151 </span>            :     allow_relaxed_whitespace_(false),
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     allow_singular_overwrites_(false) {</span>
<a name="1153"><span class="lineNum">    1153 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1154 </span>            : 
<a name="1155"><span class="lineNum">    1155 </span><span class="lineNoCov">          0 : TextFormat::Parser::~Parser() {}</span></a>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::Parse(io::ZeroCopyInputStream* input,</span>
<span class="lineNum">    1158 </span>            :                                Message* output) {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   output-&gt;Clear();</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :   ParserImpl::SingularOverwritePolicy overwrites_policy =
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :       allow_singular_overwrites_</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       ? ParserImpl::ALLOW_SINGULAR_OVERWRITES</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :       : ParserImpl::FORBID_SINGULAR_OVERWRITES;</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :   ParserImpl parser(output-&gt;GetDescriptor(), input, error_collector_,
<span class="lineNum">    1167 </span>            :                     finder_, parse_info_tree_,
<span class="lineNum">    1168 </span>            :                     overwrites_policy,
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                     allow_case_insensitive_field_, allow_unknown_field_,</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                     allow_unknown_enum_, allow_field_number_,</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                     allow_relaxed_whitespace_);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   return MergeUsingImpl(input, output, &amp;parser);</span>
<a name="1173"><span class="lineNum">    1173 </span>            : }</a>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::ParseFromString(const string&amp; input,</span>
<span class="lineNum">    1176 </span>            :                                          Message* output) {
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   io::ArrayInputStream input_stream(input.data(), input.size());</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   return Parse(&amp;input_stream, output);</span>
<a name="1179"><span class="lineNum">    1179 </span>            : }</a>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::Merge(io::ZeroCopyInputStream* input,</span>
<span class="lineNum">    1182 </span>            :                                Message* output) {
<span class="lineNum">    1183 </span>            :   ParserImpl parser(output-&gt;GetDescriptor(), input, error_collector_,
<span class="lineNum">    1184 </span>            :                     finder_, parse_info_tree_,
<span class="lineNum">    1185 </span>            :                     ParserImpl::ALLOW_SINGULAR_OVERWRITES,
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                     allow_case_insensitive_field_, allow_unknown_field_,</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                     allow_unknown_enum_, allow_field_number_,</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                     allow_relaxed_whitespace_);</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   return MergeUsingImpl(input, output, &amp;parser);</span>
<a name="1190"><span class="lineNum">    1190 </span>            : }</a>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::MergeFromString(const string&amp; input,</span>
<span class="lineNum">    1193 </span>            :                                          Message* output) {
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :   io::ArrayInputStream input_stream(input.data(), input.size());</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :   return Merge(&amp;input_stream, output);</span>
<a name="1196"><span class="lineNum">    1196 </span>            : }</a>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::MergeUsingImpl(io::ZeroCopyInputStream* /* input */,</span>
<span class="lineNum">    1199 </span>            :                                         Message* output,
<span class="lineNum">    1200 </span>            :                                         ParserImpl* parser_impl) {
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   if (!parser_impl-&gt;Parse(output)) return false;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   if (!allow_partial_ &amp;&amp; !output-&gt;IsInitialized()) {</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     vector&lt;string&gt; missing_fields;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     output-&gt;FindInitializationErrors(&amp;missing_fields);</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     parser_impl-&gt;ReportError(-1, 0, &quot;Message missing required fields: &quot; +</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                                         Join(missing_fields, &quot;, &quot;));</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1208 </span>            :   }
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="1210"><span class="lineNum">    1210 </span>            : }</a>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 : bool TextFormat::Parser::ParseFieldValueFromString(</span>
<span class="lineNum">    1213 </span>            :     const string&amp; input,
<span class="lineNum">    1214 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1215 </span>            :     Message* output) {
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   io::ArrayInputStream input_stream(input.data(), input.size());</span>
<span class="lineNum">    1217 </span>            :   ParserImpl parser(output-&gt;GetDescriptor(), &amp;input_stream, error_collector_,
<span class="lineNum">    1218 </span>            :                     finder_, parse_info_tree_,
<span class="lineNum">    1219 </span>            :                     ParserImpl::ALLOW_SINGULAR_OVERWRITES,
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                     allow_case_insensitive_field_, allow_unknown_field_,</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                     allow_unknown_enum_, allow_field_number_,</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                     allow_relaxed_whitespace_);</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :   return parser.ParseField(field, output);</span>
<a name="1224"><span class="lineNum">    1224 </span>            : }</a>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::Parse(io::ZeroCopyInputStream* input,</span>
<span class="lineNum">    1227 </span>            :                                     Message* output) {
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   return Parser().Parse(input, output);</span>
<a name="1229"><span class="lineNum">    1229 </span>            : }</a>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::Merge(io::ZeroCopyInputStream* input,</span>
<span class="lineNum">    1232 </span>            :                                     Message* output) {
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   return Parser().Merge(input, output);</span>
<a name="1234"><span class="lineNum">    1234 </span>            : }</a>
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::ParseFromString(const string&amp; input,</span>
<span class="lineNum">    1237 </span>            :                                               Message* output) {
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   return Parser().ParseFromString(input, output);</span>
<a name="1239"><span class="lineNum">    1239 </span>            : }</a>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::MergeFromString(const string&amp; input,</span>
<span class="lineNum">    1242 </span>            :                                               Message* output) {
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   return Parser().MergeFromString(input, output);</span>
<span class="lineNum">    1244 </span>            : }
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            : // ===========================================================================
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            : // The default implementation for FieldValuePrinter. The base class just
<a name="1249"><span class="lineNum">    1249 </span>            : // does simple formatting. That way, deriving classes could decide to fallback</a>
<a name="1250"><span class="lineNum">    1250 </span>            : // to that behavior.</a>
<a name="1251"><span class="lineNum">    1251 </span><span class="lineNoCov">          0 : TextFormat::FieldValuePrinter::FieldValuePrinter() {}</span></a>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 : TextFormat::FieldValuePrinter::~FieldValuePrinter() {}</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintBool(bool val) const {</span>
<a name="1254"><span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   return val ? &quot;true&quot; : &quot;false&quot;;</span></a>
<span class="lineNum">    1255 </span>            : }
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintInt32(int32 val) const {</span>
<a name="1257"><span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   return SimpleItoa(val);</span></a>
<span class="lineNum">    1258 </span>            : }
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintUInt32(uint32 val) const {</span>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   return SimpleItoa(val);</span></a>
<span class="lineNum">    1261 </span>            : }
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintInt64(int64 val) const {</span>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   return SimpleItoa(val);</span></a>
<span class="lineNum">    1264 </span>            : }
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintUInt64(uint64 val) const {</span>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   return SimpleItoa(val);</span></a>
<span class="lineNum">    1267 </span>            : }
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintFloat(float val) const {</span>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   return SimpleFtoa(val);</span></a>
<span class="lineNum">    1270 </span>            : }
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintDouble(double val) const {</span>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineNoCov">          0 :   return SimpleDtoa(val);</span></a>
<span class="lineNum">    1273 </span>            : }
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintString(const string&amp; val) const {</span>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   return StrCat(&quot;\&quot;&quot;, CEscape(val), &quot;\&quot;&quot;);</span></a>
<span class="lineNum">    1276 </span>            : }
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintBytes(const string&amp; val) const {</span>
<a name="1278"><span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   return PrintString(val);</span></a>
<span class="lineNum">    1279 </span>            : }
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintEnum(int32 val,</span>
<span class="lineNum">    1281 </span>            :                                                 const string&amp; name) const {
<a name="1282"><span class="lineNum">    1282 </span><span class="lineNoCov">          0 :   return name;</span></a>
<span class="lineNum">    1283 </span>            : }
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintFieldName(</span>
<span class="lineNum">    1285 </span>            :     const Message&amp; message,
<span class="lineNum">    1286 </span>            :     const Reflection* reflection,
<span class="lineNum">    1287 </span>            :     const FieldDescriptor* field) const {
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   if (field-&gt;is_extension()) {</span>
<span class="lineNum">    1289 </span>            :     // We special-case MessageSet elements for compatibility with proto1.
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     if (field-&gt;containing_type()-&gt;options().message_set_wire_format()</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :         &amp;&amp; field-&gt;type() == FieldDescriptor::TYPE_MESSAGE</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :         &amp;&amp; field-&gt;is_optional()</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         &amp;&amp; field-&gt;extension_scope() == field-&gt;message_type()) {</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :       return StrCat(&quot;[&quot;, field-&gt;message_type()-&gt;full_name(), &quot;]&quot;);</span>
<span class="lineNum">    1295 </span>            :     } else {
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :       return StrCat(&quot;[&quot;, field-&gt;full_name(), &quot;]&quot;);</span>
<span class="lineNum">    1297 </span>            :     }
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   } else if (field-&gt;type() == FieldDescriptor::TYPE_GROUP) {</span>
<span class="lineNum">    1299 </span>            :     // Groups must be serialized with their original capitalization.
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     return field-&gt;message_type()-&gt;name();</span>
<span class="lineNum">    1301 </span>            :   } else {
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     return field-&gt;name();</span>
<a name="1303"><span class="lineNum">    1303 </span>            :   }</a>
<span class="lineNum">    1304 </span>            : }
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintMessageStart(</span>
<span class="lineNum">    1306 </span>            :     const Message&amp; message,
<span class="lineNum">    1307 </span>            :     int field_index,
<span class="lineNum">    1308 </span>            :     int field_count,
<span class="lineNum">    1309 </span>            :     bool single_line_mode) const {
<a name="1310"><span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   return single_line_mode ? &quot; { &quot; : &quot; {\n&quot;;</span></a>
<span class="lineNum">    1311 </span>            : }
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 : string TextFormat::FieldValuePrinter::PrintMessageEnd(</span>
<span class="lineNum">    1313 </span>            :     const Message&amp; message,
<span class="lineNum">    1314 </span>            :     int field_index,
<span class="lineNum">    1315 </span>            :     int field_count,
<span class="lineNum">    1316 </span>            :     bool single_line_mode) const {
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   return single_line_mode ? &quot;} &quot; : &quot;}\n&quot;;</span>
<span class="lineNum">    1318 </span>            : }
<span class="lineNum">    1319 </span>            : 
<a name="1320"><span class="lineNum">    1320 </span>            : namespace {</a>
<span class="lineNum">    1321 </span>            : // Our own specialization: for UTF8 escaped strings.
<a name="1322"><span class="lineNum">    1322 </span><span class="lineNoCov">          0 : class FieldValuePrinterUtf8Escaping : public TextFormat::FieldValuePrinter {</span></a>
<span class="lineNum">    1323 </span>            :  public:
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :   virtual string PrintString(const string&amp; val) const {</span>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     return StrCat(&quot;\&quot;&quot;, strings::Utf8SafeCEscape(val), &quot;\&quot;&quot;);</span></a>
<span class="lineNum">    1326 </span>            :   }
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   virtual string PrintBytes(const string&amp; val) const {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     return TextFormat::FieldValuePrinter::PrintString(val);</span>
<span class="lineNum">    1329 </span>            :   }
<span class="lineNum">    1330 </span>            : };
<span class="lineNum">    1331 </span>            : 
<a name="1332"><span class="lineNum">    1332 </span>            : }  // namespace</a>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 : TextFormat::Printer::Printer()</span>
<span class="lineNum">    1335 </span>            :   : initial_indent_level_(0),
<span class="lineNum">    1336 </span>            :     single_line_mode_(false),
<span class="lineNum">    1337 </span>            :     use_field_number_(false),
<span class="lineNum">    1338 </span>            :     use_short_repeated_primitives_(false),
<span class="lineNum">    1339 </span>            :     hide_unknown_fields_(false),
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :     print_message_fields_in_index_order_(false) {</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   SetUseUtf8StringEscaping(false);</span>
<a name="1342"><span class="lineNum">    1342 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 : TextFormat::Printer::~Printer() {</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   STLDeleteValues(&amp;custom_printers_);</span>
<a name="1346"><span class="lineNum">    1346 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 : void TextFormat::Printer::SetUseUtf8StringEscaping(bool as_utf8) {</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   SetDefaultFieldValuePrinter(as_utf8</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                               ? new FieldValuePrinterUtf8Escaping()</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :                               : new FieldValuePrinter());</span>
<a name="1352"><span class="lineNum">    1352 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 : void TextFormat::Printer::SetDefaultFieldValuePrinter(</span>
<span class="lineNum">    1355 </span>            :     const FieldValuePrinter* printer) {
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :   default_field_value_printer_.reset(printer);</span>
<a name="1357"><span class="lineNum">    1357 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 : bool TextFormat::Printer::RegisterFieldValuePrinter(</span>
<span class="lineNum">    1360 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1361 </span>            :     const FieldValuePrinter* printer) {
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   return field != NULL</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :       &amp;&amp; printer != NULL</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :       &amp;&amp; custom_printers_.insert(make_pair(field, printer)).second;</span>
<a name="1365"><span class="lineNum">    1365 </span>            : }</a>
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 : bool TextFormat::Printer::PrintToString(const Message&amp; message,</span>
<span class="lineNum">    1368 </span>            :                                         string* output) const {
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   GOOGLE_DCHECK(output) &lt;&lt; &quot;output specified is NULL&quot;;</span>
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   output-&gt;clear();</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   io::StringOutputStream output_stream(output);</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   return Print(message, &amp;output_stream);</span>
<a name="1375"><span class="lineNum">    1375 </span>            : }</a>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 : bool TextFormat::Printer::PrintUnknownFieldsToString(</span>
<span class="lineNum">    1378 </span>            :     const UnknownFieldSet&amp; unknown_fields,
<span class="lineNum">    1379 </span>            :     string* output) const {
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   GOOGLE_DCHECK(output) &lt;&lt; &quot;output specified is NULL&quot;;</span>
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   output-&gt;clear();</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :   io::StringOutputStream output_stream(output);</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   return PrintUnknownFields(unknown_fields, &amp;output_stream);</span>
<a name="1385"><span class="lineNum">    1385 </span>            : }</a>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 : bool TextFormat::Printer::Print(const Message&amp; message,</span>
<span class="lineNum">    1388 </span>            :                                 io::ZeroCopyOutputStream* output) const {
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   TextGenerator generator(output, initial_indent_level_);</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   Print(message, generator);</span>
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            :   // Output false if the generator failed internally.
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   return !generator.failed();</span>
<a name="1395"><span class="lineNum">    1395 </span>            : }</a>
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 : bool TextFormat::Printer::PrintUnknownFields(</span>
<span class="lineNum">    1398 </span>            :     const UnknownFieldSet&amp; unknown_fields,
<span class="lineNum">    1399 </span>            :     io::ZeroCopyOutputStream* output) const {
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :   TextGenerator generator(output, initial_indent_level_);</span>
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   PrintUnknownFields(unknown_fields, generator);</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :   // Output false if the generator failed internally.
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :   return !generator.failed();</span>
<span class="lineNum">    1406 </span>            : }
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            : namespace {
<a name="1409"><span class="lineNum">    1409 </span>            : // Comparison functor for sorting FieldDescriptors by field index.</a>
<span class="lineNum">    1410 </span>            : struct FieldIndexSorter {
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   bool operator()(const FieldDescriptor* left,</span>
<span class="lineNum">    1412 </span>            :                   const FieldDescriptor* right) const {
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     return left-&gt;index() &lt; right-&gt;index();</span>
<span class="lineNum">    1414 </span>            :   }
<span class="lineNum">    1415 </span>            : };
<a name="1416"><span class="lineNum">    1416 </span>            : }  // namespace</a>
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 : void TextFormat::Printer::Print(const Message&amp; message,</span>
<span class="lineNum">    1419 </span>            :                                 TextGenerator&amp; generator) const {
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :   const Reflection* reflection = message.GetReflection();</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :   vector&lt;const FieldDescriptor*&gt; fields;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :   reflection-&gt;ListFields(message, &amp;fields);</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :   if (print_message_fields_in_index_order_) {</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     sort(fields.begin(), fields.end(), FieldIndexSorter());</span>
<span class="lineNum">    1425 </span>            :   }
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; fields.size(); i++) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     PrintField(message, reflection, fields[i], generator);</span>
<span class="lineNum">    1428 </span>            :   }
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   if (!hide_unknown_fields_) {</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     PrintUnknownFields(reflection-&gt;GetUnknownFields(message), generator);</span>
<span class="lineNum">    1431 </span>            :   }
<a name="1432"><span class="lineNum">    1432 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintFieldValueToString(</span>
<span class="lineNum">    1435 </span>            :     const Message&amp; message,
<span class="lineNum">    1436 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1437 </span>            :     int index,
<span class="lineNum">    1438 </span>            :     string* output) const {
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :   GOOGLE_DCHECK(output) &lt;&lt; &quot;output specified is NULL&quot;;</span>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   output-&gt;clear();</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   io::StringOutputStream output_stream(output);</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   TextGenerator generator(&amp;output_stream, initial_indent_level_);</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   PrintFieldValue(message, message.GetReflection(), field, index, generator);</span>
<a name="1447"><span class="lineNum">    1447 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintField(const Message&amp; message,</span>
<span class="lineNum">    1450 </span>            :                                      const Reflection* reflection,
<span class="lineNum">    1451 </span>            :                                      const FieldDescriptor* field,
<span class="lineNum">    1452 </span>            :                                      TextGenerator&amp; generator) const {
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   if (use_short_repeated_primitives_ &amp;&amp;</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :       field-&gt;is_repeated() &amp;&amp;</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :       field-&gt;cpp_type() != FieldDescriptor::CPPTYPE_STRING &amp;&amp;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :       field-&gt;cpp_type() != FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     PrintShortRepeatedField(message, reflection, field, generator);</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1459 </span>            :   }
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   int count = 0;</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   if (field-&gt;is_repeated()) {</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     count = reflection-&gt;FieldSize(message, field);</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   } else if (reflection-&gt;HasField(message, field)) {</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     count = 1;</span>
<span class="lineNum">    1467 </span>            :   }
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   for (int j = 0; j &lt; count; ++j) {</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     const int field_index = field-&gt;is_repeated() ? j : -1;</span>
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     PrintFieldName(message, reflection, field, generator);</span>
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :     if (field-&gt;cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {</span>
<span class="lineNum">    1475 </span>            :       const FieldValuePrinter* printer = FindWithDefault(
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :           custom_printers_, field, default_field_value_printer_.get());</span>
<span class="lineNum">    1477 </span>            :       const Message&amp; sub_message =
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :               field-&gt;is_repeated()</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :               ? reflection-&gt;GetRepeatedMessage(message, field, j)</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :               : reflection-&gt;GetMessage(message, field);</span>
<span class="lineNum">    1481 </span>            :       generator.Print(
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :           printer-&gt;PrintMessageStart(</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :               sub_message, field_index, count, single_line_mode_));</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :       generator.Indent();</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       Print(sub_message, generator);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :       generator.Outdent();</span>
<span class="lineNum">    1487 </span>            :       generator.Print(
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :           printer-&gt;PrintMessageEnd(</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :               sub_message, field_index, count, single_line_mode_));</span>
<span class="lineNum">    1490 </span>            :     } else {
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :       generator.Print(&quot;: &quot;);</span>
<span class="lineNum">    1492 </span>            :       // Write the field value.
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :       PrintFieldValue(message, reflection, field, field_index, generator);</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :       if (single_line_mode_) {</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         generator.Print(&quot; &quot;);</span>
<span class="lineNum">    1496 </span>            :       } else {
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :         generator.Print(&quot;\n&quot;);</span>
<span class="lineNum">    1498 </span>            :       }
<span class="lineNum">    1499 </span>            :     }
<span class="lineNum">    1500 </span>            :   }
<a name="1501"><span class="lineNum">    1501 </span>            : }</a>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintShortRepeatedField(</span>
<span class="lineNum">    1504 </span>            :     const Message&amp; message,
<span class="lineNum">    1505 </span>            :     const Reflection* reflection,
<span class="lineNum">    1506 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1507 </span>            :     TextGenerator&amp; generator) const {
<span class="lineNum">    1508 </span>            :   // Print primitive repeated field in short form.
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   PrintFieldName(message, reflection, field, generator);</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   int size = reflection-&gt;FieldSize(message, field);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   generator.Print(&quot;: [&quot;);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; size; i++) {</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     if (i &gt; 0) generator.Print(&quot;, &quot;);</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     PrintFieldValue(message, reflection, field, i, generator);</span>
<span class="lineNum">    1516 </span>            :   }
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :   if (single_line_mode_) {</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :     generator.Print(&quot;] &quot;);</span>
<span class="lineNum">    1519 </span>            :   } else {
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     generator.Print(&quot;]\n&quot;);</span>
<span class="lineNum">    1521 </span>            :   }
<a name="1522"><span class="lineNum">    1522 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintFieldName(const Message&amp; message,</span>
<span class="lineNum">    1525 </span>            :                                          const Reflection* reflection,
<span class="lineNum">    1526 </span>            :                                          const FieldDescriptor* field,
<span class="lineNum">    1527 </span>            :                                          TextGenerator&amp; generator) const {
<span class="lineNum">    1528 </span>            :   // if use_field_number_ is true, prints field number instead
<span class="lineNum">    1529 </span>            :   // of field name.
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   if (use_field_number_) {</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :     generator.Print(SimpleItoa(field-&gt;number()));</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1533 </span>            :   }
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            :   const FieldValuePrinter* printer = FindWithDefault(
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :       custom_printers_, field, default_field_value_printer_.get());</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :   generator.Print(printer-&gt;PrintFieldName(message, reflection, field));</span>
<a name="1538"><span class="lineNum">    1538 </span>            : }</a>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintFieldValue(</span>
<span class="lineNum">    1541 </span>            :     const Message&amp; message,
<span class="lineNum">    1542 </span>            :     const Reflection* reflection,
<span class="lineNum">    1543 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1544 </span>            :     int index,
<span class="lineNum">    1545 </span>            :     TextGenerator&amp; generator) const {
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   GOOGLE_DCHECK(field-&gt;is_repeated() || (index == -1))</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :       &lt;&lt; &quot;Index must be -1 for non-repeated fields&quot;;</span>
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            :   const FieldValuePrinter* printer
<span class="lineNum">    1550 </span>            :       = FindWithDefault(custom_printers_, field,
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :                         default_field_value_printer_.get());</span>
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   switch (field-&gt;cpp_type()) {</span>
<span class="lineNum">    1554 </span>            : #define OUTPUT_FIELD(CPPTYPE, METHOD)                                   \
<span class="lineNum">    1555 </span>            :     case FieldDescriptor::CPPTYPE_##CPPTYPE:                            \
<span class="lineNum">    1556 </span>            :       generator.Print(printer-&gt;Print##METHOD(field-&gt;is_repeated()       \
<span class="lineNum">    1557 </span>            :                ? reflection-&gt;GetRepeated##METHOD(message, field, index) \
<span class="lineNum">    1558 </span>            :                : reflection-&gt;Get##METHOD(message, field)));             \
<span class="lineNum">    1559 </span>            :         break
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD( INT32,  Int32);</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD( INT64,  Int64);</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD(UINT32, UInt32);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD(UINT64, UInt64);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD( FLOAT,  Float);</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD(DOUBLE, Double);</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :     OUTPUT_FIELD(  BOOL,   Bool);</span>
<span class="lineNum">    1568 </span>            : #undef OUTPUT_FIELD
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span>            :     case FieldDescriptor::CPPTYPE_STRING: {
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :       string scratch;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :       const string&amp; value = field-&gt;is_repeated()</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :           ? reflection-&gt;GetRepeatedStringReference(</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :               message, field, index, &amp;scratch)</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :           : reflection-&gt;GetStringReference(message, field, &amp;scratch);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :       if (field-&gt;type() == FieldDescriptor::TYPE_STRING) {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :         generator.Print(printer-&gt;PrintString(value));</span>
<span class="lineNum">    1578 </span>            :       } else {
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :         GOOGLE_DCHECK_EQ(field-&gt;type(), FieldDescriptor::TYPE_BYTES);</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :         generator.Print(printer-&gt;PrintBytes(value));</span>
<span class="lineNum">    1581 </span>            :       }
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1583 </span>            :     }
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :     case FieldDescriptor::CPPTYPE_ENUM: {
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :       const EnumValueDescriptor *enum_val = field-&gt;is_repeated()</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :           ? reflection-&gt;GetRepeatedEnum(message, field, index)</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :           : reflection-&gt;GetEnum(message, field);</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :       generator.Print(printer-&gt;PrintEnum(enum_val-&gt;number(), enum_val-&gt;name()));</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1591 </span>            :     }
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :     case FieldDescriptor::CPPTYPE_MESSAGE:
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       Print(field-&gt;is_repeated()</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :             ? reflection-&gt;GetRepeatedMessage(message, field, index)</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :             : reflection-&gt;GetMessage(message, field),</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :             generator);</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1599 </span>            :   }
<a name="1600"><span class="lineNum">    1600 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::Print(const Message&amp; message,</span>
<span class="lineNum">    1603 </span>            :                                     io::ZeroCopyOutputStream* output) {
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   return Printer().Print(message, output);</span>
<a name="1605"><span class="lineNum">    1605 </span>            : }</a>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::PrintUnknownFields(</span>
<span class="lineNum">    1608 </span>            :     const UnknownFieldSet&amp; unknown_fields,
<span class="lineNum">    1609 </span>            :     io::ZeroCopyOutputStream* output) {
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   return Printer().PrintUnknownFields(unknown_fields, output);</span>
<a name="1611"><span class="lineNum">    1611 </span>            : }</a>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::PrintToString(</span>
<span class="lineNum">    1614 </span>            :     const Message&amp; message, string* output) {
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   return Printer().PrintToString(message, output);</span>
<a name="1616"><span class="lineNum">    1616 </span>            : }</a>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::PrintUnknownFieldsToString(</span>
<span class="lineNum">    1619 </span>            :     const UnknownFieldSet&amp; unknown_fields, string* output) {
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :   return Printer().PrintUnknownFieldsToString(unknown_fields, output);</span>
<a name="1621"><span class="lineNum">    1621 </span>            : }</a>
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 : /* static */ void TextFormat::PrintFieldValueToString(</span>
<span class="lineNum">    1624 </span>            :     const Message&amp; message,
<span class="lineNum">    1625 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1626 </span>            :     int index,
<span class="lineNum">    1627 </span>            :     string* output) {
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :   return Printer().PrintFieldValueToString(message, field, index, output);</span>
<a name="1629"><span class="lineNum">    1629 </span>            : }</a>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 : /* static */ bool TextFormat::ParseFieldValueFromString(</span>
<span class="lineNum">    1632 </span>            :     const string&amp; input,
<span class="lineNum">    1633 </span>            :     const FieldDescriptor* field,
<span class="lineNum">    1634 </span>            :     Message* message) {
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   return Parser().ParseFieldValueFromString(input, field, message);</span>
<span class="lineNum">    1636 </span>            : }
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : // Prints an integer as hex with a fixed number of digits dependent on the
<span class="lineNum">    1639 </span>            : // integer type.
<span class="lineNum">    1640 </span>            : template&lt;typename IntType&gt;
<span class="lineNum">    1641 </span>            : static string PaddedHex(IntType value) {
<span class="lineNum">    1642 </span>            :   string result;
<span class="lineNum">    1643 </span>            :   result.reserve(sizeof(value) * 2);
<span class="lineNum">    1644 </span>            :   for (int i = sizeof(value) * 2 - 1; i &gt;= 0; i--) {
<span class="lineNum">    1645 </span>            :     result.push_back(int_to_hex_digit(value &gt;&gt; (i*4) &amp; 0x0F));
<span class="lineNum">    1646 </span>            :   }
<span class="lineNum">    1647 </span>            :   return result;
<a name="1648"><span class="lineNum">    1648 </span>            : }</a>
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 : void TextFormat::Printer::PrintUnknownFields(</span>
<span class="lineNum">    1651 </span>            :     const UnknownFieldSet&amp; unknown_fields, TextGenerator&amp; generator) const {
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; unknown_fields.field_count(); i++) {</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :     const UnknownField&amp; field = unknown_fields.field(i);</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :     string field_number = SimpleItoa(field.number());</span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :     switch (field.type()) {</span>
<span class="lineNum">    1657 </span>            :       case UnknownField::TYPE_VARINT:
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :         generator.Print(field_number);</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :         generator.Print(&quot;: &quot;);</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :         generator.Print(SimpleItoa(field.varint()));</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :         if (single_line_mode_) {</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :           generator.Print(&quot; &quot;);</span>
<span class="lineNum">    1663 </span>            :         } else {
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :           generator.Print(&quot;\n&quot;);</span>
<span class="lineNum">    1665 </span>            :         }
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1667 </span>            :       case UnknownField::TYPE_FIXED32: {
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :         generator.Print(field_number);</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :         generator.Print(&quot;: 0x&quot;);</span>
<span class="lineNum">    1670 </span>            :         char buffer[kFastToBufferSize];
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :         generator.Print(FastHex32ToBuffer(field.fixed32(), buffer));</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :         if (single_line_mode_) {</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :           generator.Print(&quot; &quot;);</span>
<span class="lineNum">    1674 </span>            :         } else {
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :           generator.Print(&quot;\n&quot;);</span>
<span class="lineNum">    1676 </span>            :         }
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1678 </span>            :       }
<span class="lineNum">    1679 </span>            :       case UnknownField::TYPE_FIXED64: {
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :         generator.Print(field_number);</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :         generator.Print(&quot;: 0x&quot;);</span>
<span class="lineNum">    1682 </span>            :         char buffer[kFastToBufferSize];
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :         generator.Print(FastHex64ToBuffer(field.fixed64(), buffer));</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :         if (single_line_mode_) {</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :           generator.Print(&quot; &quot;);</span>
<span class="lineNum">    1686 </span>            :         } else {
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :           generator.Print(&quot;\n&quot;);</span>
<span class="lineNum">    1688 </span>            :         }
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1690 </span>            :       }
<span class="lineNum">    1691 </span>            :       case UnknownField::TYPE_LENGTH_DELIMITED: {
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :         generator.Print(field_number);</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :         const string&amp; value = field.length_delimited();</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :         UnknownFieldSet embedded_unknown_fields;</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :         if (!value.empty() &amp;&amp; embedded_unknown_fields.ParseFromString(value)) {</span>
<span class="lineNum">    1696 </span>            :           // This field is parseable as a Message.
<span class="lineNum">    1697 </span>            :           // So it is probably an embedded message.
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :           if (single_line_mode_) {</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :             generator.Print(&quot; { &quot;);</span>
<span class="lineNum">    1700 </span>            :           } else {
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :             generator.Print(&quot; {\n&quot;);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :             generator.Indent();</span>
<span class="lineNum">    1703 </span>            :           }
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :           PrintUnknownFields(embedded_unknown_fields, generator);</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :           if (single_line_mode_) {</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :             generator.Print(&quot;} &quot;);</span>
<span class="lineNum">    1707 </span>            :           } else {
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :             generator.Outdent();</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :             generator.Print(&quot;}\n&quot;);</span>
<span class="lineNum">    1710 </span>            :           }
<span class="lineNum">    1711 </span>            :         } else {
<span class="lineNum">    1712 </span>            :           // This field is not parseable as a Message.
<span class="lineNum">    1713 </span>            :           // So it is probably just a plain string.
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :           generator.Print(&quot;: \&quot;&quot;);</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :           generator.Print(CEscape(value));</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :           generator.Print(&quot;\&quot;&quot;);</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :           if (single_line_mode_) {</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :             generator.Print(&quot; &quot;);</span>
<span class="lineNum">    1719 </span>            :           } else {
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :             generator.Print(&quot;\n&quot;);</span>
<span class="lineNum">    1721 </span>            :           }
<span class="lineNum">    1722 </span>            :         }
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1724 </span>            :       }
<span class="lineNum">    1725 </span>            :       case UnknownField::TYPE_GROUP:
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :         generator.Print(field_number);</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :         if (single_line_mode_) {</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :           generator.Print(&quot; { &quot;);</span>
<span class="lineNum">    1729 </span>            :         } else {
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :           generator.Print(&quot; {\n&quot;);</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :           generator.Indent();</span>
<span class="lineNum">    1732 </span>            :         }
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :         PrintUnknownFields(field.group(), generator);</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :         if (single_line_mode_) {</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :           generator.Print(&quot;} &quot;);</span>
<span class="lineNum">    1736 </span>            :         } else {
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :           generator.Outdent();</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :           generator.Print(&quot;}\n&quot;);</span>
<span class="lineNum">    1739 </span>            :         }
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1741 </span>            :     }
<span class="lineNum">    1742 </span>            :   }
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            : }  // namespace protobuf
<span class="lineNum">    1746 </span>            : }  // namespace google
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

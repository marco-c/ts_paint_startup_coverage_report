<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - toolkit/components/protobuf/src/google/protobuf/message.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">toolkit/components/protobuf/src/google/protobuf</a> - message.h<span style="font-size: 80%;"> (source / <a href="message.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">16.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryLo">25.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Protocol Buffers - Google's data interchange format</a>
<span class="lineNum">       2 </span>            : // Copyright 2008 Google Inc.  All rights reserved.
<span class="lineNum">       3 </span>            : // https://developers.google.com/protocol-buffers/
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       7 </span>            : // met:
<span class="lineNum">       8 </span>            : //
<span class="lineNum">       9 </span>            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">      10 </span>            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      12 </span>            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      13 </span>            : // in the documentation and/or other materials provided with the
<span class="lineNum">      14 </span>            : // distribution.
<span class="lineNum">      15 </span>            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      16 </span>            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      17 </span>            : // this software without specific prior written permission.
<span class="lineNum">      18 </span>            : //
<span class="lineNum">      19 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      20 </span>            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      21 </span>            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      22 </span>            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      23 </span>            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      24 </span>            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      25 </span>            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      26 </span>            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      27 </span>            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      28 </span>            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      29 </span>            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // Author: kenton@google.com (Kenton Varda)
<span class="lineNum">      32 </span>            : //  Based on original Protocol Buffers design by
<span class="lineNum">      33 </span>            : //  Sanjay Ghemawat, Jeff Dean, and others.
<span class="lineNum">      34 </span>            : //
<span class="lineNum">      35 </span>            : // Defines Message, the abstract interface implemented by non-lite
<span class="lineNum">      36 </span>            : // protocol message objects.  Although it's possible to implement this
<span class="lineNum">      37 </span>            : // interface manually, most users will use the protocol compiler to
<span class="lineNum">      38 </span>            : // generate implementations.
<span class="lineNum">      39 </span>            : //
<span class="lineNum">      40 </span>            : // Example usage:
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : // Say you have a message defined as:
<span class="lineNum">      43 </span>            : //
<span class="lineNum">      44 </span>            : //   message Foo {
<span class="lineNum">      45 </span>            : //     optional string text = 1;
<span class="lineNum">      46 </span>            : //     repeated int32 numbers = 2;
<span class="lineNum">      47 </span>            : //   }
<span class="lineNum">      48 </span>            : //
<span class="lineNum">      49 </span>            : // Then, if you used the protocol compiler to generate a class from the above
<span class="lineNum">      50 </span>            : // definition, you could use it like so:
<span class="lineNum">      51 </span>            : //
<span class="lineNum">      52 </span>            : //   string data;  // Will store a serialized version of the message.
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : //   {
<span class="lineNum">      55 </span>            : //     // Create a message and serialize it.
<span class="lineNum">      56 </span>            : //     Foo foo;
<span class="lineNum">      57 </span>            : //     foo.set_text(&quot;Hello World!&quot;);
<span class="lineNum">      58 </span>            : //     foo.add_numbers(1);
<span class="lineNum">      59 </span>            : //     foo.add_numbers(5);
<span class="lineNum">      60 </span>            : //     foo.add_numbers(42);
<span class="lineNum">      61 </span>            : //
<span class="lineNum">      62 </span>            : //     foo.SerializeToString(&amp;data);
<span class="lineNum">      63 </span>            : //   }
<span class="lineNum">      64 </span>            : //
<span class="lineNum">      65 </span>            : //   {
<span class="lineNum">      66 </span>            : //     // Parse the serialized message and check that it contains the
<span class="lineNum">      67 </span>            : //     // correct data.
<span class="lineNum">      68 </span>            : //     Foo foo;
<span class="lineNum">      69 </span>            : //     foo.ParseFromString(data);
<span class="lineNum">      70 </span>            : //
<span class="lineNum">      71 </span>            : //     assert(foo.text() == &quot;Hello World!&quot;);
<span class="lineNum">      72 </span>            : //     assert(foo.numbers_size() == 3);
<span class="lineNum">      73 </span>            : //     assert(foo.numbers(0) == 1);
<span class="lineNum">      74 </span>            : //     assert(foo.numbers(1) == 5);
<span class="lineNum">      75 </span>            : //     assert(foo.numbers(2) == 42);
<span class="lineNum">      76 </span>            : //   }
<span class="lineNum">      77 </span>            : //
<span class="lineNum">      78 </span>            : //   {
<span class="lineNum">      79 </span>            : //     // Same as the last block, but do it dynamically via the Message
<span class="lineNum">      80 </span>            : //     // reflection interface.
<span class="lineNum">      81 </span>            : //     Message* foo = new Foo;
<span class="lineNum">      82 </span>            : //     const Descriptor* descriptor = foo-&gt;GetDescriptor();
<span class="lineNum">      83 </span>            : //
<span class="lineNum">      84 </span>            : //     // Get the descriptors for the fields we're interested in and verify
<span class="lineNum">      85 </span>            : //     // their types.
<span class="lineNum">      86 </span>            : //     const FieldDescriptor* text_field = descriptor-&gt;FindFieldByName(&quot;text&quot;);
<span class="lineNum">      87 </span>            : //     assert(text_field != NULL);
<span class="lineNum">      88 </span>            : //     assert(text_field-&gt;type() == FieldDescriptor::TYPE_STRING);
<span class="lineNum">      89 </span>            : //     assert(text_field-&gt;label() == FieldDescriptor::LABEL_OPTIONAL);
<span class="lineNum">      90 </span>            : //     const FieldDescriptor* numbers_field = descriptor-&gt;
<span class="lineNum">      91 </span>            : //                                            FindFieldByName(&quot;numbers&quot;);
<span class="lineNum">      92 </span>            : //     assert(numbers_field != NULL);
<span class="lineNum">      93 </span>            : //     assert(numbers_field-&gt;type() == FieldDescriptor::TYPE_INT32);
<span class="lineNum">      94 </span>            : //     assert(numbers_field-&gt;label() == FieldDescriptor::LABEL_REPEATED);
<span class="lineNum">      95 </span>            : //
<span class="lineNum">      96 </span>            : //     // Parse the message.
<span class="lineNum">      97 </span>            : //     foo-&gt;ParseFromString(data);
<span class="lineNum">      98 </span>            : //
<span class="lineNum">      99 </span>            : //     // Use the reflection interface to examine the contents.
<span class="lineNum">     100 </span>            : //     const Reflection* reflection = foo-&gt;GetReflection();
<span class="lineNum">     101 </span>            : //     assert(reflection-&gt;GetString(foo, text_field) == &quot;Hello World!&quot;);
<span class="lineNum">     102 </span>            : //     assert(reflection-&gt;FieldSize(foo, numbers_field) == 3);
<span class="lineNum">     103 </span>            : //     assert(reflection-&gt;GetRepeatedInt32(foo, numbers_field, 0) == 1);
<span class="lineNum">     104 </span>            : //     assert(reflection-&gt;GetRepeatedInt32(foo, numbers_field, 1) == 5);
<span class="lineNum">     105 </span>            : //     assert(reflection-&gt;GetRepeatedInt32(foo, numbers_field, 2) == 42);
<span class="lineNum">     106 </span>            : //
<span class="lineNum">     107 </span>            : //     delete foo;
<span class="lineNum">     108 </span>            : //   }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : #ifndef GOOGLE_PROTOBUF_MESSAGE_H__
<span class="lineNum">     111 </span>            : #define GOOGLE_PROTOBUF_MESSAGE_H__
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : #include &lt;iosfwd&gt;
<span class="lineNum">     114 </span>            : #include &lt;string&gt;
<span class="lineNum">     115 </span>            : #include &lt;vector&gt;
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : #include &lt;google/protobuf/message_lite.h&gt;
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #include &lt;google/protobuf/stubs/common.h&gt;
<span class="lineNum">     120 </span>            : #include &lt;google/protobuf/descriptor.h&gt;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #define GOOGLE_PROTOBUF_HAS_ONEOF
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : namespace google {
<span class="lineNum">     126 </span>            : namespace protobuf {
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : // Defined in this file.
<span class="lineNum">     129 </span>            : class Message;
<span class="lineNum">     130 </span>            : class Reflection;
<span class="lineNum">     131 </span>            : class MessageFactory;
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : // Defined in other files.
<span class="lineNum">     134 </span>            : class UnknownFieldSet;         // unknown_field_set.h
<span class="lineNum">     135 </span>            : namespace io {
<span class="lineNum">     136 </span>            :   class ZeroCopyInputStream;   // zero_copy_stream.h
<span class="lineNum">     137 </span>            :   class ZeroCopyOutputStream;  // zero_copy_stream.h
<span class="lineNum">     138 </span>            :   class CodedInputStream;      // coded_stream.h
<span class="lineNum">     139 </span>            :   class CodedOutputStream;     // coded_stream.h
<span class="lineNum">     140 </span>            : }
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : template&lt;typename T&gt;
<span class="lineNum">     144 </span>            : class RepeatedField;     // repeated_field.h
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : template&lt;typename T&gt;
<span class="lineNum">     147 </span>            : class RepeatedPtrField;  // repeated_field.h
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : // A container to hold message metadata.
<span class="lineNum">     150 </span>            : struct Metadata {
<span class="lineNum">     151 </span>            :   const Descriptor* descriptor;
<span class="lineNum">     152 </span>            :   const Reflection* reflection;
<span class="lineNum">     153 </span>            : };
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : // Abstract interface for protocol messages.
<span class="lineNum">     156 </span>            : //
<span class="lineNum">     157 </span>            : // See also MessageLite, which contains most every-day operations.  Message
<span class="lineNum">     158 </span>            : // adds descriptors and reflection on top of that.
<span class="lineNum">     159 </span>            : //
<span class="lineNum">     160 </span>            : // The methods of this class that are virtual but not pure-virtual have
<span class="lineNum">     161 </span>            : // default implementations based on reflection.  Message classes which are
<span class="lineNum">     162 </span>            : // optimized for speed will want to override these with faster implementations,
<span class="lineNum">     163 </span>            : // but classes optimized for code size may be happy with keeping them.  See
<span class="lineNum">     164 </span>            : // the optimize_for option in descriptor.proto.
<a name="165"><span class="lineNum">     165 </span>            : class LIBPROTOBUF_EXPORT Message : public MessageLite {</a>
<span class="lineNum">     166 </span>            :  public:
<span class="lineNum">     167 </span><span class="lineCov">        660 :   inline Message() {}</span>
<span class="lineNum">     168 </span>            :   virtual ~Message();
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   // Basic Operations ------------------------------------------------
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :   // Construct a new instance of the same type.  Ownership is passed to the
<span class="lineNum">     173 </span>            :   // caller.  (This is also defined in MessageLite, but is defined again here
<span class="lineNum">     174 </span>            :   // for return-type covariance.)
<span class="lineNum">     175 </span>            :   virtual Message* New() const = 0;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   // Make this message into a copy of the given message.  The given message
<span class="lineNum">     178 </span>            :   // must have the same descriptor, but need not necessarily be the same class.
<span class="lineNum">     179 </span>            :   // By default this is just implemented as &quot;Clear(); MergeFrom(from);&quot;.
<span class="lineNum">     180 </span>            :   virtual void CopyFrom(const Message&amp; from);
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   // Merge the fields from the given message into this message.  Singular
<span class="lineNum">     183 </span>            :   // fields will be overwritten, if specified in from, except for embedded
<span class="lineNum">     184 </span>            :   // messages which will be merged.  Repeated fields will be concatenated.
<span class="lineNum">     185 </span>            :   // The given message must be of the same type as this message (i.e. the
<span class="lineNum">     186 </span>            :   // exact same class).
<span class="lineNum">     187 </span>            :   virtual void MergeFrom(const Message&amp; from);
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   // Verifies that IsInitialized() returns true.  GOOGLE_CHECK-fails otherwise, with
<span class="lineNum">     190 </span>            :   // a nice error message.
<span class="lineNum">     191 </span>            :   void CheckInitialized() const;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   // Slowly build a list of all required fields that are not set.
<span class="lineNum">     194 </span>            :   // This is much, much slower than IsInitialized() as it is implemented
<span class="lineNum">     195 </span>            :   // purely via reflection.  Generally, you should not call this unless you
<span class="lineNum">     196 </span>            :   // have already determined that an error exists by calling IsInitialized().
<span class="lineNum">     197 </span>            :   void FindInitializationErrors(vector&lt;string&gt;* errors) const;
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   // Like FindInitializationErrors, but joins all the strings, delimited by
<span class="lineNum">     200 </span>            :   // commas, and returns them.
<span class="lineNum">     201 </span>            :   string InitializationErrorString() const;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   // Clears all unknown fields from this message and all embedded messages.
<span class="lineNum">     204 </span>            :   // Normally, if unknown tag numbers are encountered when parsing a message,
<span class="lineNum">     205 </span>            :   // the tag and value are stored in the message's UnknownFieldSet and
<span class="lineNum">     206 </span>            :   // then written back out when the message is serialized.  This allows servers
<span class="lineNum">     207 </span>            :   // which simply route messages to other servers to pass through messages
<span class="lineNum">     208 </span>            :   // that have new field definitions which they don't yet know about.  However,
<span class="lineNum">     209 </span>            :   // this behavior can have security implications.  To avoid it, call this
<span class="lineNum">     210 </span>            :   // method after parsing.
<span class="lineNum">     211 </span>            :   //
<span class="lineNum">     212 </span>            :   // See Reflection::GetUnknownFields() for more on unknown fields.
<span class="lineNum">     213 </span>            :   virtual void DiscardUnknownFields();
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   // Computes (an estimate of) the total number of bytes currently used for
<span class="lineNum">     216 </span>            :   // storing the message in memory.  The default implementation calls the
<span class="lineNum">     217 </span>            :   // Reflection object's SpaceUsed() method.
<span class="lineNum">     218 </span>            :   virtual int SpaceUsed() const;
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :   // Debugging &amp; Testing----------------------------------------------
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // Generates a human readable form of this message, useful for debugging
<span class="lineNum">     223 </span>            :   // and other purposes.
<span class="lineNum">     224 </span>            :   string DebugString() const;
<span class="lineNum">     225 </span>            :   // Like DebugString(), but with less whitespace.
<span class="lineNum">     226 </span>            :   string ShortDebugString() const;
<span class="lineNum">     227 </span>            :   // Like DebugString(), but do not escape UTF-8 byte sequences.
<span class="lineNum">     228 </span>            :   string Utf8DebugString() const;
<span class="lineNum">     229 </span>            :   // Convenience function useful in GDB.  Prints DebugString() to stdout.
<span class="lineNum">     230 </span>            :   void PrintDebugString() const;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   // Heavy I/O -------------------------------------------------------
<span class="lineNum">     233 </span>            :   // Additional parsing and serialization methods not implemented by
<span class="lineNum">     234 </span>            :   // MessageLite because they are not supported by the lite library.
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   // Parse a protocol buffer from a file descriptor.  If successful, the entire
<span class="lineNum">     237 </span>            :   // input will be consumed.
<span class="lineNum">     238 </span>            :   bool ParseFromFileDescriptor(int file_descriptor);
<span class="lineNum">     239 </span>            :   // Like ParseFromFileDescriptor(), but accepts messages that are missing
<span class="lineNum">     240 </span>            :   // required fields.
<span class="lineNum">     241 </span>            :   bool ParsePartialFromFileDescriptor(int file_descriptor);
<span class="lineNum">     242 </span>            :   // Parse a protocol buffer from a C++ istream.  If successful, the entire
<span class="lineNum">     243 </span>            :   // input will be consumed.
<span class="lineNum">     244 </span>            :   bool ParseFromIstream(istream* input);
<span class="lineNum">     245 </span>            :   // Like ParseFromIstream(), but accepts messages that are missing
<span class="lineNum">     246 </span>            :   // required fields.
<span class="lineNum">     247 </span>            :   bool ParsePartialFromIstream(istream* input);
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   // Serialize the message and write it to the given file descriptor.  All
<span class="lineNum">     250 </span>            :   // required fields must be set.
<span class="lineNum">     251 </span>            :   bool SerializeToFileDescriptor(int file_descriptor) const;
<span class="lineNum">     252 </span>            :   // Like SerializeToFileDescriptor(), but allows missing required fields.
<span class="lineNum">     253 </span>            :   bool SerializePartialToFileDescriptor(int file_descriptor) const;
<span class="lineNum">     254 </span>            :   // Serialize the message and write it to the given C++ ostream.  All
<span class="lineNum">     255 </span>            :   // required fields must be set.
<span class="lineNum">     256 </span>            :   bool SerializeToOstream(ostream* output) const;
<span class="lineNum">     257 </span>            :   // Like SerializeToOstream(), but allows missing required fields.
<span class="lineNum">     258 </span>            :   bool SerializePartialToOstream(ostream* output) const;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // Reflection-based methods ----------------------------------------
<span class="lineNum">     262 </span>            :   // These methods are pure-virtual in MessageLite, but Message provides
<span class="lineNum">     263 </span>            :   // reflection-based default implementations.
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :   virtual string GetTypeName() const;
<span class="lineNum">     266 </span>            :   virtual void Clear();
<span class="lineNum">     267 </span>            :   virtual bool IsInitialized() const;
<span class="lineNum">     268 </span>            :   virtual void CheckTypeAndMergeFrom(const MessageLite&amp; other);
<span class="lineNum">     269 </span>            :   virtual bool MergePartialFromCodedStream(io::CodedInputStream* input);
<span class="lineNum">     270 </span>            :   virtual int ByteSize() const;
<span class="lineNum">     271 </span>            :   virtual void SerializeWithCachedSizes(io::CodedOutputStream* output) const;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :  private:
<span class="lineNum">     274 </span>            :   // This is called only by the default implementation of ByteSize(), to
<span class="lineNum">     275 </span>            :   // update the cached size.  If you override ByteSize(), you do not need
<span class="lineNum">     276 </span>            :   // to override this.  If you do not override ByteSize(), you MUST override
<span class="lineNum">     277 </span>            :   // this; the default implementation will crash.
<span class="lineNum">     278 </span>            :   //
<span class="lineNum">     279 </span>            :   // The method is private because subclasses should never call it; only
<span class="lineNum">     280 </span>            :   // override it.  Yes, C++ lets you do that.  Crazy, huh?
<span class="lineNum">     281 </span>            :   virtual void SetCachedSize(int size) const;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :  public:
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   // Introspection ---------------------------------------------------
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // Typedef for backwards-compatibility.
<span class="lineNum">     288 </span>            :   typedef google::protobuf::Reflection Reflection;
<span class="lineNum">     289 </span>            : 
<a name="290"><span class="lineNum">     290 </span>            :   // Get a Descriptor for this message's type.  This describes what</a>
<span class="lineNum">     291 </span>            :   // fields the message contains, the types of those fields, etc.
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   const Descriptor* GetDescriptor() const { return GetMetadata().descriptor; }</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   // Get the Reflection interface for this Message, which can be used to
<span class="lineNum">     295 </span>            :   // read and modify the fields of the Message dynamically (in other words,
<span class="lineNum">     296 </span>            :   // without knowing the message type at compile time).  This object remains
<span class="lineNum">     297 </span>            :   // property of the Message.
<span class="lineNum">     298 </span>            :   //
<a name="299"><span class="lineNum">     299 </span>            :   // This method remains virtual in case a subclass does not implement</a>
<span class="lineNum">     300 </span>            :   // reflection and wants to override the default behavior.
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   virtual const Reflection* GetReflection() const {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     return GetMetadata().reflection;</span>
<span class="lineNum">     303 </span>            :   }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :  protected:
<span class="lineNum">     306 </span>            :   // Get a struct containing the metadata for the Message. Most subclasses only
<span class="lineNum">     307 </span>            :   // need to implement this method, rather than the GetDescriptor() and
<span class="lineNum">     308 </span>            :   // GetReflection() wrappers.
<span class="lineNum">     309 </span>            :   virtual Metadata GetMetadata() const  = 0;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :  private:
<span class="lineNum">     313 </span>            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Message);
<span class="lineNum">     314 </span>            : };
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : // This interface contains methods that can be used to dynamically access
<span class="lineNum">     317 </span>            : // and modify the fields of a protocol message.  Their semantics are
<span class="lineNum">     318 </span>            : // similar to the accessors the protocol compiler generates.
<span class="lineNum">     319 </span>            : //
<span class="lineNum">     320 </span>            : // To get the Reflection for a given Message, call Message::GetReflection().
<span class="lineNum">     321 </span>            : //
<span class="lineNum">     322 </span>            : // This interface is separate from Message only for efficiency reasons;
<span class="lineNum">     323 </span>            : // the vast majority of implementations of Message will share the same
<span class="lineNum">     324 </span>            : // implementation of Reflection (GeneratedMessageReflection,
<span class="lineNum">     325 </span>            : // defined in generated_message.h), and all Messages of a particular class
<span class="lineNum">     326 </span>            : // should share the same Reflection object (though you should not rely on
<span class="lineNum">     327 </span>            : // the latter fact).
<span class="lineNum">     328 </span>            : //
<span class="lineNum">     329 </span>            : // There are several ways that these methods can be used incorrectly.  For
<span class="lineNum">     330 </span>            : // example, any of the following conditions will lead to undefined
<span class="lineNum">     331 </span>            : // results (probably assertion failures):
<span class="lineNum">     332 </span>            : // - The FieldDescriptor is not a field of this message type.
<span class="lineNum">     333 </span>            : // - The method called is not appropriate for the field's type.  For
<span class="lineNum">     334 </span>            : //   each field type in FieldDescriptor::TYPE_*, there is only one
<span class="lineNum">     335 </span>            : //   Get*() method, one Set*() method, and one Add*() method that is
<span class="lineNum">     336 </span>            : //   valid for that type.  It should be obvious which (except maybe
<span class="lineNum">     337 </span>            : //   for TYPE_BYTES, which are represented using strings in C++).
<span class="lineNum">     338 </span>            : // - A Get*() or Set*() method for singular fields is called on a repeated
<span class="lineNum">     339 </span>            : //   field.
<span class="lineNum">     340 </span>            : // - GetRepeated*(), SetRepeated*(), or Add*() is called on a non-repeated
<span class="lineNum">     341 </span>            : //   field.
<span class="lineNum">     342 </span>            : // - The Message object passed to any method is not of the right type for
<span class="lineNum">     343 </span>            : //   this Reflection object (i.e. message.GetReflection() != reflection).
<span class="lineNum">     344 </span>            : //
<span class="lineNum">     345 </span>            : // You might wonder why there is not any abstract representation for a field
<span class="lineNum">     346 </span>            : // of arbitrary type.  E.g., why isn't there just a &quot;GetField()&quot; method that
<span class="lineNum">     347 </span>            : // returns &quot;const Field&amp;&quot;, where &quot;Field&quot; is some class with accessors like
<span class="lineNum">     348 </span>            : // &quot;GetInt32Value()&quot;.  The problem is that someone would have to deal with
<span class="lineNum">     349 </span>            : // allocating these Field objects.  For generated message classes, having to
<span class="lineNum">     350 </span>            : // allocate space for an additional object to wrap every field would at least
<span class="lineNum">     351 </span>            : // double the message's memory footprint, probably worse.  Allocating the
<span class="lineNum">     352 </span>            : // objects on-demand, on the other hand, would be expensive and prone to
<span class="lineNum">     353 </span>            : // memory leaks.  So, instead we ended up with this flat interface.
<span class="lineNum">     354 </span>            : //
<span class="lineNum">     355 </span>            : // TODO(kenton):  Create a utility class which callers can use to read and
<span class="lineNum">     356 </span>            : //   write fields from a Reflection without paying attention to the type.
<a name="357"><span class="lineNum">     357 </span>            : class LIBPROTOBUF_EXPORT Reflection {</a>
<span class="lineNum">     358 </span>            :  public:
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   inline Reflection() {}</span>
<span class="lineNum">     360 </span>            :   virtual ~Reflection();
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :   // Get the UnknownFieldSet for the message.  This contains fields which
<span class="lineNum">     363 </span>            :   // were seen when the Message was parsed but were not recognized according
<span class="lineNum">     364 </span>            :   // to the Message's definition.
<span class="lineNum">     365 </span>            :   virtual const UnknownFieldSet&amp; GetUnknownFields(
<span class="lineNum">     366 </span>            :       const Message&amp; message) const = 0;
<span class="lineNum">     367 </span>            :   // Get a mutable pointer to the UnknownFieldSet for the message.  This
<span class="lineNum">     368 </span>            :   // contains fields which were seen when the Message was parsed but were not
<span class="lineNum">     369 </span>            :   // recognized according to the Message's definition.
<span class="lineNum">     370 </span>            :   virtual UnknownFieldSet* MutableUnknownFields(Message* message) const = 0;
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :   // Estimate the amount of memory used by the message object.
<span class="lineNum">     373 </span>            :   virtual int SpaceUsed(const Message&amp; message) const = 0;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :   // Check if the given non-repeated field is set.
<span class="lineNum">     376 </span>            :   virtual bool HasField(const Message&amp; message,
<span class="lineNum">     377 </span>            :                         const FieldDescriptor* field) const = 0;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   // Get the number of elements of a repeated field.
<span class="lineNum">     380 </span>            :   virtual int FieldSize(const Message&amp; message,
<span class="lineNum">     381 </span>            :                         const FieldDescriptor* field) const = 0;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   // Clear the value of a field, so that HasField() returns false or
<span class="lineNum">     384 </span>            :   // FieldSize() returns zero.
<span class="lineNum">     385 </span>            :   virtual void ClearField(Message* message,
<span class="lineNum">     386 </span>            :                           const FieldDescriptor* field) const = 0;
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   // Check if the oneof is set. Returns ture if any field in oneof
<span class="lineNum">     389 </span>            :   // is set, false otherwise.
<a name="390"><span class="lineNum">     390 </span>            :   // TODO(jieluo) - make it pure virtual after updating all</a>
<span class="lineNum">     391 </span>            :   // the subclasses.
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   virtual bool HasOneof(const Message&amp; message,</span>
<span class="lineNum">     393 </span>            :                         const OneofDescriptor* oneof_descriptor) const {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="395"><span class="lineNum">     395 </span>            :   }</a>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   virtual void ClearOneof(Message* message,</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                           const OneofDescriptor* oneof_descriptor) const {}</span>
<span class="lineNum">     399 </span>            : 
<a name="400"><span class="lineNum">     400 </span>            :   // Returns the field descriptor if the oneof is set. NULL otherwise.</a>
<span class="lineNum">     401 </span>            :   // TODO(jieluo) - make it pure virtual.
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   virtual const FieldDescriptor* GetOneofFieldDescriptor(</span>
<span class="lineNum">     403 </span>            :       const Message&amp; message,
<span class="lineNum">     404 </span>            :       const OneofDescriptor* oneof_descriptor) const {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     406 </span>            :   }
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   // Removes the last element of a repeated field.
<span class="lineNum">     409 </span>            :   // We don't provide a way to remove any element other than the last
<span class="lineNum">     410 </span>            :   // because it invites inefficient use, such as O(n^2) filtering loops
<span class="lineNum">     411 </span>            :   // that should have been O(n).  If you want to remove an element other
<span class="lineNum">     412 </span>            :   // than the last, the best way to do it is to re-arrange the elements
<span class="lineNum">     413 </span>            :   // (using Swap()) so that the one you want removed is at the end, then
<span class="lineNum">     414 </span>            :   // call RemoveLast().
<span class="lineNum">     415 </span>            :   virtual void RemoveLast(Message* message,
<span class="lineNum">     416 </span>            :                           const FieldDescriptor* field) const = 0;
<span class="lineNum">     417 </span>            :   // Removes the last element of a repeated message field, and returns the
<span class="lineNum">     418 </span>            :   // pointer to the caller.  Caller takes ownership of the returned pointer.
<span class="lineNum">     419 </span>            :   virtual Message* ReleaseLast(Message* message,
<span class="lineNum">     420 </span>            :                                const FieldDescriptor* field) const = 0;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   // Swap the complete contents of two messages.
<span class="lineNum">     423 </span>            :   virtual void Swap(Message* message1, Message* message2) const = 0;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   // Swap fields listed in fields vector of two messages.
<span class="lineNum">     426 </span>            :   virtual void SwapFields(Message* message1,
<span class="lineNum">     427 </span>            :                           Message* message2,
<span class="lineNum">     428 </span>            :                           const vector&lt;const FieldDescriptor*&gt;&amp; fields)
<span class="lineNum">     429 </span>            :       const = 0;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   // Swap two elements of a repeated field.
<span class="lineNum">     432 </span>            :   virtual void SwapElements(Message* message,
<span class="lineNum">     433 </span>            :                             const FieldDescriptor* field,
<span class="lineNum">     434 </span>            :                             int index1,
<span class="lineNum">     435 </span>            :                             int index2) const = 0;
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   // List all fields of the message which are currently set.  This includes
<span class="lineNum">     438 </span>            :   // extensions.  Singular fields will only be listed if HasField(field) would
<span class="lineNum">     439 </span>            :   // return true and repeated fields will only be listed if FieldSize(field)
<span class="lineNum">     440 </span>            :   // would return non-zero.  Fields (both normal fields and extension fields)
<span class="lineNum">     441 </span>            :   // will be listed ordered by field number.
<span class="lineNum">     442 </span>            :   virtual void ListFields(const Message&amp; message,
<span class="lineNum">     443 </span>            :                           vector&lt;const FieldDescriptor*&gt;* output) const = 0;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // Singular field getters ------------------------------------------
<span class="lineNum">     446 </span>            :   // These get the value of a non-repeated field.  They return the default
<span class="lineNum">     447 </span>            :   // value for fields that aren't set.
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   virtual int32  GetInt32 (const Message&amp; message,
<span class="lineNum">     450 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     451 </span>            :   virtual int64  GetInt64 (const Message&amp; message,
<span class="lineNum">     452 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     453 </span>            :   virtual uint32 GetUInt32(const Message&amp; message,
<span class="lineNum">     454 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     455 </span>            :   virtual uint64 GetUInt64(const Message&amp; message,
<span class="lineNum">     456 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     457 </span>            :   virtual float  GetFloat (const Message&amp; message,
<span class="lineNum">     458 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     459 </span>            :   virtual double GetDouble(const Message&amp; message,
<span class="lineNum">     460 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     461 </span>            :   virtual bool   GetBool  (const Message&amp; message,
<span class="lineNum">     462 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     463 </span>            :   virtual string GetString(const Message&amp; message,
<span class="lineNum">     464 </span>            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     465 </span>            :   virtual const EnumValueDescriptor* GetEnum(
<span class="lineNum">     466 </span>            :       const Message&amp; message, const FieldDescriptor* field) const = 0;
<span class="lineNum">     467 </span>            :   // See MutableMessage() for the meaning of the &quot;factory&quot; parameter.
<span class="lineNum">     468 </span>            :   virtual const Message&amp; GetMessage(const Message&amp; message,
<span class="lineNum">     469 </span>            :                                     const FieldDescriptor* field,
<span class="lineNum">     470 </span>            :                                     MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   // Get a string value without copying, if possible.
<span class="lineNum">     473 </span>            :   //
<span class="lineNum">     474 </span>            :   // GetString() necessarily returns a copy of the string.  This can be
<span class="lineNum">     475 </span>            :   // inefficient when the string is already stored in a string object in the
<span class="lineNum">     476 </span>            :   // underlying message.  GetStringReference() will return a reference to the
<span class="lineNum">     477 </span>            :   // underlying string in this case.  Otherwise, it will copy the string into
<span class="lineNum">     478 </span>            :   // *scratch and return that.
<span class="lineNum">     479 </span>            :   //
<span class="lineNum">     480 </span>            :   // Note:  It is perfectly reasonable and useful to write code like:
<span class="lineNum">     481 </span>            :   //     str = reflection-&gt;GetStringReference(field, &amp;str);
<span class="lineNum">     482 </span>            :   //   This line would ensure that only one copy of the string is made
<span class="lineNum">     483 </span>            :   //   regardless of the field's underlying representation.  When initializing
<span class="lineNum">     484 </span>            :   //   a newly-constructed string, though, it's just as fast and more readable
<span class="lineNum">     485 </span>            :   //   to use code like:
<span class="lineNum">     486 </span>            :   //     string str = reflection-&gt;GetString(field);
<span class="lineNum">     487 </span>            :   virtual const string&amp; GetStringReference(const Message&amp; message,
<span class="lineNum">     488 </span>            :                                            const FieldDescriptor* field,
<span class="lineNum">     489 </span>            :                                            string* scratch) const = 0;
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // Singular field mutators -----------------------------------------
<span class="lineNum">     493 </span>            :   // These mutate the value of a non-repeated field.
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   virtual void SetInt32 (Message* message,
<span class="lineNum">     496 </span>            :                          const FieldDescriptor* field, int32  value) const = 0;
<span class="lineNum">     497 </span>            :   virtual void SetInt64 (Message* message,
<span class="lineNum">     498 </span>            :                          const FieldDescriptor* field, int64  value) const = 0;
<span class="lineNum">     499 </span>            :   virtual void SetUInt32(Message* message,
<span class="lineNum">     500 </span>            :                          const FieldDescriptor* field, uint32 value) const = 0;
<span class="lineNum">     501 </span>            :   virtual void SetUInt64(Message* message,
<span class="lineNum">     502 </span>            :                          const FieldDescriptor* field, uint64 value) const = 0;
<span class="lineNum">     503 </span>            :   virtual void SetFloat (Message* message,
<span class="lineNum">     504 </span>            :                          const FieldDescriptor* field, float  value) const = 0;
<span class="lineNum">     505 </span>            :   virtual void SetDouble(Message* message,
<span class="lineNum">     506 </span>            :                          const FieldDescriptor* field, double value) const = 0;
<span class="lineNum">     507 </span>            :   virtual void SetBool  (Message* message,
<span class="lineNum">     508 </span>            :                          const FieldDescriptor* field, bool   value) const = 0;
<span class="lineNum">     509 </span>            :   virtual void SetString(Message* message,
<span class="lineNum">     510 </span>            :                          const FieldDescriptor* field,
<span class="lineNum">     511 </span>            :                          const string&amp; value) const = 0;
<span class="lineNum">     512 </span>            :   virtual void SetEnum  (Message* message,
<span class="lineNum">     513 </span>            :                          const FieldDescriptor* field,
<span class="lineNum">     514 </span>            :                          const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     515 </span>            :   // Get a mutable pointer to a field with a message type.  If a MessageFactory
<span class="lineNum">     516 </span>            :   // is provided, it will be used to construct instances of the sub-message;
<span class="lineNum">     517 </span>            :   // otherwise, the default factory is used.  If the field is an extension that
<span class="lineNum">     518 </span>            :   // does not live in the same pool as the containing message's descriptor (e.g.
<span class="lineNum">     519 </span>            :   // it lives in an overlay pool), then a MessageFactory must be provided.
<span class="lineNum">     520 </span>            :   // If you have no idea what that meant, then you probably don't need to worry
<span class="lineNum">     521 </span>            :   // about it (don't provide a MessageFactory).  WARNING:  If the
<span class="lineNum">     522 </span>            :   // FieldDescriptor is for a compiled-in extension, then
<span class="lineNum">     523 </span>            :   // factory-&gt;GetPrototype(field-&gt;message_type() MUST return an instance of the
<span class="lineNum">     524 </span>            :   // compiled-in class for this type, NOT DynamicMessage.
<span class="lineNum">     525 </span>            :   virtual Message* MutableMessage(Message* message,
<span class="lineNum">     526 </span>            :                                   const FieldDescriptor* field,
<span class="lineNum">     527 </span>            :                                   MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     528 </span>            :   // Replaces the message specified by 'field' with the already-allocated object
<span class="lineNum">     529 </span>            :   // sub_message, passing ownership to the message.  If the field contained a
<span class="lineNum">     530 </span>            :   // message, that message is deleted.  If sub_message is NULL, the field is
<span class="lineNum">     531 </span>            :   // cleared.
<span class="lineNum">     532 </span>            :   virtual void SetAllocatedMessage(Message* message,
<span class="lineNum">     533 </span>            :                                    Message* sub_message,
<span class="lineNum">     534 </span>            :                                    const FieldDescriptor* field) const = 0;
<span class="lineNum">     535 </span>            :   // Releases the message specified by 'field' and returns the pointer,
<span class="lineNum">     536 </span>            :   // ReleaseMessage() will return the message the message object if it exists.
<span class="lineNum">     537 </span>            :   // Otherwise, it may or may not return NULL.  In any case, if the return value
<span class="lineNum">     538 </span>            :   // is non-NULL, the caller takes ownership of the pointer.
<span class="lineNum">     539 </span>            :   // If the field existed (HasField() is true), then the returned pointer will
<span class="lineNum">     540 </span>            :   // be the same as the pointer returned by MutableMessage().
<span class="lineNum">     541 </span>            :   // This function has the same effect as ClearField().
<span class="lineNum">     542 </span>            :   virtual Message* ReleaseMessage(Message* message,
<span class="lineNum">     543 </span>            :                                   const FieldDescriptor* field,
<span class="lineNum">     544 </span>            :                                   MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   // Repeated field getters ------------------------------------------
<span class="lineNum">     548 </span>            :   // These get the value of one element of a repeated field.
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   virtual int32  GetRepeatedInt32 (const Message&amp; message,
<span class="lineNum">     551 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     552 </span>            :                                    int index) const = 0;
<span class="lineNum">     553 </span>            :   virtual int64  GetRepeatedInt64 (const Message&amp; message,
<span class="lineNum">     554 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     555 </span>            :                                    int index) const = 0;
<span class="lineNum">     556 </span>            :   virtual uint32 GetRepeatedUInt32(const Message&amp; message,
<span class="lineNum">     557 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     558 </span>            :                                    int index) const = 0;
<span class="lineNum">     559 </span>            :   virtual uint64 GetRepeatedUInt64(const Message&amp; message,
<span class="lineNum">     560 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     561 </span>            :                                    int index) const = 0;
<span class="lineNum">     562 </span>            :   virtual float  GetRepeatedFloat (const Message&amp; message,
<span class="lineNum">     563 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     564 </span>            :                                    int index) const = 0;
<span class="lineNum">     565 </span>            :   virtual double GetRepeatedDouble(const Message&amp; message,
<span class="lineNum">     566 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     567 </span>            :                                    int index) const = 0;
<span class="lineNum">     568 </span>            :   virtual bool   GetRepeatedBool  (const Message&amp; message,
<span class="lineNum">     569 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     570 </span>            :                                    int index) const = 0;
<span class="lineNum">     571 </span>            :   virtual string GetRepeatedString(const Message&amp; message,
<span class="lineNum">     572 </span>            :                                    const FieldDescriptor* field,
<span class="lineNum">     573 </span>            :                                    int index) const = 0;
<span class="lineNum">     574 </span>            :   virtual const EnumValueDescriptor* GetRepeatedEnum(
<span class="lineNum">     575 </span>            :       const Message&amp; message,
<span class="lineNum">     576 </span>            :       const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     577 </span>            :   virtual const Message&amp; GetRepeatedMessage(
<span class="lineNum">     578 </span>            :       const Message&amp; message,
<span class="lineNum">     579 </span>            :       const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            :   // See GetStringReference(), above.
<span class="lineNum">     582 </span>            :   virtual const string&amp; GetRepeatedStringReference(
<span class="lineNum">     583 </span>            :       const Message&amp; message, const FieldDescriptor* field,
<span class="lineNum">     584 </span>            :       int index, string* scratch) const = 0;
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   // Repeated field mutators -----------------------------------------
<span class="lineNum">     588 </span>            :   // These mutate the value of one element of a repeated field.
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   virtual void SetRepeatedInt32 (Message* message,
<span class="lineNum">     591 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     592 </span>            :                                  int index, int32  value) const = 0;
<span class="lineNum">     593 </span>            :   virtual void SetRepeatedInt64 (Message* message,
<span class="lineNum">     594 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     595 </span>            :                                  int index, int64  value) const = 0;
<span class="lineNum">     596 </span>            :   virtual void SetRepeatedUInt32(Message* message,
<span class="lineNum">     597 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     598 </span>            :                                  int index, uint32 value) const = 0;
<span class="lineNum">     599 </span>            :   virtual void SetRepeatedUInt64(Message* message,
<span class="lineNum">     600 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     601 </span>            :                                  int index, uint64 value) const = 0;
<span class="lineNum">     602 </span>            :   virtual void SetRepeatedFloat (Message* message,
<span class="lineNum">     603 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     604 </span>            :                                  int index, float  value) const = 0;
<span class="lineNum">     605 </span>            :   virtual void SetRepeatedDouble(Message* message,
<span class="lineNum">     606 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     607 </span>            :                                  int index, double value) const = 0;
<span class="lineNum">     608 </span>            :   virtual void SetRepeatedBool  (Message* message,
<span class="lineNum">     609 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     610 </span>            :                                  int index, bool   value) const = 0;
<span class="lineNum">     611 </span>            :   virtual void SetRepeatedString(Message* message,
<span class="lineNum">     612 </span>            :                                  const FieldDescriptor* field,
<span class="lineNum">     613 </span>            :                                  int index, const string&amp; value) const = 0;
<span class="lineNum">     614 </span>            :   virtual void SetRepeatedEnum(Message* message,
<span class="lineNum">     615 </span>            :                                const FieldDescriptor* field, int index,
<span class="lineNum">     616 </span>            :                                const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     617 </span>            :   // Get a mutable pointer to an element of a repeated field with a message
<span class="lineNum">     618 </span>            :   // type.
<span class="lineNum">     619 </span>            :   virtual Message* MutableRepeatedMessage(
<span class="lineNum">     620 </span>            :       Message* message, const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   // Repeated field adders -------------------------------------------
<span class="lineNum">     624 </span>            :   // These add an element to a repeated field.
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :   virtual void AddInt32 (Message* message,
<span class="lineNum">     627 </span>            :                          const FieldDescriptor* field, int32  value) const = 0;
<span class="lineNum">     628 </span>            :   virtual void AddInt64 (Message* message,
<span class="lineNum">     629 </span>            :                          const FieldDescriptor* field, int64  value) const = 0;
<span class="lineNum">     630 </span>            :   virtual void AddUInt32(Message* message,
<span class="lineNum">     631 </span>            :                          const FieldDescriptor* field, uint32 value) const = 0;
<span class="lineNum">     632 </span>            :   virtual void AddUInt64(Message* message,
<span class="lineNum">     633 </span>            :                          const FieldDescriptor* field, uint64 value) const = 0;
<span class="lineNum">     634 </span>            :   virtual void AddFloat (Message* message,
<span class="lineNum">     635 </span>            :                          const FieldDescriptor* field, float  value) const = 0;
<span class="lineNum">     636 </span>            :   virtual void AddDouble(Message* message,
<span class="lineNum">     637 </span>            :                          const FieldDescriptor* field, double value) const = 0;
<span class="lineNum">     638 </span>            :   virtual void AddBool  (Message* message,
<span class="lineNum">     639 </span>            :                          const FieldDescriptor* field, bool   value) const = 0;
<span class="lineNum">     640 </span>            :   virtual void AddString(Message* message,
<span class="lineNum">     641 </span>            :                          const FieldDescriptor* field,
<span class="lineNum">     642 </span>            :                          const string&amp; value) const = 0;
<span class="lineNum">     643 </span>            :   virtual void AddEnum  (Message* message,
<span class="lineNum">     644 </span>            :                          const FieldDescriptor* field,
<span class="lineNum">     645 </span>            :                          const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     646 </span>            :   // See MutableMessage() for comments on the &quot;factory&quot; parameter.
<span class="lineNum">     647 </span>            :   virtual Message* AddMessage(Message* message,
<span class="lineNum">     648 </span>            :                               const FieldDescriptor* field,
<span class="lineNum">     649 </span>            :                               MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   // Repeated field accessors  -------------------------------------------------
<span class="lineNum">     653 </span>            :   // The methods above, e.g. GetRepeatedInt32(msg, fd, index), provide singular
<span class="lineNum">     654 </span>            :   // access to the data in a RepeatedField.  The methods below provide aggregate
<span class="lineNum">     655 </span>            :   // access by exposing the RepeatedField object itself with the Message.
<span class="lineNum">     656 </span>            :   // Applying these templates to inappropriate types will lead to an undefined
<span class="lineNum">     657 </span>            :   // reference at link time (e.g. GetRepeatedField&lt;***double&gt;), or possibly a
<span class="lineNum">     658 </span>            :   // template matching error at compile time (e.g. GetRepeatedPtrField&lt;File&gt;).
<span class="lineNum">     659 </span>            :   //
<span class="lineNum">     660 </span>            :   // Usage example: my_doubs = refl-&gt;GetRepeatedField&lt;double&gt;(msg, fd);
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   // for T = Cord and all protobuf scalar types except enums.
<span class="lineNum">     663 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     664 </span>            :   const RepeatedField&lt;T&gt;&amp; GetRepeatedField(
<span class="lineNum">     665 </span>            :       const Message&amp;, const FieldDescriptor*) const;
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :   // for T = Cord and all protobuf scalar types except enums.
<span class="lineNum">     668 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     669 </span>            :   RepeatedField&lt;T&gt;* MutableRepeatedField(
<span class="lineNum">     670 </span>            :       Message*, const FieldDescriptor*) const;
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   // for T = string, google::protobuf::internal::StringPieceField
<span class="lineNum">     673 </span>            :   //         google::protobuf::Message &amp; descendants.
<span class="lineNum">     674 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     675 </span>            :   const RepeatedPtrField&lt;T&gt;&amp; GetRepeatedPtrField(
<span class="lineNum">     676 </span>            :       const Message&amp;, const FieldDescriptor*) const;
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   // for T = string, google::protobuf::internal::StringPieceField
<span class="lineNum">     679 </span>            :   //         google::protobuf::Message &amp; descendants.
<span class="lineNum">     680 </span>            :   template&lt;typename T&gt;
<span class="lineNum">     681 </span>            :   RepeatedPtrField&lt;T&gt;* MutableRepeatedPtrField(
<span class="lineNum">     682 </span>            :       Message*, const FieldDescriptor*) const;
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :   // Extensions ----------------------------------------------------------------
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :   // Try to find an extension of this message type by fully-qualified field
<span class="lineNum">     687 </span>            :   // name.  Returns NULL if no extension is known for this name or number.
<span class="lineNum">     688 </span>            :   virtual const FieldDescriptor* FindKnownExtensionByName(
<span class="lineNum">     689 </span>            :       const string&amp; name) const = 0;
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :   // Try to find an extension of this message type by field number.
<span class="lineNum">     692 </span>            :   // Returns NULL if no extension is known for this name or number.
<span class="lineNum">     693 </span>            :   virtual const FieldDescriptor* FindKnownExtensionByNumber(
<span class="lineNum">     694 </span>            :       int number) const = 0;
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   // ---------------------------------------------------------------------------
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :  protected:
<span class="lineNum">     699 </span>            :   // Obtain a pointer to a Repeated Field Structure and do some type checking:
<span class="lineNum">     700 </span>            :   //   on field-&gt;cpp_type(),
<span class="lineNum">     701 </span>            :   //   on field-&gt;field_option().ctype() (if ctype &gt;= 0)
<span class="lineNum">     702 </span>            :   //   of field-&gt;message_type() (if message_type != NULL).
<span class="lineNum">     703 </span>            :   // We use 1 routine rather than 4 (const vs mutable) x (scalar vs pointer).
<span class="lineNum">     704 </span>            :   virtual void* MutableRawRepeatedField(
<span class="lineNum">     705 </span>            :       Message* message, const FieldDescriptor* field, FieldDescriptor::CppType,
<span class="lineNum">     706 </span>            :       int ctype, const Descriptor* message_type) const = 0;
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :  private:
<span class="lineNum">     709 </span>            :   // Special version for specialized implementations of string.  We can't call
<span class="lineNum">     710 </span>            :   // MutableRawRepeatedField directly here because we don't have access to
<span class="lineNum">     711 </span>            :   // FieldOptions::* which are defined in descriptor.pb.h.  Including that
<span class="lineNum">     712 </span>            :   // file here is not possible because it would cause a circular include cycle.
<span class="lineNum">     713 </span>            :   void* MutableRawRepeatedString(
<span class="lineNum">     714 </span>            :       Message* message, const FieldDescriptor* field, bool is_string) const;
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Reflection);
<span class="lineNum">     717 </span>            : };
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : // Abstract interface for a factory for message objects.
<a name="720"><span class="lineNum">     720 </span>            : class LIBPROTOBUF_EXPORT MessageFactory {</a>
<span class="lineNum">     721 </span>            :  public:
<span class="lineNum">     722 </span><span class="lineCov">          3 :   inline MessageFactory() {}</span>
<span class="lineNum">     723 </span>            :   virtual ~MessageFactory();
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :   // Given a Descriptor, gets or constructs the default (prototype) Message
<span class="lineNum">     726 </span>            :   // of that type.  You can then call that message's New() method to construct
<span class="lineNum">     727 </span>            :   // a mutable message of that type.
<span class="lineNum">     728 </span>            :   //
<span class="lineNum">     729 </span>            :   // Calling this method twice with the same Descriptor returns the same
<span class="lineNum">     730 </span>            :   // object.  The returned object remains property of the factory.  Also, any
<span class="lineNum">     731 </span>            :   // objects created by calling the prototype's New() method share some data
<span class="lineNum">     732 </span>            :   // with the prototype, so these must be destroyed before the MessageFactory
<span class="lineNum">     733 </span>            :   // is destroyed.
<span class="lineNum">     734 </span>            :   //
<span class="lineNum">     735 </span>            :   // The given descriptor must outlive the returned message, and hence must
<span class="lineNum">     736 </span>            :   // outlive the MessageFactory.
<span class="lineNum">     737 </span>            :   //
<span class="lineNum">     738 </span>            :   // Some implementations do not support all types.  GetPrototype() will
<span class="lineNum">     739 </span>            :   // return NULL if the descriptor passed in is not supported.
<span class="lineNum">     740 </span>            :   //
<span class="lineNum">     741 </span>            :   // This method may or may not be thread-safe depending on the implementation.
<span class="lineNum">     742 </span>            :   // Each implementation should document its own degree thread-safety.
<span class="lineNum">     743 </span>            :   virtual const Message* GetPrototype(const Descriptor* type) = 0;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :   // Gets a MessageFactory which supports all generated, compiled-in messages.
<span class="lineNum">     746 </span>            :   // In other words, for any compiled-in type FooMessage, the following is true:
<span class="lineNum">     747 </span>            :   //   MessageFactory::generated_factory()-&gt;GetPrototype(
<span class="lineNum">     748 </span>            :   //     FooMessage::descriptor()) == FooMessage::default_instance()
<span class="lineNum">     749 </span>            :   // This factory supports all types which are found in
<span class="lineNum">     750 </span>            :   // DescriptorPool::generated_pool().  If given a descriptor from any other
<span class="lineNum">     751 </span>            :   // pool, GetPrototype() will return NULL.  (You can also check if a
<span class="lineNum">     752 </span>            :   // descriptor is for a generated message by checking if
<span class="lineNum">     753 </span>            :   // descriptor-&gt;file()-&gt;pool() == DescriptorPool::generated_pool().)
<span class="lineNum">     754 </span>            :   //
<span class="lineNum">     755 </span>            :   // This factory is 100% thread-safe; calling GetPrototype() does not modify
<span class="lineNum">     756 </span>            :   // any shared data.
<span class="lineNum">     757 </span>            :   //
<span class="lineNum">     758 </span>            :   // This factory is a singleton.  The caller must not delete the object.
<span class="lineNum">     759 </span>            :   static MessageFactory* generated_factory();
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :   // For internal use only:  Registers a .proto file at static initialization
<span class="lineNum">     762 </span>            :   // time, to be placed in generated_factory.  The first time GetPrototype()
<span class="lineNum">     763 </span>            :   // is called with a descriptor from this file, |register_messages| will be
<span class="lineNum">     764 </span>            :   // called, with the file name as the parameter.  It must call
<span class="lineNum">     765 </span>            :   // InternalRegisterGeneratedMessage() (below) to register each message type
<span class="lineNum">     766 </span>            :   // in the file.  This strange mechanism is necessary because descriptors are
<span class="lineNum">     767 </span>            :   // built lazily, so we can't register types by their descriptor until we
<span class="lineNum">     768 </span>            :   // know that the descriptor exists.  |filename| must be a permanent string.
<span class="lineNum">     769 </span>            :   static void InternalRegisterGeneratedFile(
<span class="lineNum">     770 </span>            :       const char* filename, void (*register_messages)(const string&amp;));
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :   // For internal use only:  Registers a message type.  Called only by the
<span class="lineNum">     773 </span>            :   // functions which are registered with InternalRegisterGeneratedFile(),
<span class="lineNum">     774 </span>            :   // above.
<span class="lineNum">     775 </span>            :   static void InternalRegisterGeneratedMessage(const Descriptor* descriptor,
<span class="lineNum">     776 </span>            :                                                const Message* prototype);
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :  private:
<span class="lineNum">     780 </span>            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MessageFactory);
<span class="lineNum">     781 </span>            : };
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : #define DECLARE_GET_REPEATED_FIELD(TYPE)                         \
<span class="lineNum">     784 </span>            : template&lt;&gt;                                                       \
<span class="lineNum">     785 </span>            : LIBPROTOBUF_EXPORT                                               \
<span class="lineNum">     786 </span>            : const RepeatedField&lt;TYPE&gt;&amp; Reflection::GetRepeatedField&lt;TYPE&gt;(   \
<span class="lineNum">     787 </span>            :     const Message&amp; message, const FieldDescriptor* field) const; \
<span class="lineNum">     788 </span>            :                                                                  \
<span class="lineNum">     789 </span>            : template&lt;&gt;                                                       \
<span class="lineNum">     790 </span>            : RepeatedField&lt;TYPE&gt;* Reflection::MutableRepeatedField&lt;TYPE&gt;(     \
<span class="lineNum">     791 </span>            :     Message* message, const FieldDescriptor* field) const;
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            : DECLARE_GET_REPEATED_FIELD(int32)
<span class="lineNum">     794 </span>            : DECLARE_GET_REPEATED_FIELD(int64)
<span class="lineNum">     795 </span>            : DECLARE_GET_REPEATED_FIELD(uint32)
<span class="lineNum">     796 </span>            : DECLARE_GET_REPEATED_FIELD(uint64)
<span class="lineNum">     797 </span>            : DECLARE_GET_REPEATED_FIELD(float)
<span class="lineNum">     798 </span>            : DECLARE_GET_REPEATED_FIELD(double)
<span class="lineNum">     799 </span>            : DECLARE_GET_REPEATED_FIELD(bool)
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : #undef DECLARE_GET_REPEATED_FIELD
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : // =============================================================================
<span class="lineNum">     804 </span>            : // Implementation details for {Get,Mutable}RawRepeatedPtrField.  We provide
<span class="lineNum">     805 </span>            : // specializations for &lt;string&gt;, &lt;StringPieceField&gt; and &lt;Message&gt; and handle
<span class="lineNum">     806 </span>            : // everything else with the default template which will match any type having
<span class="lineNum">     807 </span>            : // a method with signature &quot;static const google::protobuf::Descriptor* descriptor()&quot;.
<span class="lineNum">     808 </span>            : // Such a type presumably is a descendant of google::protobuf::Message.
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : template&lt;&gt;
<span class="lineNum">     811 </span>            : inline const RepeatedPtrField&lt;string&gt;&amp; Reflection::GetRepeatedPtrField&lt;string&gt;(
<span class="lineNum">     812 </span>            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">     813 </span>            :   return *static_cast&lt;RepeatedPtrField&lt;string&gt;* &gt;(
<span class="lineNum">     814 </span>            :       MutableRawRepeatedString(const_cast&lt;Message*&gt;(&amp;message), field, true));
<span class="lineNum">     815 </span>            : }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : template&lt;&gt;
<span class="lineNum">     818 </span>            : inline RepeatedPtrField&lt;string&gt;* Reflection::MutableRepeatedPtrField&lt;string&gt;(
<span class="lineNum">     819 </span>            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">     820 </span>            :   return static_cast&lt;RepeatedPtrField&lt;string&gt;* &gt;(
<span class="lineNum">     821 </span>            :       MutableRawRepeatedString(message, field, true));
<span class="lineNum">     822 </span>            : }
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : // -----
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : template&lt;&gt;
<span class="lineNum">     828 </span>            : inline const RepeatedPtrField&lt;Message&gt;&amp; Reflection::GetRepeatedPtrField(
<span class="lineNum">     829 </span>            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">     830 </span>            :   return *static_cast&lt;RepeatedPtrField&lt;Message&gt;* &gt;(
<span class="lineNum">     831 </span>            :       MutableRawRepeatedField(const_cast&lt;Message*&gt;(&amp;message), field,
<span class="lineNum">     832 </span>            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">     833 </span>            :           NULL));
<span class="lineNum">     834 </span>            : }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : template&lt;&gt;
<span class="lineNum">     837 </span>            : inline RepeatedPtrField&lt;Message&gt;* Reflection::MutableRepeatedPtrField(
<span class="lineNum">     838 </span>            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">     839 </span>            :   return static_cast&lt;RepeatedPtrField&lt;Message&gt;* &gt;(
<span class="lineNum">     840 </span>            :       MutableRawRepeatedField(message, field,
<span class="lineNum">     841 </span>            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">     842 </span>            :           NULL));
<span class="lineNum">     843 </span>            : }
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            : template&lt;typename PB&gt;
<span class="lineNum">     846 </span>            : inline const RepeatedPtrField&lt;PB&gt;&amp; Reflection::GetRepeatedPtrField(
<span class="lineNum">     847 </span>            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">     848 </span>            :   return *static_cast&lt;RepeatedPtrField&lt;PB&gt;* &gt;(
<span class="lineNum">     849 </span>            :       MutableRawRepeatedField(const_cast&lt;Message*&gt;(&amp;message), field,
<span class="lineNum">     850 </span>            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">     851 </span>            :           PB::default_instance().GetDescriptor()));
<span class="lineNum">     852 </span>            : }
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : template&lt;typename PB&gt;
<span class="lineNum">     855 </span>            : inline RepeatedPtrField&lt;PB&gt;* Reflection::MutableRepeatedPtrField(
<span class="lineNum">     856 </span>            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">     857 </span>            :   return static_cast&lt;RepeatedPtrField&lt;PB&gt;* &gt;(
<span class="lineNum">     858 </span>            :       MutableRawRepeatedField(message, field,
<span class="lineNum">     859 </span>            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">     860 </span>            :           PB::default_instance().GetDescriptor()));
<span class="lineNum">     861 </span>            : }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : }  // namespace protobuf
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            : }  // namespace google
<span class="lineNum">     866 </span>            : #endif  // GOOGLE_PROTOBUF_MESSAGE_H__
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/pkix/include/pkix/pkixtypes.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">security/pkix/include/pkix</a> - pkixtypes.h<span style="font-size: 80%;"> (source / <a href="pkixtypes.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">18.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">18.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This code is made available to you under your choice of the following sets
<span class="lineNum">       4 </span>            :  * of licensing terms:
<span class="lineNum">       5 </span>            :  */
<span class="lineNum">       6 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       7 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       8 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : /* Copyright 2013 Mozilla Contributors
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">      13 </span>            :  * you may not use this file except in compliance with the License.
<span class="lineNum">      14 </span>            :  * You may obtain a copy of the License at
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      19 </span>            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      20 </span>            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      21 </span>            :  * See the License for the specific language governing permissions and
<span class="lineNum">      22 </span>            :  * limitations under the License.
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #ifndef mozilla_pkix_pkixtypes_h
<span class="lineNum">      26 </span>            : #define mozilla_pkix_pkixtypes_h
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;pkix/Input.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;pkix/Time.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;stdint.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : namespace mozilla { namespace pkix {
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : enum class DigestAlgorithm
<span class="lineNum">      35 </span>            : {
<span class="lineNum">      36 </span>            :   sha512 = 1,
<span class="lineNum">      37 </span>            :   sha384 = 2,
<span class="lineNum">      38 </span>            :   sha256 = 3,
<span class="lineNum">      39 </span>            :   sha1 = 4,
<span class="lineNum">      40 </span>            : };
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : enum class NamedCurve
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span>            :   // secp521r1 (OID 1.3.132.0.35, RFC 5480)
<span class="lineNum">      45 </span>            :   secp521r1 = 1,
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :   // secp384r1 (OID 1.3.132.0.34, RFC 5480)
<span class="lineNum">      48 </span>            :   secp384r1 = 2,
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :   // secp256r1 (OID 1.2.840.10045.3.1.7, RFC 5480)
<span class="lineNum">      51 </span>            :   secp256r1 = 3,
<a name="52"><span class="lineNum">      52 </span>            : };</a>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : struct SignedDigest final</span>
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span>            :   Input digest;
<span class="lineNum">      57 </span>            :   DigestAlgorithm digestAlgorithm;
<span class="lineNum">      58 </span>            :   Input signature;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   void operator=(const SignedDigest&amp;) = delete;
<span class="lineNum">      61 </span>            : };
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : enum class EndEntityOrCA { MustBeEndEntity = 0, MustBeCA = 1 };
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : enum class KeyUsage : uint8_t
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :   digitalSignature = 0,
<span class="lineNum">      68 </span>            :   nonRepudiation   = 1,
<span class="lineNum">      69 </span>            :   keyEncipherment  = 2,
<span class="lineNum">      70 </span>            :   dataEncipherment = 3,
<span class="lineNum">      71 </span>            :   keyAgreement     = 4,
<span class="lineNum">      72 </span>            :   keyCertSign      = 5,
<span class="lineNum">      73 </span>            :   // cRLSign       = 6,
<span class="lineNum">      74 </span>            :   // encipherOnly  = 7,
<span class="lineNum">      75 </span>            :   // decipherOnly  = 8,
<span class="lineNum">      76 </span>            :   noParticularKeyUsageRequired = 0xff,
<span class="lineNum">      77 </span>            : };
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : enum class KeyPurposeId
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :   anyExtendedKeyUsage = 0,
<span class="lineNum">      82 </span>            :   id_kp_serverAuth = 1,           // id-kp-serverAuth
<span class="lineNum">      83 </span>            :   id_kp_clientAuth = 2,           // id-kp-clientAuth
<span class="lineNum">      84 </span>            :   id_kp_codeSigning = 3,          // id-kp-codeSigning
<span class="lineNum">      85 </span>            :   id_kp_emailProtection = 4,      // id-kp-emailProtection
<span class="lineNum">      86 </span>            :   id_kp_OCSPSigning = 9,          // id-kp-OCSPSigning
<span class="lineNum">      87 </span>            : };
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : struct CertPolicyId final
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span>            :   uint16_t numBytes;
<span class="lineNum">      92 </span>            :   static const uint16_t MAX_BYTES = 24;
<span class="lineNum">      93 </span>            :   uint8_t bytes[MAX_BYTES];
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :   bool IsAnyPolicy() const;
<span class="lineNum">      96 </span>            :   bool operator==(const CertPolicyId&amp; other) const;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   static const CertPolicyId anyPolicy;
<span class="lineNum">      99 </span>            : };
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : enum class TrustLevel
<span class="lineNum">     102 </span>            : {
<span class="lineNum">     103 </span>            :   TrustAnchor = 1,        // certificate is a trusted root CA certificate or
<span class="lineNum">     104 </span>            :                           // equivalent *for the given policy*.
<span class="lineNum">     105 </span>            :   ActivelyDistrusted = 2, // certificate is known to be bad
<span class="lineNum">     106 </span>            :   InheritsTrust = 3       // certificate must chain to a trust anchor
<span class="lineNum">     107 </span>            : };
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : // Extensions extracted during the verification flow.
<span class="lineNum">     110 </span>            : // See TrustDomain::NoteAuxiliaryExtension.
<span class="lineNum">     111 </span>            : enum class AuxiliaryExtension
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span>            :   // Certificate Transparency data, specifically Signed Certificate
<span class="lineNum">     114 </span>            :   // Timestamps (SCTs). See RFC 6962.
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   // SCT list embedded in the end entity certificate. Called by BuildCertChain
<span class="lineNum">     117 </span>            :   // after the certificate containing the SCTs has passed the revocation checks.
<span class="lineNum">     118 </span>            :   EmbeddedSCTList = 1,
<span class="lineNum">     119 </span>            :   // SCT list from OCSP response. Called by VerifyEncodedOCSPResponse
<span class="lineNum">     120 </span>            :   // when its result is a success and the SCT list is present.
<span class="lineNum">     121 </span>            :   SCTListFromOCSPResponse = 2
<span class="lineNum">     122 </span>            : };
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : // CertID references the information needed to do revocation checking for the
<span class="lineNum">     125 </span>            : // certificate issued by the given issuer with the given serial number.
<span class="lineNum">     126 </span>            : //
<span class="lineNum">     127 </span>            : // issuer must be the DER-encoded issuer field from the certificate for which
<span class="lineNum">     128 </span>            : // revocation checking is being done, **NOT** the subject field of the issuer
<span class="lineNum">     129 </span>            : // certificate. (Those two fields must be equal to each other, but they may not
<span class="lineNum">     130 </span>            : // be encoded exactly the same, and the encoding matters for OCSP.)
<span class="lineNum">     131 </span>            : // issuerSubjectPublicKeyInfo is the entire DER-encoded subjectPublicKeyInfo
<span class="lineNum">     132 </span>            : // field from the issuer's certificate. serialNumber is the entire DER-encoded
<span class="lineNum">     133 </span>            : // serial number from the subject certificate (the certificate for which we are
<span class="lineNum">     134 </span>            : // checking the revocation status).
<span class="lineNum">     135 </span>            : struct CertID final
<a name="136"><span class="lineNum">     136 </span>            : {</a>
<span class="lineNum">     137 </span>            : public:
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   CertID(Input issuer, Input issuerSubjectPublicKeyInfo, Input serialNumber)</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     : issuer(issuer)</span>
<span class="lineNum">     140 </span>            :     , issuerSubjectPublicKeyInfo(issuerSubjectPublicKeyInfo)
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     , serialNumber(serialNumber)</span>
<span class="lineNum">     142 </span>            :   {
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     144 </span>            :   const Input issuer;
<span class="lineNum">     145 </span>            :   const Input issuerSubjectPublicKeyInfo;
<span class="lineNum">     146 </span>            :   const Input serialNumber;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :   void operator=(const CertID&amp;) = delete;
<span class="lineNum">     149 </span>            : };
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : class DERArray
<span class="lineNum">     152 </span>            : {
<span class="lineNum">     153 </span>            : public:
<span class="lineNum">     154 </span>            :   // Returns the number of DER-encoded items in the array.
<span class="lineNum">     155 </span>            :   virtual size_t GetLength() const = 0;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   // Returns a weak (non-owning) pointer the ith DER-encoded item in the array
<span class="lineNum">     158 </span>            :   // (0-indexed). The result is guaranteed to be non-null if i &lt; GetLength(),
<span class="lineNum">     159 </span>            :   // and the result is guaranteed to be nullptr if i &gt;= GetLength().
<a name="160"><span class="lineNum">     160 </span>            :   virtual const Input* GetDER(size_t i) const = 0;</a>
<a name="161"><span class="lineNum">     161 </span>            : protected:</a>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   DERArray() { }</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   virtual ~DERArray() { }</span>
<span class="lineNum">     164 </span>            : };
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : // Applications control the behavior of path building and verification by
<span class="lineNum">     167 </span>            : // implementing the TrustDomain interface. The TrustDomain is used for all
<span class="lineNum">     168 </span>            : // cryptography and for determining which certificates are trusted or
<span class="lineNum">     169 </span>            : // distrusted.
<span class="lineNum">     170 </span>            : class TrustDomain
<a name="171"><span class="lineNum">     171 </span>            : {</a>
<span class="lineNum">     172 </span>            : public:
<span class="lineNum">     173 </span><span class="lineCov">         15 :   virtual ~TrustDomain() { }</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   // Determine the level of trust in the given certificate for the given role.
<span class="lineNum">     176 </span>            :   // This will be called for every certificate encountered during path
<span class="lineNum">     177 </span>            :   // building.
<span class="lineNum">     178 </span>            :   //
<span class="lineNum">     179 </span>            :   // When policy.IsAnyPolicy(), then no policy-related checking should be done.
<span class="lineNum">     180 </span>            :   // When !policy.IsAnyPolicy(), then GetCertTrust MUST NOT return with
<span class="lineNum">     181 </span>            :   // trustLevel == TrustAnchor unless the given cert is considered a trust
<span class="lineNum">     182 </span>            :   // anchor *for that policy*. In particular, if the user has marked an
<span class="lineNum">     183 </span>            :   // intermediate certificate as trusted, but that intermediate isn't in the
<span class="lineNum">     184 </span>            :   // list of EV roots, then GetCertTrust must result in
<span class="lineNum">     185 </span>            :   // trustLevel == InheritsTrust instead of trustLevel == TrustAnchor
<span class="lineNum">     186 </span>            :   // (assuming the candidate cert is not actively distrusted).
<span class="lineNum">     187 </span>            :   virtual Result GetCertTrust(EndEntityOrCA endEntityOrCA,
<span class="lineNum">     188 </span>            :                               const CertPolicyId&amp; policy,
<span class="lineNum">     189 </span>            :                               Input candidateCertDER,
<span class="lineNum">     190 </span>            :                               /*out*/ TrustLevel&amp; trustLevel) = 0;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :   class IssuerChecker
<span class="lineNum">     193 </span>            :   {
<span class="lineNum">     194 </span>            :   public:
<span class="lineNum">     195 </span>            :     // potentialIssuerDER is the complete DER encoding of the certificate to
<span class="lineNum">     196 </span>            :     // be checked as a potential issuer.
<span class="lineNum">     197 </span>            :     //
<span class="lineNum">     198 </span>            :     // If additionalNameConstraints is not nullptr then it must point to an
<span class="lineNum">     199 </span>            :     // encoded NameConstraints extension value; in that case, those name
<span class="lineNum">     200 </span>            :     // constraints will be checked in addition to any any name constraints
<span class="lineNum">     201 </span>            :     // contained in potentialIssuerDER.
<span class="lineNum">     202 </span>            :     virtual Result Check(Input potentialIssuerDER,
<span class="lineNum">     203 </span>            :             /*optional*/ const Input* additionalNameConstraints,
<span class="lineNum">     204 </span>            :                  /*out*/ bool&amp; keepGoing) = 0;
<span class="lineNum">     205 </span>            :   protected:
<span class="lineNum">     206 </span>            :     IssuerChecker();
<span class="lineNum">     207 </span>            :     virtual ~IssuerChecker();
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :     IssuerChecker(const IssuerChecker&amp;) = delete;
<span class="lineNum">     210 </span>            :     void operator=(const IssuerChecker&amp;) = delete;
<span class="lineNum">     211 </span>            :   };
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   // Search for a CA certificate with the given name. The implementation must
<span class="lineNum">     214 </span>            :   // call checker.Check with the DER encoding of the potential issuer
<span class="lineNum">     215 </span>            :   // certificate. The implementation must follow these rules:
<span class="lineNum">     216 </span>            :   //
<span class="lineNum">     217 </span>            :   // * The implementation must be reentrant and must limit the amount of stack
<span class="lineNum">     218 </span>            :   //   space it uses; see the note on reentrancy and stack usage below.
<span class="lineNum">     219 </span>            :   // * When checker.Check does not return Success then immediately return its
<span class="lineNum">     220 </span>            :   //   return value.
<span class="lineNum">     221 </span>            :   // * When checker.Check returns Success and sets keepGoing = false, then
<span class="lineNum">     222 </span>            :   //   immediately return Success.
<span class="lineNum">     223 </span>            :   // * When checker.Check returns Success and sets keepGoing = true, then
<span class="lineNum">     224 </span>            :   //   call checker.Check again with a different potential issuer certificate,
<span class="lineNum">     225 </span>            :   //   if any more are available.
<span class="lineNum">     226 </span>            :   // * When no more potential issuer certificates are available, return
<span class="lineNum">     227 </span>            :   //   Success.
<span class="lineNum">     228 </span>            :   // * Don't call checker.Check with the same potential issuer certificate more
<span class="lineNum">     229 </span>            :   //   than once in a given call of FindIssuer.
<span class="lineNum">     230 </span>            :   // * The given time parameter may be used to filter out certificates that are
<span class="lineNum">     231 </span>            :   //   not valid at the given time, or it may be ignored.
<span class="lineNum">     232 </span>            :   //
<span class="lineNum">     233 </span>            :   // Note on reentrancy and stack usage: checker.Check will attempt to
<span class="lineNum">     234 </span>            :   // recursively build a certificate path from the potential issuer it is given
<span class="lineNum">     235 </span>            :   // to a trusted root, as determined by this TrustDomain. That means that
<span class="lineNum">     236 </span>            :   // checker.Check may call any/all of the methods on this TrustDomain. In
<span class="lineNum">     237 </span>            :   // particular, there will be call stacks that look like this:
<span class="lineNum">     238 </span>            :   //
<span class="lineNum">     239 </span>            :   //    BuildCertChain
<span class="lineNum">     240 </span>            :   //      [...]
<span class="lineNum">     241 </span>            :   //        TrustDomain::FindIssuer
<span class="lineNum">     242 </span>            :   //          [...]
<span class="lineNum">     243 </span>            :   //            IssuerChecker::Check
<span class="lineNum">     244 </span>            :   //              [...]
<span class="lineNum">     245 </span>            :   //                TrustDomain::FindIssuer
<span class="lineNum">     246 </span>            :   //                  [...]
<span class="lineNum">     247 </span>            :   //                    IssuerChecker::Check
<span class="lineNum">     248 </span>            :   //                      [...]
<span class="lineNum">     249 </span>            :   //
<span class="lineNum">     250 </span>            :   // checker.Check is responsible for limiting the recursion to a reasonable
<span class="lineNum">     251 </span>            :   // limit.
<span class="lineNum">     252 </span>            :   //
<span class="lineNum">     253 </span>            :   // checker.Check will verify that the subject's issuer field matches the
<span class="lineNum">     254 </span>            :   // potential issuer's subject field. It will also check that the potential
<span class="lineNum">     255 </span>            :   // issuer is valid at the given time. However, if the FindIssuer
<span class="lineNum">     256 </span>            :   // implementation has an efficient way of filtering potential issuers by name
<span class="lineNum">     257 </span>            :   // and/or validity period itself, then it is probably better for performance
<span class="lineNum">     258 </span>            :   // for it to do so.
<span class="lineNum">     259 </span>            :   virtual Result FindIssuer(Input encodedIssuerName,
<span class="lineNum">     260 </span>            :                             IssuerChecker&amp; checker, Time time) = 0;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   // Called as soon as we think we have a valid chain but before revocation
<span class="lineNum">     263 </span>            :   // checks are done. This function can be used to compute additional checks,
<span class="lineNum">     264 </span>            :   // especially checks that require the entire certificate chain. This callback
<span class="lineNum">     265 </span>            :   // can also be used to save a copy of the built certificate chain for later
<span class="lineNum">     266 </span>            :   // use.
<span class="lineNum">     267 </span>            :   //
<span class="lineNum">     268 </span>            :   // This function may be called multiple times, regardless of whether it
<span class="lineNum">     269 </span>            :   // returns success or failure. It is guaranteed that BuildCertChain will not
<span class="lineNum">     270 </span>            :   // return Success unless the last call to IsChainValid returns Success. Further,
<span class="lineNum">     271 </span>            :   // it is guaranteed that when BuildCertChain returns Success the last chain
<span class="lineNum">     272 </span>            :   // passed to IsChainValid is the valid chain that should be used for further
<span class="lineNum">     273 </span>            :   // operations that require the whole chain.
<span class="lineNum">     274 </span>            :   //
<span class="lineNum">     275 </span>            :   // Keep in mind, in particular, that if the application saves a copy of the
<span class="lineNum">     276 </span>            :   // certificate chain the last invocation of IsChainValid during a validation,
<span class="lineNum">     277 </span>            :   // it is still possible for BuildCertChain to fail, in which case the
<span class="lineNum">     278 </span>            :   // application must not assume anything about the validity of the last
<span class="lineNum">     279 </span>            :   // certificate chain passed to IsChainValid; especially, it would be very
<span class="lineNum">     280 </span>            :   // wrong to assume that the certificate chain is valid.
<span class="lineNum">     281 </span>            :   //
<span class="lineNum">     282 </span>            :   // certChain.GetDER(0) is the trust anchor.
<span class="lineNum">     283 </span>            :   virtual Result IsChainValid(const DERArray&amp; certChain, Time time,
<span class="lineNum">     284 </span>            :                               const CertPolicyId&amp; requiredPolicy) = 0;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :   virtual Result CheckRevocation(EndEntityOrCA endEntityOrCA,
<span class="lineNum">     287 </span>            :                                  const CertID&amp; certID, Time time,
<span class="lineNum">     288 </span>            :                                  Duration validityDuration,
<span class="lineNum">     289 </span>            :                     /*optional*/ const Input* stapledOCSPresponse,
<span class="lineNum">     290 </span>            :                     /*optional*/ const Input* aiaExtension) = 0;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   // Check that the given digest algorithm is acceptable for use in signatures.
<span class="lineNum">     293 </span>            :   //
<span class="lineNum">     294 </span>            :   // Return Success if the algorithm is acceptable,
<span class="lineNum">     295 </span>            :   // Result::ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED if the algorithm is not
<span class="lineNum">     296 </span>            :   // acceptable, or another error code if another error occurred.
<span class="lineNum">     297 </span>            :   virtual Result CheckSignatureDigestAlgorithm(DigestAlgorithm digestAlg,
<span class="lineNum">     298 </span>            :                                                EndEntityOrCA endEntityOrCA,
<span class="lineNum">     299 </span>            :                                                Time notBefore) = 0;
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   // Check that the RSA public key size is acceptable.
<span class="lineNum">     302 </span>            :   //
<span class="lineNum">     303 </span>            :   // Return Success if the key size is acceptable,
<span class="lineNum">     304 </span>            :   // Result::ERROR_INADEQUATE_KEY_SIZE if the key size is not acceptable,
<span class="lineNum">     305 </span>            :   // or another error code if another error occurred.
<span class="lineNum">     306 </span>            :   virtual Result CheckRSAPublicKeyModulusSizeInBits(
<span class="lineNum">     307 </span>            :                    EndEntityOrCA endEntityOrCA,
<span class="lineNum">     308 </span>            :                    unsigned int modulusSizeInBits) = 0;
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :   // Verify the given RSA PKCS#1.5 signature on the given digest using the
<span class="lineNum">     311 </span>            :   // given RSA public key.
<span class="lineNum">     312 </span>            :   //
<span class="lineNum">     313 </span>            :   // CheckRSAPublicKeyModulusSizeInBits will be called before calling this
<span class="lineNum">     314 </span>            :   // function, so it is not necessary to repeat those checks here. However,
<span class="lineNum">     315 </span>            :   // VerifyRSAPKCS1SignedDigest *is* responsible for doing the mathematical
<span class="lineNum">     316 </span>            :   // verification of the public key validity as specified in NIST SP 800-56A.
<span class="lineNum">     317 </span>            :   virtual Result VerifyRSAPKCS1SignedDigest(
<span class="lineNum">     318 </span>            :                    const SignedDigest&amp; signedDigest,
<span class="lineNum">     319 </span>            :                    Input subjectPublicKeyInfo) = 0;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   // Check that the given named ECC curve is acceptable for ECDSA signatures.
<span class="lineNum">     322 </span>            :   //
<span class="lineNum">     323 </span>            :   // Return Success if the curve is acceptable,
<span class="lineNum">     324 </span>            :   // Result::ERROR_UNSUPPORTED_ELLIPTIC_CURVE if the curve is not acceptable,
<span class="lineNum">     325 </span>            :   // or another error code if another error occurred.
<span class="lineNum">     326 </span>            :   virtual Result CheckECDSACurveIsAcceptable(EndEntityOrCA endEntityOrCA,
<span class="lineNum">     327 </span>            :                                              NamedCurve curve) = 0;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // Verify the given ECDSA signature on the given digest using the given ECC
<span class="lineNum">     330 </span>            :   // public key.
<span class="lineNum">     331 </span>            :   //
<span class="lineNum">     332 </span>            :   // CheckECDSACurveIsAcceptable will be called before calling this function,
<span class="lineNum">     333 </span>            :   // so it is not necessary to repeat that check here. However,
<span class="lineNum">     334 </span>            :   // VerifyECDSASignedDigest *is* responsible for doing the mathematical
<span class="lineNum">     335 </span>            :   // verification of the public key validity as specified in NIST SP 800-56A.
<span class="lineNum">     336 </span>            :   virtual Result VerifyECDSASignedDigest(const SignedDigest&amp; signedDigest,
<span class="lineNum">     337 </span>            :                                          Input subjectPublicKeyInfo) = 0;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   // Check that the validity duration is acceptable.
<span class="lineNum">     340 </span>            :   //
<span class="lineNum">     341 </span>            :   // Return Success if the validity duration is acceptable,
<span class="lineNum">     342 </span>            :   // Result::ERROR_VALIDITY_TOO_LONG if the validity duration is not acceptable,
<span class="lineNum">     343 </span>            :   // or another error code if another error occurred.
<span class="lineNum">     344 </span>            :   virtual Result CheckValidityIsAcceptable(Time notBefore, Time notAfter,
<span class="lineNum">     345 </span>            :                                            EndEntityOrCA endEntityOrCA,
<span class="lineNum">     346 </span>            :                                            KeyPurposeId keyPurpose) = 0;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // For compatibility, a CA certificate with an extended key usage that
<span class="lineNum">     349 </span>            :   // contains the id-Netscape-stepUp OID but does not contain the
<span class="lineNum">     350 </span>            :   // id-kp-serverAuth OID may be considered valid for issuing server auth
<span class="lineNum">     351 </span>            :   // certificates. This function allows TrustDomain implementations to control
<span class="lineNum">     352 </span>            :   // this setting based on the start of the validity period of the certificate
<span class="lineNum">     353 </span>            :   // in question.
<span class="lineNum">     354 </span>            :   virtual Result NetscapeStepUpMatchesServerAuth(Time notBefore,
<span class="lineNum">     355 </span>            :                                                  /*out*/ bool&amp; matches) = 0;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :   // Some certificate or OCSP response extensions do not directly participate
<span class="lineNum">     358 </span>            :   // in the verification flow, but might still be of interest to the clients
<span class="lineNum">     359 </span>            :   // (notably Certificate Transparency data, RFC 6962). Such extensions are
<span class="lineNum">     360 </span>            :   // extracted and passed to this function for further processing.
<span class="lineNum">     361 </span>            :   virtual void NoteAuxiliaryExtension(AuxiliaryExtension extension,
<span class="lineNum">     362 </span>            :                                       Input extensionData) = 0;
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   // Compute a digest of the data in item using the given digest algorithm.
<span class="lineNum">     365 </span>            :   //
<span class="lineNum">     366 </span>            :   // item contains the data to hash.
<span class="lineNum">     367 </span>            :   // digestBuf points to a buffer to where the digest will be written.
<span class="lineNum">     368 </span>            :   // digestBufLen will be the size of the digest output (20 for SHA-1,
<span class="lineNum">     369 </span>            :   // 32 for SHA-256, etc.).
<span class="lineNum">     370 </span>            :   //
<span class="lineNum">     371 </span>            :   // TODO: Taking the output buffer as (uint8_t*, size_t) is counter to our
<span class="lineNum">     372 </span>            :   // other, extensive, memory safety efforts in mozilla::pkix, and we should
<span class="lineNum">     373 </span>            :   // find a way to provide a more-obviously-safe interface.
<span class="lineNum">     374 </span>            :   virtual Result DigestBuf(Input item,
<span class="lineNum">     375 </span>            :                            DigestAlgorithm digestAlg,
<span class="lineNum">     376 </span>            :                            /*out*/ uint8_t* digestBuf,
<a name="377"><span class="lineNum">     377 </span>            :                            size_t digestBufLen) = 0;</a>
<span class="lineNum">     378 </span>            : protected:
<span class="lineNum">     379 </span><span class="lineCov">         15 :   TrustDomain() { }</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :   TrustDomain(const TrustDomain&amp;) = delete;
<span class="lineNum">     382 </span>            :   void operator=(const TrustDomain&amp;) = delete;
<span class="lineNum">     383 </span>            : };
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : enum class FallBackToSearchWithinSubject { No = 0, Yes = 1 };
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : // Applications control the behavior of matching presented name information from
<span class="lineNum">     388 </span>            : // a certificate against a reference hostname by implementing the
<span class="lineNum">     389 </span>            : // NameMatchingPolicy interface. Used in concert with CheckCertHostname.
<span class="lineNum">     390 </span>            : class NameMatchingPolicy
<a name="391"><span class="lineNum">     391 </span>            : {</a>
<span class="lineNum">     392 </span>            : public:
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   virtual ~NameMatchingPolicy() { }</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   // Given that the certificate in question has a notBefore field with the given
<span class="lineNum">     396 </span>            :   // value, should name matching fall back to searching within the subject
<span class="lineNum">     397 </span>            :   // common name field?
<span class="lineNum">     398 </span>            :   virtual Result FallBackToCommonName(
<span class="lineNum">     399 </span>            :     Time notBefore,
<span class="lineNum">     400 </span>            :     /*out*/ FallBackToSearchWithinSubject&amp; fallBackToCommonName) = 0;
<a name="401"><span class="lineNum">     401 </span>            : </a>
<span class="lineNum">     402 </span>            : protected:
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   NameMatchingPolicy() { }</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   NameMatchingPolicy(const NameMatchingPolicy&amp;) = delete;
<span class="lineNum">     406 </span>            :   void operator=(const NameMatchingPolicy&amp;) = delete;
<span class="lineNum">     407 </span>            : };
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : } } // namespace mozilla::pkix
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : #endif // mozilla_pkix_pkixtypes_h
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - xpcom/base/SystemMemoryReporter.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">xpcom/base</a> - SystemMemoryReporter.cpp<span style="font-size: 80%;"> (source / <a href="SystemMemoryReporter.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">407</td>
            <td class="headerCovTableEntryLo">1.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryLo">16.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;mozilla/SystemMemoryReporter.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/LinuxUtils.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/PodOperations.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/TaggedAnonymousMemory.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;nsDataHashtable.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsIMemoryReporter.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsPrintfCString.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsTHashtable.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsHashKeys.h&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &lt;dirent.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;inttypes.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // This file implements a Linux-specific, system-wide memory reporter.  It
<span class="lineNum">      32 </span>            : // gathers all the useful memory measurements obtainable from the OS in a
<span class="lineNum">      33 </span>            : // single place, giving a high-level view of memory consumption for the entire
<span class="lineNum">      34 </span>            : // machine/device.
<span class="lineNum">      35 </span>            : //
<span class="lineNum">      36 </span>            : // Other memory reporters measure part of a single process's memory consumption.
<span class="lineNum">      37 </span>            : // This reporter is different in that it measures memory consumption of many
<span class="lineNum">      38 </span>            : // processes, and they end up in a single reports tree.  This is a slight abuse
<span class="lineNum">      39 </span>            : // of the memory reporting infrastructure, and therefore the results are given
<span class="lineNum">      40 </span>            : // their own &quot;process&quot; called &quot;System&quot;, which means they show up in about:memory
<span class="lineNum">      41 </span>            : // in their own section, distinct from the per-process sections.
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : namespace mozilla {
<span class="lineNum">      44 </span>            : namespace SystemMemoryReporter {
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #if !defined(XP_LINUX)
<span class="lineNum">      47 </span>            : #error &quot;This won't work if we're not on Linux.&quot;
<span class="lineNum">      48 </span>            : #endif
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /**
<span class="lineNum">      51 </span>            :  * RAII helper that will close an open DIR handle.
<span class="lineNum">      52 </span>            :  */
<a name="53"><span class="lineNum">      53 </span>            : struct MOZ_STACK_CLASS AutoDir</a>
<a name="54"><span class="lineNum">      54 </span>            : {</a>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   explicit AutoDir(DIR* aDir) : mDir(aDir) {}</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   ~AutoDir() { if (mDir) closedir(mDir); };</span>
<span class="lineNum">      57 </span>            :   DIR* mDir;
<span class="lineNum">      58 </span>            : };
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /**
<span class="lineNum">      61 </span>            :  * RAII helper that will close an open FILE handle.
<span class="lineNum">      62 </span>            :  */
<a name="63"><span class="lineNum">      63 </span>            : struct MOZ_STACK_CLASS AutoFile</a>
<a name="64"><span class="lineNum">      64 </span>            : {</a>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   explicit AutoFile(FILE* aFile) : mFile(aFile) {}</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   ~AutoFile() { if (mFile) fclose(mFile); }</span>
<span class="lineNum">      67 </span>            :   FILE* mFile;
<span class="lineNum">      68 </span>            : };
<a name="69"><span class="lineNum">      69 </span>            : </a>
<span class="lineNum">      70 </span>            : static bool
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : EndsWithLiteral(const nsCString&amp; aHaystack, const char* aNeedle)</span>
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   int32_t idx = aHaystack.RFind(aNeedle);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   return idx != -1 &amp;&amp; idx + strlen(aNeedle) == aHaystack.Length();</span>
<span class="lineNum">      75 </span>            : }
<a name="76"><span class="lineNum">      76 </span>            : </a>
<span class="lineNum">      77 </span>            : static void
<span class="lineNum">      78 </span><span class="lineNoCov">          0 : GetDirname(const nsCString&amp; aPath, nsACString&amp; aOut)</span>
<span class="lineNum">      79 </span>            : {
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   int32_t idx = aPath.RFind(&quot;/&quot;);</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   if (idx == -1) {</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     aOut.Truncate();</span>
<span class="lineNum">      83 </span>            :   } else {
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     aOut.Assign(Substring(aPath, 0, idx));</span>
<span class="lineNum">      85 </span>            :   }
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : }</span>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<span class="lineNum">      88 </span>            : static void
<span class="lineNum">      89 </span><span class="lineNoCov">          0 : GetBasename(const nsCString&amp; aPath, nsACString&amp; aOut)</span>
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   nsCString out;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   int32_t idx = aPath.RFind(&quot;/&quot;);</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   if (idx == -1) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     out.Assign(aPath);</span>
<span class="lineNum">      95 </span>            :   } else {
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     out.Assign(Substring(aPath, idx + 1));</span>
<span class="lineNum">      97 </span>            :   }
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   // On Android, some entries in /dev/ashmem end with &quot;(deleted)&quot; (e.g.
<span class="lineNum">     100 </span>            :   // &quot;/dev/ashmem/libxul.so(deleted)&quot;).  We don't care about this modifier, so
<span class="lineNum">     101 </span>            :   // cut it off when getting the entry's basename.
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   if (EndsWithLiteral(out, &quot;(deleted)&quot;)) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     out.Assign(Substring(out, 0, out.RFind(&quot;(deleted)&quot;)));</span>
<span class="lineNum">     104 </span>            :   }
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   out.StripChars(&quot; &quot;);</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   aOut.Assign(out);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 : }</span>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<span class="lineNum">     110 </span>            : static bool
<span class="lineNum">     111 </span><span class="lineNoCov">          0 : IsNumeric(const char* aStr)</span>
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(*aStr);  // shouldn't see empty strings</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   while (*aStr) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     if (!isdigit(*aStr)) {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     117 </span>            :     }
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     ++aStr;</span>
<span class="lineNum">     119 </span>            :   }
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     121 </span>            : }
<a name="122"><span class="lineNum">     122 </span>            : </a>
<span class="lineNum">     123 </span>            : static bool
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : IsAnonymous(const nsACString&amp; aName)</span>
<span class="lineNum">     125 </span>            : {
<span class="lineNum">     126 </span>            :   // Recent kernels have multiple [stack:nnnn] entries, where |nnnn| is a
<span class="lineNum">     127 </span>            :   // thread ID.  However, the entire virtual memory area containing a thread's
<span class="lineNum">     128 </span>            :   // stack pointer is considered the stack for that thread, even if it was
<span class="lineNum">     129 </span>            :   // merged with an adjacent area containing non-stack data.  So we treat them
<span class="lineNum">     130 </span>            :   // as regular anonymous memory.  However, see below about tagged anonymous
<span class="lineNum">     131 </span>            :   // memory.
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   return aName.IsEmpty() ||</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :          StringBeginsWith(aName, NS_LITERAL_CSTRING(&quot;[stack:&quot;));</span>
<a name="134"><span class="lineNum">     134 </span>            : }</a>
<span class="lineNum">     135 </span>            : 
<a name="136"><span class="lineNum">     136 </span><span class="lineCov">          1 : class SystemReporter final : public nsIMemoryReporter</span></a>
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   ~SystemReporter() {}</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : public:
<span class="lineNum">     141 </span>            :   NS_DECL_THREADSAFE_ISUPPORTS
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : #define REPORT(_path, _units, _amount, _desc)                                 \
<span class="lineNum">     144 </span>            :   do {                                                                        \
<span class="lineNum">     145 </span>            :     size_t __amount = _amount;  /* evaluate _amount only once */              \
<span class="lineNum">     146 </span>            :     if (__amount &gt; 0) {                                                       \
<span class="lineNum">     147 </span>            :       aHandleReport-&gt;Callback(NS_LITERAL_CSTRING(&quot;System&quot;), _path,            \
<span class="lineNum">     148 </span>            :                               KIND_OTHER, _units, __amount, _desc, aData);    \
<span class="lineNum">     149 </span>            :     }                                                                         \
<a name="150"><span class="lineNum">     150 </span>            :   } while (0)</a>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   NS_IMETHOD CollectReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     153 </span>            :                             nsISupports* aData, bool aAnonymize) override
<span class="lineNum">     154 </span>            :   {
<span class="lineNum">     155 </span>            :     // There is lots of privacy-sensitive data in /proc. Just skip this
<span class="lineNum">     156 </span>            :     // reporter entirely when anonymization is required.
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     if (aAnonymize) {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     if (!Preferences::GetBool(&quot;memory.system_memory_reporter&quot;)) {</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">     163 </span>            :     }
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     // Read relevant fields from /proc/meminfo.
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     int64_t memTotal = 0, memFree = 0;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     nsresult rv1 = ReadMemInfo(&amp;memTotal, &amp;memFree);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :     // Collect per-process reports from /proc/&lt;pid&gt;/smaps.
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     int64_t totalPss = 0;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     nsresult rv2 = CollectProcessReports(aHandleReport, aData, &amp;totalPss);</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :     // Report the non-process numbers.
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     if (NS_SUCCEEDED(rv1) &amp;&amp; NS_SUCCEEDED(rv2)) {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       int64_t other = memTotal - memFree - totalPss;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       REPORT(NS_LITERAL_CSTRING(&quot;mem/other&quot;), UNITS_BYTES, other,</span>
<span class="lineNum">     177 </span>            :              NS_LITERAL_CSTRING(
<span class="lineNum">     178 </span>            : &quot;Memory which is neither owned by any user-space process nor free. Note that &quot;
<span class="lineNum">     179 </span>            : &quot;this includes memory holding cached files from the disk which can be &quot;
<span class="lineNum">     180 </span>            : &quot;reclaimed by the OS at any time.&quot;));
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       REPORT(NS_LITERAL_CSTRING(&quot;mem/free&quot;), UNITS_BYTES, memFree,</span>
<span class="lineNum">     183 </span>            :              NS_LITERAL_CSTRING(
<span class="lineNum">     184 </span>            : &quot;Memory which is free and not being used for any purpose.&quot;));
<span class="lineNum">     185 </span>            :     }
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :     // Report reserved memory not included in memTotal.
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     CollectPmemReports(aHandleReport, aData);</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     // Report zram usage statistics.
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     CollectZramReports(aHandleReport, aData);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     // Report kgsl graphics memory usage.
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     CollectKgslReports(aHandleReport, aData);</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :     // Report ION memory usage.
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     CollectIonReports(aHandleReport, aData);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span>            : 
<a name="202"><span class="lineNum">     202 </span>            : private:</a>
<span class="lineNum">     203 </span>            :   // These are the cross-cutting measurements across all processes.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   class ProcessSizes</span>
<a name="205"><span class="lineNum">     205 </span>            :   {</a>
<span class="lineNum">     206 </span>            :   public:
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     void Add(const nsACString&amp; aKey, size_t aSize)</span>
<span class="lineNum">     208 </span>            :     {
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       mTagged.Put(aKey, mTagged.Get(aKey) + aSize);</span>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     void Report(nsIHandleReportCallback* aHandleReport, nsISupports* aData)</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       for (auto iter = mTagged.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         nsCStringHashKey::KeyType key = iter.Key();</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         size_t amount = iter.UserData();</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         nsAutoCString path(&quot;processes/&quot;);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         path.Append(key);</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         nsAutoCString desc(&quot;This is the sum of all processes' '&quot;);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         desc.Append(key);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         desc.AppendLiteral(&quot;' numbers.&quot;);</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         REPORT(path, UNITS_BYTES, amount, desc);</span>
<span class="lineNum">     226 </span>            :       }
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   private:
<span class="lineNum">     230 </span>            :     nsDataHashtable&lt;nsCStringHashKey, size_t&gt; mTagged;
<a name="231"><span class="lineNum">     231 </span>            :   };</a>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   nsresult ReadMemInfo(int64_t* aMemTotal, int64_t* aMemFree)</span>
<span class="lineNum">     234 </span>            :   {
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     FILE* f = fopen(&quot;/proc/meminfo&quot;, &quot;r&quot;);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (!f) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     int n1 = fscanf(f, &quot;MemTotal: %&quot; SCNd64 &quot; kB\n&quot;, aMemTotal);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     int n2 = fscanf(f, &quot;MemFree: %&quot;  SCNd64 &quot; kB\n&quot;, aMemFree);</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     fclose(f);</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (n1 != 1 || n2 != 1) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">     247 </span>            :     }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :     // Convert from KB to B.
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     *aMemTotal *= 1024;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     *aMemFree  *= 1024;</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<a name="254"><span class="lineNum">     254 </span>            :   }</a>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   nsresult CollectProcessReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     257 </span>            :                                  nsISupports* aData,
<span class="lineNum">     258 </span>            :                                  int64_t* aTotalPss)
<span class="lineNum">     259 </span>            :   {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     *aTotalPss = 0;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     ProcessSizes processSizes;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     DIR* d = opendir(&quot;/proc&quot;);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     if (NS_WARN_IF(!d)) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span>            :     struct dirent* ent;
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     while ((ent = readdir(d))) {</span>
<span class="lineNum">     269 </span>            :       struct stat statbuf;
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       const char* pidStr = ent-&gt;d_name;</span>
<span class="lineNum">     271 </span>            :       // Don't check the return value of stat() -- it can return -1 for these
<span class="lineNum">     272 </span>            :       // directories even when it has succeeded, apparently.
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       stat(pidStr, &amp;statbuf);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       if (S_ISDIR(statbuf.st_mode) &amp;&amp; IsNumeric(pidStr)) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         nsCString processName(&quot;process(&quot;);</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         // Get the command name from cmdline.  If that fails, the pid is still
<span class="lineNum">     278 </span>            :         // shown.
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         nsPrintfCString cmdlinePath(&quot;/proc/%s/cmdline&quot;, pidStr);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         FILE* f = fopen(cmdlinePath.get(), &quot;r&quot;);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         if (f) {</span>
<span class="lineNum">     282 </span>            :           static const size_t len = 256;
<span class="lineNum">     283 </span>            :           char buf[len];
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :           if (fgets(buf, len, f)) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :             processName.Append(buf);</span>
<span class="lineNum">     286 </span>            :             // A hack: replace forward slashes with '\\' so they aren't treated
<span class="lineNum">     287 </span>            :             // as path separators.  Consumers of this reporter (such as
<span class="lineNum">     288 </span>            :             // about:memory) have to undo this change.
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :             processName.ReplaceChar('/', '\\');</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :             processName.AppendLiteral(&quot;, &quot;);</span>
<span class="lineNum">     291 </span>            :           }
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :           fclose(f);</span>
<span class="lineNum">     293 </span>            :         }
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         processName.AppendLiteral(&quot;pid=&quot;);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         processName.Append(pidStr);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         processName.Append(')');</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :         // Read the PSS values from the smaps file.
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         nsPrintfCString smapsPath(&quot;/proc/%s/smaps&quot;, pidStr);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         f = fopen(smapsPath.get(), &quot;r&quot;);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         if (!f) {</span>
<span class="lineNum">     302 </span>            :           // Processes can terminate between the readdir() call above and now,
<span class="lineNum">     303 </span>            :           // so just skip if we can't open the file.
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     305 </span>            :         }
<span class="lineNum">     306 </span>            :         ParseMappings(f, processName, aHandleReport, aData, &amp;processSizes,
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                       aTotalPss);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         fclose(f);</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :         // Report the open file descriptors for this process.
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         nsPrintfCString procFdPath(&quot;/proc/%s/fd&quot;, pidStr);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         CollectOpenFileReports(aHandleReport, aData, procFdPath, processName);</span>
<span class="lineNum">     313 </span>            :       }
<span class="lineNum">     314 </span>            :     }
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     closedir(d);</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :     // Report the &quot;processes/&quot; tree.
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     processSizes.Report(aHandleReport, aData);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<a name="321"><span class="lineNum">     321 </span>            :   }</a>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   void ParseMappings(FILE* aFile,</span>
<span class="lineNum">     324 </span>            :                      const nsACString&amp; aProcessName,
<span class="lineNum">     325 </span>            :                      nsIHandleReportCallback* aHandleReport,
<span class="lineNum">     326 </span>            :                      nsISupports* aData,
<span class="lineNum">     327 </span>            :                      ProcessSizes* aProcessSizes,
<span class="lineNum">     328 </span>            :                      int64_t* aTotalPss)
<span class="lineNum">     329 </span>            :   {
<span class="lineNum">     330 </span>            :     // The first line of an entry in /proc/&lt;pid&gt;/smaps looks just like an entry
<span class="lineNum">     331 </span>            :     // in /proc/&lt;pid&gt;/maps:
<span class="lineNum">     332 </span>            :     //
<span class="lineNum">     333 </span>            :     //   address           perms offset  dev   inode  pathname
<span class="lineNum">     334 </span>            :     //   02366000-025d8000 rw-p 00000000 00:00 0      [heap]
<span class="lineNum">     335 </span>            :     //
<span class="lineNum">     336 </span>            :     // Each of the following lines contains a key and a value, separated
<span class="lineNum">     337 </span>            :     // by &quot;: &quot;, where the key does not contain either of those characters.
<span class="lineNum">     338 </span>            :     // Assuming more than this about the structure of those lines has
<span class="lineNum">     339 </span>            :     // failed to be future-proof in the past, so we avoid doing so.
<span class="lineNum">     340 </span>            :     //
<span class="lineNum">     341 </span>            :     // This makes it difficult to detect the start of a new entry
<span class="lineNum">     342 </span>            :     // until it's been removed from the stdio buffer, so we just loop
<span class="lineNum">     343 </span>            :     // over all lines in the file in this routine.
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     const int argCount = 8;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     unsigned long long addrStart, addrEnd;
<span class="lineNum">     348 </span>            :     char perms[5];
<span class="lineNum">     349 </span>            :     unsigned long long offset;
<span class="lineNum">     350 </span>            :     // The 2.6 and 3.0 kernels allocate 12 bits for the major device number and
<span class="lineNum">     351 </span>            :     // 20 bits for the minor device number.  Future kernels might allocate more.
<span class="lineNum">     352 </span>            :     // 64 bits ought to be enough for anybody.
<span class="lineNum">     353 </span>            :     char devMajor[17];
<span class="lineNum">     354 </span>            :     char devMinor[17];
<span class="lineNum">     355 </span>            :     unsigned int inode;
<span class="lineNum">     356 </span>            :     char line[1025];
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :     // This variable holds the path of the current entry, or is void
<span class="lineNum">     359 </span>            :     // if we're scanning for the start of a new entry.
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     nsAutoCString currentPath;</span>
<span class="lineNum">     361 </span>            :     int pathOffset;
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     currentPath.SetIsVoid(true);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     while (fgets(line, sizeof(line), aFile)) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       if (currentPath.IsVoid()) {</span>
<span class="lineNum">     366 </span>            :         int n = sscanf(line,
<span class="lineNum">     367 </span>            :                        &quot;%llx-%llx %4s %llx &quot;
<span class="lineNum">     368 </span>            :                        &quot;%16[0-9a-fA-F]:%16[0-9a-fA-F] %u %n&quot;,
<span class="lineNum">     369 </span>            :                        &amp;addrStart, &amp;addrEnd, perms, &amp;offset, devMajor,
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                        devMinor, &amp;inode, &amp;pathOffset);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         if (n &gt;= argCount - 1) {</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :           currentPath.Assign(line + pathOffset);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :           currentPath.StripChars(&quot;\n&quot;);</span>
<span class="lineNum">     375 </span>            :         }
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     377 </span>            :       }
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :       // Now that we have a name and other metadata, scan for the PSS.
<span class="lineNum">     380 </span>            :       size_t pss_kb;
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       int n = sscanf(line, &quot;Pss: %zu&quot;, &amp;pss_kb);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       if (n &lt; 1) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     384 </span>            :       }
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       size_t pss = pss_kb * 1024;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       if (pss &gt; 0) {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         nsAutoCString name, description, tag;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         GetReporterNameAndDescription(currentPath.get(), perms, name, description, tag);</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         nsAutoCString processMemPath(&quot;mem/processes/&quot;);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         processMemPath.Append(aProcessName);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         processMemPath.Append('/');</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         processMemPath.Append(name);</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         REPORT(processMemPath, UNITS_BYTES, pss, description);</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :         // Increment the appropriate aProcessSizes values, and the total.
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         aProcessSizes-&gt;Add(tag, pss);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         *aTotalPss += pss;</span>
<span class="lineNum">     401 </span>            :       }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :       // Now that we've seen the PSS, we're done with this entry.
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       currentPath.SetIsVoid(true);</span>
<span class="lineNum">     405 </span>            :     }
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   void GetReporterNameAndDescription(const char* aPath,</span>
<span class="lineNum">     409 </span>            :                                      const char* aPerms,
<span class="lineNum">     410 </span>            :                                      nsACString&amp; aName,
<span class="lineNum">     411 </span>            :                                      nsACString&amp; aDesc,
<span class="lineNum">     412 </span>            :                                      nsACString&amp; aTag)
<span class="lineNum">     413 </span>            :   {
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     aName.Truncate();</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     aDesc.Truncate();</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     aTag.Truncate();</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :     // If aPath points to a file, we have its absolute path; it might
<span class="lineNum">     419 </span>            :     // also be a bracketed pseudo-name (see below).  In either case
<span class="lineNum">     420 </span>            :     // there is also some whitespace to trim.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     nsAutoCString absPath;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     absPath.Append(aPath);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     absPath.StripChars(&quot; &quot;);</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     if (absPath.EqualsLiteral(&quot;[heap]&quot;)) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;anonymous/brk-heap&quot;);</span>
<span class="lineNum">     427 </span>            :       aDesc.AppendLiteral(
<span class="lineNum">     428 </span>            :         &quot;Memory in anonymous mappings within the boundaries defined by &quot;
<span class="lineNum">     429 </span>            :         &quot;brk() / sbrk().  This is likely to be just a portion of the &quot;
<span class="lineNum">     430 </span>            :         &quot;application's heap; the remainder lives in other anonymous mappings. &quot;
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         &quot;This corresponds to '[heap]' in /proc/&lt;pid&gt;/smaps.&quot;);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       aTag = aName;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     } else if (absPath.EqualsLiteral(&quot;[stack]&quot;)) {</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;stack/main-thread&quot;);</span>
<span class="lineNum">     435 </span>            :       aDesc.AppendPrintf(
<span class="lineNum">     436 </span>            :         &quot;The stack size of the process's main thread.  This corresponds to &quot;
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         &quot;'[stack]' in /proc/&lt;pid&gt;/smaps.&quot;);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       aTag = aName;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     } else if (MozTaggedMemoryIsSupported() &amp;&amp;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                StringBeginsWith(absPath, NS_LITERAL_CSTRING(&quot;[stack:&quot;))) {</span>
<span class="lineNum">     441 </span>            :       // If tagged memory is supported, we can be reasonably sure that
<span class="lineNum">     442 </span>            :       // the virtual memory area containing the stack hasn't been
<span class="lineNum">     443 </span>            :       // merged with unrelated heap memory.  (This prevents the
<span class="lineNum">     444 </span>            :       // &quot;[stack:&quot; entries from reaching the IsAnonymous case below.)
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :       pid_t tid = atoi(absPath.get() + 7);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       nsAutoCString threadName, escapedThreadName;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       LinuxUtils::GetThreadName(tid, threadName);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       if (threadName.IsEmpty()) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :         threadName.AssignLiteral(&quot;&lt;unknown&gt;&quot;);</span>
<span class="lineNum">     450 </span>            :       }
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       escapedThreadName.Assign(threadName);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       escapedThreadName.StripChars(&quot;()&quot;);</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       escapedThreadName.ReplaceChar('/', '\\');</span>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;stack/non-main-thread&quot;);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;/name(&quot;);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       aName.Append(escapedThreadName);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       aName.Append(')');</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       aTag = aName;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       aName.AppendPrintf(&quot;/thread(%d)&quot;, tid);</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       aDesc.AppendPrintf(&quot;The stack size of a non-main thread named '%s' with &quot;</span>
<span class="lineNum">     463 </span>            :                          &quot;thread ID %d.  This corresponds to '[stack:%d]' &quot;
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                          &quot;in /proc/%d/smaps.&quot;, threadName.get(), tid, tid, tid);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     } else if (absPath.EqualsLiteral(&quot;[vdso]&quot;)) {</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;vdso&quot;);</span>
<span class="lineNum">     467 </span>            :       aDesc.AppendLiteral(
<span class="lineNum">     468 </span>            :         &quot;The virtual dynamically-linked shared object, also known as the &quot;
<span class="lineNum">     469 </span>            :         &quot;'vsyscall page'. This is a memory region mapped by the operating &quot;
<span class="lineNum">     470 </span>            :         &quot;system for the purpose of allowing processes to perform some &quot;
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         &quot;privileged actions without the overhead of a syscall.&quot;);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       aTag = aName;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     } else if (StringBeginsWith(absPath, NS_LITERAL_CSTRING(&quot;[anon:&quot;)) &amp;&amp;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                EndsWithLiteral(absPath, &quot;]&quot;)) {</span>
<span class="lineNum">     475 </span>            :       // It's tagged memory; see also &quot;mfbt/TaggedAnonymousMemory.h&quot;.
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       nsAutoCString tag(Substring(absPath, 6, absPath.Length() - 7));</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       aName.AppendLiteral(&quot;anonymous/&quot;);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       aName.Append(tag);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       aTag = aName;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       aDesc.AppendLiteral(&quot;Memory in anonymous mappings tagged with '&quot;);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       aDesc.Append(tag);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       aDesc.Append('\'');</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     } else if (!IsAnonymous(absPath)) {</span>
<span class="lineNum">     485 </span>            :       // We now know it's an actual file.  Truncate this to its
<span class="lineNum">     486 </span>            :       // basename, and put the absolute path in the description.
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       nsAutoCString basename, dirname;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       GetBasename(absPath, basename);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       GetDirname(absPath, dirname);</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :       // Hack: A file is a shared library if the basename contains &quot;.so&quot; and
<span class="lineNum">     492 </span>            :       // its dirname contains &quot;/lib&quot;, or if the basename ends with &quot;.so&quot;.
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       if (EndsWithLiteral(basename, &quot;.so&quot;) ||</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :           (basename.Find(&quot;.so&quot;) != -1 &amp;&amp; dirname.Find(&quot;/lib&quot;) != -1)) {</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         aName.AppendLiteral(&quot;shared-libraries/&quot;);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         aTag = aName;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         if (strncmp(aPerms, &quot;r-x&quot;, 3) == 0) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :           aTag.AppendLiteral(&quot;read-executable&quot;);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         } else if (strncmp(aPerms, &quot;rw-&quot;, 3) == 0) {</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :           aTag.AppendLiteral(&quot;read-write&quot;);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         } else if (strncmp(aPerms, &quot;r--&quot;, 3) == 0) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           aTag.AppendLiteral(&quot;read-only&quot;);</span>
<span class="lineNum">     504 </span>            :         } else {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :           aTag.AppendLiteral(&quot;other&quot;);</span>
<span class="lineNum">     506 </span>            :         }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :       } else {
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         aName.AppendLiteral(&quot;other-files&quot;);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         if (EndsWithLiteral(basename, &quot;.xpi&quot;)) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :           aName.AppendLiteral(&quot;/extensions&quot;);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         } else if (dirname.Find(&quot;/fontconfig&quot;) != -1) {</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :           aName.AppendLiteral(&quot;/fontconfig&quot;);</span>
<span class="lineNum">     514 </span>            :         } else {
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :           aName.AppendLiteral(&quot;/misc&quot;);</span>
<span class="lineNum">     516 </span>            :         }
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         aTag = aName;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         aName.Append('/');</span>
<span class="lineNum">     519 </span>            :       }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       aName.Append(basename);</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       aDesc.Append(absPath);</span>
<span class="lineNum">     523 </span>            :     } else {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (MozTaggedMemoryIsSupported()) {</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         aName.AppendLiteral(&quot;anonymous/untagged&quot;);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         aDesc.AppendLiteral(&quot;Memory in untagged anonymous mappings.&quot;);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         aTag = aName;</span>
<span class="lineNum">     528 </span>            :       } else {
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         aName.AppendLiteral(&quot;anonymous/outside-brk&quot;);</span>
<span class="lineNum">     530 </span>            :         aDesc.AppendLiteral(&quot;Memory in anonymous mappings outside the &quot;
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                             &quot;boundaries defined by brk() / sbrk().&quot;);</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         aTag = aName;</span>
<span class="lineNum">     533 </span>            :       }
<span class="lineNum">     534 </span>            :     }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     aName.AppendLiteral(&quot;/[&quot;);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     aName.Append(aPerms);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     aName.Append(']');</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :     // Append the permissions.  This is useful for non-verbose mode in
<span class="lineNum">     541 </span>            :     // about:memory when the filename is long and goes of the right side of the
<span class="lineNum">     542 </span>            :     // window.
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     aDesc.AppendLiteral(&quot; [&quot;);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     aDesc.Append(aPerms);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     aDesc.Append(']');</span>
<a name="546"><span class="lineNum">     546 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   void CollectPmemReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     549 </span>            :                           nsISupports* aData)
<span class="lineNum">     550 </span>            :   {
<span class="lineNum">     551 </span>            :     // The pmem subsystem allocates physically contiguous memory for
<span class="lineNum">     552 </span>            :     // interfacing with hardware.  In order to ensure availability,
<span class="lineNum">     553 </span>            :     // this memory is reserved during boot, and allocations are made
<span class="lineNum">     554 </span>            :     // within these regions at runtime.
<span class="lineNum">     555 </span>            :     //
<span class="lineNum">     556 </span>            :     // There are typically several of these pools allocated at boot.
<span class="lineNum">     557 </span>            :     // The /sys/kernel/pmem_regions directory contains a subdirectory
<span class="lineNum">     558 </span>            :     // for each one.  Within each subdirectory, the files we care
<span class="lineNum">     559 </span>            :     // about are &quot;size&quot; (the total amount of physical memory) and
<span class="lineNum">     560 </span>            :     // &quot;mapped_regions&quot; (a list of the current allocations within that
<span class="lineNum">     561 </span>            :     // area).
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     DIR* d = opendir(&quot;/sys/kernel/pmem_regions&quot;);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     if (!d) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     565 </span>            :     }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :     struct dirent* ent;
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     while ((ent = readdir(d))) {</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :       const char* name = ent-&gt;d_name;</span>
<span class="lineNum">     570 </span>            :       uint64_t size;
<span class="lineNum">     571 </span>            :       int scanned;
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :       // Skip &quot;.&quot; and &quot;..&quot; (and any other dotfiles).
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       if (name[0] == '.') {</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     576 </span>            :       }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :       // Read the total size.  The file gives the size in decimal and
<span class="lineNum">     579 </span>            :       // hex, in the form &quot;13631488(0xd00000)&quot;; we parse the former.
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :       nsPrintfCString sizePath(&quot;/sys/kernel/pmem_regions/%s/size&quot;, name);</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       FILE* sizeFile = fopen(sizePath.get(), &quot;r&quot;);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       if (NS_WARN_IF(!sizeFile)) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     584 </span>            :       }
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       scanned = fscanf(sizeFile, &quot;%&quot; SCNu64, &amp;size);</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       fclose(sizeFile);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       if (NS_WARN_IF(scanned != 1)) {</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     589 </span>            :       }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :       // Read mapped regions; format described below.
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       uint64_t freeSize = size;</span>
<span class="lineNum">     593 </span>            :       nsPrintfCString regionsPath(&quot;/sys/kernel/pmem_regions/%s/mapped_regions&quot;,
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                                   name);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       FILE* regionsFile = fopen(regionsPath.get(), &quot;r&quot;);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :       if (regionsFile) {</span>
<span class="lineNum">     597 </span>            :         static const size_t bufLen = 4096;
<span class="lineNum">     598 </span>            :         char buf[bufLen];
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :         while (fgets(buf, bufLen, regionsFile)) {</span>
<span class="lineNum">     600 </span>            :           int pid;
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :           // Skip header line.
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :           if (strncmp(buf, &quot;pid #&quot;, 5) == 0) {</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     605 </span>            :           }
<span class="lineNum">     606 </span>            :           // Line format: &quot;pid N:&quot; + zero or more &quot;(Start,Len) &quot;.
<span class="lineNum">     607 </span>            :           // N is decimal; Start and Len are in hex.
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :           scanned = sscanf(buf, &quot;pid %d&quot;, &amp;pid);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :           if (NS_WARN_IF(scanned != 1)) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     611 </span>            :           }
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :           for (const char* nextParen = strchr(buf, '(');</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                nextParen != nullptr;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                nextParen = strchr(nextParen + 1, '(')) {</span>
<span class="lineNum">     615 </span>            :             uint64_t mapStart, mapLen;
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :             scanned = sscanf(nextParen + 1, &quot;%&quot; SCNx64 &quot;,%&quot; SCNx64,</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                              &amp;mapStart, &amp;mapLen);</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             if (NS_WARN_IF(scanned != 2)) {</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     621 </span>            :             }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :             nsPrintfCString path(&quot;mem/pmem/used/%s/segment(pid=%d, &quot;
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :                                  &quot;offset=0x%&quot; PRIx64 &quot;)&quot;, name, pid, mapStart);</span>
<span class="lineNum">     625 </span>            :             nsPrintfCString desc(&quot;Physical memory reserved for the \&quot;%s\&quot; pool &quot;
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                                  &quot;and allocated to a buffer.&quot;, name);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :             REPORT(path, UNITS_BYTES, mapLen, desc);</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             freeSize -= mapLen;</span>
<span class="lineNum">     629 </span>            :           }
<span class="lineNum">     630 </span>            :         }
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :         fclose(regionsFile);</span>
<span class="lineNum">     632 </span>            :       }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       nsPrintfCString path(&quot;mem/pmem/free/%s&quot;, name);</span>
<span class="lineNum">     635 </span>            :       nsPrintfCString desc(&quot;Physical memory reserved for the \&quot;%s\&quot; pool and &quot;
<span class="lineNum">     636 </span>            :                            &quot;unavailable to the rest of the system, but not &quot;
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                            &quot;currently allocated.&quot;, name);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       REPORT(path, UNITS_BYTES, freeSize, desc);</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     closedir(d);</span>
<span class="lineNum">     641 </span>            :   }
<a name="642"><span class="lineNum">     642 </span>            : </a>
<span class="lineNum">     643 </span>            :   void
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   CollectIonReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     645 </span>            :                     nsISupports* aData)
<span class="lineNum">     646 </span>            :   {
<span class="lineNum">     647 </span>            :     // ION is a replacement for PMEM (and other similar allocators).
<span class="lineNum">     648 </span>            :     //
<span class="lineNum">     649 </span>            :     // More details from http://lwn.net/Articles/480055/
<span class="lineNum">     650 </span>            :     //  &quot;Like its PMEM-like predecessors, ION manages one or more memory pools,
<span class="lineNum">     651 </span>            :     //   some of which are set aside at boot time to combat fragmentation or to
<span class="lineNum">     652 </span>            :     //   serve special hardware needs. GPUs, display controllers, and cameras
<span class="lineNum">     653 </span>            :     //   are some of the hardware blocks that may have special memory
<span class="lineNum">     654 </span>            :     //   requirements.&quot;
<span class="lineNum">     655 </span>            :     //
<span class="lineNum">     656 </span>            :     // The file format starts as follows:
<span class="lineNum">     657 </span>            :     //     client              pid             size
<span class="lineNum">     658 </span>            :     //     ----------------------------------------------------
<span class="lineNum">     659 </span>            :     //     adsprpc-smd                1             4096
<span class="lineNum">     660 </span>            :     //     fd900000.qcom,mdss_mdp     1          1658880
<span class="lineNum">     661 </span>            :     //     ----------------------------------------------------
<span class="lineNum">     662 </span>            :     //     orphaned allocations (info is from last known client):
<span class="lineNum">     663 </span>            :     //     Homescreen            24100           294912 0 1
<span class="lineNum">     664 </span>            :     //     b2g                   23987          1658880 0 1
<span class="lineNum">     665 </span>            :     //     mdss_fb0                401          1658880 0 1
<span class="lineNum">     666 </span>            :     //     b2g                   23987             4096 0 1
<span class="lineNum">     667 </span>            :     //     Built-in Keyboa       24205            61440 0 1
<span class="lineNum">     668 </span>            :     //     ----------------------------------------------------
<span class="lineNum">     669 </span>            :     //     &lt;other stuff&gt;
<span class="lineNum">     670 </span>            :     //
<span class="lineNum">     671 </span>            :     // For our purposes we only care about the first portion of the file noted
<span class="lineNum">     672 </span>            :     // above which contains memory alloations (both sections). The term
<span class="lineNum">     673 </span>            :     // &quot;orphaned&quot; is misleading, it appears that every allocation not by the
<span class="lineNum">     674 </span>            :     // first process is considered orphaned on FxOS devices.
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :     // The first three fields of each entry interest us:
<span class="lineNum">     677 </span>            :     //   1) client - Essentially the process name. We limit client names to 63
<span class="lineNum">     678 </span>            :     //               characters, in theory they should never be greater than 15
<span class="lineNum">     679 </span>            :     //               due to thread name length limitations.
<span class="lineNum">     680 </span>            :     //   2) pid    - The ID of the allocating process, read as a uint32_t.
<span class="lineNum">     681 </span>            :     //   3) size   - The size of the allocation in bytes, read as as a uint64_t.
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     const char* const kFormatString = &quot;%63s %&quot; SCNu32 &quot; %&quot; SCNu64;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     const int kNumFields = 3;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     const size_t kStringSize = 64;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     const char* const kIonIommuPath = &quot;/sys/kernel/debug/ion/iommu&quot;;</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     FILE* iommu = fopen(kIonIommuPath, &quot;r&quot;);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     if (!iommu) {</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     690 </span>            :     }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     AutoFile iommuGuard(iommu);</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     const size_t kBufferLen = 256;</span>
<span class="lineNum">     695 </span>            :     char buffer[kBufferLen];
<span class="lineNum">     696 </span>            :     char client[kStringSize];
<span class="lineNum">     697 </span>            :     uint32_t pid;
<span class="lineNum">     698 </span>            :     uint64_t size;
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     // Ignore the header line.
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     Unused &lt;&lt; fgets(buffer, kBufferLen, iommu);</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :     // Ignore the separator line.
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     Unused &lt;&lt; fgets(buffer, kBufferLen, iommu);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     const char* const kSep = &quot;----&quot;;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     const size_t kSepLen = 4;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :     // Read non-orphaned entries.
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     while (fgets(buffer, kBufferLen, iommu) &amp;&amp;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :            strncmp(kSep, buffer, kSepLen) != 0) {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       if (sscanf(buffer, kFormatString, client, &amp;pid, &amp;size) == kNumFields) {</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         nsPrintfCString entryPath(&quot;ion-memory/%s (pid=%d)&quot;, client, pid);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         REPORT(entryPath, UNITS_BYTES, size,</span>
<span class="lineNum">     715 </span>            :                NS_LITERAL_CSTRING(&quot;An ION kernel memory allocation.&quot;));
<span class="lineNum">     716 </span>            :       }
<span class="lineNum">     717 </span>            :     }
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :     // Ignore the orphaned header.
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     Unused &lt;&lt; fgets(buffer, kBufferLen, iommu);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     // Read orphaned entries.
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     while (fgets(buffer, kBufferLen, iommu) &amp;&amp;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :            strncmp(kSep, buffer, kSepLen) != 0) {</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       if (sscanf(buffer, kFormatString, client, &amp;pid, &amp;size) == kNumFields) {</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         nsPrintfCString entryPath(&quot;ion-memory/%s (pid=%d)&quot;, client, pid);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         REPORT(entryPath, UNITS_BYTES, size,</span>
<span class="lineNum">     728 </span>            :                NS_LITERAL_CSTRING(&quot;An ION kernel memory allocation.&quot;));
<span class="lineNum">     729 </span>            :       }
<span class="lineNum">     730 </span>            :     }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :     // Ignore the rest of the file.
<span class="lineNum">     733 </span>            :   }
<a name="734"><span class="lineNum">     734 </span>            : </a>
<span class="lineNum">     735 </span>            :   uint64_t
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   ReadSizeFromFile(const char* aFilename)</span>
<span class="lineNum">     737 </span>            :   {
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     FILE* sizeFile = fopen(aFilename, &quot;r&quot;);</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     if (NS_WARN_IF(!sizeFile)) {</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     741 </span>            :     }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     uint64_t size = 0;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     Unused &lt;&lt; fscanf(sizeFile, &quot;%&quot; SCNu64, &amp;size);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     fclose(sizeFile);</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     return size;</span>
<span class="lineNum">     748 </span>            :   }
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            :   void
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   CollectZramReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     752 </span>            :                      nsISupports* aData)
<span class="lineNum">     753 </span>            :   {
<span class="lineNum">     754 </span>            :     // zram usage stats files can be found under:
<span class="lineNum">     755 </span>            :     //  /sys/block/zram&lt;id&gt;
<span class="lineNum">     756 </span>            :     //  |--&gt; disksize        - Maximum amount of uncompressed data that can be
<span class="lineNum">     757 </span>            :     //                         stored on the disk (bytes)
<span class="lineNum">     758 </span>            :     //  |--&gt; orig_data_size  - Uncompressed size of data in the disk (bytes)
<span class="lineNum">     759 </span>            :     //  |--&gt; compr_data_size - Compressed size of the data in the disk (bytes)
<span class="lineNum">     760 </span>            :     //  |--&gt; num_reads       - Number of attempted reads to the disk (count)
<span class="lineNum">     761 </span>            :     //  |--&gt; num_writes      - Number of attempted writes to the disk (count)
<span class="lineNum">     762 </span>            :     //
<span class="lineNum">     763 </span>            :     // Each file contains a single integer value in decimal form.
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     DIR* d = opendir(&quot;/sys/block&quot;);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     if (!d) {</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     768 </span>            :     }
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     struct dirent* ent;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     while ((ent = readdir(d))) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       const char* name = ent-&gt;d_name;</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :       // Skip non-zram entries.
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       if (strncmp(&quot;zram&quot;, name, 4) != 0) {</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     777 </span>            :       }
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :       // Report disk size statistics.
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       nsPrintfCString diskSizeFile(&quot;/sys/block/%s/disksize&quot;, name);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       nsPrintfCString origSizeFile(&quot;/sys/block/%s/orig_data_size&quot;, name);</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       uint64_t diskSize = ReadSizeFromFile(diskSizeFile.get());</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       uint64_t origSize = ReadSizeFromFile(origSizeFile.get());</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       uint64_t unusedSize = diskSize - origSize;</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       nsPrintfCString diskUsedPath(&quot;zram-disksize/%s/used&quot;, name);</span>
<span class="lineNum">     788 </span>            :       nsPrintfCString diskUsedDesc(
<span class="lineNum">     789 </span>            :         &quot;The uncompressed size of data stored in \&quot;%s.\&quot; &quot;
<span class="lineNum">     790 </span>            :         &quot;This excludes zero-filled pages since &quot;
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         &quot;no memory is allocated for them.&quot;, name);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       REPORT(diskUsedPath, UNITS_BYTES, origSize, diskUsedDesc);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       nsPrintfCString diskUnusedPath(&quot;zram-disksize/%s/unused&quot;, name);</span>
<span class="lineNum">     795 </span>            :       nsPrintfCString diskUnusedDesc(
<span class="lineNum">     796 </span>            :         &quot;The amount of uncompressed data that can still be &quot;
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         &quot;be stored in \&quot;%s\&quot;&quot;, name);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :       REPORT(diskUnusedPath, UNITS_BYTES, unusedSize, diskUnusedDesc);</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :       // Report disk accesses.
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       nsPrintfCString readsFile(&quot;/sys/block/%s/num_reads&quot;, name);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       nsPrintfCString writesFile(&quot;/sys/block/%s/num_writes&quot;, name);</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :       uint64_t reads = ReadSizeFromFile(readsFile.get());</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       uint64_t writes = ReadSizeFromFile(writesFile.get());</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :       nsPrintfCString readsDesc(
<span class="lineNum">     808 </span>            :         &quot;The number of reads (failed or successful) done on &quot;
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         &quot;\&quot;%s\&quot;&quot;, name);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       nsPrintfCString readsPath(&quot;zram-accesses/%s/reads&quot;, name);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :       REPORT(readsPath, UNITS_COUNT_CUMULATIVE, reads, readsDesc);</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :       nsPrintfCString writesDesc(
<span class="lineNum">     814 </span>            :         &quot;The number of writes (failed or successful) done &quot;
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         &quot;on \&quot;%s\&quot;&quot;, name);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       nsPrintfCString writesPath(&quot;zram-accesses/%s/writes&quot;, name);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       REPORT(writesPath, UNITS_COUNT_CUMULATIVE, writes, writesDesc);</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :       // Report compressed data size.
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       nsPrintfCString comprSizeFile(&quot;/sys/block/%s/compr_data_size&quot;, name);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       uint64_t comprSize = ReadSizeFromFile(comprSizeFile.get());</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :       nsPrintfCString comprSizeDesc(
<span class="lineNum">     824 </span>            :         &quot;The compressed size of data stored in \&quot;%s\&quot;&quot;,
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         name);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :       nsPrintfCString comprSizePath(&quot;zram-compr-data-size/%s&quot;, name);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       REPORT(comprSizePath, UNITS_BYTES, comprSize, comprSizeDesc);</span>
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     closedir(d);</span>
<span class="lineNum">     831 </span>            :   }
<a name="832"><span class="lineNum">     832 </span>            : </a>
<span class="lineNum">     833 </span>            :   void
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   CollectOpenFileReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     835 </span>            :                          nsISupports* aData,
<span class="lineNum">     836 </span>            :                          const nsACString&amp; aProcPath,
<span class="lineNum">     837 </span>            :                          const nsACString&amp; aProcessName)
<span class="lineNum">     838 </span>            :   {
<span class="lineNum">     839 </span>            :     // All file descriptors opened by a process are listed under
<span class="lineNum">     840 </span>            :     // /proc/&lt;pid&gt;/fd/&lt;numerical_fd&gt;. Each entry is a symlink that points to the
<span class="lineNum">     841 </span>            :     // path that was opened. This can be an actual file, a socket, a pipe, an
<span class="lineNum">     842 </span>            :     // anon_inode, or possibly an uncategorized device.
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     const char kFilePrefix[] = &quot;/&quot;;</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     const char kSocketPrefix[] = &quot;socket:&quot;;</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     const char kPipePrefix[] = &quot;pipe:&quot;;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     const char kAnonInodePrefix[] = &quot;anon_inode:&quot;;</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     const nsCString procPath(aProcPath);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     DIR* d = opendir(procPath.get());</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     if (!d) {</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     852 </span>            :     }
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :     char linkPath[PATH_MAX + 1];
<span class="lineNum">     855 </span>            :     struct dirent* ent;
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     while ((ent = readdir(d))) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       const char* fd = ent-&gt;d_name;</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :       // Skip &quot;.&quot; and &quot;..&quot; (and any other dotfiles).
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       if (fd[0] == '.') {</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     862 </span>            :       }
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       nsPrintfCString fullPath(&quot;%s/%s&quot;, procPath.get(), fd);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :       ssize_t linkPathSize = readlink(fullPath.get(), linkPath, PATH_MAX);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       if (linkPathSize &gt; 0) {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         linkPath[linkPathSize] = '\0';</span>
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            : #define CHECK_PREFIX(prefix) \
<span class="lineNum">     870 </span>            :   (strncmp(linkPath, prefix, sizeof(prefix) - 1) == 0)
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         const char* category = nullptr;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         const char* descriptionPrefix = nullptr;</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         if (CHECK_PREFIX(kFilePrefix)) {</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :           category = &quot;files&quot;; // No trailing slash, the file path will have one</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :           descriptionPrefix = &quot;An open&quot;;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         } else if (CHECK_PREFIX(kSocketPrefix)) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :           category = &quot;sockets/&quot;;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :           descriptionPrefix = &quot;A socket&quot;;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         } else if (CHECK_PREFIX(kPipePrefix)) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :           category = &quot;pipes/&quot;;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :           descriptionPrefix = &quot;A pipe&quot;;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         } else if (CHECK_PREFIX(kAnonInodePrefix)) {</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :           category = &quot;anon_inodes/&quot;;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :           descriptionPrefix = &quot;An anon_inode&quot;;</span>
<span class="lineNum">     887 </span>            :         } else {
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           category = &quot;&quot;;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           descriptionPrefix = &quot;An uncategorized&quot;;</span>
<span class="lineNum">     890 </span>            :         }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            : #undef CHECK_PREFIX
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         const nsCString processName(aProcessName);</span>
<span class="lineNum">     895 </span>            :         nsPrintfCString entryPath(&quot;open-fds/%s/%s%s/%s&quot;,
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                                   processName.get(), category, linkPath, fd);</span>
<span class="lineNum">     897 </span>            :         nsPrintfCString entryDescription(&quot;%s file descriptor opened by the process&quot;,
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                                          descriptionPrefix);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         REPORT(entryPath, UNITS_COUNT, 1, entryDescription);</span>
<span class="lineNum">     900 </span>            :       }
<span class="lineNum">     901 </span>            :     }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     closedir(d);</span>
<span class="lineNum">     904 </span>            :   }
<a name="905"><span class="lineNum">     905 </span>            : </a>
<span class="lineNum">     906 </span>            :   void
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   CollectKgslReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">     908 </span>            :                      nsISupports* aData)
<span class="lineNum">     909 </span>            :   {
<span class="lineNum">     910 </span>            :     // Each process that uses kgsl memory will have an entry under
<span class="lineNum">     911 </span>            :     // /sys/kernel/debug/kgsl/proc/&lt;pid&gt;/mem. This file format includes a
<span class="lineNum">     912 </span>            :     // header and then entries with types as follows:
<span class="lineNum">     913 </span>            :     //   gpuaddr useraddr size id  flags type usage sglen
<span class="lineNum">     914 </span>            :     //   hexaddr hexaddr  int  int str   str  str   int
<span class="lineNum">     915 </span>            :     // We care primarily about the usage and size.
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     // For simplicity numbers will be uint64_t, strings 63 chars max.
<span class="lineNum">     918 </span>            :     const char* const kScanFormat =
<span class="lineNum">     919 </span>            :       &quot;%&quot; SCNx64 &quot; %&quot; SCNx64 &quot; %&quot; SCNu64 &quot; %&quot; SCNu64
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       &quot; %63s %63s %63s %&quot; SCNu64;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     const int kNumFields = 8;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     const size_t kStringSize = 64;</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     DIR* d = opendir(&quot;/sys/kernel/debug/kgsl/proc/&quot;);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     if (!d) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     AutoDir dirGuard(d);</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :     struct dirent* ent;
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     while ((ent = readdir(d))) {</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       const char* pid = ent-&gt;d_name;</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :       // Skip &quot;.&quot; and &quot;..&quot; (and any other dotfiles).
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :       if (pid[0] == '.') {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     938 </span>            :       }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :       nsPrintfCString memPath(&quot;/sys/kernel/debug/kgsl/proc/%s/mem&quot;, pid);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       FILE* memFile = fopen(memPath.get(), &quot;r&quot;);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       if (NS_WARN_IF(!memFile)) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     944 </span>            :       }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :       AutoFile fileGuard(memFile);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :       // Attempt to map the pid to a more useful name.
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :       nsAutoCString procName;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :       LinuxUtils::GetThreadName(atoi(pid), procName);</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       if (procName.IsEmpty()) {</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         procName.Append(&quot;pid=&quot;);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         procName.Append(pid);</span>
<span class="lineNum">     955 </span>            :       } else {
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         procName.Append(&quot; (pid=&quot;);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         procName.Append(pid);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         procName.Append(&quot;)&quot;);</span>
<span class="lineNum">     959 </span>            :       }
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :       uint64_t gpuaddr, useraddr, size, id, sglen;
<span class="lineNum">     962 </span>            :       char flags[kStringSize];
<span class="lineNum">     963 </span>            :       char type[kStringSize];
<span class="lineNum">     964 </span>            :       char usage[kStringSize];
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :       // Bypass the header line.
<span class="lineNum">     967 </span>            :       char buff[1024];
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       Unused &lt;&lt; fgets(buff, 1024, memFile);</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :       while (fscanf(memFile, kScanFormat, &amp;gpuaddr, &amp;useraddr, &amp;size, &amp;id,</span>
<span class="lineNum">     971 </span>            :                     flags, type, usage, &amp;sglen) == kNumFields) {
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         nsPrintfCString entryPath(&quot;kgsl-memory/%s/%s&quot;, procName.get(), usage);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         REPORT(entryPath, UNITS_BYTES, size,</span>
<span class="lineNum">     974 </span>            :                NS_LITERAL_CSTRING(&quot;A kgsl graphics memory allocation.&quot;));
<span class="lineNum">     975 </span>            :       }
<span class="lineNum">     976 </span>            :     }
<span class="lineNum">     977 </span>            :   }
<a name="978"><span class="lineNum">     978 </span>            : };</a>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineCov">         13 : NS_IMPL_ISUPPORTS(SystemReporter, nsIMemoryReporter)</span>
<a name="981"><span class="lineNum">     981 </span>            : </a>
<span class="lineNum">     982 </span>            : void
<span class="lineNum">     983 </span><span class="lineCov">          1 : Init()</span>
<span class="lineNum">     984 </span>            : {
<span class="lineNum">     985 </span><span class="lineCov">          1 :   RegisterStrongMemoryReporter(new SystemReporter());</span>
<span class="lineNum">     986 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            : } // namespace SystemMemoryReporter
<span class="lineNum">     989 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

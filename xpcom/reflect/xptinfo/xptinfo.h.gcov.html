<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - xpcom/reflect/xptinfo/xptinfo.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">xpcom/reflect/xptinfo</a> - xptinfo.h<span style="font-size: 80%;"> (source / <a href="xptinfo.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">53</td>
            <td class="headerCovTableEntry">54</td>
            <td class="headerCovTableEntryHi">98.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryHi">96.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : /* XPTI_PUBLIC_API and XPTI_GetInterfaceInfoManager declarations. */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #ifndef xptiinfo_h___
<span class="lineNum">       9 </span>            : #define xptiinfo_h___
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;nscore.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;xpt_struct.h&quot;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : // Flyweight wrapper classes for xpt_struct.h structs.
<span class="lineNum">      15 </span>            : // Everything here is dependent upon - and sensitive to changes in -
<span class="lineNum">      16 </span>            : // xpcom/typelib/xpt/xpt_struct.h!
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : class nsXPTType : public XPTTypeDescriptorPrefix
<span class="lineNum">      19 </span>            : {
<a name="20"><span class="lineNum">      20 </span>            : // NO DATA - this a flyweight wrapper</a>
<span class="lineNum">      21 </span>            : public:
<a name="22"><span class="lineNum">      22 </span><span class="lineCov">      38412 :     nsXPTType()</span></a>
<span class="lineNum">      23 </span><span class="lineCov">      38412 :         {}    // random contents</span>
<span class="lineNum">      24 </span><span class="lineCov">     151299 :     MOZ_IMPLICIT nsXPTType(const XPTTypeDescriptorPrefix&amp; prefix)</span>
<a name="25"><span class="lineNum">      25 </span><span class="lineCov">     151299 :         {*(XPTTypeDescriptorPrefix*)this = prefix;}</span></a>
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span><span class="lineCov">        142 :     MOZ_IMPLICIT nsXPTType(const uint8_t&amp; prefix)</span>
<a name="28"><span class="lineNum">      28 </span><span class="lineCov">        142 :         {*(uint8_t*)this = prefix;}</span></a>
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span><span class="lineCov">       3401 :     nsXPTType&amp; operator=(uint8_t val)</span>
<a name="31"><span class="lineNum">      31 </span><span class="lineCov">       3401 :         {flags = val; return *this;}</span></a>
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineCov">      35034 :     nsXPTType&amp; operator=(const nsXPTType&amp; other)</span>
<a name="34"><span class="lineNum">      34 </span><span class="lineCov">      35034 :         {flags = other.flags; return *this;}</span></a>
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span><span class="lineCov">      53422 :     operator uint8_t() const</span>
<span class="lineNum">      37 </span><span class="lineCov">      53422 :         {return flags;}</span>
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :     // 'Arithmetic' here roughly means that the value is self-contained and
<span class="lineNum">      40 </span>            :     // doesn't depend on anything else in memory (ie: not a pointer, not an
<span class="lineNum">      41 </span>            :     // XPCOM object, not a jsval, etc).
<span class="lineNum">      42 </span>            :     //
<span class="lineNum">      43 </span>            :     // Supposedly this terminology comes from Harbison/Steele, but it's still
<a name="44"><span class="lineNum">      44 </span>            :     // a rather crappy name. We'd change it if it wasn't used all over the</a>
<span class="lineNum">      45 </span>            :     // place in xptcall. :-(
<span class="lineNum">      46 </span><span class="lineCov">      34288 :     bool IsArithmetic() const</span>
<span class="lineNum">      47 </span><span class="lineCov">      34288 :         {return flags &lt;= T_WCHAR;}</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :     // We used to abuse 'pointer' flag bit in typelib format quite extensively.
<span class="lineNum">      50 </span>            :     // We've gotten rid of most of the cases, but there's still a fair amount
<span class="lineNum">      51 </span>            :     // of refactoring to be done in XPCWrappedJSClass before we can safely stop
<a name="52"><span class="lineNum">      52 </span>            :     // asking about this. In the mean time, we've got a temporary version of</a>
<span class="lineNum">      53 </span>            :     // IsPointer() that should be equivalent to what's in the typelib.
<span class="lineNum">      54 </span><span class="lineCov">        234 :     bool deprecated_IsPointer() const</span>
<a name="55"><span class="lineNum">      55 </span><span class="lineCov">        234 :         {return !IsArithmetic() &amp;&amp; TagPart() != T_JSVAL;}</span></a>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span><span class="lineCov">       9968 :     bool IsInterfacePointer() const</span>
<span class="lineNum">      58 </span><span class="lineCov">       9968 :         {  switch (TagPart()) {</span>
<span class="lineNum">      59 </span>            :              default:
<span class="lineNum">      60 </span><span class="lineCov">       7192 :                return false;</span>
<span class="lineNum">      61 </span>            :              case T_INTERFACE:
<span class="lineNum">      62 </span>            :              case T_INTERFACE_IS:
<span class="lineNum">      63 </span><span class="lineCov">       2776 :                return true;</span>
<span class="lineNum">      64 </span>            :            }
<a name="65"><span class="lineNum">      65 </span>            :         }</a>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span><span class="lineCov">      34984 :     bool IsArray() const</span>
<span class="lineNum">      68 </span><span class="lineCov">      34984 :         {return TagPart() == T_ARRAY;}</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :     // 'Dependent' means that params of this type are dependent upon other
<a name="71"><span class="lineNum">      71 </span>            :     // params. e.g. an T_INTERFACE_IS is dependent upon some other param at</a>
<span class="lineNum">      72 </span>            :     // runtime to say what the interface type of this param really is.
<span class="lineNum">      73 </span><span class="lineCov">      25631 :     bool IsDependent() const</span>
<span class="lineNum">      74 </span><span class="lineCov">      25631 :         {  switch (TagPart()) {</span>
<span class="lineNum">      75 </span>            :              default:
<span class="lineNum">      76 </span><span class="lineCov">      25347 :                return false;</span>
<span class="lineNum">      77 </span>            :              case T_INTERFACE_IS:
<span class="lineNum">      78 </span>            :              case TD_ARRAY:
<span class="lineNum">      79 </span>            :              case T_PSTRING_SIZE_IS:
<span class="lineNum">      80 </span>            :              case T_PWSTRING_SIZE_IS:
<span class="lineNum">      81 </span><span class="lineCov">        284 :                return true;</span>
<span class="lineNum">      82 </span>            :            }
<a name="83"><span class="lineNum">      83 </span>            :         }</a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineCov">     266098 :     uint8_t TagPart() const</span>
<span class="lineNum">      86 </span><span class="lineCov">     266098 :         {return (uint8_t) (flags &amp; XPT_TDP_TAGMASK);}</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     enum
<span class="lineNum">      89 </span>            :     {
<span class="lineNum">      90 </span>            :         T_I8                = TD_INT8             ,
<span class="lineNum">      91 </span>            :         T_I16               = TD_INT16            ,
<span class="lineNum">      92 </span>            :         T_I32               = TD_INT32            ,
<span class="lineNum">      93 </span>            :         T_I64               = TD_INT64            ,
<span class="lineNum">      94 </span>            :         T_U8                = TD_UINT8            ,
<span class="lineNum">      95 </span>            :         T_U16               = TD_UINT16           ,
<span class="lineNum">      96 </span>            :         T_U32               = TD_UINT32           ,
<span class="lineNum">      97 </span>            :         T_U64               = TD_UINT64           ,
<span class="lineNum">      98 </span>            :         T_FLOAT             = TD_FLOAT            ,
<span class="lineNum">      99 </span>            :         T_DOUBLE            = TD_DOUBLE           ,
<span class="lineNum">     100 </span>            :         T_BOOL              = TD_BOOL             ,
<span class="lineNum">     101 </span>            :         T_CHAR              = TD_CHAR             ,
<span class="lineNum">     102 </span>            :         T_WCHAR             = TD_WCHAR            ,
<span class="lineNum">     103 </span>            :         T_VOID              = TD_VOID             ,
<span class="lineNum">     104 </span>            :         T_IID               = TD_PNSIID           ,
<span class="lineNum">     105 </span>            :         T_DOMSTRING         = TD_DOMSTRING        ,
<span class="lineNum">     106 </span>            :         T_CHAR_STR          = TD_PSTRING          ,
<span class="lineNum">     107 </span>            :         T_WCHAR_STR         = TD_PWSTRING         ,
<span class="lineNum">     108 </span>            :         T_INTERFACE         = TD_INTERFACE_TYPE   ,
<span class="lineNum">     109 </span>            :         T_INTERFACE_IS      = TD_INTERFACE_IS_TYPE,
<span class="lineNum">     110 </span>            :         T_ARRAY             = TD_ARRAY            ,
<span class="lineNum">     111 </span>            :         T_PSTRING_SIZE_IS   = TD_PSTRING_SIZE_IS  ,
<span class="lineNum">     112 </span>            :         T_PWSTRING_SIZE_IS  = TD_PWSTRING_SIZE_IS ,
<span class="lineNum">     113 </span>            :         T_UTF8STRING        = TD_UTF8STRING       ,
<span class="lineNum">     114 </span>            :         T_CSTRING           = TD_CSTRING          ,
<span class="lineNum">     115 </span>            :         T_ASTRING           = TD_ASTRING          ,
<span class="lineNum">     116 </span>            :         T_JSVAL             = TD_JSVAL
<span class="lineNum">     117 </span>            :     };
<span class="lineNum">     118 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     119 </span>            : };
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : class nsXPTParamInfo : public XPTParamDescriptor
<span class="lineNum">     122 </span>            : {
<a name="123"><span class="lineNum">     123 </span>            : // NO DATA - this a flyweight wrapper</a>
<span class="lineNum">     124 </span>            : public:
<span class="lineNum">     125 </span><span class="lineCov">     167000 :     MOZ_IMPLICIT nsXPTParamInfo(const XPTParamDescriptor&amp; desc)</span>
<span class="lineNum">     126 </span><span class="lineCov">     167000 :         {*(XPTParamDescriptor*)this = desc;}</span>
<a name="127"><span class="lineNum">     127 </span>            : </a>
<a name="128"><span class="lineNum">     128 </span>            : </a>
<a name="129"><span class="lineNum">     129 </span><span class="lineCov">      26206 :     bool IsIn()  const    {return 0 != (XPT_PD_IS_IN(flags));}</span></a>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">      95197 :     bool IsOut() const    {return 0 != (XPT_PD_IS_OUT(flags));}</span></a>
<span class="lineNum">     131 </span><span class="lineCov">      32058 :     bool IsRetval() const {return 0 != (XPT_PD_IS_RETVAL(flags));}</span>
<span class="lineNum">     132 </span><span class="lineCov">      26512 :     bool IsShared() const {return 0 != (XPT_PD_IS_SHARED(flags));}</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :     // Dipper types are one of the more inscrutable aspects of xpidl. In a
<span class="lineNum">     135 </span>            :     // nutshell, dippers are empty container objects, created and passed by
<span class="lineNum">     136 </span>            :     // the caller, and filled by the callee. The callee receives a fully-
<span class="lineNum">     137 </span>            :     // formed object, and thus does not have to construct anything. But
<span class="lineNum">     138 </span>            :     // the object is functionally empty, and the callee is responsible for
<span class="lineNum">     139 </span>            :     // putting something useful inside of it.
<span class="lineNum">     140 </span>            :     //
<span class="lineNum">     141 </span>            :     // XPIDL decides which types to make dippers. The list of these types
<span class="lineNum">     142 </span>            :     // is given in the isDipperType() function in typelib.py, and is currently
<span class="lineNum">     143 </span>            :     // limited to 4 string types.
<span class="lineNum">     144 </span>            :     //
<span class="lineNum">     145 </span>            :     // When a dipper type is declared as an 'out' parameter, xpidl internally
<span class="lineNum">     146 </span>            :     // converts it to an 'in', and sets the XPT_PD_DIPPER flag on it. For this
<span class="lineNum">     147 </span>            :     // reason, dipper types are sometimes referred to as 'out parameters
<span class="lineNum">     148 </span>            :     // masquerading as in'. The burden of maintaining this illusion falls mostly
<a name="149"><span class="lineNum">     149 </span>            :     // on XPConnect, which creates the empty containers, and harvest the results</a>
<a name="150"><span class="lineNum">     150 </span>            :     // after the call.</a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">      41054 :     bool IsDipper() const {return 0 != (XPT_PD_IS_DIPPER(flags));}</span></a>
<span class="lineNum">     152 </span><span class="lineCov">       7671 :     bool IsOptional() const {return 0 != (XPT_PD_IS_OPTIONAL(flags));}</span>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">     151209 :     const nsXPTType GetType() const {return type.prefix;}</span></a>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineCov">      24941 :     bool IsStringClass() const {</span>
<span class="lineNum">     156 </span><span class="lineCov">      24941 :       switch (GetType().TagPart()) {</span>
<span class="lineNum">     157 </span>            :         case nsXPTType::T_ASTRING:
<span class="lineNum">     158 </span>            :         case nsXPTType::T_DOMSTRING:
<span class="lineNum">     159 </span>            :         case nsXPTType::T_UTF8STRING:
<span class="lineNum">     160 </span>            :         case nsXPTType::T_CSTRING:
<span class="lineNum">     161 </span><span class="lineCov">       2481 :           return true;</span>
<span class="lineNum">     162 </span>            :         default:
<span class="lineNum">     163 </span><span class="lineCov">      22460 :           return false;</span>
<span class="lineNum">     164 </span>            :       }
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     // Whether this parameter is passed indirectly on the stack. This mainly
<a name="168"><span class="lineNum">     168 </span>            :     // applies to out/inout params, but we use it unconditionally for certain</a>
<span class="lineNum">     169 </span>            :     // types.
<span class="lineNum">     170 </span><span class="lineCov">      57897 :     bool IsIndirect() const {return IsOut() ||</span>
<span class="lineNum">     171 </span><span class="lineCov">      57897 :                                GetType().TagPart() == nsXPTType::T_JSVAL;}</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :     // NOTE: other activities on types are done via methods on nsIInterfaceInfo
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : private:
<span class="lineNum">     176 </span>            :     nsXPTParamInfo();   // no implementation
<span class="lineNum">     177 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     178 </span>            : };
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : class nsXPTMethodInfo : public XPTMethodDescriptor
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     183 </span>            : public:
<span class="lineNum">     184 </span>            :     MOZ_IMPLICIT nsXPTMethodInfo(const XPTMethodDescriptor&amp; desc)
<a name="185"><span class="lineNum">     185 </span>            :         {*(XPTMethodDescriptor*)this = desc;}</a>
<a name="186"><span class="lineNum">     186 </span>            : </a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">       9599 :     bool IsGetter()      const {return 0 != (XPT_MD_IS_GETTER(flags) );}</span></a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">      10149 :     bool IsSetter()      const {return 0 != (XPT_MD_IS_SETTER(flags) );}</span></a>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">       3486 :     bool IsNotXPCOM()    const {return 0 != (XPT_MD_IS_NOTXPCOM(flags));}</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 :     bool IsHidden()      const {return 0 != (XPT_MD_IS_HIDDEN(flags) );}</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">      12546 :     bool WantsOptArgc()  const {return 0 != (XPT_MD_WANTS_OPT_ARGC(flags));}</span></a>
<a name="192"><span class="lineNum">     192 </span><span class="lineCov">      12546 :     bool WantsContext()  const {return 0 != (XPT_MD_WANTS_CONTEXT(flags));}</span></a>
<span class="lineNum">     193 </span><span class="lineCov">      10018 :     const char* GetName()  const {return name;}</span>
<a name="194"><span class="lineNum">     194 </span><span class="lineCov">     189734 :     uint8_t GetParamCount()  const {return num_args;}</span></a>
<span class="lineNum">     195 </span>            :     /* idx was index before I got _sick_ of the warnings on Unix, sorry jband */
<span class="lineNum">     196 </span><span class="lineCov">     141945 :     const nsXPTParamInfo GetParam(uint8_t idx) const</span>
<span class="lineNum">     197 </span>            :         {
<span class="lineNum">     198 </span><span class="lineCov">     141945 :             NS_PRECONDITION(idx &lt; GetParamCount(),&quot;bad arg&quot;);</span>
<span class="lineNum">     199 </span><span class="lineCov">     141945 :             return params[idx];</span>
<span class="lineNum">     200 </span>            :         }
<span class="lineNum">     201 </span>            :     const nsXPTParamInfo GetResult() const
<span class="lineNum">     202 </span>            :         {return result;}
<span class="lineNum">     203 </span>            : private:
<span class="lineNum">     204 </span>            :     nsXPTMethodInfo();  // no implementation
<span class="lineNum">     205 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     206 </span>            : };
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : // forward declaration
<span class="lineNum">     210 </span>            : struct nsXPTCMiniVariant;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : class nsXPTConstant : public XPTConstDescriptor
<span class="lineNum">     213 </span>            : {
<span class="lineNum">     214 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     215 </span>            : public:
<span class="lineNum">     216 </span>            :     MOZ_IMPLICIT nsXPTConstant(const XPTConstDescriptor&amp; desc)
<span class="lineNum">     217 </span>            :         {*(XPTConstDescriptor*)this = desc;}
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :     const char* GetName() const
<span class="lineNum">     220 </span>            :         {return name;}
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     const nsXPTType GetType() const
<span class="lineNum">     223 </span>            :         {return type.prefix;}
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     // XXX this is ugly. But sometimes you gotta do what you gotta do.
<span class="lineNum">     226 </span>            :     // A reinterpret_cast won't do the trick here. And this plain C cast
<span class="lineNum">     227 </span>            :     // works correctly and is safe enough.
<span class="lineNum">     228 </span>            :     // See http://bugzilla.mozilla.org/show_bug.cgi?id=49641
<span class="lineNum">     229 </span>            :     const nsXPTCMiniVariant* GetValue() const
<span class="lineNum">     230 </span>            :         {return (nsXPTCMiniVariant*) &amp;value;}
<span class="lineNum">     231 </span>            : private:
<span class="lineNum">     232 </span>            :     nsXPTConstant();    // no implementation
<span class="lineNum">     233 </span>            : // NO DATA - this a flyweight wrapper
<span class="lineNum">     234 </span>            : };
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : #endif /* xptiinfo_h___ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
